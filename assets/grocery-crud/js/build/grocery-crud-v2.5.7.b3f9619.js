(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LinkedValue = function (_React$Component) {
    _inherits(LinkedValue, _React$Component);

    function LinkedValue(props) {
        _classCallCheck(this, LinkedValue);

        var fieldValue = props.data.fieldValue;

        var _this = _possibleConstructorReturn(this, (LinkedValue.__proto__ || Object.getPrototypeOf(LinkedValue)).call(this, props));

        _this.state = {
            fieldValue: fieldValue ? fieldValue : ''
        };
        return _this;
    }

    _createClass(LinkedValue, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var fieldValue = nextProps.data.fieldValue;


            this.setState({
                fieldValue: fieldValue ? fieldValue : ''
            });
        }
    }, {
        key: 'linkedChange',
        value: function linkedChange(event) {
            this.setState({
                fieldValue: event.target.value
            });
        }
    }]);

    return LinkedValue;
}(React.Component);

exports.default = LinkedValue;

},{}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _text = require('./input/text.jsx');

var _text2 = _interopRequireDefault(_text);

var _textarea = require('./input/textarea.jsx');

var _textarea2 = _interopRequireDefault(_textarea);

var _richTexteditor = require('./input/rich-texteditor.jsx');

var _richTexteditor2 = _interopRequireDefault(_richTexteditor);

var _date = require('./input/date.jsx');

var _date2 = _interopRequireDefault(_date);

var _datetime = require('./input/datetime.jsx');

var _datetime2 = _interopRequireDefault(_datetime);

var _enum = require('./input/enum.jsx');

var _enum2 = _interopRequireDefault(_enum);

var _enumSearchable = require('./input/enum-searchable.jsx');

var _enumSearchable2 = _interopRequireDefault(_enumSearchable);

var _dropdown = require('./input/dropdown.jsx');

var _dropdown2 = _interopRequireDefault(_dropdown);

var _dropdownSearchable = require('./input/dropdown-searchable.jsx');

var _dropdownSearchable2 = _interopRequireDefault(_dropdownSearchable);

var _relationalSearchable = require('./input/relational-searchable.jsx');

var _relationalSearchable2 = _interopRequireDefault(_relationalSearchable);

var _relationalNative = require('./input/relational-native.jsx');

var _relationalNative2 = _interopRequireDefault(_relationalNative);

var _upload = require('./input/upload.jsx');

var _upload2 = _interopRequireDefault(_upload);

var _relationNN = require('./input/relation-n-n.jsx');

var _relationNN2 = _interopRequireDefault(_relationNN);

var _searchableRelationNN = require('./input/searchable-relation-n-n.jsx');

var _searchableRelationNN2 = _interopRequireDefault(_searchableRelationNN);

var _numeric = require('./input/numeric.jsx');

var _numeric2 = _interopRequireDefault(_numeric);

var _checkboxBoolean = require('./input/checkbox-boolean.jsx');

var _checkboxBoolean2 = _interopRequireDefault(_checkboxBoolean);

var _email = require('./input/email.jsx');

var _email2 = _interopRequireDefault(_email);

var _color = require('./input/color.jsx');

var _color2 = _interopRequireDefault(_color);

var _password = require('./input/password.jsx');

var _password2 = _interopRequireDefault(_password);

var _url = require('./input/url.jsx');

var _url2 = _interopRequireDefault(_url);

var _backendCallback = require('./input/backend-callback.js');

var _backendCallback2 = _interopRequireDefault(_backendCallback);

var _multiselectSearchable = require('./input/multiselect-searchable.js');

var _multiselectSearchable2 = _interopRequireDefault(_multiselectSearchable);

var _multiselect = require('./input/multiselect');

var _multiselect2 = _interopRequireDefault(_multiselect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FieldInput = function (_React$Component) {
    _inherits(FieldInput, _React$Component);

    function FieldInput() {
        _classCallCheck(this, FieldInput);

        return _possibleConstructorReturn(this, (FieldInput.__proto__ || Object.getPrototypeOf(FieldInput)).apply(this, arguments));
    }

    _createClass(FieldInput, [{
        key: '__type_email',
        value: function __type_email(fieldName, data) {
            return React.createElement(_email2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_url',
        value: function __type_url(fieldName, data) {
            return React.createElement(_url2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_color',
        value: function __type_color(fieldName, data) {
            return React.createElement(_color2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_password',
        value: function __type_password(fieldName, data) {
            return React.createElement(_password2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_checkbox_boolean',
        value: function __type_checkbox_boolean(fieldName, data) {
            return React.createElement(_checkboxBoolean2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_dropdown',
        value: function __type_dropdown(fieldName, data) {
            return React.createElement(_dropdown2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_dropdown_search',
        value: function __type_dropdown_search(fieldName, data) {
            return React.createElement(_dropdownSearchable2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_enum',
        value: function __type_enum(fieldName, data) {
            return React.createElement(_enum2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_multiselect_searchable',
        value: function __type_multiselect_searchable(fieldName, data) {
            return React.createElement(_multiselectSearchable2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_multiselect_native',
        value: function __type_multiselect_native(fieldName, data) {
            return React.createElement(_multiselect2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_enum_searchable',
        value: function __type_enum_searchable(fieldName, data) {
            return React.createElement(_enumSearchable2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_int',
        value: function __type_int(fieldName, data) {
            return React.createElement(_numeric2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_relational',
        value: function __type_relational(fieldName, data) {
            return React.createElement(_relationalSearchable2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_relational_native',
        value: function __type_relational_native(fieldName, data) {
            return React.createElement(_relationalNative2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_relational_n_n',
        value: function __type_relational_n_n(fieldName, data) {
            return React.createElement(_searchableRelationNN2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_native_relational_n_n',
        value: function __type_native_relational_n_n(fieldName, data) {
            return React.createElement(_relationNN2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_numeric',
        value: function __type_numeric(fieldName, data) {
            return this.__type_int(fieldName, data);
        }
    }, {
        key: '__type_backend_callback',
        value: function __type_backend_callback(fieldName, data) {
            return React.createElement(_backendCallback2.default, { key: fieldName, data: data });
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldType = _props$data.fieldType,
                data = this.props.data,
                gcrudInstance = this.props.gcrudInstance,
                timestamp = Math.floor(Date.now() / 1000);


            if (this['__type_' + fieldType] !== undefined) {
                return this['__type_' + fieldType](fieldName, data);
            }

            if (/^texteditor$/i.test(fieldType)) {
                return React.createElement(_richTexteditor2.default, { data: data });
            }

            if (/^text$/i.test(fieldType)) {
                return React.createElement(_textarea2.default, { key: timestamp, data: data });
            }

            if (/^date$/i.test(fieldType)) {
                return React.createElement(_date2.default, { key: timestamp, data: data, gcrudInstance: gcrudInstance });
            }

            if (/^(datetime|timestamp)$/i.test(fieldType)) {
                return React.createElement(_datetime2.default, { key: timestamp, data: data, gcrudInstance: gcrudInstance });
            }

            if (/^upload$/i.test(fieldType)) {
                return React.createElement(_upload2.default, { key: timestamp, data: data, gcrudInstance: gcrudInstance });
            }

            return React.createElement(_text2.default, { key: fieldName, data: data });
        }
    }]);

    return FieldInput;
}(React.Component);

exports.default = FieldInput;

},{"./input/backend-callback.js":5,"./input/checkbox-boolean.jsx":6,"./input/color.jsx":7,"./input/date.jsx":8,"./input/datetime.jsx":9,"./input/dropdown-searchable.jsx":10,"./input/dropdown.jsx":11,"./input/email.jsx":12,"./input/enum-searchable.jsx":13,"./input/enum.jsx":14,"./input/multiselect":17,"./input/multiselect-searchable.js":16,"./input/numeric.jsx":18,"./input/password.jsx":19,"./input/relation-n-n.jsx":21,"./input/relational-native.jsx":22,"./input/relational-searchable.jsx":23,"./input/rich-texteditor.jsx":26,"./input/searchable-relation-n-n.jsx":27,"./input/text.jsx":28,"./input/textarea.jsx":29,"./input/upload.jsx":31,"./input/url.jsx":32}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _fieldRow = require('./field-row.jsx');

var _fieldRow2 = _interopRequireDefault(_fieldRow);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FieldList = function (_React$Component) {
    _inherits(FieldList, _React$Component);

    function FieldList() {
        _classCallCheck(this, FieldList);

        return _possibleConstructorReturn(this, (FieldList.__proto__ || Object.getPrototypeOf(FieldList)).apply(this, arguments));
    }

    _createClass(FieldList, [{
        key: 'render',
        value: function render() {
            var _props = this.props,
                gcrudInstance = _props.gcrudInstance,
                FieldInputComponent = _props.FieldInputComponent,
                FieldRowWrapper = _props.FieldRowWrapper,
                fields = _props.fields;


            return React.createElement(
                'div',
                null,
                fields.map(function FieldsForEach(field) {
                    var fieldName = field.fieldName;


                    return React.createElement(_fieldRow2.default, {
                        key: fieldName,
                        data: field,
                        gcrudInstance: gcrudInstance,
                        FieldInputComponent: FieldInputComponent,
                        FieldRowWrapper: FieldRowWrapper
                    });
                })
            );
        }
    }]);

    return FieldList;
}(React.Component);

FieldList.propTypes = {
    gcrudInstance: _propTypes2.default.object,
    FieldInputComponent: _propTypes2.default.func,
    FieldRowWrapper: _propTypes2.default.func,
    fields: _propTypes2.default.array
};

exports.default = FieldList;

},{"./field-row.jsx":4,"prop-types":182}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _hidden = require('./input/hidden.jsx');

var _hidden2 = _interopRequireDefault(_hidden);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FieldRow = function (_React$Component) {
    _inherits(FieldRow, _React$Component);

    function FieldRow() {
        _classCallCheck(this, FieldRow);

        return _possibleConstructorReturn(this, (FieldRow.__proto__ || Object.getPrototypeOf(FieldRow)).apply(this, arguments));
    }

    _createClass(FieldRow, [{
        key: 'render',
        value: function render() {
            var _props = this.props,
                data = _props.data,
                _props$data = _props.data,
                fieldType = _props$data.fieldType,
                isRequired = _props$data.isRequired,
                displayAs = _props$data.displayAs,
                gcrudInstance = _props.gcrudInstance,
                FieldInputComponent = _props.FieldInputComponent,
                FieldRowWrapper = _props.FieldRowWrapper;


            if (/^hidden$/i.test(fieldType)) {
                return React.createElement(_hidden2.default, { data: data });
            }

            return React.createElement(FieldRowWrapper, {
                isRequired: isRequired,
                displayAs: displayAs,
                data: data,
                gcrudInstance: gcrudInstance,
                FieldInput: FieldInputComponent
            });
        }
    }]);

    return FieldRow;
}(React.Component);

FieldRow.propTypes = {
    data: _propTypes2.default.shape({
        displayAs: _propTypes2.default.string,
        fieldType: _propTypes2.default.string,
        isRequired: _propTypes2.default.bool
    }),
    gcrudInstance: _propTypes2.default.object,
    FieldInputComponent: _propTypes2.default.func,
    FieldRowWrapper: _propTypes2.default.func
};

FieldRow.defaultProps = {
    FieldInputComponent: function FieldInputComponent(props) {
        return React.createElement('input', { name: props.data.fieldName });
    },
    FieldRowWrapper: function FieldRowWrapper(props) {
        var isRequired = props.isRequired,
            displayAs = props.displayAs,
            FieldInput = props.FieldInput,
            data = props.data,
            gcrudInstance = props.gcrudInstance;


        return React.createElement(
            'div',
            null,
            React.createElement(
                'label',
                null,
                isRequired ? '*' : '',
                displayAs
            ),
            React.createElement(
                'div',
                null,
                React.createElement(FieldInput, { data: data, gcrudInstance: gcrudInstance })
            )
        );
    }
};

exports.default = FieldRow;

},{"./input/hidden.jsx":15,"prop-types":182}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputBackendCallback = function (_React$Component) {
    _inherits(InputBackendCallback, _React$Component);

    function InputBackendCallback(props) {
        _classCallCheck(this, InputBackendCallback);

        var fieldValue = props.data.fieldValue;

        var _this = _possibleConstructorReturn(this, (InputBackendCallback.__proto__ || Object.getPrototypeOf(InputBackendCallback)).call(this, props));

        _this.state = {
            fieldValue: fieldValue ? fieldValue : ''
        };
        return _this;
    }

    _createClass(InputBackendCallback, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var fieldValue = nextProps.data.fieldValue;


            this.setState({
                fieldValue: fieldValue ? fieldValue : ''
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var defaultValue = this.props.data.defaultValue,
                fieldValue = this.state.fieldValue,
                dangerouslyInnerHTML = {
                __html: defaultValue ? defaultValue : fieldValue
            };


            return React.createElement('div', { dangerouslySetInnerHTML: dangerouslyInnerHTML });
        }
    }]);

    return InputBackendCallback;
}(React.Component);

InputBackendCallback.propTypes = {
    data: _propTypes2.default.shape({
        fieldValue: _propTypes2.default.string,
        defaultValue: _propTypes2.default.string
    })
};

exports.default = InputBackendCallback;

},{"prop-types":182}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputCheckboxBoolean = function (_React$Component) {
    _inherits(InputCheckboxBoolean, _React$Component);

    function InputCheckboxBoolean(props) {
        _classCallCheck(this, InputCheckboxBoolean);

        var _props$data = props.data,
            fieldValue = _props$data.fieldValue,
            defaultValue = _props$data.defaultValue,
            showDefaultValue = _props$data.showDefaultValue,
            value = showDefaultValue && defaultValue ? defaultValue : fieldValue;

        var _this = _possibleConstructorReturn(this, (InputCheckboxBoolean.__proto__ || Object.getPrototypeOf(InputCheckboxBoolean)).call(this, props));

        _this.state = {
            fieldValue: _this.getCheckboxValue(value),
            isChecked: _this.checkboxIsChecked(value)
        };
        return _this;
    }

    _createClass(InputCheckboxBoolean, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var _nextProps$data = nextProps.data,
                fieldValue = _nextProps$data.fieldValue,
                defaultValue = _nextProps$data.defaultValue,
                showDefaultValue = _nextProps$data.showDefaultValue,
                value = showDefaultValue && defaultValue ? defaultValue : fieldValue;


            this.setState({
                fieldValue: this.getCheckboxValue(value),
                isChecked: this.checkboxIsChecked(value)
            });
        }
    }, {
        key: 'linkedChange',
        value: function linkedChange() {
            var isChecked = this.state.isChecked;


            this.setState({
                fieldValue: isChecked ? '0' : '1',
                isChecked: !isChecked
            });
        }
    }, {
        key: 'getCheckboxValue',
        value: function getCheckboxValue(value) {
            return value === '1' ? '1' : '0';
        }
    }, {
        key: 'checkboxIsChecked',
        value: function checkboxIsChecked(value) {
            return value === '1';
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data2 = this.props.data,
                fieldName = _props$data2.fieldName,
                isReadOnly = _props$data2.isReadOnly,
                _state = this.state,
                fieldValue = _state.fieldValue,
                isChecked = _state.isChecked;


            if (isReadOnly) {
                return React.createElement(
                    'div',
                    { className: 'form-control gc-read-only-input' },
                    isChecked ? React.createElement('i', { className: 'fa fa-check' }) : ''
                );
            }

            return React.createElement(
                'div',
                null,
                React.createElement('input', { value: fieldValue,
                    disabled: isReadOnly,
                    checked: isChecked,
                    type: 'checkbox',
                    onChange: this.linkedChange.bind(this) }),
                React.createElement('input', { name: fieldName,
                    value: fieldValue,
                    type: 'hidden' })
            );
        }
    }]);

    return InputCheckboxBoolean;
}(React.Component);

InputCheckboxBoolean.propTypes = {
    data: _propTypes2.default.shape({
        fieldName: _propTypes2.default.string,
        isReadOnly: _propTypes2.default.bool,
        fieldValue: _propTypes2.default.string,
        defaultValue: _propTypes2.default.string,
        showDefaultValue: _propTypes2.default.bool
    })
};

exports.default = InputCheckboxBoolean;

},{"prop-types":182}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _text = require('./text.jsx');

var _text2 = _interopRequireDefault(_text);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputColor = function (_InputText) {
    _inherits(InputColor, _InputText);

    function InputColor() {
        _classCallCheck(this, InputColor);

        return _possibleConstructorReturn(this, (InputColor.__proto__ || Object.getPrototypeOf(InputColor)).apply(this, arguments));
    }

    _createClass(InputColor, [{
        key: 'render',
        value: function render() {
            var data = this.props.data,
                fieldName = this.props.data.fieldName;


            return React.createElement(_text2.default, { key: fieldName, data: data });
        }
    }]);

    return InputColor;
}(_text2.default);

InputColor.propTypes = {
    data: _propTypes2.default.shape({
        fieldName: _propTypes2.default.string,
        isReadOnly: _propTypes2.default.bool,
        fieldType: _propTypes2.default.string
    })
};

exports.default = InputColor;

},{"./text.jsx":28,"prop-types":182}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var jQueryPlugins = require('../../../Resources/public/js/modules/jquery/jquery-plugins').jQueryPlugins,
    $ = jQuery;

var InputDate = function (_React$Component) {
    _inherits(InputDate, _React$Component);

    function InputDate() {
        _classCallCheck(this, InputDate);

        return _possibleConstructorReturn(this, (InputDate.__proto__ || Object.getPrototypeOf(InputDate)).apply(this, arguments));
    }

    _createClass(InputDate, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            jQueryPlugins.datepicker($(ReactDOM.findDOMNode(this)).find('.gc-input-date'), this.props.gcrudInstance);
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValue = _props$data.fieldValue,
                isReadOnly = _props$data.isReadOnly,
                extraInput = '',
                inputClasses = 'form-control gc-input-date';


            if (isReadOnly) {
                extraInput = React.createElement(_readOnly2.default, { fieldValue: fieldValue });
                inputClasses += ' hidden';
            }
            return React.createElement(
                'div',
                null,
                extraInput,
                React.createElement('input', {
                    className: inputClasses,
                    name: fieldName,
                    readOnly: isReadOnly,
                    defaultValue: fieldValue,
                    type: 'text',
                    step: '1'
                })
            );
        }
    }]);

    return InputDate;
}(React.Component);

exports.default = InputDate;

},{"../../../Resources/public/js/modules/jquery/jquery-plugins":88,"./read-only.jsx":20}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var jQueryPlugins = require('../../../Resources/public/js/modules/jquery/jquery-plugins').jQueryPlugins,
    $ = jQuery;

var InputDatetime = function (_React$Component) {
    _inherits(InputDatetime, _React$Component);

    function InputDatetime() {
        _classCallCheck(this, InputDatetime);

        return _possibleConstructorReturn(this, (InputDatetime.__proto__ || Object.getPrototypeOf(InputDatetime)).apply(this, arguments));
    }

    _createClass(InputDatetime, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            jQueryPlugins.datetimepicker($(ReactDOM.findDOMNode(this)).find('.gc-input-datetime'), this.props.gcrudInstance);
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValue = _props$data.fieldValue,
                isReadOnly = _props$data.isReadOnly,
                extraInput = '',
                inputClasses = 'form-control gc-input-datetime';


            if (isReadOnly) {
                extraInput = React.createElement(_readOnly2.default, { fieldValue: fieldValue });
                inputClasses += ' hidden';
            }

            return React.createElement(
                'div',
                null,
                extraInput,
                React.createElement('input', {
                    className: inputClasses,
                    name: fieldName,
                    readOnly: isReadOnly,
                    defaultValue: fieldValue,
                    type: 'text',
                    step: '1'
                })
            );
        }
    }]);

    return InputDatetime;
}(React.Component);

exports.default = InputDatetime;

},{"../../../Resources/public/js/modules/jquery/jquery-plugins":88,"./read-only.jsx":20}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _linkedValue = require('../components/linked-value.js');

var _linkedValue2 = _interopRequireDefault(_linkedValue);

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var jQueryPlugins = require('../../../Resources/public/js/modules/jquery/jquery-plugins').jQueryPlugins,
    $ = jQuery,
    i18n = require('../../../Resources/public/js/sections/i18n').i18n;

var InputDropdownSearchable = function (_LinkedValue) {
    _inherits(InputDropdownSearchable, _LinkedValue);

    function InputDropdownSearchable() {
        _classCallCheck(this, InputDropdownSearchable);

        return _possibleConstructorReturn(this, (InputDropdownSearchable.__proto__ || Object.getPrototypeOf(InputDropdownSearchable)).apply(this, arguments));
    }

    _createClass(InputDropdownSearchable, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            jQueryPlugins.searchableSelect($(ReactDOM.findDOMNode(this)).find('select'), this.props.data.isReadOnly);
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            jQueryPlugins.searchableSelectUpdate($(ReactDOM.findDOMNode(this)).find('select'), this.props.data.isReadOnly);
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValues = _props$data.fieldValues,
                isNullable = _props$data.isNullable,
                isReadOnly = _props$data.isReadOnly,
                fieldValue = this.state.fieldValue,
                fieldValueDescription = '',
                extraInput = '',
                options = [];


            if (isNullable) {
                options.push({ id: '', title: '' });
            }
            _underscore2.default.each(fieldValues, function forEachFieldValue(optionDisplay, optionValue) {
                options.push({
                    id: optionValue,
                    title: optionDisplay
                });
                if (optionValue === fieldValue) {
                    fieldValueDescription = optionDisplay;
                }
            });

            if (isReadOnly) {
                extraInput = React.createElement(_readOnly2.default, { fieldValue: fieldValueDescription });
            }

            return React.createElement(
                'div',
                null,
                extraInput,
                React.createElement(
                    'select',
                    {
                        name: fieldName,
                        value: fieldValue,
                        onChange: this.linkedChange.bind(this),
                        className: 'form-control',
                        disabled: isReadOnly,
                        'data-placeholder': i18n.t('select_an_option') },
                    options.map(function DropDownForEach(field) {
                        var id = field.id,
                            title = field.title;

                        return React.createElement(
                            'option',
                            { value: id, key: id },
                            title
                        );
                    })
                )
            );
        }
    }]);

    return InputDropdownSearchable;
}(_linkedValue2.default);

exports.default = InputDropdownSearchable;

},{"../../../Resources/public/js/modules/jquery/jquery-plugins":88,"../../../Resources/public/js/sections/i18n":97,"../components/linked-value.js":1,"./read-only.jsx":20,"underscore":198}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _linkedValue = require('../components/linked-value.js');

var _linkedValue2 = _interopRequireDefault(_linkedValue);

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputDropdown = function (_LinkedValue) {
    _inherits(InputDropdown, _LinkedValue);

    function InputDropdown() {
        _classCallCheck(this, InputDropdown);

        return _possibleConstructorReturn(this, (InputDropdown.__proto__ || Object.getPrototypeOf(InputDropdown)).apply(this, arguments));
    }

    _createClass(InputDropdown, [{
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValues = _props$data.fieldValues,
                isNullable = _props$data.isNullable,
                isReadOnly = _props$data.isReadOnly,
                fieldValue = this.state.fieldValue,
                fieldValueDescription = '',
                options = [];


            if (isNullable) {
                options.push({ id: '', title: '' });
            }
            _underscore2.default.each(fieldValues, function forEachFieldValue(optionDisplay, optionValue) {
                options.push({
                    id: optionValue,
                    title: optionDisplay
                });

                // For the select id show the option display instead of the id
                if (optionValue === fieldValue) {
                    fieldValueDescription = optionDisplay;
                }
            });

            if (isReadOnly) {
                return React.createElement(_readOnly2.default, { fieldValue: fieldValueDescription });
            }

            return React.createElement(
                'select',
                {
                    name: fieldName,
                    value: fieldValue,
                    onChange: this.linkedChange.bind(this),
                    className: 'form-control',
                    disabled: isReadOnly },
                options.map(function DropDownForEach(field) {
                    var id = field.id,
                        title = field.title;

                    return React.createElement(
                        'option',
                        { value: id, key: id },
                        title
                    );
                })
            );
        }
    }]);

    return InputDropdown;
}(_linkedValue2.default);

exports.default = InputDropdown;

},{"../components/linked-value.js":1,"./read-only.jsx":20,"underscore":198}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _text = require('./text.jsx');

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputEmail = function (_InputText) {
    _inherits(InputEmail, _InputText);

    function InputEmail() {
        _classCallCheck(this, InputEmail);

        return _possibleConstructorReturn(this, (InputEmail.__proto__ || Object.getPrototypeOf(InputEmail)).apply(this, arguments));
    }

    _createClass(InputEmail, [{
        key: 'render',
        value: function render() {
            var data = this.props.data,
                fieldName = this.props.data.fieldName;


            return React.createElement(_text2.default, { key: fieldName, data: data });
        }
    }]);

    return InputEmail;
}(_text2.default);

exports.default = InputEmail;

},{"./text.jsx":28}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _linkedValue = require('../components/linked-value.js');

var _linkedValue2 = _interopRequireDefault(_linkedValue);

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var jQueryPlugins = require('../../../Resources/public/js/modules/jquery/jquery-plugins').jQueryPlugins,
    $ = jQuery,
    i18n = require('../../../Resources/public/js/sections/i18n').i18n;

var InputEnumSearchable = function (_LinkedValue) {
    _inherits(InputEnumSearchable, _LinkedValue);

    function InputEnumSearchable() {
        _classCallCheck(this, InputEnumSearchable);

        return _possibleConstructorReturn(this, (InputEnumSearchable.__proto__ || Object.getPrototypeOf(InputEnumSearchable)).apply(this, arguments));
    }

    _createClass(InputEnumSearchable, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            jQueryPlugins.searchableSelect($(ReactDOM.findDOMNode(this)).find('select'), this.props.data.isReadOnly);
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            jQueryPlugins.searchableSelectUpdate($(ReactDOM.findDOMNode(this)).find('select'), this.props.data.isReadOnly);
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValues = _props$data.fieldValues,
                isNullable = _props$data.isNullable,
                isReadOnly = _props$data.isReadOnly,
                fieldValue = this.state.fieldValue,
                extraInput = '',
                options = [];


            if (isReadOnly) {
                extraInput = React.createElement(_readOnly2.default, { fieldValue: fieldValue });
            }
            if (isNullable) {
                options.push('');
            }
            fieldValues.forEach(function forEachFieldValue(optionValue) {
                options.push(optionValue);
            });
            options = _underscore2.default.uniq(options);
            return React.createElement(
                'div',
                null,
                extraInput,
                React.createElement(
                    'select',
                    {
                        name: fieldName,
                        value: fieldValue,
                        className: 'form-control',
                        disabled: isReadOnly,
                        onChange: this.linkedChange.bind(this),
                        'data-placeholder': i18n.t('select_an_option') },
                    options.map(function optionsForEach(field) {
                        return React.createElement(
                            'option',
                            { defaultValue: field, key: field },
                            field
                        );
                    })
                )
            );
        }
    }]);

    return InputEnumSearchable;
}(_linkedValue2.default);

exports.default = InputEnumSearchable;

},{"../../../Resources/public/js/modules/jquery/jquery-plugins":88,"../../../Resources/public/js/sections/i18n":97,"../components/linked-value.js":1,"./read-only.jsx":20,"underscore":198}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _linkedValue = require('../components/linked-value.js');

var _linkedValue2 = _interopRequireDefault(_linkedValue);

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputEnum = function (_LinkedValue) {
    _inherits(InputEnum, _LinkedValue);

    function InputEnum() {
        _classCallCheck(this, InputEnum);

        return _possibleConstructorReturn(this, (InputEnum.__proto__ || Object.getPrototypeOf(InputEnum)).apply(this, arguments));
    }

    _createClass(InputEnum, [{
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValues = _props$data.fieldValues,
                isNullable = _props$data.isNullable,
                isReadOnly = _props$data.isReadOnly,
                fieldValue = this.state.fieldValue,
                options = [];


            if (isReadOnly) {
                return React.createElement(_readOnly2.default, { fieldValue: fieldValue });
            }

            if (isNullable) {
                options.push('');
            }
            fieldValues.forEach(function forEachFieldValue(optionValue) {
                options.push(optionValue);
            });
            options = _underscore2.default.uniq(options);
            return React.createElement(
                'select',
                { name: fieldName, value: fieldValue, className: 'form-control', disabled: isReadOnly, onChange: this.linkedChange.bind(this) },
                options.map(function optionsForEach(field) {
                    return React.createElement(
                        'option',
                        { defaultValue: field, key: field },
                        field
                    );
                })
            );
        }
    }]);

    return InputEnum;
}(_linkedValue2.default);

exports.default = InputEnum;

},{"../components/linked-value.js":1,"./read-only.jsx":20,"underscore":198}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputHidden = function (_React$Component) {
    _inherits(InputHidden, _React$Component);

    function InputHidden(props) {
        _classCallCheck(this, InputHidden);

        var fieldValue = props.data.fieldValue;

        var _this = _possibleConstructorReturn(this, (InputHidden.__proto__ || Object.getPrototypeOf(InputHidden)).call(this, props));

        _this.state = {
            fieldValue: fieldValue ? fieldValue : ''
        };
        return _this;
    }

    _createClass(InputHidden, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var fieldValue = nextProps.data.fieldValue;


            this.setState({
                fieldValue: fieldValue ? fieldValue : ''
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var fieldName = this.props.data.fieldName,
                fieldValue = this.state.fieldValue;


            return React.createElement('input', {
                className: 'form-control',
                name: fieldName,
                value: fieldValue,
                readOnly: 'readOnly',
                type: 'hidden'
            });
        }
    }]);

    return InputHidden;
}(React.Component);

InputHidden.propTypes = {
    data: _propTypes2.default.shape({
        fieldName: _propTypes2.default.string,
        fieldValue: _propTypes2.default.string
    })
};

exports.default = InputHidden;

},{"prop-types":182}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _multiselect = require('./multiselect.js');

var _multiselect2 = _interopRequireDefault(_multiselect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var jQueryPlugins = require('../../../Resources/public/js/modules/jquery/jquery-plugins').jQueryPlugins,
    $ = jQuery;

var InputMultiselectSearchable = function (_InputMultiselect) {
    _inherits(InputMultiselectSearchable, _InputMultiselect);

    function InputMultiselectSearchable() {
        _classCallCheck(this, InputMultiselectSearchable);

        return _possibleConstructorReturn(this, (InputMultiselectSearchable.__proto__ || Object.getPrototypeOf(InputMultiselectSearchable)).apply(this, arguments));
    }

    _createClass(InputMultiselectSearchable, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var $select = $(ReactDOM.findDOMNode(this)).find('select'),
                isReadOnly = this.props.data.isReadOnly;

            jQueryPlugins.searchableSelect($select, isReadOnly);
            $select.on('change', function SearchableSelectUpdate(event) {
                this.linkedChange.apply(this, [event]);
            }.bind(this));
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            jQueryPlugins.searchableSelectUpdate($(ReactDOM.findDOMNode(this)).find('select'), this.props.data.isReadOnly);
        }
    }]);

    return InputMultiselectSearchable;
}(_multiselect2.default);

exports.default = InputMultiselectSearchable;

},{"../../../Resources/public/js/modules/jquery/jquery-plugins":88,"./multiselect.js":17}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var i18n = require('../../../Resources/public/js/sections/i18n').i18n;

var InputMultiselect = function (_React$Component) {
    _inherits(InputMultiselect, _React$Component);

    function InputMultiselect(props) {
        _classCallCheck(this, InputMultiselect);

        var fieldValue = props.data.fieldValue;

        var _this = _possibleConstructorReturn(this, (InputMultiselect.__proto__ || Object.getPrototypeOf(InputMultiselect)).call(this, props));

        _this.state = {
            fieldValue: fieldValue
        };
        return _this;
    }

    _createClass(InputMultiselect, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var fieldValue = nextProps.data.fieldValue;


            this.setState({
                fieldValue: fieldValue
            });
        }
    }, {
        key: 'linkedChange',
        value: function linkedChange(event) {
            var selectedValues = [].concat(_toConsumableArray(event.target.options)).filter(function (option) {
                return option.selected;
            }).map(function (option) {
                return option.value;
            });

            this.setState({
                fieldValue: selectedValues
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValues = _props$data.fieldValues,
                isNullable = _props$data.isNullable,
                isReadOnly = _props$data.isReadOnly,
                fieldValue = this.state.fieldValue,
                selectedItems = void 0,
                selectedItemsAsString = void 0,
                fieldValueDescription = [],
                extraInput = null,
                options = [],
                selectClassName = 'form-control';


            selectedItems = fieldValue !== null ? fieldValue : [];
            selectedItemsAsString = selectedItems.join();

            if (isNullable) {
                options.push({ id: '', title: '' });
            }
            _underscore2.default.each(fieldValues, function forEachFieldValue(optionDisplay, optionValue) {
                options.push({
                    id: optionValue,
                    title: optionDisplay
                });
                if (selectedItems.indexOf(optionValue) > -1) {
                    fieldValueDescription.push(optionDisplay);
                }
            });

            if (isReadOnly) {
                extraInput = React.createElement(_readOnly2.default, { fieldValue: fieldValueDescription.join(', ') });
                selectClassName += ' hidden';
            } else {
                extraInput = React.createElement('input', { type: 'hidden', name: fieldName, value: selectedItemsAsString });
            }

            return React.createElement(
                'div',
                null,
                extraInput,
                React.createElement(
                    'select',
                    {
                        multiple: true,
                        value: selectedItems,
                        onChange: this.linkedChange.bind(this),
                        className: selectClassName,
                        disabled: isReadOnly,
                        'data-placeholder': i18n.t('select_an_option') },
                    options.map(function DropDownForEach(field) {
                        var id = field.id,
                            title = field.title;

                        return React.createElement(
                            'option',
                            { value: id, key: id },
                            title
                        );
                    })
                )
            );
        }
    }]);

    return InputMultiselect;
}(React.Component);

exports.default = InputMultiselect;

},{"../../../Resources/public/js/sections/i18n":97,"./read-only.jsx":20,"underscore":198}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _text = require('./text.jsx');

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputNumeric = function (_React$Component) {
    _inherits(InputNumeric, _React$Component);

    function InputNumeric() {
        _classCallCheck(this, InputNumeric);

        return _possibleConstructorReturn(this, (InputNumeric.__proto__ || Object.getPrototypeOf(InputNumeric)).apply(this, arguments));
    }

    _createClass(InputNumeric, [{
        key: 'render',
        value: function render() {
            var data = this.props.data,
                fieldName = this.props.data.fieldName;


            return React.createElement(_text2.default, { key: fieldName, data: data });
        }
    }]);

    return InputNumeric;
}(React.Component);

exports.default = InputNumeric;

},{"./text.jsx":28}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _text = require('./text.jsx');

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputPassword = function (_InputText) {
    _inherits(InputPassword, _InputText);

    function InputPassword() {
        _classCallCheck(this, InputPassword);

        return _possibleConstructorReturn(this, (InputPassword.__proto__ || Object.getPrototypeOf(InputPassword)).apply(this, arguments));
    }

    _createClass(InputPassword, [{
        key: 'render',
        value: function render() {
            var data = this.props.data,
                fieldName = this.props.data.fieldName;


            return React.createElement(_text2.default, { key: fieldName, data: data });
        }
    }]);

    return InputPassword;
}(_text2.default);

exports.default = InputPassword;

},{"./text.jsx":28}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputReadOnly = function (_React$Component) {
    _inherits(InputReadOnly, _React$Component);

    function InputReadOnly() {
        _classCallCheck(this, InputReadOnly);

        return _possibleConstructorReturn(this, (InputReadOnly.__proto__ || Object.getPrototypeOf(InputReadOnly)).apply(this, arguments));
    }

    _createClass(InputReadOnly, [{
        key: 'render',
        value: function render() {
            var fieldValue = this.props.fieldValue;


            if (!fieldValue) {
                fieldValue = '-';
            }

            return React.createElement(
                'div',
                { className: 'form-control gc-read-only-input' },
                fieldValue
            );
        }
    }]);

    return InputReadOnly;
}(React.Component);

InputReadOnly.propTypes = {
    fieldValue: _propTypes2.default.string
};

exports.default = InputReadOnly;

},{"prop-types":182}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _linkedValue = require("../components/linked-value.js");

var _linkedValue2 = _interopRequireDefault(_linkedValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputRelationNtoN = function (_LinkedValue) {
    _inherits(InputRelationNtoN, _LinkedValue);

    function InputRelationNtoN() {
        _classCallCheck(this, InputRelationNtoN);

        return _possibleConstructorReturn(this, (InputRelationNtoN.__proto__ || Object.getPrototypeOf(InputRelationNtoN)).apply(this, arguments));
    }

    _createClass(InputRelationNtoN, [{
        key: "linkedChange",
        value: function linkedChange(event) {
            var selectedValues = [].concat(_toConsumableArray(event.target.options)).filter(function (option) {
                return option.selected;
            }).map(function (option) {
                return option.value;
            });

            this.setState({
                fieldValue: selectedValues
            });
        }
    }, {
        key: "render",
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValues = _props$data.fieldValues,
                isReadOnly = _props$data.isReadOnly,
                fieldValue = this.state.fieldValue,
                options = [];


            fieldValues.forEach(function forEachFieldValue(optionValue) {
                options.push(optionValue);
            });
            return React.createElement(
                "select",
                { name: fieldName, multiple: "multiple", className: "form-control",
                    disabled: isReadOnly, value: fieldValue, onChange: this.linkedChange.bind(this) },
                options.map(function DropDownForEach(field) {
                    var id = field.id,
                        title = field.title;

                    return React.createElement(
                        "option",
                        { value: id, key: id },
                        title
                    );
                })
            );
        }
    }]);

    return InputRelationNtoN;
}(_linkedValue2.default);

exports.default = InputRelationNtoN;

},{"../components/linked-value.js":1}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _linkedValue = require('../components/linked-value.js');

var _linkedValue2 = _interopRequireDefault(_linkedValue);

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputRelationalNative = function (_LinkedValue) {
    _inherits(InputRelationalNative, _LinkedValue);

    function InputRelationalNative() {
        _classCallCheck(this, InputRelationalNative);

        return _possibleConstructorReturn(this, (InputRelationalNative.__proto__ || Object.getPrototypeOf(InputRelationalNative)).apply(this, arguments));
    }

    _createClass(InputRelationalNative, [{
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValues = _props$data.fieldValues,
                isNullable = _props$data.isNullable,
                isReadOnly = _props$data.isReadOnly,
                fieldValue = this.state.fieldValue,
                fieldValueDescription = '',
                options = [];


            if (fieldValue === null) {
                fieldValue = '';
            }
            if (isNullable) {
                options.push({ id: '', title: '' });
            }
            fieldValues.forEach(function forEachFieldValue(optionValue) {
                options.push(optionValue);

                if (optionValue.id === fieldValue) {
                    fieldValueDescription = optionValue.title;
                }
            });

            if (isReadOnly) {
                return React.createElement(_readOnly2.default, { fieldValue: fieldValueDescription });
            }

            return React.createElement(
                'select',
                { name: fieldName,
                    value: fieldValue,
                    className: 'form-control',
                    disabled: isReadOnly,
                    onChange: this.linkedChange.bind(this) },
                options.map(function DropDownForEach(field) {
                    var id = field.id,
                        title = field.title;

                    return React.createElement(
                        'option',
                        { value: id, key: id },
                        title
                    );
                })
            );
        }
    }]);

    return InputRelationalNative;
}(_linkedValue2.default);

exports.default = InputRelationalNative;

},{"../components/linked-value.js":1,"./read-only.jsx":20}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _linkedValue = require('../components/linked-value.js');

var _linkedValue2 = _interopRequireDefault(_linkedValue);

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var jQueryPlugins = require('../../../Resources/public/js/modules/jquery/jquery-plugins').jQueryPlugins,
    $ = jQuery,
    i18n = require('../../../Resources/public/js/sections/i18n').i18n;

var InputRelationalSearchable = function (_LinkedValue) {
    _inherits(InputRelationalSearchable, _LinkedValue);

    function InputRelationalSearchable() {
        _classCallCheck(this, InputRelationalSearchable);

        return _possibleConstructorReturn(this, (InputRelationalSearchable.__proto__ || Object.getPrototypeOf(InputRelationalSearchable)).apply(this, arguments));
    }

    _createClass(InputRelationalSearchable, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            jQueryPlugins.searchableSelect($(ReactDOM.findDOMNode(this)).find('select'), this.props.data.isReadOnly);
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            jQueryPlugins.searchableSelectUpdate($(ReactDOM.findDOMNode(this)).find('select'), this.props.data.isReadOnly);
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValue = _props$data.fieldValue,
                fieldValues = _props$data.fieldValues,
                isNullable = _props$data.isNullable,
                isReadOnly = _props$data.isReadOnly,
                options = [],
                fieldValueDescription = '',
                extraInput = '';


            if (fieldValue === null) {
                fieldValue = '';
            }
            if (isNullable) {
                options.push({ id: '', title: '' });
            }
            fieldValues.forEach(function forEachFieldValue(optionValue) {
                options.push(optionValue);

                if (optionValue.id === fieldValue) {
                    fieldValueDescription = optionValue.title;
                }
            });
            if (isReadOnly) {
                extraInput = React.createElement(_readOnly2.default, { fieldValue: fieldValueDescription });
            }

            return React.createElement(
                'div',
                null,
                extraInput,
                React.createElement(
                    'select',
                    { name: fieldName, value: fieldValue,
                        className: 'form-control', disabled: isReadOnly,
                        onChange: this.linkedChange.bind(this), 'data-placeholder': i18n.t('select_an_option') },
                    options.map(function DropDownForEach(field) {
                        var id = field.id,
                            title = field.title;

                        return React.createElement(
                            'option',
                            { value: id, key: id },
                            title
                        );
                    })
                )
            );
        }
    }]);

    return InputRelationalSearchable;
}(_linkedValue2.default);

exports.default = InputRelationalSearchable;

},{"../../../Resources/public/js/modules/jquery/jquery-plugins":88,"../../../Resources/public/js/sections/i18n":97,"../components/linked-value.js":1,"./read-only.jsx":20}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RichTexteditorReadOnly = function (_React$Component) {
    _inherits(RichTexteditorReadOnly, _React$Component);

    function RichTexteditorReadOnly(props) {
        _classCallCheck(this, RichTexteditorReadOnly);

        var _this = _possibleConstructorReturn(this, (RichTexteditorReadOnly.__proto__ || Object.getPrototypeOf(RichTexteditorReadOnly)).call(this, props));

        _this.state = {
            previewAsHtml: false
        };
        return _this;
    }

    _createClass(RichTexteditorReadOnly, [{
        key: 'togglePreviewAsHtml',
        value: function togglePreviewAsHtml() {
            var previewAsHtml = this.state.previewAsHtml;

            this.setState({
                previewAsHtml: !previewAsHtml
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _props = this.props,
                fieldValue = _props.fieldValue,
                i18n = _props.i18n,
                previewAsHtml = this.state.previewAsHtml;


            if (!fieldValue) {
                return React.createElement(_readOnly2.default, null);
            }

            return React.createElement(
                React.Fragment,
                null,
                previewAsHtml ? React.createElement('div', { className: 'gc-html-preview', dangerouslySetInnerHTML: { __html: fieldValue } }) : React.createElement(
                    'pre',
                    { className: 'gc-rich-texteditor-read-only' },
                    fieldValue
                ),
                React.createElement(
                    'button',
                    {
                        onClick: this.togglePreviewAsHtml.bind(this),
                        type: 'button',
                        className: 'btn btn-default btn-outline-dark'
                    },
                    previewAsHtml ? i18n.preview_as_plain_text : i18n.preview_as_html
                )
            );
        }
    }]);

    return RichTexteditorReadOnly;
}(React.Component);

RichTexteditorReadOnly.propTypes = {
    fieldValue: _propTypes2.default.string,
    i18n: _propTypes2.default.shape({
        preview_as_plain_text: _propTypes2.default.string,
        preview_as_html: _propTypes2.default.string
    })
};

RichTexteditorReadOnly.defaultProps = {
    i18n: {
        preview_as_plain_text: 'Preview as plain text',
        preview_as_html: 'Preview as HTML'
    }
};

exports.default = RichTexteditorReadOnly;

},{"./read-only.jsx":20,"prop-types":182}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var jQueryPlugins = require('../../../Resources/public/js/modules/jquery/jquery-plugins').jQueryPlugins,
    $ = jQuery;

var RichTexteditorWithPlugin = function (_React$Component) {
    _inherits(RichTexteditorWithPlugin, _React$Component);

    function RichTexteditorWithPlugin(props) {
        _classCallCheck(this, RichTexteditorWithPlugin);

        var _this = _possibleConstructorReturn(this, (RichTexteditorWithPlugin.__proto__ || Object.getPrototypeOf(RichTexteditorWithPlugin)).call(this, props));

        _this.state = {
            fieldValue: props.fieldValue
        };
        return _this;
    }

    _createClass(RichTexteditorWithPlugin, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var fieldName = nextProps.fieldName,
                fieldValue = nextProps.fieldValue;

            jQueryPlugins.updateTexteditor(fieldName, fieldValue);
            this.setState({
                fieldValue: fieldValue
            });
        }
    }, {
        key: 'linkedChange',
        value: function linkedChange(event) {
            this.setState({
                fieldValue: event.target.value
            });
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            var _props = this.props,
                fieldName = _props.fieldName,
                fieldValue = _props.fieldValue;

            jQueryPlugins.texteditor($(ReactDOM.findDOMNode(this)), fieldName, fieldValue);
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            var fieldName = this.props.fieldName;

            jQueryPlugins.destroyTexteditor(fieldName);
        }
    }, {
        key: 'render',
        value: function render() {
            var fieldName = this.props.fieldName,
                fieldValue = this.state.fieldValue;


            return React.createElement('textarea', {
                className: 'form-control',
                name: fieldName,
                value: fieldValue,
                onChange: this.linkedChange.bind(this)
            });
        }
    }]);

    return RichTexteditorWithPlugin;
}(React.Component);

RichTexteditorWithPlugin.propTypes = {
    fieldName: _propTypes2.default.string,
    fieldValue: _propTypes2.default.string
};

exports.default = RichTexteditorWithPlugin;

},{"../../../Resources/public/js/modules/jquery/jquery-plugins":88,"prop-types":182}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _richTexteditorWithPlugin = require('./rich-texteditor-with-plugin');

var _richTexteditorWithPlugin2 = _interopRequireDefault(_richTexteditorWithPlugin);

var _richTexteditorReadOnly = require('./rich-texteditor-read-only.jsx');

var _richTexteditorReadOnly2 = _interopRequireDefault(_richTexteditorReadOnly);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var i18n = require('../../../Resources/public/js/sections/i18n').i18n;

var InputRichTexteditor = function (_React$Component) {
    _inherits(InputRichTexteditor, _React$Component);

    function InputRichTexteditor() {
        _classCallCheck(this, InputRichTexteditor);

        return _possibleConstructorReturn(this, (InputRichTexteditor.__proto__ || Object.getPrototypeOf(InputRichTexteditor)).apply(this, arguments));
    }

    _createClass(InputRichTexteditor, [{
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValue = _props$data.fieldValue,
                isReadOnly = _props$data.isReadOnly;


            if (isReadOnly) {
                return React.createElement(_richTexteditorReadOnly2.default, {
                    i18n: i18n.translations,
                    fieldValue: fieldValue
                });
            }

            return React.createElement(_richTexteditorWithPlugin2.default, {
                fieldName: fieldName,
                fieldValue: fieldValue
            });
        }
    }]);

    return InputRichTexteditor;
}(React.Component);

exports.default = InputRichTexteditor;

},{"../../../Resources/public/js/sections/i18n":97,"./rich-texteditor-read-only.jsx":24,"./rich-texteditor-with-plugin":25}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _linkedValue = require('../components/linked-value.js');

var _linkedValue2 = _interopRequireDefault(_linkedValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var jQueryPlugins = require('../../../Resources/public/js/modules/jquery/jquery-plugins').jQueryPlugins,
    $ = jQuery,
    i18n = require('../../../Resources/public/js/sections/i18n').i18n;

var InputSearchableRelationNtoN = function (_LinkedValue) {
    _inherits(InputSearchableRelationNtoN, _LinkedValue);

    function InputSearchableRelationNtoN() {
        _classCallCheck(this, InputSearchableRelationNtoN);

        return _possibleConstructorReturn(this, (InputSearchableRelationNtoN.__proto__ || Object.getPrototypeOf(InputSearchableRelationNtoN)).apply(this, arguments));
    }

    _createClass(InputSearchableRelationNtoN, [{
        key: 'linkedChange',
        value: function linkedChange(event) {
            var selectedValues = [].concat(_toConsumableArray(event.target.options)).filter(function (option) {
                return option.selected;
            }).map(function (option) {
                return option.value;
            });

            this.setState({
                fieldValue: selectedValues
            });
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            jQueryPlugins.searchableSelect($(ReactDOM.findDOMNode(this)));
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            jQueryPlugins.searchableSelectUpdate($(ReactDOM.findDOMNode(this)));
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValues = _props$data.fieldValues,
                isReadOnly = _props$data.isReadOnly;
            var fieldValue = this.state.fieldValue,
                options = [];


            fieldValues.forEach(function forEachFieldValue(optionValue) {
                options.push(optionValue);
            });

            if (!fieldValue) {
                fieldValue = [];
            }

            return React.createElement(
                'select',
                { name: fieldName, multiple: 'multiple', className: 'form-control',
                    disabled: isReadOnly, value: fieldValue, onChange: this.linkedChange.bind(this),
                    'data-placeholder': i18n.t('select_some_options') },
                options.map(function DropDownForEach(field) {
                    var id = field.id,
                        title = field.title;

                    return React.createElement(
                        'option',
                        { value: id, key: id },
                        title
                    );
                })
            );
        }
    }]);

    return InputSearchableRelationNtoN;
}(_linkedValue2.default);

exports.default = InputSearchableRelationNtoN;

},{"../../../Resources/public/js/modules/jquery/jquery-plugins":88,"../../../Resources/public/js/sections/i18n":97,"../components/linked-value.js":1}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputText = function (_React$Component) {
    _inherits(InputText, _React$Component);

    function InputText(props) {
        _classCallCheck(this, InputText);

        var fieldValue = props.data.fieldValue;

        var _this = _possibleConstructorReturn(this, (InputText.__proto__ || Object.getPrototypeOf(InputText)).call(this, props));

        _this.state = {
            fieldValue: fieldValue ? fieldValue : ''
        };
        return _this;
    }

    _createClass(InputText, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var fieldValue = nextProps.data.fieldValue;


            this.setState({
                fieldValue: fieldValue ? fieldValue : ''
            });
        }
    }, {
        key: 'linkedChange',
        value: function linkedChange(event) {
            this.setState({
                fieldValue: event.target.value
            });
        }
    }, {
        key: 'getInputType',
        value: function getInputType(fieldType) {
            if (/^(email|url|color|password)$/.test(fieldType)) {
                return fieldType;
            }

            if (/^(int|numeric)$/.test(fieldType)) {
                return 'number';
            }

            return 'text';
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                isReadOnly = _props$data.isReadOnly,
                fieldType = _props$data.fieldType,
                fieldValue = this.state.fieldValue;


            if (isReadOnly) {
                return React.createElement(_readOnly2.default, { fieldValue: fieldValue });
            }

            return React.createElement('input', {
                className: 'form-control',
                name: fieldName,
                type: this.getInputType(fieldType),
                readOnly: isReadOnly,
                value: fieldValue,
                onChange: this.linkedChange.bind(this) });
        }
    }]);

    return InputText;
}(React.Component);

InputText.propTypes = {
    data: _propTypes2.default.shape({
        fieldName: _propTypes2.default.string,
        isReadOnly: _propTypes2.default.bool,
        fieldType: _propTypes2.default.string
    })
};

exports.default = InputText;

},{"./read-only.jsx":20,"prop-types":182}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputTextarea = function (_React$Component) {
    _inherits(InputTextarea, _React$Component);

    function InputTextarea(props) {
        _classCallCheck(this, InputTextarea);

        var fieldValue = props.data.fieldValue;

        var _this = _possibleConstructorReturn(this, (InputTextarea.__proto__ || Object.getPrototypeOf(InputTextarea)).call(this, props));

        _this.state = {
            fieldValue: fieldValue ? fieldValue : ''
        };
        return _this;
    }

    _createClass(InputTextarea, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var fieldValue = nextProps.data.fieldValue;


            this.setState({
                fieldValue: fieldValue ? fieldValue : ''
            });
        }
    }, {
        key: 'linkedChange',
        value: function linkedChange(event) {
            this.setState({
                fieldValue: event.target.value
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                isReadOnly = _props$data.isReadOnly,
                fieldValue = this.state.fieldValue;


            if (isReadOnly) {
                return React.createElement(_readOnly2.default, { fieldValue: fieldValue });
            }

            return React.createElement('textarea', {
                className: 'form-control',
                name: fieldName,
                disabled: isReadOnly,
                value: fieldValue,
                onChange: this.linkedChange.bind(this) });
        }
    }]);

    return InputTextarea;
}(React.Component);

exports.default = InputTextarea;

},{"./read-only.jsx":20}],30:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
  if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object') module.exports = factory(require("prop-types"));else if (typeof define === 'function' && define.amd) define(["prop-types"], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["Dropzone"] = factory(require("prop-types"));else root["Dropzone"] = factory(root["prop-types"]);
})(undefined, function (__WEBPACK_EXTERNAL_MODULE_2__) {
  return (/******/function (modules) {
      // webpackBootstrap
      /******/ // The module cache
      /******/var installedModules = {};
      /******/
      /******/ // The require function
      /******/function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/if (installedModules[moduleId]) {
          /******/return installedModules[moduleId].exports;
          /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/var module = installedModules[moduleId] = {
          /******/i: moduleId,
          /******/l: false,
          /******/exports: {}
          /******/ };
        /******/
        /******/ // Execute the module function
        /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/return module.exports;
        /******/
      }
      /******/
      /******/
      /******/ // expose the modules object (__webpack_modules__)
      /******/__webpack_require__.m = modules;
      /******/
      /******/ // expose the module cache
      /******/__webpack_require__.c = installedModules;
      /******/
      /******/ // define getter function for harmony exports
      /******/__webpack_require__.d = function (exports, name, getter) {
        /******/if (!__webpack_require__.o(exports, name)) {
          /******/Object.defineProperty(exports, name, {
            /******/configurable: false,
            /******/enumerable: true,
            /******/get: getter
            /******/ });
          /******/
        }
        /******/
      };
      /******/
      /******/ // getDefaultExport function for compatibility with non-harmony modules
      /******/__webpack_require__.n = function (module) {
        /******/var getter = module && module.__esModule ?
        /******/function getDefault() {
          return module['default'];
        } :
        /******/function getModuleExports() {
          return module;
        };
        /******/__webpack_require__.d(getter, 'a', getter);
        /******/return getter;
        /******/
      };
      /******/
      /******/ // Object.prototype.hasOwnProperty.call
      /******/__webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/
      /******/ // __webpack_public_path__
      /******/__webpack_require__.p = "";
      /******/
      /******/ // Load entry module and return exports
      /******/return __webpack_require__(__webpack_require__.s = 0);
      /******/
    }(
    /************************************************************************/
    /******/[
    /* 0 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";
      /* WEBPACK VAR INJECTION */
      (function (process) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _extends = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }return target;
        };

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
          };
        }();

        var _propTypes = __webpack_require__(2);

        var _propTypes2 = _interopRequireDefault(_propTypes);

        var _utils = __webpack_require__(3);

        var _styles = __webpack_require__(5);

        var _styles2 = _interopRequireDefault(_styles);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }

        function _objectWithoutProperties(obj, keys) {
          var target = {};for (var i in obj) {
            if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
          }return target;
        }

        function _toConsumableArray(arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
              arr2[i] = arr[i];
            }return arr2;
          } else {
            return Array.from(arr);
          }
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
          }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        } /* eslint prefer-template: 0 */

        //import React from 'react'


        var Dropzone = function (_React$Component) {
          _inherits(Dropzone, _React$Component);

          function Dropzone(props, context) {
            _classCallCheck(this, Dropzone);

            var _this = _possibleConstructorReturn(this, (Dropzone.__proto__ || Object.getPrototypeOf(Dropzone)).call(this, props, context));

            _this.renderChildren = function (children, isDragActive, isDragAccept, isDragReject) {
              if (typeof children === 'function') {
                return children(_extends({}, _this.state, {
                  isDragActive: isDragActive,
                  isDragAccept: isDragAccept,
                  isDragReject: isDragReject
                }));
              }
              return children;
            };

            _this.composeHandlers = _this.composeHandlers.bind(_this);
            _this.onClick = _this.onClick.bind(_this);
            _this.onDocumentDrop = _this.onDocumentDrop.bind(_this);
            _this.onDragEnter = _this.onDragEnter.bind(_this);
            _this.onDragLeave = _this.onDragLeave.bind(_this);
            _this.onDragOver = _this.onDragOver.bind(_this);
            _this.onDragStart = _this.onDragStart.bind(_this);
            _this.onDrop = _this.onDrop.bind(_this);
            _this.onFileDialogCancel = _this.onFileDialogCancel.bind(_this);
            _this.onInputElementClick = _this.onInputElementClick.bind(_this);

            _this.setRef = _this.setRef.bind(_this);
            _this.setRefs = _this.setRefs.bind(_this);

            _this.isFileDialogActive = false;

            _this.state = {
              draggedFiles: [],
              acceptedFiles: [],
              rejectedFiles: []
            };
            return _this;
          }

          _createClass(Dropzone, [{
            key: 'componentDidMount',
            value: function componentDidMount() {
              var preventDropOnDocument = this.props.preventDropOnDocument;

              this.dragTargets = [];

              if (preventDropOnDocument) {
                document.addEventListener('dragover', _utils.onDocumentDragOver, false);
                document.addEventListener('drop', this.onDocumentDrop, false);
              }
              this.fileInputEl.addEventListener('click', this.onInputElementClick, false);
              // Tried implementing addEventListener, but didn't work out
              document.body.onfocus = this.onFileDialogCancel;
            }
          }, {
            key: 'componentWillUnmount',
            value: function componentWillUnmount() {
              var preventDropOnDocument = this.props.preventDropOnDocument;

              if (preventDropOnDocument) {
                document.removeEventListener('dragover', _utils.onDocumentDragOver);
                document.removeEventListener('drop', this.onDocumentDrop);
              }
              this.fileInputEl.removeEventListener('click', this.onInputElementClick, false);
              // Can be replaced with removeEventListener, if addEventListener works
              document.body.onfocus = null;
            }
          }, {
            key: 'composeHandlers',
            value: function composeHandlers(handler) {
              if (this.props.disabled) {
                return null;
              }

              return handler;
            }
          }, {
            key: 'onDocumentDrop',
            value: function onDocumentDrop(evt) {
              if (this.node.contains(evt.target)) {
                // if we intercepted an event for our instance, let it propagate down to the instance's onDrop handler
                return;
              }
              evt.preventDefault();
              this.dragTargets = [];
            }
          }, {
            key: 'onDragStart',
            value: function onDragStart(evt) {
              if (this.props.onDragStart) {
                this.props.onDragStart.call(this, evt);
              }
            }
          }, {
            key: 'onDragEnter',
            value: function onDragEnter(evt) {
              evt.preventDefault();

              // Count the dropzone and any children that are entered.
              if (this.dragTargets.indexOf(evt.target) === -1) {
                this.dragTargets.push(evt.target);
              }

              this.setState({
                isDragActive: true, // Do not rely on files for the drag state. It doesn't work in Safari.
                draggedFiles: (0, _utils.getDataTransferItems)(evt)
              });

              if (this.props.onDragEnter) {
                this.props.onDragEnter.call(this, evt);
              }
            }
          }, {
            key: 'onDragOver',
            value: function onDragOver(evt) {
              // eslint-disable-line class-methods-use-this
              evt.preventDefault();
              evt.stopPropagation();
              try {
                evt.dataTransfer.dropEffect = 'copy'; // eslint-disable-line no-param-reassign
              } catch (err) {
                // continue regardless of error
              }

              if (this.props.onDragOver) {
                this.props.onDragOver.call(this, evt);
              }
              return false;
            }
          }, {
            key: 'onDragLeave',
            value: function onDragLeave(evt) {
              var _this2 = this;

              evt.preventDefault();

              // Only deactivate once the dropzone and all children have been left.
              this.dragTargets = this.dragTargets.filter(function (el) {
                return el !== evt.target && _this2.node.contains(el);
              });
              if (this.dragTargets.length > 0) {
                return;
              }

              // Clear dragging files state
              this.setState({
                isDragActive: false,
                draggedFiles: []
              });

              if (this.props.onDragLeave) {
                this.props.onDragLeave.call(this, evt);
              }
            }
          }, {
            key: 'onDrop',
            value: function onDrop(evt) {
              var _this3 = this;

              var _props = this.props,
                  onDrop = _props.onDrop,
                  onDropAccepted = _props.onDropAccepted,
                  onDropRejected = _props.onDropRejected,
                  multiple = _props.multiple,
                  disablePreview = _props.disablePreview,
                  accept = _props.accept;

              var fileList = (0, _utils.getDataTransferItems)(evt);
              var acceptedFiles = [];
              var rejectedFiles = [];

              // Stop default browser behavior
              evt.preventDefault();

              // Reset the counter along with the drag on a drop.
              this.dragTargets = [];
              this.isFileDialogActive = false;

              fileList.forEach(function (file) {
                if (!disablePreview) {
                  try {
                    file.preview = window.URL.createObjectURL(file); // eslint-disable-line no-param-reassign
                  } catch (err) {
                    if (process.env.NODE_ENV !== 'production') {
                      console.error('Failed to generate preview for file', file, err); // eslint-disable-line no-console
                    }
                  }
                }

                if ((0, _utils.fileAccepted)(file, accept) && (0, _utils.fileMatchSize)(file, _this3.props.maxSize, _this3.props.minSize)) {
                  acceptedFiles.push(file);
                } else {
                  rejectedFiles.push(file);
                }
              });

              if (!multiple) {
                // if not in multi mode add any extra accepted files to rejected.
                // This will allow end users to easily ignore a multi file drop in "single" mode.
                rejectedFiles.push.apply(rejectedFiles, _toConsumableArray(acceptedFiles.splice(1)));
              }

              if (onDrop) {
                onDrop.call(this, acceptedFiles, rejectedFiles, evt);
              }

              if (rejectedFiles.length > 0 && onDropRejected) {
                onDropRejected.call(this, rejectedFiles, evt);
              }

              if (acceptedFiles.length > 0 && onDropAccepted) {
                onDropAccepted.call(this, acceptedFiles, evt);
              }

              // Clear files value
              this.draggedFiles = null;

              // Reset drag state
              this.setState({
                isDragActive: false,
                draggedFiles: [],
                acceptedFiles: acceptedFiles,
                rejectedFiles: rejectedFiles
              });
            }
          }, {
            key: 'onClick',
            value: function onClick(evt) {
              var _props2 = this.props,
                  onClick = _props2.onClick,
                  disableClick = _props2.disableClick;

              if (!disableClick) {
                evt.stopPropagation();

                if (onClick) {
                  onClick.call(this, evt);
                }

                // in IE11/Edge the file-browser dialog is blocking, ensure this is behind setTimeout
                // this is so react can handle state changes in the onClick prop above above
                // see: https://github.com/react-dropzone/react-dropzone/issues/450
                setTimeout(this.open.bind(this), 0);
              }
            }
          }, {
            key: 'onInputElementClick',
            value: function onInputElementClick(evt) {
              evt.stopPropagation();
              if (this.props.inputProps && this.props.inputProps.onClick) {
                this.props.inputProps.onClick();
              }
            }
          }, {
            key: 'onFileDialogCancel',
            value: function onFileDialogCancel() {
              // timeout will not recognize context of this method
              var onFileDialogCancel = this.props.onFileDialogCancel;
              var fileInputEl = this.fileInputEl;
              var isFileDialogActive = this.isFileDialogActive;
              // execute the timeout only if the onFileDialogCancel is defined and FileDialog
              // is opened in the browser

              if (onFileDialogCancel && isFileDialogActive) {
                setTimeout(function () {
                  // Returns an object as FileList
                  var FileList = fileInputEl.files;
                  if (!FileList.length) {
                    isFileDialogActive = false;
                    onFileDialogCancel();
                  }
                }, 300);
              }
            }
          }, {
            key: 'setRef',
            value: function setRef(ref) {
              this.node = ref;
            }
          }, {
            key: 'setRefs',
            value: function setRefs(ref) {
              this.fileInputEl = ref;
            }
            /**
             * Open system file upload dialog.
             *
             * @public
             */

          }, {
            key: 'open',
            value: function open() {
              this.isFileDialogActive = true;
              this.fileInputEl.value = null;
              this.fileInputEl.click();
            }
          }, {
            key: 'render',
            value: function render() {
              var _props3 = this.props,
                  accept = _props3.accept,
                  acceptClassName = _props3.acceptClassName,
                  activeClassName = _props3.activeClassName,
                  children = _props3.children,
                  disabled = _props3.disabled,
                  disabledClassName = _props3.disabledClassName,
                  inputProps = _props3.inputProps,
                  multiple = _props3.multiple,
                  name = _props3.name,
                  rejectClassName = _props3.rejectClassName,
                  rest = _objectWithoutProperties(_props3, ['accept', 'acceptClassName', 'activeClassName', 'children', 'disabled', 'disabledClassName', 'inputProps', 'multiple', 'name', 'rejectClassName']);

              var acceptStyle = rest.acceptStyle,
                  activeStyle = rest.activeStyle,
                  className = rest.className,
                  disabledStyle = rest.disabledStyle,
                  rejectStyle = rest.rejectStyle,
                  style = rest.style,
                  props = _objectWithoutProperties(rest, ['acceptStyle', 'activeStyle', 'className', 'disabledStyle', 'rejectStyle', 'style']);

              var _state = this.state,
                  isDragActive = _state.isDragActive,
                  draggedFiles = _state.draggedFiles;

              var filesCount = draggedFiles.length;
              var isMultipleAllowed = multiple || filesCount <= 1;
              var isDragAccept = filesCount > 0 && (0, _utils.allFilesAccepted)(draggedFiles, this.props.accept);
              var isDragReject = filesCount > 0 && (!isDragAccept || !isMultipleAllowed);
              className = className || '';
              var noStyles = !className && !style && !activeStyle && !acceptStyle && !rejectStyle && !disabledStyle;

              if (isDragActive && activeClassName) {
                className += ' ' + activeClassName;
              }
              if (isDragAccept && acceptClassName) {
                className += ' ' + acceptClassName;
              }
              if (isDragReject && rejectClassName) {
                className += ' ' + rejectClassName;
              }
              if (disabled && disabledClassName) {
                className += ' ' + disabledClassName;
              }

              if (noStyles) {
                style = _styles2.default.default;
                activeStyle = _styles2.default.active;
                acceptStyle = style.active;
                rejectStyle = _styles2.default.rejected;
                disabledStyle = _styles2.default.disabled;
              }

              var appliedStyle = _extends({}, style);
              if (activeStyle && isDragActive) {
                appliedStyle = _extends({}, style, activeStyle);
              }
              if (acceptStyle && isDragAccept) {
                appliedStyle = _extends({}, appliedStyle, acceptStyle);
              }
              if (rejectStyle && isDragReject) {
                appliedStyle = _extends({}, appliedStyle, rejectStyle);
              }
              if (disabledStyle && disabled) {
                appliedStyle = _extends({}, style, disabledStyle);
              }

              var inputAttributes = {
                accept: accept,
                disabled: disabled,
                type: 'file',
                style: { display: 'none' },
                multiple: _utils.supportMultiple && multiple,
                ref: this.setRefs,
                onChange: this.onDrop,
                autoComplete: 'off'
              };

              if (name && name.length) {
                inputAttributes.name = name;
              }

              // Remove custom properties before passing them to the wrapper div element
              var customProps = ['acceptedFiles', 'preventDropOnDocument', 'disablePreview', 'disableClick', 'activeClassName', 'acceptClassName', 'rejectClassName', 'disabledClassName', 'onDropAccepted', 'onDropRejected', 'onFileDialogCancel', 'maxSize', 'minSize'];
              var divProps = _extends({}, props);
              customProps.forEach(function (prop) {
                return delete divProps[prop];
              });

              return React.createElement('div', _extends({
                className: className,
                style: appliedStyle
              }, divProps /* expand user provided props first so event handlers are never overridden */, {
                onClick: this.composeHandlers(this.onClick),
                onDragStart: this.composeHandlers(this.onDragStart),
                onDragEnter: this.composeHandlers(this.onDragEnter),
                onDragOver: this.composeHandlers(this.onDragOver),
                onDragLeave: this.composeHandlers(this.onDragLeave),
                onDrop: this.composeHandlers(this.onDrop),
                ref: this.setRef,
                'aria-disabled': disabled
              }), this.renderChildren(children, isDragActive, isDragAccept, isDragReject), React.createElement('input', _extends({}, inputProps /* expand user provided inputProps first so inputAttributes override them */, inputAttributes)));
            }
          }]);

          return Dropzone;
        }(React.Component);

        exports.default = Dropzone;

        Dropzone.propTypes = {
          /**
           * Allow specific types of files. See https://github.com/okonet/attr-accept for more information.
           * Keep in mind that mime type determination is not reliable across platforms. CSV files,
           * for example, are reported as text/plain under macOS but as application/vnd.ms-excel under
           * Windows. In some cases there might not be a mime type set at all.
           * See: https://github.com/react-dropzone/react-dropzone/issues/276
           */
          accept: _propTypes2.default.string,

          /**
           * Contents of the dropzone
           */
          children: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.func]),

          /**
           * Disallow clicking on the dropzone container to open file dialog
           */
          disableClick: _propTypes2.default.bool,

          /**
          * Enable/disable the dropzone entirely
          */
          disabled: _propTypes2.default.bool,

          /**
           * Enable/disable preview generation
           */
          disablePreview: _propTypes2.default.bool,

          /**
           * If false, allow dropped items to take over the current browser window
           */
          preventDropOnDocument: _propTypes2.default.bool,

          /**
           * Pass additional attributes to the `<input type="file"/>` tag
           */
          inputProps: _propTypes2.default.object,

          /**
           * Allow dropping multiple files
           */
          multiple: _propTypes2.default.bool,

          /**
           * `name` attribute for the input tag
           */
          name: _propTypes2.default.string,

          /**
           * Maximum file size
           */
          maxSize: _propTypes2.default.number,

          /**
           * Minimum file size
           */
          minSize: _propTypes2.default.number,

          /**
           * className
           */
          className: _propTypes2.default.string,

          /**
           * className for active state
           */
          activeClassName: _propTypes2.default.string,

          /**
           * className for accepted state
           */
          acceptClassName: _propTypes2.default.string,

          /**
           * className for rejected state
           */
          rejectClassName: _propTypes2.default.string,

          /**
           * className for disabled state
           */
          disabledClassName: _propTypes2.default.string,

          /**
           * CSS styles to apply
           */
          style: _propTypes2.default.object,

          /**
           * CSS styles to apply when drag is active
           */
          activeStyle: _propTypes2.default.object,

          /**
           * CSS styles to apply when drop will be accepted
           */
          acceptStyle: _propTypes2.default.object,

          /**
           * CSS styles to apply when drop will be rejected
           */
          rejectStyle: _propTypes2.default.object,

          /**
           * CSS styles to apply when dropzone is disabled
           */
          disabledStyle: _propTypes2.default.object,

          /**
           * onClick callback
           * @param {Event} event
           */
          onClick: _propTypes2.default.func,

          /**
           * onDrop callback
           */
          onDrop: _propTypes2.default.func,

          /**
           * onDropAccepted callback
           */
          onDropAccepted: _propTypes2.default.func,

          /**
           * onDropRejected callback
           */
          onDropRejected: _propTypes2.default.func,

          /**
           * onDragStart callback
           */
          onDragStart: _propTypes2.default.func,

          /**
           * onDragEnter callback
           */
          onDragEnter: _propTypes2.default.func,

          /**
           * onDragOver callback
           */
          onDragOver: _propTypes2.default.func,

          /**
           * onDragLeave callback
           */
          onDragLeave: _propTypes2.default.func,

          /**
           * Provide a callback on clicking the cancel button of the file dialog
           */
          onFileDialogCancel: _propTypes2.default.func
        };

        Dropzone.defaultProps = {
          preventDropOnDocument: true,
          disabled: false,
          disablePreview: false,
          disableClick: false,
          multiple: true,
          maxSize: Infinity,
          minSize: 0
        };
        module.exports = exports['default'];
        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(1));

      /***/
    },
    /* 1 */
    /***/function (module, exports) {

      // shim for using process in browser
      var process = module.exports = {};

      // cached from whatever global is present so that test runners that stub it
      // don't break things.  But we need to wrap it in a try catch in case it is
      // wrapped in strict mode code which doesn't define any globals.  It's inside a
      // function because try/catches deoptimize in certain engines.

      var cachedSetTimeout;
      var cachedClearTimeout;

      function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
      }
      function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
      }
      (function () {
        try {
          if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;

      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }

      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }

      process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };

      // v8 likes predictible objects
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function () {
        this.fun.apply(null, this.array);
      };
      process.title = 'browser';
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = ''; // empty string to avoid regexp issues
      process.versions = {};

      function noop() {}

      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;

      process.listeners = function (name) {
        return [];
      };

      process.binding = function (name) {
        throw new Error('process.binding is not supported');
      };

      process.cwd = function () {
        return '/';
      };
      process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
      };
      process.umask = function () {
        return 0;
      };

      /***/
    },
    /* 2 */
    /***/function (module, exports) {

      module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

      /***/
    },
    /* 3 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.supportMultiple = undefined;
      exports.getDataTransferItems = getDataTransferItems;
      exports.fileAccepted = fileAccepted;
      exports.fileMatchSize = fileMatchSize;
      exports.allFilesAccepted = allFilesAccepted;
      exports.onDocumentDragOver = onDocumentDragOver;

      var _attrAccept = __webpack_require__(4);

      var _attrAccept2 = _interopRequireDefault(_attrAccept);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      var supportMultiple = exports.supportMultiple = typeof document !== 'undefined' && document && document.createElement ? 'multiple' in document.createElement('input') : true;

      function getDataTransferItems(event) {
        var dataTransferItemsList = [];
        if (event.dataTransfer) {
          var dt = event.dataTransfer;
          if (dt.files && dt.files.length) {
            dataTransferItemsList = dt.files;
          } else if (dt.items && dt.items.length) {
            // During the drag even the dataTransfer.files is null
            // but Chrome implements some drag store, which is accesible via dataTransfer.items
            dataTransferItemsList = dt.items;
          }
        } else if (event.target && event.target.files) {
          dataTransferItemsList = event.target.files;
        }
        // Convert from DataTransferItemsList to the native Array
        return Array.prototype.slice.call(dataTransferItemsList);
      }

      // Firefox versions prior to 53 return a bogus MIME type for every file drag, so dragovers with
      // that MIME type will always be accepted
      function fileAccepted(file, accept) {
        return file.type === 'application/x-moz-file' || (0, _attrAccept2.default)(file, accept);
      }

      function fileMatchSize(file, maxSize, minSize) {
        return file.size <= maxSize && file.size >= minSize;
      }

      function allFilesAccepted(files, accept) {
        return files.every(function (file) {
          return fileAccepted(file, accept);
        });
      }

      // allow the entire document to be a drag target
      function onDocumentDragOver(evt) {
        evt.preventDefault();
      }

      /***/
    },
    /* 4 */
    /***/function (module, exports) {

      module.exports = function (t) {
        function n(e) {
          if (r[e]) return r[e].exports;var o = r[e] = { exports: {}, id: e, loaded: !1 };return t[e].call(o.exports, o, o.exports, n), o.loaded = !0, o.exports;
        }var r = {};return n.m = t, n.c = r, n.p = "", n(0);
      }([function (t, n, r) {
        "use strict";
        n.__esModule = !0, r(8), r(9), n["default"] = function (t, n) {
          if (t && n) {
            var r = function () {
              var r = Array.isArray(n) ? n : n.split(","),
                  e = t.name || "",
                  o = t.type || "",
                  i = o.replace(/\/.*$/, "");return { v: r.some(function (t) {
                  var n = t.trim();return "." === n.charAt(0) ? e.toLowerCase().endsWith(n.toLowerCase()) : /\/\*$/.test(n) ? i === n.replace(/\/.*$/, "") : o === n;
                }) };
            }();if ("object" == (typeof r === 'undefined' ? 'undefined' : _typeof(r))) return r.v;
          }return !0;
        }, t.exports = n["default"];
      }, function (t, n) {
        var r = t.exports = { version: "1.2.2" };"number" == typeof __e && (__e = r);
      }, function (t, n) {
        var r = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();"number" == typeof __g && (__g = r);
      }, function (t, n, r) {
        var e = r(2),
            o = r(1),
            i = r(4),
            u = r(19),
            c = "prototype",
            f = function f(t, n) {
          return function () {
            return t.apply(n, arguments);
          };
        },
            s = function s(t, n, r) {
          var a,
              p,
              l,
              y,
              d = t & s.G,
              h = t & s.P,
              v = d ? e : t & s.S ? e[n] || (e[n] = {}) : (e[n] || {})[c],
              x = d ? o : o[n] || (o[n] = {});d && (r = n);for (a in r) {
            p = !(t & s.F) && v && a in v, l = (p ? v : r)[a], y = t & s.B && p ? f(l, e) : h && "function" == typeof l ? f(Function.call, l) : l, v && !p && u(v, a, l), x[a] != l && i(x, a, y), h && ((x[c] || (x[c] = {}))[a] = l);
          }
        };e.core = o, s.F = 1, s.G = 2, s.S = 4, s.P = 8, s.B = 16, s.W = 32, t.exports = s;
      }, function (t, n, r) {
        var e = r(5),
            o = r(18);t.exports = r(22) ? function (t, n, r) {
          return e.setDesc(t, n, o(1, r));
        } : function (t, n, r) {
          return t[n] = r, t;
        };
      }, function (t, n) {
        var r = Object;t.exports = { create: r.create, getProto: r.getPrototypeOf, isEnum: {}.propertyIsEnumerable, getDesc: r.getOwnPropertyDescriptor, setDesc: r.defineProperty, setDescs: r.defineProperties, getKeys: r.keys, getNames: r.getOwnPropertyNames, getSymbols: r.getOwnPropertySymbols, each: [].forEach };
      }, function (t, n) {
        var r = 0,
            e = Math.random();t.exports = function (t) {
          return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++r + e).toString(36));
        };
      }, function (t, n, r) {
        var e = r(20)("wks"),
            o = r(2).Symbol;t.exports = function (t) {
          return e[t] || (e[t] = o && o[t] || (o || r(6))("Symbol." + t));
        };
      }, function (t, n, r) {
        r(26), t.exports = r(1).Array.some;
      }, function (t, n, r) {
        r(25), t.exports = r(1).String.endsWith;
      }, function (t, n) {
        t.exports = function (t) {
          if ("function" != typeof t) throw TypeError(t + " is not a function!");return t;
        };
      }, function (t, n) {
        var r = {}.toString;t.exports = function (t) {
          return r.call(t).slice(8, -1);
        };
      }, function (t, n, r) {
        var e = r(10);t.exports = function (t, n, r) {
          if (e(t), void 0 === n) return t;switch (r) {case 1:
              return function (r) {
                return t.call(n, r);
              };case 2:
              return function (r, e) {
                return t.call(n, r, e);
              };case 3:
              return function (r, e, o) {
                return t.call(n, r, e, o);
              };}return function () {
            return t.apply(n, arguments);
          };
        };
      }, function (t, n) {
        t.exports = function (t) {
          if (void 0 == t) throw TypeError("Can't call method on  " + t);return t;
        };
      }, function (t, n, r) {
        t.exports = function (t) {
          var n = /./;try {
            "/./"[t](n);
          } catch (e) {
            try {
              return n[r(7)("match")] = !1, !"/./"[t](n);
            } catch (o) {}
          }return !0;
        };
      }, function (t, n) {
        t.exports = function (t) {
          try {
            return !!t();
          } catch (n) {
            return !0;
          }
        };
      }, function (t, n) {
        t.exports = function (t) {
          return "object" == (typeof t === 'undefined' ? 'undefined' : _typeof(t)) ? null !== t : "function" == typeof t;
        };
      }, function (t, n, r) {
        var e = r(16),
            o = r(11),
            i = r(7)("match");t.exports = function (t) {
          var n;return e(t) && (void 0 !== (n = t[i]) ? !!n : "RegExp" == o(t));
        };
      }, function (t, n) {
        t.exports = function (t, n) {
          return { enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: n };
        };
      }, function (t, n, r) {
        var e = r(2),
            o = r(4),
            i = r(6)("src"),
            u = "toString",
            c = Function[u],
            f = ("" + c).split(u);r(1).inspectSource = function (t) {
          return c.call(t);
        }, (t.exports = function (t, n, r, u) {
          "function" == typeof r && (o(r, i, t[n] ? "" + t[n] : f.join(String(n))), "name" in r || (r.name = n)), t === e ? t[n] = r : (u || delete t[n], o(t, n, r));
        })(Function.prototype, u, function () {
          return "function" == typeof this && this[i] || c.call(this);
        });
      }, function (t, n, r) {
        var e = r(2),
            o = "__core-js_shared__",
            i = e[o] || (e[o] = {});t.exports = function (t) {
          return i[t] || (i[t] = {});
        };
      }, function (t, n, r) {
        var e = r(17),
            o = r(13);t.exports = function (t, n, r) {
          if (e(n)) throw TypeError("String#" + r + " doesn't accept regex!");return String(o(t));
        };
      }, function (t, n, r) {
        t.exports = !r(15)(function () {
          return 7 != Object.defineProperty({}, "a", { get: function get() {
              return 7;
            } }).a;
        });
      }, function (t, n) {
        var r = Math.ceil,
            e = Math.floor;t.exports = function (t) {
          return isNaN(t = +t) ? 0 : (t > 0 ? e : r)(t);
        };
      }, function (t, n, r) {
        var e = r(23),
            o = Math.min;t.exports = function (t) {
          return t > 0 ? o(e(t), 9007199254740991) : 0;
        };
      }, function (t, n, r) {
        "use strict";
        var e = r(3),
            o = r(24),
            i = r(21),
            u = "endsWith",
            c = ""[u];e(e.P + e.F * r(14)(u), "String", { endsWith: function endsWith(t) {
            var n = i(this, t, u),
                r = arguments,
                e = r.length > 1 ? r[1] : void 0,
                f = o(n.length),
                s = void 0 === e ? f : Math.min(o(e), f),
                a = String(t);return c ? c.call(n, a, s) : n.slice(s - a.length, s) === a;
          } });
      }, function (t, n, r) {
        var e = r(5),
            o = r(3),
            i = r(1).Array || Array,
            u = {},
            c = function c(t, n) {
          e.each.call(t.split(","), function (t) {
            void 0 == n && t in i ? u[t] = i[t] : t in [] && (u[t] = r(12)(Function.call, [][t], n));
          });
        };c("pop,reverse,shift,keys,values,entries", 1), c("indexOf,every,some,forEach,map,filter,find,findIndex,includes", 3), c("join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill"), o(o.S, "Array", u);
      }]);

      /***/
    },
    /* 5 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = {
        rejected: {
          borderStyle: 'solid',
          borderColor: '#c66',
          backgroundColor: '#eee'
        },
        disabled: {
          opacity: 0.5
        },
        active: {
          borderStyle: 'solid',
          borderColor: '#6c6',
          backgroundColor: '#eee'
        },
        default: {
          width: 200,
          height: 200,
          borderWidth: 2,
          borderColor: '#666',
          borderStyle: 'dashed',
          borderRadius: 5
        }
      };
      module.exports = exports['default'];

      /***/
    }]
    /******/)
  );
});


},{"prop-types":182}],31:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _reactDropzone = require('./third-party/react-dropzone');

var _reactDropzone2 = _interopRequireDefault(_reactDropzone);

var _superagent = require('superagent');

var _superagent2 = _interopRequireDefault(_superagent);

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ajaxHelper = require('../../../Resources/public/js/helpers/ajax-helper').ajaxHelper,
    i18n = require('../../../Resources/public/js/sections/i18n').i18n,
    $ = jQuery;

var InputUpload = function (_React$Component) {
    _inherits(InputUpload, _React$Component);

    function InputUpload(props) {
        _classCallCheck(this, InputUpload);

        var _props$data = props.data,
            options = _props$data.options,
            fieldValue = _props$data.fieldValue;

        var _this = _possibleConstructorReturn(this, (InputUpload.__proto__ || Object.getPrototypeOf(InputUpload)).call(this, props));

        _this.state = {
            filePath: fieldValue ? options.publicPath + '/' + fieldValue : null,
            filename: fieldValue,
            loading: false
        };
        return _this;
    }

    _createClass(InputUpload, [{
        key: 'onDrop',
        value: function onDrop(acceptedFiles) {
            var uploadUrl = ajaxHelper.getUrl.apply(this.props.gcrudInstance, ['upload']),
                uploadRequest = _superagent2.default.post(uploadUrl),
                requestExtraHeaders = void 0;

            this.setState({
                loading: true
            });

            requestExtraHeaders = $.ajaxSetup().headers;

            if (requestExtraHeaders !== undefined) {
                _underscore2.default.each(requestExtraHeaders, function foreachRequestHeaders(headerValue, headerName) {
                    uploadRequest.set(headerName, headerValue);
                });
            }

            uploadRequest.attach(this.props.data.fieldName, acceptedFiles[0]);
            uploadRequest.end(function uploadResponse(err, output) {
                var gcrudInstance = this.props.gcrudInstance,
                    jsonResponse = output.body;

                this.setState({
                    loading: false
                });
                if (err || jsonResponse === null) {
                    ajaxHelper.ajaxOnFail.apply(gcrudInstance, [output.text, err ? err.status : 'Not well JSON formatted response', 'error']);
                } else {

                    // Handled error
                    if (jsonResponse.status === 'failure') {
                        ajaxHelper.ajaxOnFail.apply(gcrudInstance, [jsonResponse.message, jsonResponse.status, 'error']);
                    }

                    if (jsonResponse.csrfToken) {
                        gcrudInstance.cachedInitialData.csrfToken = jsonResponse.csrfToken;
                    }

                    this.setState({
                        filePath: jsonResponse.uploadResult.filePath,
                        filename: jsonResponse.uploadResult.filename
                    });
                }
            }.bind(this));
        }
    }, {
        key: 'deleteOnClick',
        value: function deleteOnClick(event) {
            var gcrudInstance = this.props.gcrudInstance;
            var deleteFileUrl = ajaxHelper.getUrl.apply(gcrudInstance, []),
                deleteFileRequest = _superagent2.default.post(deleteFileUrl),
                fieldName = this.props.data.fieldName,
                filename = this.state.filename,
                dataToSend = {
                action: 'delete-file',
                fieldName: fieldName,
                filename: filename
            };


            if (gcrudInstance.cachedInitialData.csrfToken) {
                dataToSend[gcrudInstance.cachedInitialData.csrfToken.inputName] = gcrudInstance.cachedInitialData.csrfToken.inputValue;
            }

            deleteFileRequest.type('form');
            deleteFileRequest.send(dataToSend);

            event.preventDefault();
            this.setState({
                loading: true
            });
            deleteFileRequest.end(function deleteFileRequestEnd(err, output) {
                var jsonResponse = output.body;

                if (err || jsonResponse === null) {
                    ajaxHelper.ajaxOnFail.apply(gcrudInstance, [output.text, err ? err.status : 'Not well JSON formatted response', 'error']);
                } else {
                    // Handled error
                    if (jsonResponse.status === 'failure') {
                        ajaxHelper.ajaxOnFail.apply(gcrudInstance, [jsonResponse.message, jsonResponse.status, 'error']);
                    }

                    if (jsonResponse.csrfToken) {
                        gcrudInstance.cachedInitialData.csrfToken = jsonResponse.csrfToken;
                    }

                    this.setState({
                        loading: false,
                        filePath: null,
                        filename: ''
                    });
                }
            }.bind(this));
        }
    }, {
        key: 'getTranslationFileAttach',
        value: function getTranslationFileAttach() {
            var splittedString = i18n.t('upload_attach_file').split('{browse_file}');

            if (splittedString.length <= 1) {
                return splittedString[0];
            }

            return React.createElement(
                'span',
                null,
                splittedString[0],
                ' ',
                React.createElement(
                    'a',
                    null,
                    i18n.t('browse_file')
                ),
                ' ',
                splittedString[1]
            );
        }
    }, {
        key: 'render',
        value: function render() {
            var _state = this.state,
                filePath = _state.filePath,
                loading = _state.loading,
                filename = _state.filename,
                _props$data2 = this.props.data,
                fieldName = _props$data2.fieldName,
                isReadOnly = _props$data2.isReadOnly;


            if (loading) {
                return React.createElement(
                    'div',
                    null,
                    React.createElement('i', { className: 'fa fa-refresh fa-spin' }),
                    ' Loading...'
                );
            }

            if (isReadOnly && !filename) {
                return React.createElement(_readOnly2.default, { fieldValue: '' });
            }

            if (!filename) {
                return React.createElement(
                    'div',
                    null,
                    React.createElement(
                        _reactDropzone2.default,
                        { style: { display: 'block' }, onDrop: this.onDrop.bind(this), multiple: false },
                        React.createElement(
                            'div',
                            { className: 'gc-dropzone' },
                            React.createElement('i', { className: 'fa fa-cloud-upload' }),
                            '\xA0 ',
                            this.getTranslationFileAttach()
                        )
                    ),
                    React.createElement('input', { type: 'hidden', name: fieldName, value: '' })
                );
            }

            return React.createElement(
                'div',
                null,
                React.createElement(
                    'a',
                    { href: filePath, target: '_blank' },
                    /\.(jp(e)?g|gif|png|tiff)$/.test(filePath) ? React.createElement('img', { src: filePath, height: '50' }) : React.createElement(
                        'span',
                        null,
                        filename
                    )
                ),
                ' \xA0',
                isReadOnly ? '' : React.createElement(
                    'a',
                    { onClick: this.deleteOnClick.bind(this), className: 'btn btn-default' },
                    React.createElement('i', { className: 'fa fa-trash-o' }),
                    ' ',
                    i18n.t('action_delete')
                ),
                isReadOnly ? '' : React.createElement('input', { type: 'hidden', name: fieldName, value: filename })
            );
        }
    }]);

    return InputUpload;
}(React.Component);

exports.default = InputUpload;

},{"../../../Resources/public/js/helpers/ajax-helper":79,"../../../Resources/public/js/sections/i18n":97,"./read-only.jsx":20,"./third-party/react-dropzone":30,"superagent":192,"underscore":198}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _text = require('./text.jsx');

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputUrl = function (_InputText) {
    _inherits(InputUrl, _InputText);

    function InputUrl() {
        _classCallCheck(this, InputUrl);

        return _possibleConstructorReturn(this, (InputUrl.__proto__ || Object.getPrototypeOf(InputUrl)).apply(this, arguments));
    }

    _createClass(InputUrl, [{
        key: 'render',
        value: function render() {
            var data = this.props.data,
                fieldName = this.props.data.fieldName;


            return React.createElement(_text2.default, { key: fieldName, data: data });
        }
    }]);

    return InputUrl;
}(_text2.default);

exports.default = InputUrl;

},{"./text.jsx":28}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ModalTitle = function (_React$Component) {
    _inherits(ModalTitle, _React$Component);

    function ModalTitle() {
        _classCallCheck(this, ModalTitle);

        return _possibleConstructorReturn(this, (ModalTitle.__proto__ || Object.getPrototypeOf(ModalTitle)).apply(this, arguments));
    }

    _createClass(ModalTitle, [{
        key: "render",
        value: function render() {
            var _props = this.props,
                title = _props.title,
                ModalTitleWrapper = _props.ModalTitleWrapper;


            return React.createElement(ModalTitleWrapper, { title: title });
        }
    }]);

    return ModalTitle;
}(React.Component);

ModalTitle.propTypes = {
    title: _propTypes2.default.string,
    ModalTitleWrapper: _propTypes2.default.func
};

ModalTitle.defaultProps = {
    ModalTitleWrapper: function ModalTitleWrapper(props) {
        return React.createElement(
            React.Fragment,
            null,
            React.createElement(
                "button",
                {
                    type: "button",
                    className: "close",
                    "data-dismiss": "modal",
                    "aria-label": "Close"
                },
                React.createElement(
                    "span",
                    { "aria-hidden": "true" },
                    "\xD7"
                )
            ),
            React.createElement(
                "h4",
                { className: "modal-title" },
                props.title
            )
        );
    }
};

exports.default = ModalTitle;

},{"prop-types":182}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _visibleColumns = require('./visible-columns.jsx');

var _visibleColumns2 = _interopRequireDefault(_visibleColumns);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Settings = function (_React$Component) {
    _inherits(Settings, _React$Component);

    function Settings() {
        _classCallCheck(this, Settings);

        var _this = _possibleConstructorReturn(this, (Settings.__proto__ || Object.getPrototypeOf(Settings)).call(this));

        _this.setContainer = _this.setContainer.bind(_this);
        _this.state = {
            settingsOpen: false
        };
        return _this;
    }

    _createClass(Settings, [{
        key: 'toggleSettings',
        value: function toggleSettings() {
            this.setState({
                settingsOpen: !this.state.settingsOpen
            });
        }
    }, {
        key: 'setContainer',
        value: function setContainer(ref) {
            this.container = ref;
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            var _this2 = this;

            document.addEventListener('click', function (e) {
                return _this2.clickOutside(e);
            }, true);
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            var _this3 = this;

            document.removeEventListener('click', function (e) {
                return _this3.clickOutside(e);
            }, true);
        }
    }, {
        key: 'clickOutside',
        value: function clickOutside(event) {
            var settingsOpen = this.state.settingsOpen;


            if (settingsOpen && this.container && !this.container.contains(event.target)) {
                this.setState({
                    settingsOpen: false
                });
            }
        }
    }, {
        key: 'onRefreshCallback',
        value: function onRefreshCallback() {
            var onRefreshCallback = this.props.onRefreshCallback;


            if (onRefreshCallback) {
                onRefreshCallback();
            }
        }
    }, {
        key: 'onClearFilteringCallback',
        value: function onClearFilteringCallback() {
            var onClearFilteringCallback = this.props.onClearFilteringCallback;


            if (onClearFilteringCallback) {
                onClearFilteringCallback();
            }
        }
    }, {
        key: 'onClearCacheCallback',
        value: function onClearCacheCallback() {
            var onClearCacheCallback = this.props.onClearCacheCallback;


            if (onClearCacheCallback) {
                onClearCacheCallback();
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _this4 = this;

            var settingsOpen = this.state.settingsOpen,
                _props = this.props,
                i18n = _props.i18n,
                visibleColumnsCallbackOnChange = _props.visibleColumnsCallbackOnChange,
                columns = _props.columns,
                visibleColumns = _props.visibleColumns,
                gcrudInstance = _props.gcrudInstance,
                GroupPrimaryButton = _props.GroupPrimaryButton,
                GroupButtonsList = _props.GroupButtonsList,
                subMenuLeftDirection = _props.subMenuLeftDirection,
                buttons = [{
                hasSubMenu: true,
                subMenuLeftDirection: subMenuLeftDirection,
                icon: 'fa fa-list-alt',
                text: i18n.columns,
                key: 'columns',
                onClick: function onClick(e) {
                    return e.preventDefault();
                },
                subComponent: React.createElement(_visibleColumns2.default, {
                    callbackOnChange: visibleColumnsCallbackOnChange,
                    columns: columns,
                    gcrudInstance: gcrudInstance,
                    visibleColumns: visibleColumns
                })
            }, {
                icon: 'fa fa-refresh',
                text: i18n.refresh,
                key: 'refresh',
                onClick: function onClick(e) {
                    return _this4.onRefreshCallback(e);
                }

            }, {
                icon: 'fa fa-filter',
                text: i18n.clear_filtering,
                key: 'clear_filtering',
                onClick: function onClick(e) {
                    return _this4.onClearFilteringCallback(e);
                }

            }, {
                icon: 'fa fa-eraser',
                text: i18n.clear_cache,
                key: 'clear_cache',
                onClick: function onClick(e) {
                    return _this4.onClearCacheCallback(e);
                }
            }];


            return React.createElement(
                'div',
                { ref: this.setContainer, className: (0, _classnames2.default)('btn-group', {
                        open: settingsOpen
                    }) },
                React.createElement(
                    GroupPrimaryButton,
                    { type: 'button', onClick: function onClick() {
                            return _this4.toggleSettings();
                        } },
                    React.createElement('span', { className: 'fa fa-gear' }),
                    '\xA0',
                    i18n.settings,
                    '\xA0',
                    React.createElement('span', { className: 'caret' })
                ),
                React.createElement(GroupButtonsList, {
                    subMenuLeftDirection: subMenuLeftDirection,
                    buttons: buttons.map(function (button) {
                        return {
                            subMenuLeftDirection: button.subMenuLeftDirection,
                            hasSubMenu: button.hasSubMenu,
                            icon: button.icon,
                            text: button.text,
                            key: button.key,
                            onClick: function onClick(event) {
                                if (button.onClick) {
                                    event.preventDefault();
                                    button.onClick(event);
                                }
                            },
                            subComponent: button.subComponent
                        };
                    }) })
            );
        }
    }]);

    return Settings;
}(React.Component);

Settings.propTypes = {
    onRefreshCallback: _propTypes2.default.func,
    onClearFilteringCallback: _propTypes2.default.func,
    onClearCacheCallback: _propTypes2.default.func,
    columns: _propTypes2.default.array,
    gcrudInstance: _propTypes2.default.object,
    visibleColumns: _propTypes2.default.array,
    visibleColumnsCallbackOnChange: _propTypes2.default.func,
    i18n: _propTypes2.default.shape({
        settings: _propTypes2.default.string,
        columns: _propTypes2.default.string,
        refresh: _propTypes2.default.string,
        clear_filtering: _propTypes2.default.string,
        clear_cache: _propTypes2.default.string
    }),
    GroupPrimaryButton: _propTypes2.default.func,
    subMenuLeftDirection: _propTypes2.default.bool
};

Settings.defaultProps = {
    GroupPrimaryButton: function GroupPrimaryButton(props) {
        return React.createElement(
            'button',
            props,
            props.children
        );
    },
    GroupButtonsList: function GroupButtonsList(props) {
        return React.createElement(
            'ul',
            { className: 'dropdown-menu' },
            props.buttons.map(function (button) {
                return React.createElement(
                    'li',
                    { key: button.key, className: (0, _classnames2.default)({
                            'dropdown-submenu': button.hasSubMenu,
                            'left-direction': button.hasSubMenu && button.subMenuLeftDirection
                        }) },
                    React.createElement(
                        'a',
                        {
                            href: button.href ? button.href : '',
                            onClick: button.onClick,
                            target: button.target
                        },
                        button.icon && React.createElement('i', { className: (0, _classnames2.default)(button.icon, 'gc-button-icon') }),
                        button.text
                    ),
                    button.subComponent && React.createElement(
                        'ul',
                        { className: 'dropdown-menu' },
                        button.subComponent
                    )
                );
            })
        );
    }
};

exports.default = Settings;

},{"./visible-columns.jsx":35,"classnames":118,"prop-types":182}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var VisibleColumns = function (_React$Component) {
    _inherits(VisibleColumns, _React$Component);

    function VisibleColumns(props) {
        _classCallCheck(this, VisibleColumns);

        var _this = _possibleConstructorReturn(this, (VisibleColumns.__proto__ || Object.getPrototypeOf(VisibleColumns)).call(this, props));

        var checkedColumns = {},
            visibleColumns = _this.props.visibleColumns;


        _this.props.columns.forEach(function (column) {
            checkedColumns[column.columnName] = visibleColumns.indexOf(column.columnName) > -1;
        });

        _this.state = {
            checkedColumns: checkedColumns
        };
        return _this;
    }

    _createClass(VisibleColumns, [{
        key: 'onCheckboxChange',
        value: function onCheckboxChange(event) {
            var checkedColumns = this.state.checkedColumns,
                visibleColumns = [];

            checkedColumns[event.target.getAttribute('data-field-name')] = event.target.checked;

            if (!this.hasAtLeastOneChecked(checkedColumns)) {
                checkedColumns[event.target.getAttribute('data-field-name')] = true;
            }

            this.setState({
                checkedColumns: checkedColumns
            });

            Object.keys(checkedColumns).forEach(function (columnName) {
                if (checkedColumns[columnName]) {
                    visibleColumns.push(columnName);
                }
            });

            this.props.callbackOnChange.apply(this.props.gcrudInstance, [visibleColumns]);
        }
    }, {
        key: 'hasAtLeastOneChecked',
        value: function hasAtLeastOneChecked(checkedColumns) {
            var atLeastOneChecked = false;

            Object.keys(checkedColumns).forEach(function (columnName) {
                if (checkedColumns[columnName]) {
                    atLeastOneChecked = true;
                }
            });

            return atLeastOneChecked;
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            var columns = this.props.columns,
                checkedColumns = this.state.checkedColumns,
                columnsCheckboxes = columns.map(function (column) {
                return React.createElement(
                    'li',
                    { className: 'dropdown-item', key: column.columnName },
                    React.createElement(
                        'a',
                        null,
                        React.createElement(
                            'label',
                            null,
                            React.createElement('input', { type: 'checkbox', 'data-field-name': column.columnName, onChange: _this2.onCheckboxChange.bind(_this2), checked: checkedColumns[column.columnName] }),
                            '\xA0 ',
                            column.displayAs
                        )
                    )
                );
            });


            return columnsCheckboxes;
        }
    }]);

    return VisibleColumns;
}(React.Component);

VisibleColumns.propTypes = {
    columns: _propTypes2.default.array,
    visibleColumns: _propTypes2.default.array,
    gcrudInstance: _propTypes2.default.object,
    callbackOnChange: _propTypes2.default.func
};

exports.default = VisibleColumns;

},{"prop-types":182}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BasicOperator = function (_React$Component) {
    _inherits(BasicOperator, _React$Component);

    function BasicOperator(props) {
        _classCallCheck(this, BasicOperator);

        return _possibleConstructorReturn(this, (BasicOperator.__proto__ || Object.getPrototypeOf(BasicOperator)).call(this, props));
    }

    _createClass(BasicOperator, [{
        key: 'render',
        value: function render() {
            var i18n = {
                basic_operator: 'Basic Operator',
                and_statement: 'AND',
                or_statement: 'OR'
            };

            if (this.props.i18n) {
                i18n = Object.assign({}, i18n, this.props.i18n);
            }

            return React.createElement(
                'div',
                { className: 'row form-group' },
                React.createElement(
                    'label',
                    { className: 'col-md-3 control-label' },
                    i18n.basic_operator,
                    ' :'
                ),
                React.createElement(
                    'div',
                    { className: 'col-md-3' },
                    React.createElement(
                        'select',
                        { name: 'basic_operator', className: 'form-control' },
                        React.createElement(
                            'option',
                            { value: 'AND' },
                            i18n.and_statement
                        ),
                        React.createElement(
                            'option',
                            { value: 'OR' },
                            i18n.or_statement
                        )
                    )
                )
            );
        }
    }]);

    return BasicOperator;
}(React.Component);

exports.default = BasicOperator;

},{}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputDate = function (_React$Component) {
    _inherits(InputDate, _React$Component);

    function InputDate(props) {
        _classCallCheck(this, InputDate);

        return _possibleConstructorReturn(this, (InputDate.__proto__ || Object.getPrototypeOf(InputDate)).call(this, props));
    }

    _createClass(InputDate, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var onComponentMount = this.props.onComponentMount;


            if (onComponentMount) {
                onComponentMount.apply(this);
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            var onComponentUpdate = this.props.onComponentUpdate;


            if (onComponentUpdate) {
                onComponentUpdate.apply(this);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _props = this.props,
                inputValue = _props.inputValue,
                fieldIndex = _props.fieldIndex;


            return React.createElement('input', {
                required: true,
                className: 'form-control',
                name: 'extended_search[' + fieldIndex + '][value]',
                type: 'text', value: inputValue
            });
        }
    }]);

    return InputDate;
}(React.Component);

exports.default = InputDate;


InputDate.propTypes = {
    fieldIndex: _propTypes2.default.number,
    inputValue: _propTypes2.default.string,
    inputValueOnChange: _propTypes2.default.func
};

},{"prop-types":182}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputSelectDropdown = function (_React$Component) {
    _inherits(InputSelectDropdown, _React$Component);

    function InputSelectDropdown(props) {
        _classCallCheck(this, InputSelectDropdown);

        return _possibleConstructorReturn(this, (InputSelectDropdown.__proto__ || Object.getPrototypeOf(InputSelectDropdown)).call(this, props));
    }

    _createClass(InputSelectDropdown, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var onComponentMount = this.props.onComponentMount;


            if (onComponentMount) {
                onComponentMount.apply(this);
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            var onComponentUpdate = this.props.onComponentUpdate;


            if (onComponentUpdate) {
                onComponentUpdate.apply(this);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _props = this.props,
                permittedValues = _props.permittedValues,
                fieldIndex = _props.fieldIndex;

            var optionsArray = [];

            Object.keys(permittedValues).forEach(function (itemId) {
                var itemDisplay = permittedValues[itemId];
                optionsArray.push(React.createElement(
                    'option',
                    { value: itemId, key: itemId },
                    itemDisplay
                ));
            });

            return React.createElement(
                'select',
                { className: 'form-control', name: 'extended_search[' + fieldIndex + '][value]' },
                optionsArray
            );
        }
    }]);

    return InputSelectDropdown;
}(React.Component);

exports.default = InputSelectDropdown;

},{}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputSelectRelational = function (_React$Component) {
    _inherits(InputSelectRelational, _React$Component);

    function InputSelectRelational(props) {
        _classCallCheck(this, InputSelectRelational);

        return _possibleConstructorReturn(this, (InputSelectRelational.__proto__ || Object.getPrototypeOf(InputSelectRelational)).call(this, props));
    }

    _createClass(InputSelectRelational, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var onComponentMount = this.props.onComponentMount;


            if (onComponentMount) {
                onComponentMount.apply(this);
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            var onComponentUpdate = this.props.onComponentUpdate;


            if (onComponentUpdate) {
                onComponentUpdate.apply(this);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _props = this.props,
                permittedValues = _props.permittedValues,
                fieldIndex = _props.fieldIndex;


            return React.createElement(
                'select',
                { className: 'form-control', name: 'extended_search[' + fieldIndex + '][value]' },
                permittedValues.map(function (item) {
                    return React.createElement(
                        'option',
                        { value: item.id, key: item.id },
                        item.title
                    );
                })
            );
        }
    }]);

    return InputSelectRelational;
}(React.Component);

exports.default = InputSelectRelational;

},{}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputSelect = function (_React$Component) {
    _inherits(InputSelect, _React$Component);

    function InputSelect(props) {
        _classCallCheck(this, InputSelect);

        return _possibleConstructorReturn(this, (InputSelect.__proto__ || Object.getPrototypeOf(InputSelect)).call(this, props));
    }

    _createClass(InputSelect, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var onComponentMount = this.props.onComponentMount;


            if (onComponentMount) {
                onComponentMount.apply(this);
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            var onComponentUpdate = this.props.onComponentUpdate;


            if (onComponentUpdate) {
                onComponentUpdate.apply(this);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _props = this.props,
                permittedValues = _props.permittedValues,
                fieldIndex = _props.fieldIndex;


            return React.createElement(
                'select',
                { className: 'form-control', name: 'extended_search[' + fieldIndex + '][value]' },
                permittedValues.map(function (item) {
                    return React.createElement(
                        'option',
                        { value: item, key: item },
                        item
                    );
                })
            );
        }
    }]);

    return InputSelect;
}(React.Component);

exports.default = InputSelect;

},{}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _equal_not_equal = require('../select-options/equal_not_equal');

var _equal_not_equal2 = _interopRequireDefault(_equal_not_equal);

var _filterSelect = require('../filter-select');

var _filterSelect2 = _interopRequireDefault(_filterSelect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SearchCheckboxBoolean = function (_React$Component) {
    _inherits(SearchCheckboxBoolean, _React$Component);

    function SearchCheckboxBoolean(props) {
        _classCallCheck(this, SearchCheckboxBoolean);

        var _this = _possibleConstructorReturn(this, (SearchCheckboxBoolean.__proto__ || Object.getPrototypeOf(SearchCheckboxBoolean)).call(this, props));

        _this.state = {
            comparisonValue: 'equals',
            isChecked: true
        };
        return _this;
    }

    _createClass(SearchCheckboxBoolean, [{
        key: 'inputValueOnChange',
        value: function inputValueOnChange() {
            var isChecked = this.state.isChecked;


            this.setState({
                isChecked: !isChecked
            });
        }
    }, {
        key: 'comparisonOnChange',
        value: function comparisonOnChange(comparisonValue) {
            this.setState({
                comparisonValue: comparisonValue
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _state = this.state,
                isChecked = _state.isChecked,
                comparisonValue = _state.comparisonValue,
                _props = this.props,
                fieldIndex = _props.fieldIndex,
                i18n = _props.i18n,
                isMobile = _props.isMobile;

            var JsxArray = void 0;

            JsxArray = [React.createElement(_filterSelect2.default, {
                i18n: i18n,
                fieldIndex: fieldIndex,
                SelectOptions: _equal_not_equal2.default,
                onChangeCallback: this.comparisonOnChange.bind(this),
                key: '0',
                isMobile: isMobile
            })];

            if (comparisonValue !== 'is_empty' && comparisonValue !== 'is_not_empty') {
                JsxArray.push(React.createElement(
                    'div',
                    { key: '2', className: 'col-md-8' },
                    React.createElement('input', { type: 'checkbox', checked: isChecked, onChange: this.inputValueOnChange.bind(this), style: { marginTop: 12 } }),
                    React.createElement('input', { name: 'extended_search[' + fieldIndex + '][value]', type: 'hidden', value: isChecked ? '1' : '0' })
                ));
            }

            return JsxArray;
        }
    }]);

    return SearchCheckboxBoolean;
}(React.Component);

exports.default = SearchCheckboxBoolean;


SearchCheckboxBoolean.propTypes = {
    fieldIndex: _propTypes2.default.number,
    isMobile: _propTypes2.default.bool
};

SearchCheckboxBoolean.defaultProps = {
    isMobile: false
};

},{"../filter-select":49,"../select-options/equal_not_equal":53,"prop-types":182}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _comparison = require('../select-options/comparison');

var _comparison2 = _interopRequireDefault(_comparison);

var _filterSelect = require('../filter-select');

var _filterSelect2 = _interopRequireDefault(_filterSelect);

var _date = require('../field-input/date');

var _date2 = _interopRequireDefault(_date);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SearchDate = function (_React$Component) {
    _inherits(SearchDate, _React$Component);

    function SearchDate(props) {
        _classCallCheck(this, SearchDate);

        var _this = _possibleConstructorReturn(this, (SearchDate.__proto__ || Object.getPrototypeOf(SearchDate)).call(this, props));

        _this.state = {
            comparisonValue: 'contains',
            inputValue: ''
        };
        return _this;
    }

    _createClass(SearchDate, [{
        key: 'comparisonOnChange',
        value: function comparisonOnChange(comparisonValue) {
            this.setState({
                comparisonValue: comparisonValue
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var comparisonValue = this.state.comparisonValue,
                _props = this.props,
                fieldIndex = _props.fieldIndex,
                onComponentMount = _props.onComponentMount,
                onComponentUpdate = _props.onComponentUpdate,
                i18n = _props.i18n,
                isMobile = _props.isMobile;

            var JsxArray = void 0;

            JsxArray = [React.createElement(_filterSelect2.default, {
                i18n: i18n,
                fieldIndex: fieldIndex,
                SelectOptions: _comparison2.default,
                onChangeCallback: this.comparisonOnChange.bind(this),
                key: '0',
                isMobile: isMobile
            })];

            if (comparisonValue !== 'is_empty' && comparisonValue !== 'is_not_empty') {
                JsxArray.push(React.createElement(
                    'div',
                    { key: '2', className: 'col-md-8' },
                    React.createElement(_date2.default, {
                        i18n: i18n,
                        fieldIndex: fieldIndex,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate
                    })
                ));
            }

            return JsxArray;
        }
    }]);

    return SearchDate;
}(React.Component);

SearchDate.propTypes = {
    fieldIndex: _propTypes2.default.number,
    onComponentMount: _propTypes2.default.func,
    onComponentUpdate: _propTypes2.default.func,
    isMobile: _propTypes2.default.bool
};

SearchDate.defaultProps = {
    isMobile: false
};

exports.default = SearchDate;

},{"../field-input/date":37,"../filter-select":49,"../select-options/comparison":52,"prop-types":182}],43:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _filterSelect = require("../filter-select");

var _filterSelect2 = _interopRequireDefault(_filterSelect);

var _selectDropdown = require("../field-input/select-dropdown");

var _selectDropdown2 = _interopRequireDefault(_selectDropdown);

var _equal_not_equal = require("../select-options/equal_not_equal");

var _equal_not_equal2 = _interopRequireDefault(_equal_not_equal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SearchDropdown = function (_React$Component) {
    _inherits(SearchDropdown, _React$Component);

    function SearchDropdown(props) {
        _classCallCheck(this, SearchDropdown);

        var _this = _possibleConstructorReturn(this, (SearchDropdown.__proto__ || Object.getPrototypeOf(SearchDropdown)).call(this, props));

        _this.state = {
            comparisonValue: 'contains',
            inputValue: ''
        };
        return _this;
    }

    _createClass(SearchDropdown, [{
        key: "comparisonOnChange",
        value: function comparisonOnChange(comparisonValue) {
            this.setState({
                comparisonValue: comparisonValue
            });
        }
    }, {
        key: "render",
        value: function render() {
            var comparisonValue = this.state.comparisonValue,
                _props = this.props,
                fieldIndex = _props.fieldIndex,
                permittedValues = _props.permittedValues,
                onComponentMount = _props.onComponentMount,
                onComponentUpdate = _props.onComponentUpdate,
                i18n = _props.i18n,
                isMobile = _props.isMobile;

            var JsxArray = void 0,
                optionsArray = [];

            JsxArray = [React.createElement(_filterSelect2.default, {
                i18n: i18n,
                fieldIndex: fieldIndex,
                SelectOptions: _equal_not_equal2.default,
                onChangeCallback: this.comparisonOnChange.bind(this),
                key: "0",
                isMobile: isMobile
            })];

            Object.keys(permittedValues).forEach(function (itemId) {
                var itemDisplay = permittedValues[itemId];
                optionsArray.push(React.createElement(
                    "option",
                    { value: itemId, key: itemId },
                    itemDisplay
                ));
            });

            if (comparisonValue !== 'is_empty' && comparisonValue !== 'is_not_empty') {
                JsxArray.push(React.createElement(
                    "div",
                    { key: "2", className: "col-md-8" },
                    React.createElement(_selectDropdown2.default, {
                        fieldIndex: fieldIndex,
                        permittedValues: permittedValues,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate
                    })
                ));
            }

            return JsxArray;
        }
    }]);

    return SearchDropdown;
}(React.Component);

exports.default = SearchDropdown;


SearchDropdown.propTypes = {
    fieldIndex: _propTypes2.default.number,
    permittedValues: _propTypes2.default.object,
    isMobile: _propTypes2.default.isMobile
};

SearchDropdown.defaultProps = {
    isMobile: false
};

},{"../field-input/select-dropdown":38,"../filter-select":49,"../select-options/equal_not_equal":53,"prop-types":182}],44:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _filterSelect = require("../filter-select");

var _filterSelect2 = _interopRequireDefault(_filterSelect);

var _select = require("../field-input/select");

var _select2 = _interopRequireDefault(_select);

var _equal_not_equal = require("../select-options/equal_not_equal");

var _equal_not_equal2 = _interopRequireDefault(_equal_not_equal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SearchEnum = function (_React$Component) {
    _inherits(SearchEnum, _React$Component);

    function SearchEnum(props) {
        _classCallCheck(this, SearchEnum);

        var _this = _possibleConstructorReturn(this, (SearchEnum.__proto__ || Object.getPrototypeOf(SearchEnum)).call(this, props));

        _this.state = {
            comparisonValue: 'contains'
        };
        return _this;
    }

    _createClass(SearchEnum, [{
        key: "comparisonOnChange",
        value: function comparisonOnChange(comparisonValue) {
            this.setState({
                comparisonValue: comparisonValue
            });
        }
    }, {
        key: "render",
        value: function render() {
            var comparisonValue = this.state.comparisonValue,
                _props = this.props,
                fieldIndex = _props.fieldIndex,
                permittedValues = _props.permittedValues,
                onComponentMount = _props.onComponentMount,
                onComponentUpdate = _props.onComponentUpdate,
                i18n = _props.i18n,
                isMobile = _props.isMobile;

            var JsxArray = void 0;

            JsxArray = [React.createElement(_filterSelect2.default, {
                i18n: i18n,
                fieldIndex: fieldIndex,
                SelectOptions: _equal_not_equal2.default,
                onChangeCallback: this.comparisonOnChange.bind(this),
                key: "0",
                isMobile: isMobile
            })];

            if (comparisonValue !== 'is_empty' && comparisonValue !== 'is_not_empty') {
                JsxArray.push(React.createElement(
                    "div",
                    { key: "2", className: "col-md-8" },
                    React.createElement(_select2.default, {
                        permittedValues: permittedValues,
                        fieldIndex: fieldIndex,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate
                    })
                ));
            }

            return JsxArray;
        }
    }]);

    return SearchEnum;
}(React.Component);

exports.default = SearchEnum;


SearchEnum.propTypes = {
    fieldIndex: _propTypes2.default.number,
    permittedValues: _propTypes2.default.array,
    isMobile: _propTypes2.default.bool
};

SearchEnum.defaultProps = {
    isMobile: false
};

},{"../field-input/select":40,"../filter-select":49,"../select-options/equal_not_equal":53,"prop-types":182}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _comparison = require('../select-options/comparison');

var _comparison2 = _interopRequireDefault(_comparison);

var _filterSelect = require('../filter-select');

var _filterSelect2 = _interopRequireDefault(_filterSelect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SearchNumeric = function (_React$Component) {
    _inherits(SearchNumeric, _React$Component);

    function SearchNumeric(props) {
        _classCallCheck(this, SearchNumeric);

        var _this = _possibleConstructorReturn(this, (SearchNumeric.__proto__ || Object.getPrototypeOf(SearchNumeric)).call(this, props));

        _this.state = {
            comparisonValue: 'equals',
            inputValue: ''
        };
        return _this;
    }

    _createClass(SearchNumeric, [{
        key: 'inputValueOnChange',
        value: function inputValueOnChange(event) {
            this.setState({
                inputValue: event.target.value
            });
        }
    }, {
        key: 'comparisonOnChange',
        value: function comparisonOnChange(comparisonValue) {
            this.setState({
                comparisonValue: comparisonValue
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _state = this.state,
                comparisonValue = _state.comparisonValue,
                inputValue = _state.inputValue,
                _props = this.props,
                fieldIndex = _props.fieldIndex,
                i18n = _props.i18n,
                isMobile = _props.isMobile;

            var JsxArray = void 0;

            JsxArray = [React.createElement(_filterSelect2.default, {
                i18n: i18n,
                fieldIndex: fieldIndex,
                SelectOptions: _comparison2.default,
                onChangeCallback: this.comparisonOnChange.bind(this),
                key: '0',
                isMobile: isMobile
            })];

            if (comparisonValue !== 'is_empty' && comparisonValue !== 'is_not_empty') {
                JsxArray.push(React.createElement(
                    'div',
                    { key: '2', className: 'col-md-8' },
                    React.createElement('input', { required: true, className: 'form-control', name: 'extended_search[' + fieldIndex + '][value]', type: 'number', value: inputValue, onChange: this.inputValueOnChange.bind(this) })
                ));
            }

            return JsxArray;
        }
    }]);

    return SearchNumeric;
}(React.Component);

exports.default = SearchNumeric;


SearchNumeric.propTypes = {
    fieldIndex: _propTypes2.default.number,
    isMobile: _propTypes2.default.bool
};

SearchNumeric.defaultProps = {
    isMobile: false
};

},{"../filter-select":49,"../select-options/comparison":52,"prop-types":182}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _has_or_not = require("../select-options/has_or_not");

var _has_or_not2 = _interopRequireDefault(_has_or_not);

var _filterSelect = require("../filter-select");

var _filterSelect2 = _interopRequireDefault(_filterSelect);

var _selectRelational = require("../field-input/select-relational");

var _selectRelational2 = _interopRequireDefault(_selectRelational);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SearchRelationalNtoN = function (_React$Component) {
    _inherits(SearchRelationalNtoN, _React$Component);

    function SearchRelationalNtoN(props) {
        _classCallCheck(this, SearchRelationalNtoN);

        var _this = _possibleConstructorReturn(this, (SearchRelationalNtoN.__proto__ || Object.getPrototypeOf(SearchRelationalNtoN)).call(this, props));

        _this.state = {
            comparisonValue: 'has'
        };
        return _this;
    }

    _createClass(SearchRelationalNtoN, [{
        key: "comparisonOnChange",
        value: function comparisonOnChange(comparisonValue) {
            this.setState({
                comparisonValue: comparisonValue
            });
        }
    }, {
        key: "render",
        value: function render() {
            var comparisonValue = this.state.comparisonValue,
                _props = this.props,
                fieldIndex = _props.fieldIndex,
                permittedValues = _props.permittedValues,
                onComponentMount = _props.onComponentMount,
                onComponentUpdate = _props.onComponentUpdate,
                i18n = _props.i18n,
                isMobile = _props.isMobile;

            var JsxArray = void 0;

            JsxArray = [React.createElement(_filterSelect2.default, {
                i18n: i18n,
                fieldIndex: fieldIndex,
                SelectOptions: _has_or_not2.default,
                onChangeCallback: this.comparisonOnChange.bind(this),
                key: "0",
                isMobile: isMobile
            })];

            if (comparisonValue !== 'is_empty' && comparisonValue !== 'is_not_empty') {
                JsxArray.push(React.createElement(
                    "div",
                    { key: "2", className: "col-md-8" },
                    React.createElement(_selectRelational2.default, {
                        fieldIndex: fieldIndex,
                        permittedValues: permittedValues,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate
                    })
                ));
            }

            return JsxArray;
        }
    }]);

    return SearchRelationalNtoN;
}(React.Component);

exports.default = SearchRelationalNtoN;


SearchRelationalNtoN.propTypes = {
    fieldIndex: _propTypes2.default.number,
    permittedValues: _propTypes2.default.array,
    isMobile: _propTypes2.default.bool
};

SearchRelationalNtoN.defaultProps = {
    isMobile: false
};

},{"../field-input/select-relational":39,"../filter-select":49,"../select-options/has_or_not":54,"prop-types":182}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _filterSelect = require("../filter-select");

var _filterSelect2 = _interopRequireDefault(_filterSelect);

var _selectRelational = require("../field-input/select-relational");

var _selectRelational2 = _interopRequireDefault(_selectRelational);

var _equal_not_equal = require("../select-options/equal_not_equal");

var _equal_not_equal2 = _interopRequireDefault(_equal_not_equal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SearchRelational = function (_React$Component) {
    _inherits(SearchRelational, _React$Component);

    function SearchRelational(props) {
        _classCallCheck(this, SearchRelational);

        var _this = _possibleConstructorReturn(this, (SearchRelational.__proto__ || Object.getPrototypeOf(SearchRelational)).call(this, props));

        _this.state = {
            comparisonValue: 'has'
        };
        return _this;
    }

    _createClass(SearchRelational, [{
        key: "comparisonOnChange",
        value: function comparisonOnChange(comparisonValue) {
            this.setState({
                comparisonValue: comparisonValue
            });
        }
    }, {
        key: "render",
        value: function render() {
            var comparisonValue = this.state.comparisonValue,
                _props = this.props,
                fieldIndex = _props.fieldIndex,
                permittedValues = _props.permittedValues,
                onComponentMount = _props.onComponentMount,
                onComponentUpdate = _props.onComponentUpdate,
                i18n = _props.i18n,
                isMobile = _props.isMobile;

            var JsxArray = void 0;

            JsxArray = [React.createElement(_filterSelect2.default, {
                i18n: i18n,
                fieldIndex: fieldIndex,
                SelectOptions: _equal_not_equal2.default,
                onChangeCallback: this.comparisonOnChange.bind(this),
                key: "0",
                isMobile: isMobile
            })];

            if (comparisonValue !== 'is_empty' && comparisonValue !== 'is_not_empty') {
                JsxArray.push(React.createElement(
                    "div",
                    { key: "2", className: "col-md-8" },
                    React.createElement(_selectRelational2.default, {
                        fieldIndex: fieldIndex,
                        permittedValues: permittedValues,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate
                    })
                ));
            }

            return JsxArray;
        }
    }]);

    return SearchRelational;
}(React.Component);

exports.default = SearchRelational;


SearchRelational.propTypes = {
    fieldIndex: _propTypes2.default.number,
    permittedValues: _propTypes2.default.array,
    isMobile: _propTypes2.default.bool
};

SearchRelational.defaultProps = {
    isMobile: false
};

},{"../field-input/select-relational":39,"../filter-select":49,"../select-options/equal_not_equal":53,"prop-types":182}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _filterSelect = require('../filter-select');

var _filterSelect2 = _interopRequireDefault(_filterSelect);

var _text = require('../select-options/text');

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SearchText = function (_React$Component) {
    _inherits(SearchText, _React$Component);

    function SearchText(props) {
        _classCallCheck(this, SearchText);

        var _this = _possibleConstructorReturn(this, (SearchText.__proto__ || Object.getPrototypeOf(SearchText)).call(this, props));

        _this.state = {
            comparisonValue: 'contains',
            inputValue: ''
        };
        return _this;
    }

    _createClass(SearchText, [{
        key: 'inputValueOnChange',
        value: function inputValueOnChange(event) {
            this.setState({
                inputValue: event.target.value
            });
        }
    }, {
        key: 'comparisonOnChange',
        value: function comparisonOnChange(comparisonValue) {
            this.setState({
                comparisonValue: comparisonValue
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _state = this.state,
                comparisonValue = _state.comparisonValue,
                inputValue = _state.inputValue,
                _props = this.props,
                fieldIndex = _props.fieldIndex,
                i18n = _props.i18n,
                isMobile = _props.isMobile;

            var JsxArray = void 0;

            JsxArray = [React.createElement(_filterSelect2.default, {
                i18n: i18n,
                fieldIndex: fieldIndex,
                SelectOptions: _text2.default,
                onChangeCallback: this.comparisonOnChange.bind(this),
                key: '1',
                isMobile: isMobile
            })];

            if (comparisonValue !== 'is_empty' && comparisonValue !== 'is_not_empty') {
                JsxArray.push(React.createElement(
                    'div',
                    { key: '2', className: 'col-md-8' },
                    React.createElement('input', {
                        required: true,
                        className: 'form-control',
                        name: 'extended_search[' + fieldIndex + '][value]',
                        type: 'text',
                        value: inputValue,
                        onChange: this.inputValueOnChange.bind(this)
                    })
                ));
            }

            return JsxArray;
        }
    }]);

    return SearchText;
}(React.Component);

exports.default = SearchText;


SearchText.propTypes = {
    fieldIndex: _propTypes2.default.number,
    isMobile: _propTypes2.default.bool
};

SearchText.defaultProps = {
    isMobile: false
};

},{"../filter-select":49,"../select-options/text":55,"prop-types":182}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FilterSelect = function (_React$Component) {
    _inherits(FilterSelect, _React$Component);

    function FilterSelect(props) {
        _classCallCheck(this, FilterSelect);

        var _this = _possibleConstructorReturn(this, (FilterSelect.__proto__ || Object.getPrototypeOf(FilterSelect)).call(this, props));

        _this.state = {
            comparisonValue: ''
        };
        return _this;
    }

    _createClass(FilterSelect, [{
        key: 'selectOnChange',
        value: function selectOnChange(event) {
            var comparisonValue = event.target.value,
                onChangeCallback = this.props.onChangeCallback;


            this.setState({
                comparisonValue: comparisonValue
            });

            onChangeCallback(comparisonValue);
        }
    }, {
        key: 'render',
        value: function render() {
            var _props = this.props,
                fieldIndex = _props.fieldIndex,
                SelectOptions = _props.SelectOptions,
                i18n = _props.i18n,
                isMobile = _props.isMobile,
                comparisonValue = this.state.comparisonValue;


            return React.createElement(
                'div',
                { className: (0, _classnames2.default)('col-md-4', {
                        'b10': isMobile
                    }) },
                React.createElement(
                    'select',
                    { className: 'form-control', name: 'extended_search[' + fieldIndex + '][filter]', value: comparisonValue, onChange: this.selectOnChange.bind(this) },
                    React.createElement(SelectOptions, { i18n: i18n })
                )
            );
        }
    }]);

    return FilterSelect;
}(React.Component);

exports.default = FilterSelect;


FilterSelect.propTypes = {
    fieldIndex: _propTypes2.default.number,
    SelectOptions: _propTypes2.default.func,
    onChangeCallback: _propTypes2.default.func,
    isMobile: _propTypes2.default.bool
};

FilterSelect.defaultProps = {
    isMobile: false
};

},{"classnames":118,"prop-types":182}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _basicOperator = require('./basic-operator.js');

var _basicOperator2 = _interopRequireDefault(_basicOperator);

var _multipleSearch = require('./multiple-search.js');

var _multipleSearch2 = _interopRequireDefault(_multipleSearch);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Filtering = function (_React$Component) {
    _inherits(Filtering, _React$Component);

    function Filtering(props) {
        _classCallCheck(this, Filtering);

        var _this = _possibleConstructorReturn(this, (Filtering.__proto__ || Object.getPrototypeOf(Filtering)).call(this, props));

        _this.state = {
            indexes: [0]
        };
        return _this;
    }

    _createClass(Filtering, [{
        key: 'addMoreFilters',
        value: function addMoreFilters() {
            var indexes = this.state.indexes;

            // the last index is always the bigger one so add +1

            indexes.push(indexes[indexes.length - 1] + 1);

            this.setState({
                indexes: indexes
            });
        }
    }, {
        key: 'removeFilter',
        value: function removeFilter(fieldIndex) {
            var indexes = this.state.indexes;


            indexes = indexes.filter(function (index) {
                return index !== fieldIndex;
            });

            this.setState({
                indexes: indexes
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            var indexes = this.state.indexes,
                _props = this.props,
                fields = _props.fields,
                onSubmitCallback = _props.onSubmitCallback,
                onInputMount = _props.onInputMount,
                ModalTitle = _props.ModalTitle,
                screenSize = _props.screenSize,
                indexesLength = indexes.length;

            var JSXarray = void 0,
                i18n = {
                basic_operator: 'Basic Operator',
                and_statement: 'AND',
                or_statement: 'OR',
                filtering: 'Filtering',
                filter: 'Filter',
                cancel_filtering: 'Cancel',
                add_more: 'Add more',
                remove_filter: 'Remove Filter'
            };

            if (this.props.i18n) {
                i18n = Object.assign({}, i18n, this.props.i18n);
            }

            JSXarray = indexes.map(function (index) {
                return React.createElement(_multipleSearch2.default, {
                    i18n: i18n,
                    fields: fields,
                    fieldIndex: index,
                    key: index,
                    hasRemoveButton: indexesLength > 1,
                    onDeleteCallback: _this2.removeFilter.bind(_this2),
                    onInputMount: onInputMount,
                    screenSize: screenSize
                });
            });

            return React.createElement(
                'div',
                { className: 'modal-dialog gc-modal-dialog' },
                React.createElement(
                    'div',
                    { className: 'modal-content' },
                    React.createElement(
                        'form',
                        { method: 'post', className: 'form-horizontal', onSubmit: onSubmitCallback.bind(this) },
                        React.createElement(
                            'div',
                            { className: 'modal-header' },
                            React.createElement(ModalTitle, { title: i18n.filtering })
                        ),
                        React.createElement(
                            'div',
                            { className: 'modal-body delete-modal' },
                            React.createElement(_basicOperator2.default, { i18n: i18n }),
                            JSXarray,
                            React.createElement(
                                'div',
                                { className: 'gc-filtering-row' },
                                React.createElement(
                                    'button',
                                    {
                                        type: 'button',
                                        className: 'btn btn-default btn-outline-dark',
                                        onClick: this.addMoreFilters.bind(this) },
                                    React.createElement('em', { className: 'fa fa-plus' }),
                                    '\xA0',
                                    i18n.add_more
                                )
                            )
                        ),
                        React.createElement(
                            'div',
                            { className: 'modal-footer' },
                            React.createElement(
                                'button',
                                { type: 'button', className: 'btn btn-default btn-outline-dark', 'data-dismiss': 'modal' },
                                i18n.cancel_filtering
                            ),
                            React.createElement(
                                'button',
                                { type: 'submit', className: 'btn btn-success delete-multiple-confirmation-button' },
                                i18n.filter
                            )
                        )
                    )
                )
            );
        }
    }]);

    return Filtering;
}(React.Component);

exports.default = Filtering;


Filtering.propTypes = {
    fields: _propTypes2.default.array,
    onSubmitCallback: _propTypes2.default.func,
    onInputMount: _propTypes2.default.object,
    ModalTitle: _propTypes2.default.func,
    screenSize: _propTypes2.default.string
};

Filtering.defaultProps = {
    ModalTitle: function ModalTitle(props) {
        return React.createElement(
            React.Fragment,
            null,
            React.createElement(
                'button',
                {
                    type: 'button',
                    className: 'close',
                    'data-dismiss': 'modal',
                    'aria-label': 'Close'
                },
                React.createElement(
                    'span',
                    { 'aria-hidden': 'true' },
                    '\xD7'
                )
            ),
            React.createElement(
                'h4',
                { className: 'modal-title' },
                props.title
            )
        );
    },
    screenSize: 'l'
};

},{"./basic-operator.js":36,"./multiple-search.js":51,"prop-types":182}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _text = require("./field-types/text");

var _text2 = _interopRequireDefault(_text);

var _date = require("./field-types/date");

var _date2 = _interopRequireDefault(_date);

var _numeric = require("./field-types/numeric");

var _numeric2 = _interopRequireDefault(_numeric);

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _checkbox_boolean = require("./field-types/checkbox_boolean");

var _checkbox_boolean2 = _interopRequireDefault(_checkbox_boolean);

var _enum = require("./field-types/enum");

var _enum2 = _interopRequireDefault(_enum);

var _dropdown = require("./field-types/dropdown");

var _dropdown2 = _interopRequireDefault(_dropdown);

var _relational = require("./field-types/relational");

var _relational2 = _interopRequireDefault(_relational);

var _relationalNN = require("./field-types/relational-n-n");

var _relationalNN2 = _interopRequireDefault(_relationalNN);

var _classnames = require("classnames");

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MultipleSearch = function (_React$Component) {
    _inherits(MultipleSearch, _React$Component);

    function MultipleSearch(props) {
        _classCallCheck(this, MultipleSearch);

        var firstFieldsKey = props.fields.find(function (__item, key) {
            return key === 0;
        }),
            fieldName = firstFieldsKey.fieldName,
            type = firstFieldsKey.type,
            permittedValues = firstFieldsKey.permittedValues;

        var _this = _possibleConstructorReturn(this, (MultipleSearch.__proto__ || Object.getPrototypeOf(MultipleSearch)).call(this, props));

        _this.state = {
            selectedValue: fieldName,
            selectedType: type,
            permittedValues: permittedValues
        };
        return _this;
    }

    _createClass(MultipleSearch, [{
        key: "onChangeSelect",
        value: function onChangeSelect(event) {
            var selectedField = this.props.fields.find(function (field) {
                return field.fieldName === event.target.value;
            }),
                fieldName = selectedField.fieldName,
                type = selectedField.type,
                permittedValues = selectedField.permittedValues;


            this.setState({
                selectedValue: fieldName,
                selectedType: type,
                permittedValues: permittedValues
            });
        }
    }, {
        key: "onDeleteClick",
        value: function onDeleteClick() {
            var _props = this.props,
                fieldIndex = _props.fieldIndex,
                onDeleteCallback = _props.onDeleteCallback;


            onDeleteCallback(fieldIndex);
        }
    }, {
        key: "render",
        value: function render() {
            var _state = this.state,
                selectedValue = _state.selectedValue,
                selectedType = _state.selectedType,
                permittedValues = _state.permittedValues,
                _props2 = this.props,
                fieldIndex = _props2.fieldIndex,
                fields = _props2.fields,
                hasRemoveButton = _props2.hasRemoveButton,
                onInputMount = _props2.onInputMount,
                screenSize = _props2.screenSize,
                evenOrOdd = fieldIndex % 2 === 0 ? 'even' : 'odd',
                isMobile = screenSize === 's' || screenSize === 'xs';

            var searchInput = void 0,
                onComponentMount = void 0,
                onComponentUpdate = void 0,
                i18n = {
                remove_filter: 'Remove Filter'
            };

            if (this.props.i18n) {
                i18n = Object.assign({}, i18n, this.props.i18n);
            }

            if (onInputMount && onInputMount[selectedType]) {
                onComponentMount = onInputMount[selectedType].onMount;
                onComponentUpdate = onInputMount[selectedType].onUpdate;
            }

            switch (selectedType) {
                case 'date':
                case 'datetime':
                case 'timestamp':
                    searchInput = React.createElement(_date2.default, {
                        fieldIndex: fieldIndex,
                        i18n: i18n,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate,
                        isMobile: isMobile
                    });
                    break;

                case 'int':
                case 'numeric':
                    searchInput = React.createElement(_numeric2.default, {
                        fieldIndex: fieldIndex,
                        i18n: i18n,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate,
                        isMobile: isMobile
                    });
                    break;

                case 'checkbox_boolean':
                    searchInput = React.createElement(_checkbox_boolean2.default, {
                        fieldIndex: fieldIndex,
                        i18n: i18n,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate,
                        isMobile: isMobile
                    });
                    break;

                case 'relational_n_n':
                case 'native_relational_n_n':
                    searchInput = React.createElement(_relationalNN2.default, {
                        fieldIndex: fieldIndex,
                        i18n: i18n,
                        permittedValues: permittedValues,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate,
                        isMobile: isMobile
                    });
                    break;

                case 'relational':
                case 'relational_native':
                    searchInput = React.createElement(_relational2.default, {
                        fieldIndex: fieldIndex,
                        i18n: i18n,
                        permittedValues: permittedValues,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate,
                        isMobile: isMobile
                    });
                    break;

                case 'multiselect_native':
                case 'multiselect_searchable':
                case 'dropdown':
                case 'dropdown_search':
                    searchInput = React.createElement(_dropdown2.default, {
                        fieldIndex: fieldIndex,
                        i18n: i18n,
                        permittedValues: permittedValues,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate,
                        isMobile: isMobile
                    });
                    break;

                case 'enum_searchable':
                case 'enum':
                    searchInput = React.createElement(_enum2.default, {
                        fieldIndex: fieldIndex,
                        i18n: i18n,
                        permittedValues: permittedValues,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate,
                        isMobile: isMobile
                    });
                    break;

                default:
                    searchInput = React.createElement(_text2.default, {
                        fieldIndex: fieldIndex,
                        i18n: i18n,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate,
                        screenSize: screenSize,
                        isMobile: isMobile
                    });
                    break;
            }

            return React.createElement(
                "div",
                { className: 'row gc-filtering-row ' + evenOrOdd },
                hasRemoveButton ? React.createElement(
                    "div",
                    { className: (0, _classnames2.default)('col-md-1', {
                            'b10': isMobile
                        }) },
                    React.createElement(
                        "button",
                        {
                            type: "button",
                            className: (0, _classnames2.default)('btn', 'btn-default', 'btn-outline-dark', 'btn-block'),
                            onClick: this.onDeleteClick.bind(this),
                            title: i18n.remove_filter },
                        React.createElement("em", { className: "fa fa-trash-o" }),
                        isMobile && React.createElement(
                            React.Fragment,
                            null,
                            "\xA0 ",
                            i18n.remove_filter
                        )
                    )
                ) : '',
                React.createElement(
                    "div",
                    { className: (0, _classnames2.default)('col-md-3', {
                            'b10': isMobile
                        }) },
                    React.createElement(
                        "select",
                        { className: "form-control", name: 'extended_search[' + fieldIndex + '][name]',
                            onChange: this.onChangeSelect.bind(this), value: selectedValue },
                        fields.map(function (field) {
                            return React.createElement(
                                "option",
                                { value: field.fieldName,
                                    key: field.fieldName },
                                field.displayAs
                            );
                        })
                    )
                ),
                React.createElement(
                    "div",
                    { className: (0, _classnames2.default)('row', {
                            'col-md-8': hasRemoveButton,
                            'col-md-9': !hasRemoveButton,
                            'b10': isMobile
                        }) },
                    searchInput
                )
            );
        }
    }]);

    return MultipleSearch;
}(React.Component);

MultipleSearch.propTypes = {
    fieldIndex: _propTypes2.default.number,
    fields: _propTypes2.default.array,
    hasRemoveButton: _propTypes2.default.bool,
    onDeleteCallback: _propTypes2.default.func,
    screenSize: _propTypes2.default.string
};

MultipleSearch.defaultProps = {
    screenSize: 'l'
};

exports.default = MultipleSearch;

},{"./field-types/checkbox_boolean":41,"./field-types/date":42,"./field-types/dropdown":43,"./field-types/enum":44,"./field-types/numeric":45,"./field-types/relational":47,"./field-types/relational-n-n":46,"./field-types/text":48,"classnames":118,"prop-types":182}],52:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _i18nComparison = require('./translations/i18n-comparison');

var _i18nComparison2 = _interopRequireDefault(_i18nComparison);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ComparisonSelectOptions = function (_React$Component) {
    _inherits(ComparisonSelectOptions, _React$Component);

    function ComparisonSelectOptions() {
        _classCallCheck(this, ComparisonSelectOptions);

        return _possibleConstructorReturn(this, (ComparisonSelectOptions.__proto__ || Object.getPrototypeOf(ComparisonSelectOptions)).apply(this, arguments));
    }

    _createClass(ComparisonSelectOptions, [{
        key: 'render',
        value: function render() {
            var i18n = _i18nComparison2.default;

            console.log(i18n);

            if (this.props.i18n) {
                i18n = Object.assign({}, i18n, this.props.i18n);
            }

            console.log(i18n);

            return [React.createElement(
                'option',
                { key: 'equals', value: 'equals' },
                i18n.comparison_equals
            ), React.createElement(
                'option',
                { key: 'not_equals', value: 'not_equals' },
                i18n.comparison_not_equals
            ), React.createElement(
                'option',
                { key: 'greater_than', value: 'greater_than' },
                i18n.comparison_greater_than
            ), React.createElement(
                'option',
                { key: 'less_than', value: 'less_than' },
                i18n.comparison_less_than
            ), React.createElement(
                'option',
                { key: 'greater_than_or_equal', value: 'greater_than_or_equal' },
                i18n.comparison_greater_than_or_equal
            ), React.createElement(
                'option',
                { key: 'less_than_or_equal', value: 'less_than_or_equal' },
                i18n.comparison_less_than_or_equal
            ), React.createElement(
                'option',
                { key: 'is_empty', value: 'is_empty' },
                i18n.comparison_is_empty
            ), React.createElement(
                'option',
                { key: 'is_not_empty', value: 'is_not_empty' },
                i18n.comparison_is_not_empty
            )];
        }
    }]);

    return ComparisonSelectOptions;
}(React.Component);

ComparisonSelectOptions.propTypes = {
    i18n: _propTypes2.default.object
};

exports.default = ComparisonSelectOptions;

},{"./translations/i18n-comparison":56,"prop-types":182}],53:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _i18nEqualNotEqual = require('./translations/i18n-equal-not-equal');

var _i18nEqualNotEqual2 = _interopRequireDefault(_i18nEqualNotEqual);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SelectOptionsEqualNotEqual = function (_React$Component) {
    _inherits(SelectOptionsEqualNotEqual, _React$Component);

    function SelectOptionsEqualNotEqual() {
        _classCallCheck(this, SelectOptionsEqualNotEqual);

        return _possibleConstructorReturn(this, (SelectOptionsEqualNotEqual.__proto__ || Object.getPrototypeOf(SelectOptionsEqualNotEqual)).apply(this, arguments));
    }

    _createClass(SelectOptionsEqualNotEqual, [{
        key: 'render',
        value: function render() {
            var i18n = _i18nEqualNotEqual2.default;

            if (this.props.i18n) {
                i18n = Object.assign({}, i18n, this.props.i18n);
            }

            return [React.createElement(
                'option',
                { key: 'equals', value: 'equals' },
                i18n.comparison_equals
            ), React.createElement(
                'option',
                { key: 'not_equals', value: 'not_equals' },
                i18n.comparison_not_equals
            ), React.createElement(
                'option',
                { key: 'is_empty', value: 'is_empty' },
                i18n.comparison_is_empty
            ), React.createElement(
                'option',
                { key: 'is_not_empty', value: 'is_not_empty' },
                i18n.comparison_is_not_empty
            )];
        }
    }]);

    return SelectOptionsEqualNotEqual;
}(React.Component);

SelectOptionsEqualNotEqual.propTypes = {
    i18n: _propTypes2.default.object
};

exports.default = SelectOptionsEqualNotEqual;

},{"./translations/i18n-equal-not-equal":57,"prop-types":182}],54:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _i18nHasOrNot = require('./translations/i18n-has-or-not');

var _i18nHasOrNot2 = _interopRequireDefault(_i18nHasOrNot);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SelectOptionsHasOrNot = function (_React$Component) {
    _inherits(SelectOptionsHasOrNot, _React$Component);

    function SelectOptionsHasOrNot() {
        _classCallCheck(this, SelectOptionsHasOrNot);

        return _possibleConstructorReturn(this, (SelectOptionsHasOrNot.__proto__ || Object.getPrototypeOf(SelectOptionsHasOrNot)).apply(this, arguments));
    }

    _createClass(SelectOptionsHasOrNot, [{
        key: 'render',
        value: function render() {
            var i18n = _i18nHasOrNot2.default;

            if (this.props.i18n) {
                i18n = Object.assign({}, i18n, this.props.i18n);
            }

            return [React.createElement(
                'option',
                { key: 'has', value: 'has' },
                i18n.comparison_has
            ), React.createElement(
                'option',
                { key: 'does_not_have', value: 'does_not_have' },
                i18n.comparison_does_not_have
            ), React.createElement(
                'option',
                { key: 'is_empty', value: 'is_empty' },
                i18n.comparison_is_empty
            ), React.createElement(
                'option',
                { key: 'is_not_empty', value: 'is_not_empty' },
                i18n.comparison_is_not_empty
            )];
        }
    }]);

    return SelectOptionsHasOrNot;
}(React.Component);

SelectOptionsHasOrNot.propTypes = {
    i18n: _propTypes2.default.object
};

exports.default = SelectOptionsHasOrNot;

},{"./translations/i18n-has-or-not":58,"prop-types":182}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _i18nText = require('./translations/i18n-text');

var _i18nText2 = _interopRequireDefault(_i18nText);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TextSelectOptions = function (_React$Component) {
    _inherits(TextSelectOptions, _React$Component);

    function TextSelectOptions() {
        _classCallCheck(this, TextSelectOptions);

        return _possibleConstructorReturn(this, (TextSelectOptions.__proto__ || Object.getPrototypeOf(TextSelectOptions)).apply(this, arguments));
    }

    _createClass(TextSelectOptions, [{
        key: 'render',
        value: function render() {
            var i18n = _i18nText2.default;

            if (this.props.i18n) {
                i18n = Object.assign({}, i18n, this.props.i18n);
            }

            return [React.createElement(
                'option',
                { key: 'contains', value: 'contains' },
                i18n.comparison_contains
            ), React.createElement(
                'option',
                { key: 'starts_with', value: 'starts_with' },
                i18n.comparison_starts_with
            ), React.createElement(
                'option',
                { key: 'ends_with', value: 'ends_with' },
                i18n.comparison_ends_with
            ), React.createElement(
                'option',
                { key: 'equals', value: 'equals' },
                i18n.comparison_equals
            ), React.createElement(
                'option',
                { key: 'not_equals', value: 'not_equals' },
                i18n.comparison_not_equals
            ), React.createElement(
                'option',
                { key: 'is_empty', value: 'is_empty' },
                i18n.comparison_is_empty
            ), React.createElement(
                'option',
                { key: 'is_not_empty', value: 'is_not_empty' },
                i18n.comparison_is_not_empty
            )];
        }
    }]);

    return TextSelectOptions;
}(React.Component);

TextSelectOptions.propTypes = {
    i18n: _propTypes2.default.object
};

exports.default = TextSelectOptions;

},{"./translations/i18n-text":59,"prop-types":182}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    comparison_equals: 'equals',
    comparison_not_equals: 'not equals',
    comparison_greater_than: 'greater than',
    comparison_less_than: 'less than',
    comparison_greater_than_or_equal: 'greater than or equal',
    comparison_less_than_or_equal: 'less than or equal',
    comparison_is_empty: 'is empty',
    comparison_is_not_empty: 'is not empty'
};

},{}],57:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    comparison_equals: 'equals',
    comparison_not_equals: 'not equals',
    comparison_is_empty: 'is empty',
    comparison_is_not_empty: 'is not empty'
};

},{}],58:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    comparison_has: 'has',
    comparison_does_not_have: 'does not have',
    comparison_is_empty: 'is empty',
    comparison_is_not_empty: 'is not empty'
};

},{}],59:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    comparison_contains: 'contains',
    comparison_starts_with: 'starts with',
    comparison_ends_with: 'ends with',
    comparison_equals: 'equals',
    comparison_not_equals: 'not equals',
    comparison_is_empty: 'is empty',
    comparison_is_not_empty: 'is not empty'
};

},{}],60:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DefaultGroupButton = function (_React$Component) {
    _inherits(DefaultGroupButton, _React$Component);

    function DefaultGroupButton() {
        _classCallCheck(this, DefaultGroupButton);

        var _this = _possibleConstructorReturn(this, (DefaultGroupButton.__proto__ || Object.getPrototypeOf(DefaultGroupButton)).call(this));

        _this.setContainer = _this.setContainer.bind(_this);
        _this.state = {
            settingsOpen: false
        };
        return _this;
    }

    _createClass(DefaultGroupButton, [{
        key: 'toggleSettings',
        value: function toggleSettings() {
            this.setState({
                settingsOpen: !this.state.settingsOpen
            });
        }
    }, {
        key: 'setContainer',
        value: function setContainer(ref) {
            this.container = ref;
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            var _this2 = this;

            document.addEventListener('click', function (e) {
                return _this2.clickOutside(e);
            }, true);
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            var _this3 = this;

            document.removeEventListener('click', function (e) {
                return _this3.clickOutside(e);
            }, true);
        }
    }, {
        key: 'clickOutside',
        value: function clickOutside(event) {
            var settingsOpen = this.state.settingsOpen;


            if (settingsOpen && this.container && !this.container.contains(event.target)) {
                this.setState({
                    settingsOpen: false
                });
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _this4 = this;

            var settingsOpen = this.state.settingsOpen,
                _props = this.props,
                buttons = _props.buttons,
                maxButtons = _props.maxButtons,
                i18n = _props.i18n,
                GroupPrimaryButton = _props.GroupPrimaryButton,
                GroupButtonsList = _props.GroupButtonsList;


            return React.createElement(
                'div',
                {
                    ref: this.setContainer,
                    className: (0, _classnames2.default)('btn-group', {
                        open: settingsOpen
                    }),
                    role: 'group'
                },
                React.createElement(
                    GroupPrimaryButton,
                    { type: 'button', onClick: function onClick(e) {
                            return _this4.toggleSettings();
                        } },
                    maxButtons === 1 ? i18n.actions : i18n.more,
                    '\xA0',
                    React.createElement('span', { className: 'caret' })
                ),
                React.createElement(GroupButtonsList, { buttons: buttons.map(function (button) {
                        return {
                            href: button.url ? button.url : '',
                            target: button.newTab ? '_blank' : '',
                            icon: button.icon,
                            text: button.text,
                            key: button.key,
                            onClick: function onClick(e) {
                                if (button.onClick) {
                                    e.preventDefault();
                                    button.onClick(button.primaryKeyValue);
                                }
                            }
                        };
                    }) })
            );
        }
    }]);

    return DefaultGroupButton;
}(React.Component);

DefaultGroupButton.propTypes = {
    buttons: _propTypes2.default.array,
    maxButtons: _propTypes2.default.number,
    i18n: (0, _propTypes.shape)({
        actions: _propTypes2.default.string,
        more: _propTypes2.default.string
    })
};

DefaultGroupButton.defaultProps = {
    i18n: {
        actions: 'Actions',
        more: 'More'
    },
    GroupPrimaryButton: function GroupPrimaryButton(props) {
        return React.createElement(
            'button',
            props,
            props.children
        );
    },
    GroupButtonsList: function GroupButtonsList(props) {
        return React.createElement(
            'ul',
            { className: 'dropdown-menu' },
            props.buttons.map(function (button) {
                return React.createElement(
                    'li',
                    { key: button.key, className: (0, _classnames2.default)({ 'dropdown-submenu': button.hasSubMenu }) },
                    React.createElement(
                        'a',
                        {
                            href: button.href,
                            onClick: button.onClick,
                            target: button.target
                        },
                        button.icon && React.createElement('i', { className: (0, _classnames2.default)(button.icon, 'gc-button-icon') }),
                        button.text
                    )
                );
            })
        );
    }
};

exports.default = DefaultGroupButton;

},{"classnames":118,"prop-types":182}],61:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DefaultLinkButton = function (_React$PureComponent) {
    _inherits(DefaultLinkButton, _React$PureComponent);

    function DefaultLinkButton() {
        _classCallCheck(this, DefaultLinkButton);

        return _possibleConstructorReturn(this, (DefaultLinkButton.__proto__ || Object.getPrototypeOf(DefaultLinkButton)).apply(this, arguments));
    }

    _createClass(DefaultLinkButton, [{
        key: 'onClickCallback',
        value: function onClickCallback(event) {
            var _props = this.props,
                onClick = _props.onClick,
                primaryKeyValue = _props.primaryKeyValue;


            if (onClick) {
                event.preventDefault();
                onClick(primaryKeyValue);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            var _props2 = this.props,
                icon = _props2.icon,
                url = _props2.url,
                text = _props2.text,
                rightMargin = _props2.rightMargin,
                newTab = _props2.newTab,
                LinkButtonWrapper = _props2.LinkButtonWrapper;


            return React.createElement(
                LinkButtonWrapper,
                {
                    classNames: { 'r5': rightMargin },
                    href: url ? url : '',
                    role: 'button',
                    onClick: function onClick(e) {
                        return _this2.onClickCallback(e);
                    },
                    target: newTab ? '_blank' : ''
                },
                icon && React.createElement('i', { className: icon }),
                text && React.createElement(
                    'span',
                    null,
                    '\xA0',
                    text
                )
            );
        }
    }]);

    return DefaultLinkButton;
}(React.PureComponent);

;

DefaultLinkButton.propTypes = {
    icon: _propTypes2.default.string,
    url: _propTypes2.default.string,
    text: _propTypes2.default.string,
    rightMargin: _propTypes2.default.bool,
    onClick: _propTypes2.default.func,
    primaryKeyValue: _propTypes2.default.string,
    newTab: _propTypes2.default.bool,
    LinkButtonWrapper: _propTypes2.default.func
};

DefaultLinkButton.defaultProps = {
    LinkButtonWrapper: function LinkButtonWrapper(props) {
        return React.createElement(
            'a',
            props,
            props.children
        );
    }
};

exports.default = DefaultLinkButton;

},{"classnames":118,"prop-types":182}],62:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _groupButtons = require('./wrappers/bootstrap-v3/group-buttons.jsx');

var _groupButtons2 = _interopRequireDefault(_groupButtons);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _datagridCheckbox = require('./datagrid-checkbox.jsx');

var _datagridCheckbox2 = _interopRequireDefault(_datagridCheckbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DatagridActionsColumn = function (_React$Component) {
    _inherits(DatagridActionsColumn, _React$Component);

    function DatagridActionsColumn() {
        _classCallCheck(this, DatagridActionsColumn);

        return _possibleConstructorReturn(this, (DatagridActionsColumn.__proto__ || Object.getPrototypeOf(DatagridActionsColumn)).apply(this, arguments));
    }

    _createClass(DatagridActionsColumn, [{
        key: 'render',
        value: function render() {
            var _props = this.props,
                actionButtons = _props.actionButtons,
                backendActionButtons = _props.backendActionButtons,
                _props$options = _props.options,
                hasEdit = _props$options.hasEdit,
                hasRead = _props$options.hasRead,
                hasClone = _props$options.hasClone,
                hasDelete = _props$options.hasDelete,
                hasActionButtons = _props$options.hasActionButtons,
                deleteMultiple = _props$options.deleteMultiple,
                onEditClick = _props.onEditClick,
                onReadClick = _props.onReadClick,
                onCloneClick = _props.onCloneClick,
                onDeleteClick = _props.onDeleteClick,
                onRowCheckboxClick = _props.onRowCheckboxClick,
                urlUniqueHash = _props.urlUniqueHash,
                screenSize = _props.screenSize,
                rowSelected = _props.rowSelected,
                toggleSelectRow = _props.toggleSelectRow,
                primaryKeyValue = _props.primaryKeyValue,
                i18n = _props.i18n,
                LinkButtonWrapper = _props.LinkButtonWrapper,
                GroupPrimaryButton = _props.GroupPrimaryButton,
                GroupButtonsList = _props.GroupButtonsList;

            var buttons = [];

            if (hasEdit) {
                buttons.push({
                    key: 'gc-edit',
                    url: '#/' + urlUniqueHash + 'edit/' + primaryKeyValue,
                    icon: 'fa fa-pencil',
                    text: i18n.edit,
                    onClick: onEditClick,
                    newTab: false,
                    primaryKeyValue: primaryKeyValue
                });
            }

            if (hasRead) {
                buttons.push({
                    key: 'gc-read',
                    url: '#/' + urlUniqueHash + 'read/' + primaryKeyValue,
                    icon: 'fa fa-eye',
                    text: i18n.view,
                    onClick: onReadClick,
                    newTab: false,
                    primaryKeyValue: primaryKeyValue
                });
            }

            if (hasClone) {
                buttons.push({
                    key: 'gc-clone',
                    url: '#/' + urlUniqueHash + 'clone/' + primaryKeyValue,
                    icon: 'fa fa-copy',
                    text: i18n.clone,
                    onClick: onCloneClick,
                    newTab: false,
                    primaryKeyValue: primaryKeyValue
                });
            }

            if (hasActionButtons && actionButtons) {
                actionButtons.forEach(function (button) {
                    buttons.push({
                        key: button.label,
                        icon: button.iconCssClass,
                        text: button.label,
                        onClick: button.onClick,
                        newTab: false,
                        primaryKeyValue: primaryKeyValue
                    });
                });
            }

            if (hasActionButtons && backendActionButtons) {
                backendActionButtons.forEach(function (button) {
                    buttons.push({
                        key: button.label,
                        icon: button.iconCssClass,
                        text: button.label,
                        newTab: button.newTab,
                        url: button.url,
                        primaryKeyValue: primaryKeyValue
                    });
                });
            }

            if (hasDelete) {
                buttons.push({
                    key: 'gc-delete',
                    icon: 'fa fa-trash-o',
                    text: i18n.action_delete,
                    onClick: onDeleteClick,
                    newTab: false,
                    primaryKeyValue: primaryKeyValue
                });
            }

            return React.createElement(
                'td',
                { className: 'gc-actions' },
                deleteMultiple && screenSize !== 'xs' && screenSize !== 's' && React.createElement(_datagridCheckbox2.default, {
                    rowSelected: rowSelected,
                    toggleSelectRow: toggleSelectRow,
                    onRowCheckboxClick: onRowCheckboxClick,
                    primaryKeyValue: primaryKeyValue
                }),
                React.createElement(_groupButtons2.default, {
                    buttons: buttons,
                    screenSize: screenSize,
                    i18n: i18n,
                    LinkButtonWrapper: LinkButtonWrapper,
                    GroupPrimaryButton: GroupPrimaryButton,
                    GroupButtonsList: GroupButtonsList
                })
            );
        }
    }]);

    return DatagridActionsColumn;
}(React.Component);

DatagridActionsColumn.propTypes = {
    actionButtons: _propTypes2.default.array,
    backendActionButtons: _propTypes2.default.array,
    options: (0, _propTypes.shape)({
        deleteMultiple: _propTypes2.default.bool,
        hasEdit: _propTypes2.default.bool,
        hasClone: _propTypes2.default.bool,
        hasDelete: _propTypes2.default.bool,
        hasRead: _propTypes2.default.bool,
        hasActionButtons: _propTypes2.default.bool
    }),
    onEditClick: _propTypes2.default.func,
    onCloneClick: _propTypes2.default.func,
    onReadClick: _propTypes2.default.func,
    onDeleteClick: _propTypes2.default.func,
    onRowCheckboxClick: _propTypes2.default.func,
    urlUniqueHash: _propTypes2.default.string,
    screenSize: _propTypes2.default.string,
    rowSelected: _propTypes2.default.bool,
    toggleSelectRow: _propTypes2.default.func,
    primaryKeyValue: _propTypes2.default.string,
    i18n: _propTypes2.default.shape({
        edit: _propTypes2.default.string,
        view: _propTypes2.default.string,
        action_delete: _propTypes2.default.string,
        actions: _propTypes2.default.string,
        more: _propTypes2.default.string,
        clone: _propTypes2.default.string
    }),
    LinkButtonWrapper: _propTypes2.default.func,
    GroupButtonsList: _propTypes2.default.func
};

DatagridActionsColumn.defaultProps = {
    urlUniqueHash: ''
};

exports.default = DatagridActionsColumn;

},{"./datagrid-checkbox.jsx":63,"./wrappers/bootstrap-v3/group-buttons.jsx":68,"prop-types":182}],63:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DatagridCheckbox = function (_React$Component) {
    _inherits(DatagridCheckbox, _React$Component);

    function DatagridCheckbox() {
        _classCallCheck(this, DatagridCheckbox);

        return _possibleConstructorReturn(this, (DatagridCheckbox.__proto__ || Object.getPrototypeOf(DatagridCheckbox)).apply(this, arguments));
    }

    _createClass(DatagridCheckbox, [{
        key: "onCheckboxClick",
        value: function onCheckboxClick(event) {
            var _props = this.props,
                toggleSelectRow = _props.toggleSelectRow,
                onRowCheckboxClick = _props.onRowCheckboxClick,
                primaryKeyValue = _props.primaryKeyValue;


            toggleSelectRow(primaryKeyValue);
            onRowCheckboxClick(event, primaryKeyValue);
        }
    }, {
        key: "render",
        value: function render() {
            var _this2 = this;

            var _props2 = this.props,
                rowSelected = _props2.rowSelected,
                primaryKeyValue = _props2.primaryKeyValue;


            return React.createElement("input", {
                checked: rowSelected,
                onClick: function onClick(e) {
                    return _this2.onCheckboxClick(e);
                },
                type: "checkbox",
                className: "gc-select-row",
                "data-id": primaryKeyValue
            });
        }
    }]);

    return DatagridCheckbox;
}(React.Component);

DatagridCheckbox.propTypes = {
    rowSelected: _propTypes2.default.bool,
    toggleSelectRow: _propTypes2.default.func,
    onRowCheckboxClick: _propTypes2.default.func,
    primaryKeyValue: _propTypes2.default.string
};

exports.default = DatagridCheckbox;

},{"prop-types":182}],64:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _DatagridRow$propType;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _datagridActionsColumn = require('./datagrid-actions-column.jsx');

var _datagridActionsColumn2 = _interopRequireDefault(_datagridActionsColumn);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DatagridRow = function (_React$Component) {
    _inherits(DatagridRow, _React$Component);

    function DatagridRow() {
        _classCallCheck(this, DatagridRow);

        return _possibleConstructorReturn(this, (DatagridRow.__proto__ || Object.getPrototypeOf(DatagridRow)).apply(this, arguments));
    }

    _createClass(DatagridRow, [{
        key: 'render',
        value: function render() {
            var _props = this.props,
                columnsData = _props.data.columnsData,
                options = _props.options,
                hasActionButtons = _props.options.hasActionButtons,
                onEditClick = _props.onEditClick,
                onCloneClick = _props.onCloneClick,
                onReadClick = _props.onReadClick,
                onDeleteClick = _props.onDeleteClick,
                onRowCheckboxClick = _props.onRowCheckboxClick,
                urlUniqueHash = _props.urlUniqueHash,
                actionButtons = _props.actionButtons,
                backendActionButtons = _props.backendActionButtons,
                screenSize = _props.screenSize,
                orderBy = _props.orderBy,
                i18n = _props.i18n,
                primaryKeyValue = _props.primaryKeyValue,
                toggleSelectRow = _props.toggleSelectRow,
                rowSelected = _props.rowSelected,
                LinkButtonWrapper = _props.LinkButtonWrapper,
                GroupPrimaryButton = _props.GroupPrimaryButton,
                GroupButtonsList = _props.GroupButtonsList;


            var columnData = [];

            columnsData.forEach(function (column) {

                columnData.push(React.createElement(
                    'td',
                    {
                        className: (0, _classnames2.default)({
                            'active': orderBy === column.name,
                            'table-active': orderBy === column.name
                        }, 'gc-data-container'),
                        key: column.name
                    },
                    !column.value && React.createElement(
                        'span',
                        null,
                        '\xA0'
                    ),
                    column.value && !column.isHtml && React.createElement(
                        'div',
                        { className: 'gc-data-container-text' },
                        column.value
                    ),
                    column.value && column.isHtml && React.createElement('div', { className: 'gc-data-container-text', dangerouslySetInnerHTML: { __html: column.value } })
                ));
            });

            return React.createElement(
                'tr',
                {
                    className: (0, _classnames2.default)({
                        'warning': rowSelected
                    }),
                    'data-id': primaryKeyValue
                },
                hasActionButtons && React.createElement(_datagridActionsColumn2.default, {
                    options: options,
                    actionButtons: actionButtons,
                    backendActionButtons: backendActionButtons,
                    onEditClick: onEditClick,
                    onCloneClick: onCloneClick,
                    onReadClick: onReadClick,
                    onDeleteClick: onDeleteClick,
                    onRowCheckboxClick: onRowCheckboxClick,
                    urlUniqueHash: urlUniqueHash,
                    screenSize: screenSize,
                    toggleSelectRow: toggleSelectRow,
                    rowSelected: rowSelected,
                    i18n: i18n,
                    primaryKeyValue: primaryKeyValue,
                    LinkButtonWrapper: LinkButtonWrapper,
                    GroupPrimaryButton: GroupPrimaryButton,
                    GroupButtonsList: GroupButtonsList
                }),
                columnData
            );
        }
    }]);

    return DatagridRow;
}(React.Component);

DatagridRow.propTypes = (_DatagridRow$propType = {
    data: (0, _propTypes.shape)({
        columnsData: _propTypes2.default.array
    }),
    options: (0, _propTypes.shape)({
        deleteMultiple: _propTypes2.default.bool,
        hasEdit: _propTypes2.default.bool,
        hasClone: _propTypes2.default.bool,
        hasDelete: _propTypes2.default.bool,
        hasRead: _propTypes2.default.bool,
        hasActionButtons: _propTypes2.default.bool
    }),
    onEditClick: _propTypes2.default.func,
    onCloneClick: _propTypes2.default.func,
    onReadClick: _propTypes2.default.func,
    onDeleteClick: _propTypes2.default.func,
    onRowCheckboxClick: _propTypes2.default.func,
    urlUniqueHash: _propTypes2.default.string,
    actionButtons: _propTypes2.default.array,
    backendActionButtons: _propTypes2.default.array,
    screenSize: _propTypes2.default.string,
    i18n: _propTypes2.default.object,
    primaryKeyValue: _propTypes2.default.string,
    toggleSelectRow: _propTypes2.default.func,
    rowSelected: _propTypes2.default.bool,
    LinkButtonWrapper: _propTypes2.default.func
}, _defineProperty(_DatagridRow$propType, 'LinkButtonWrapper', _propTypes2.default.func), _defineProperty(_DatagridRow$propType, 'GroupButtonsList', _propTypes2.default.func), _DatagridRow$propType);

exports.default = DatagridRow;

},{"./datagrid-actions-column.jsx":62,"classnames":118,"prop-types":182}],65:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _datagridRow = require('./datagrid-row.jsx');

var _datagridRow2 = _interopRequireDefault(_datagridRow);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DatagridTbody = function (_React$Component) {
    _inherits(DatagridTbody, _React$Component);

    function DatagridTbody(props) {
        _classCallCheck(this, DatagridTbody);

        var _this = _possibleConstructorReturn(this, (DatagridTbody.__proto__ || Object.getPrototypeOf(DatagridTbody)).call(this, props));

        _this.state = {
            selectedIds: []
        };
        return _this;
    }

    _createClass(DatagridTbody, [{
        key: 'toggleSelectRow',
        value: function toggleSelectRow(id) {
            var selectedIds = this.state.selectedIds;


            if (selectedIds.indexOf(id) > -1) {
                selectedIds = selectedIds.filter(function (selectedId) {
                    return selectedId !== id;
                });
            } else {
                selectedIds.push(id);
            }

            this.setState({
                selectedIds: selectedIds
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            var _props = this.props,
                rows = _props.rows,
                options = _props.options,
                orderBy = _props.orderBy,
                columns = _props.columns,
                onEditClick = _props.onEditClick,
                onCloneClick = _props.onCloneClick,
                onReadClick = _props.onReadClick,
                onDeleteClick = _props.onDeleteClick,
                onRowCheckboxClick = _props.onRowCheckboxClick,
                urlUniqueHash = _props.urlUniqueHash,
                actionButtons = _props.actionButtons,
                screenSize = _props.screenSize,
                i18n = _props.i18n,
                LinkButtonWrapper = _props.LinkButtonWrapper,
                GroupPrimaryButton = _props.GroupPrimaryButton,
                GroupButtonsList = _props.GroupButtonsList,
                selectedIds = this.state.selectedIds;


            return rows.map(function (row, key) {
                return React.createElement(_datagridRow2.default, {
                    columns: columns,
                    options: options,
                    data: row,
                    orderBy: orderBy,
                    key: key,
                    onEditClick: onEditClick,
                    onReadClick: onReadClick,
                    onCloneClick: onCloneClick,
                    onDeleteClick: onDeleteClick,
                    onRowCheckboxClick: onRowCheckboxClick,
                    urlUniqueHash: urlUniqueHash,
                    actionButtons: actionButtons,
                    backendActionButtons: row.backendActionButtons,
                    screenSize: screenSize,
                    toggleSelectRow: function toggleSelectRow(id) {
                        return _this2.toggleSelectRow(id);
                    },
                    i18n: i18n,
                    primaryKeyValue: row.primaryKeyValue,
                    rowSelected: selectedIds.indexOf(row.primaryKeyValue) > -1,
                    LinkButtonWrapper: LinkButtonWrapper,
                    GroupPrimaryButton: GroupPrimaryButton,
                    GroupButtonsList: GroupButtonsList
                });
            });
        }
    }]);

    return DatagridTbody;
}(React.Component);

DatagridTbody.propTypes = {
    rows: _propTypes2.default.array,
    options: (0, _propTypes.shape)({
        deleteMultiple: _propTypes2.default.bool,
        hasEdit: _propTypes2.default.bool,
        hasClone: _propTypes2.default.bool,
        hasDelete: _propTypes2.default.bool,
        hasRead: _propTypes2.default.bool,
        hasActionButtons: _propTypes2.default.bool
    }),
    orderBy: _propTypes2.default.string,
    columns: _propTypes2.default.array,
    onEditClick: _propTypes2.default.func,
    onCloneClick: _propTypes2.default.func,
    onReadClick: _propTypes2.default.func,
    onDeleteClick: _propTypes2.default.func,
    onRowCheckboxClick: _propTypes2.default.func,
    urlUniqueHash: _propTypes2.default.string,
    actionButtons: _propTypes2.default.array,
    screenSize: _propTypes2.default.string,
    i18n: _propTypes2.default.object,
    LinkButtonWrapper: _propTypes2.default.func,
    GroupPrimaryButton: _propTypes2.default.func,
    GroupButtonsList: _propTypes2.default.func
};

exports.default = DatagridTbody;

},{"./datagrid-row.jsx":64,"prop-types":182}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FieldRowWrapper = function (_React$Component) {
    _inherits(FieldRowWrapper, _React$Component);

    function FieldRowWrapper() {
        _classCallCheck(this, FieldRowWrapper);

        return _possibleConstructorReturn(this, (FieldRowWrapper.__proto__ || Object.getPrototypeOf(FieldRowWrapper)).apply(this, arguments));
    }

    _createClass(FieldRowWrapper, [{
        key: "render",
        value: function render() {
            var _props = this.props,
                isRequired = _props.isRequired,
                displayAs = _props.displayAs,
                FieldInput = _props.FieldInput,
                data = _props.data,
                gcrudInstance = _props.gcrudInstance;


            return React.createElement(
                "div",
                { className: "form-group" },
                React.createElement(
                    "label",
                    { className: "col-sm-3 control-label" },
                    isRequired ? '*' : '',
                    displayAs
                ),
                React.createElement(
                    "div",
                    { className: "col-sm-9" },
                    React.createElement(FieldInput, { data: data, gcrudInstance: gcrudInstance })
                )
            );
        }
    }]);

    return FieldRowWrapper;
}(React.Component);

FieldRowWrapper.propTypes = {
    isRequired: _propTypes2.default.bool,
    displayAs: _propTypes2.default.string,
    FieldInput: _propTypes2.default.func,
    data: _propTypes2.default.object,
    gcrudInstance: _propTypes2.default.object
};

exports.default = FieldRowWrapper;

},{"prop-types":182}],67:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require("classnames");

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GroupButtonsList = function (_React$Component) {
    _inherits(GroupButtonsList, _React$Component);

    function GroupButtonsList() {
        _classCallCheck(this, GroupButtonsList);

        return _possibleConstructorReturn(this, (GroupButtonsList.__proto__ || Object.getPrototypeOf(GroupButtonsList)).apply(this, arguments));
    }

    _createClass(GroupButtonsList, [{
        key: "render",
        value: function render() {
            var buttons = this.props.buttons;


            return React.createElement(
                "ul",
                { className: "dropdown-menu" },
                buttons.map(function (button) {
                    return React.createElement(
                        "li",
                        _defineProperty({
                            className: "dropdown-item",
                            key: button.key
                        }, "className", (0, _classnames2.default)({
                            'dropdown-submenu': button.hasSubMenu,
                            'left-direction': button.hasSubMenu && button.subMenuLeftDirection
                        })),
                        React.createElement(
                            "a",
                            {
                                href: button.href ? button.href : '',
                                onClick: button.onClick,
                                target: button.target
                            },
                            button.icon && React.createElement("i", { className: (0, _classnames2.default)(button.icon, 'gc-button-icon') }),
                            button.text
                        ),
                        button.subComponent && React.createElement(
                            "ul",
                            { className: "dropdown-menu" },
                            button.subComponent
                        )
                    );
                })
            );
        }
    }]);

    return GroupButtonsList;
}(React.Component);

GroupButtonsList.propTypes = {
    buttons: _propTypes2.default.array
};

exports.default = GroupButtonsList;

},{"classnames":118,"prop-types":182}],68:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _defaultLinkButton = require("../../buttons/default-link-button.jsx");

var _defaultLinkButton2 = _interopRequireDefault(_defaultLinkButton);

var _defaultGroupButton = require("../../buttons/default-group-button.jsx");

var _defaultGroupButton2 = _interopRequireDefault(_defaultGroupButton);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GroupButtons = function (_React$Component) {
    _inherits(GroupButtons, _React$Component);

    function GroupButtons() {
        _classCallCheck(this, GroupButtons);

        return _possibleConstructorReturn(this, (GroupButtons.__proto__ || Object.getPrototypeOf(GroupButtons)).apply(this, arguments));
    }

    _createClass(GroupButtons, [{
        key: "render",
        value: function render() {
            var _props = this.props,
                buttons = _props.buttons,
                screenSize = _props.screenSize,
                i18n = _props.i18n,
                LinkButtonWrapper = _props.LinkButtonWrapper,
                GroupPrimaryButton = _props.GroupPrimaryButton,
                GroupButtonsList = _props.GroupButtonsList,
                maxButtons = screenSize === 'xs' || screenSize === 's' ? 1 : 2,
                buttonMap = function buttonMap(button) {
                return React.createElement(_defaultLinkButton2.default, {
                    key: button.key,
                    url: button.url,
                    icon: button.icon,
                    text: button.text,
                    newTab: button.newTab,
                    rightMargin: true,
                    primaryKeyValue: button.primaryKeyValue,
                    onClick: button.onClick,
                    LinkButtonWrapper: LinkButtonWrapper
                });
            };

            if (!buttons || buttons.length === 0) {
                return null;
            }

            if (buttons.length <= maxButtons) {
                return buttons.map(buttonMap);
            }

            return React.createElement(
                "span",
                null,
                buttons.filter(function (__button, key) {
                    return key < maxButtons - 1;
                }).map(buttonMap),
                React.createElement(_defaultGroupButton2.default, {
                    buttons: buttons.filter(function (__button, key) {
                        return key >= maxButtons - 1;
                    }),
                    maxButtons: maxButtons,
                    i18n: i18n,
                    GroupPrimaryButton: GroupPrimaryButton,
                    GroupButtonsList: GroupButtonsList
                })
            );
        }
    }]);

    return GroupButtons;
}(React.Component);

GroupButtons.propTypes = {
    buttons: _propTypes2.default.array,
    screenSize: _propTypes2.default.string,
    i18n: _propTypes2.default.object,
    GroupButtonsList: _propTypes2.default.func,
    LinkButtonWrapper: _propTypes2.default.func
};

exports.default = GroupButtons;

},{"../../buttons/default-group-button.jsx":60,"../../buttons/default-link-button.jsx":61,"prop-types":182}],69:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GroupPrimaryButton = function (_React$Component) {
  _inherits(GroupPrimaryButton, _React$Component);

  function GroupPrimaryButton() {
    _classCallCheck(this, GroupPrimaryButton);

    return _possibleConstructorReturn(this, (GroupPrimaryButton.__proto__ || Object.getPrototypeOf(GroupPrimaryButton)).apply(this, arguments));
  }

  _createClass(GroupPrimaryButton, [{
    key: "render",
    value: function render() {
      var props = this.props;


      return React.createElement(
        "button",
        _extends({ type: "button", className: "btn btn-default dropdown-toggle" }, props),
        props.children
      );
    }
  }]);

  return GroupPrimaryButton;
}(React.Component);

exports.default = GroupPrimaryButton;

},{}],70:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LinkButtonWrapper = function (_React$Component) {
  _inherits(LinkButtonWrapper, _React$Component);

  function LinkButtonWrapper() {
    _classCallCheck(this, LinkButtonWrapper);

    return _possibleConstructorReturn(this, (LinkButtonWrapper.__proto__ || Object.getPrototypeOf(LinkButtonWrapper)).apply(this, arguments));
  }

  _createClass(LinkButtonWrapper, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          children = _props.children,
          classNames = _props.classNames,
          href = _props.href,
          role = _props.role,
          onClick = _props.onClick,
          target = _props.target;


      return React.createElement(
        'a',
        {
          className: (0, _classnames2.default)('btn', 'btn-default', classNames),
          href: href,
          role: role,
          onClick: onClick,
          target: target
        },
        children
      );
    }
  }]);

  return LinkButtonWrapper;
}(React.Component);

exports.default = LinkButtonWrapper;

},{"classnames":118}],71:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ModalTitleWrapper = function (_React$Component) {
    _inherits(ModalTitleWrapper, _React$Component);

    function ModalTitleWrapper() {
        _classCallCheck(this, ModalTitleWrapper);

        return _possibleConstructorReturn(this, (ModalTitleWrapper.__proto__ || Object.getPrototypeOf(ModalTitleWrapper)).apply(this, arguments));
    }

    _createClass(ModalTitleWrapper, [{
        key: "render",
        value: function render() {
            var title = this.props.title;


            return React.createElement(
                React.Fragment,
                null,
                React.createElement(
                    "button",
                    {
                        type: "button",
                        className: "close",
                        "data-dismiss": "modal",
                        "aria-label": "Close"
                    },
                    React.createElement(
                        "span",
                        { "aria-hidden": "true" },
                        "\xD7"
                    )
                ),
                React.createElement(
                    "h4",
                    { className: "modal-title" },
                    title
                )
            );
        }
    }]);

    return ModalTitleWrapper;
}(React.Component);

ModalTitleWrapper.propTypes = {
    title: _propTypes2.default.string
};

exports.default = ModalTitleWrapper;

},{"prop-types":182}],72:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FieldRowWrapper = function (_React$Component) {
    _inherits(FieldRowWrapper, _React$Component);

    function FieldRowWrapper() {
        _classCallCheck(this, FieldRowWrapper);

        return _possibleConstructorReturn(this, (FieldRowWrapper.__proto__ || Object.getPrototypeOf(FieldRowWrapper)).apply(this, arguments));
    }

    _createClass(FieldRowWrapper, [{
        key: "render",
        value: function render() {
            var _props = this.props,
                isRequired = _props.isRequired,
                displayAs = _props.displayAs,
                FieldInput = _props.FieldInput,
                data = _props.data,
                gcrudInstance = _props.gcrudInstance;


            return React.createElement(
                "div",
                { className: "form-group row" },
                React.createElement(
                    "label",
                    { className: "col-sm-3 col-form-label" },
                    isRequired ? '*' : '',
                    displayAs
                ),
                React.createElement(
                    "div",
                    { className: "col-sm-9" },
                    React.createElement(FieldInput, { data: data, gcrudInstance: gcrudInstance })
                )
            );
        }
    }]);

    return FieldRowWrapper;
}(React.Component);

FieldRowWrapper.propTypes = {
    isRequired: _propTypes2.default.bool,
    displayAs: _propTypes2.default.string,
    FieldInput: _propTypes2.default.func,
    data: _propTypes2.default.object,
    gcrudInstance: _propTypes2.default.object
};

exports.default = FieldRowWrapper;

},{"prop-types":182}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require("classnames");

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GroupButtonsList = function (_React$Component) {
    _inherits(GroupButtonsList, _React$Component);

    function GroupButtonsList() {
        _classCallCheck(this, GroupButtonsList);

        return _possibleConstructorReturn(this, (GroupButtonsList.__proto__ || Object.getPrototypeOf(GroupButtonsList)).apply(this, arguments));
    }

    _createClass(GroupButtonsList, [{
        key: "render",
        value: function render() {
            var buttons = this.props.buttons;


            return React.createElement(
                "div",
                { className: "dropdown-menu" },
                buttons.map(function (button) {
                    return !button.hasSubMenu ? React.createElement(
                        "a",
                        {
                            key: button.key,
                            href: button.href,
                            onClick: button.onClick,
                            target: button.target,
                            className: "dropdown-item"
                        },
                        button.icon && React.createElement("i", { className: (0, _classnames2.default)(button.icon, 'gc-button-icon') }),
                        button.text
                    ) : React.createElement(
                        "div",
                        {
                            key: button.key,
                            className: (0, _classnames2.default)('dropdown-item', 'dropdown-submenu', 'dropdown-submenu-item', {
                                'left-direction': button.subMenuLeftDirection
                            })
                        },
                        button.icon && React.createElement("i", { className: (0, _classnames2.default)(button.icon, 'gc-button-icon') }),
                        button.text,
                        button.subComponent && React.createElement(
                            "ul",
                            { className: "dropdown-menu" },
                            button.subComponent
                        )
                    );
                })
            );
        }
    }]);

    return GroupButtonsList;
}(React.Component);

GroupButtonsList.propTypes = {
    buttons: _propTypes2.default.array
};

exports.default = GroupButtonsList;

},{"classnames":118,"prop-types":182}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GroupPrimaryButton = function (_React$Component) {
  _inherits(GroupPrimaryButton, _React$Component);

  function GroupPrimaryButton() {
    _classCallCheck(this, GroupPrimaryButton);

    return _possibleConstructorReturn(this, (GroupPrimaryButton.__proto__ || Object.getPrototypeOf(GroupPrimaryButton)).apply(this, arguments));
  }

  _createClass(GroupPrimaryButton, [{
    key: "render",
    value: function render() {
      var props = this.props;


      return React.createElement(
        "button",
        _extends({ type: "button", className: "btn btn-outline-dark dropdown-toggle" }, props),
        props.children
      );
    }
  }]);

  return GroupPrimaryButton;
}(React.Component);

exports.default = GroupPrimaryButton;

},{}],75:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LinkButtonWrapper = function (_React$Component) {
    _inherits(LinkButtonWrapper, _React$Component);

    function LinkButtonWrapper() {
        _classCallCheck(this, LinkButtonWrapper);

        return _possibleConstructorReturn(this, (LinkButtonWrapper.__proto__ || Object.getPrototypeOf(LinkButtonWrapper)).apply(this, arguments));
    }

    _createClass(LinkButtonWrapper, [{
        key: 'render',
        value: function render() {
            var _props = this.props,
                children = _props.children,
                classNames = _props.classNames,
                href = _props.href,
                role = _props.role,
                onClick = _props.onClick,
                target = _props.target;


            return React.createElement(
                'a',
                {
                    className: (0, _classnames2.default)('btn', 'btn-outline-dark', classNames),
                    href: href,
                    role: role,
                    onClick: onClick,
                    target: target
                },
                children
            );
        }
    }]);

    return LinkButtonWrapper;
}(React.Component);

exports.default = LinkButtonWrapper;

},{"classnames":118}],76:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ModalTitleWrapper = function (_React$Component) {
    _inherits(ModalTitleWrapper, _React$Component);

    function ModalTitleWrapper() {
        _classCallCheck(this, ModalTitleWrapper);

        return _possibleConstructorReturn(this, (ModalTitleWrapper.__proto__ || Object.getPrototypeOf(ModalTitleWrapper)).apply(this, arguments));
    }

    _createClass(ModalTitleWrapper, [{
        key: "render",
        value: function render() {
            var title = this.props.title;


            return React.createElement(
                React.Fragment,
                null,
                React.createElement(
                    "h4",
                    { className: "modal-title" },
                    title
                ),
                React.createElement(
                    "button",
                    {
                        type: "button",
                        className: "close",
                        "data-dismiss": "modal",
                        "aria-label": "Close"
                    },
                    React.createElement(
                        "span",
                        { "aria-hidden": "true" },
                        "\xD7"
                    )
                )
            );
        }
    }]);

    return ModalTitleWrapper;
}(React.Component);

ModalTitleWrapper.propTypes = {
    title: _propTypes2.default.string
};

exports.default = ModalTitleWrapper;

},{"prop-types":182}],77:[function(require,module,exports){
'use strict';

var _perPageDropdown = require('../modules/react/jsx/datagrid/footer/per-page-dropdown.jsx');

var _perPageDropdown2 = _interopRequireDefault(_perPageDropdown);

var _filtering = require('../../../../React-Components/gce-react-datagrid-filtering/filtering');

var _filtering2 = _interopRequireDefault(_filtering);

var _datagridTbody = require('../../../../React-Components/gce-react-datagrid/datagrid-tbody.jsx');

var _datagridTbody2 = _interopRequireDefault(_datagridTbody);

var _settings = require('../../../../React-Components/gce-datagrid-settings/gce-datagrid-settings/settings.jsx');

var _settings2 = _interopRequireDefault(_settings);

var _groupPrimaryButton = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/group-primary-button.jsx');

var _groupPrimaryButton2 = _interopRequireDefault(_groupPrimaryButton);

var _groupButtonsList = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/group-buttons-list.jsx');

var _groupButtonsList2 = _interopRequireDefault(_groupButtonsList);

var _linkButtonWrapper = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/link-button-wrapper.jsx');

var _linkButtonWrapper2 = _interopRequireDefault(_linkButtonWrapper);

var _fieldRowWrapper = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/field-row-wrapper');

var _fieldRowWrapper2 = _interopRequireDefault(_fieldRowWrapper);

var _modalTitleWrapper = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/modal-title-wrapper');

var _modalTitleWrapper2 = _interopRequireDefault(_modalTitleWrapper);

var _groupPrimaryButton3 = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/group-primary-button.jsx');

var _groupPrimaryButton4 = _interopRequireDefault(_groupPrimaryButton3);

var _groupButtonsList3 = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/group-buttons-list.jsx');

var _groupButtonsList4 = _interopRequireDefault(_groupButtonsList3);

var _linkButtonWrapper3 = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/link-button-wrapper.jsx');

var _linkButtonWrapper4 = _interopRequireDefault(_linkButtonWrapper3);

var _fieldRowWrapper3 = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/field-row-wrapper');

var _fieldRowWrapper4 = _interopRequireDefault(_fieldRowWrapper3);

var _modalTitleWrapper3 = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/modal-title-wrapper');

var _modalTitleWrapper4 = _interopRequireDefault(_modalTitleWrapper3);

var _title = require('../../../../React-Components/gce-crud-forms/modal/title.jsx');

var _title2 = _interopRequireDefault(_title);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line no-unused-vars


// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
var Handlebars = require('../libraries/HandlebarsExtended').Handlebars,
    _ = require('underscore'),
    $ = jQuery,
    jQueryPlugins = require('../modules/jquery/jquery-plugins').jQueryPlugins,
    Constants = require('../sections/constants').Constants,
    ajaxHelper = require('../helpers/ajax-helper').ajaxHelper,
    i18n = require('../sections/i18n').i18n,
    localStorageHelper = require('../helpers/local-storage-helper').localStorageHelper,
    Grid = require('./../sections/datagrid/datagrid.grid.js').Grid,
    OperationAdd = require('./../sections/operations/add.js').OperationAdd,
    OperationEdit = require('./../sections/operations/edit.js').OperationEdit,
    OperationClone = require('./../sections/operations/clone.js').OperationClone,
    OperationRead = require('./../sections/operations/read.js').OperationRead,
    OperationDelete = require('./../sections/operations/delete.js').OperationDelete,
    OperationsCommon = require('./../sections/operations/common.js').OperationsCommon,
    Column = require('../sections/datagrid/column').Column,
    DatagridColumns = require('../sections/datagrid/datagrid.columns').DatagridColumns,
    DatagridPaging = require('../sections/datagrid/datagrid.paging').DatagridPaging,
    DatagridHeaderActions = require('./../sections/datagrid/datagrid.header-actions.js').DatagridHeaderActions,
    DatagridSearch = require('./../sections/datagrid/datagrid.search.js').DatagridSearch,
    Router = require('../sections/routes/router').Router,

/**
 * This is the basic Object that does all the functionality for GroceryCrud
 *
 * @class GroceryCrud
 * @param {jQuery} gcrud_container
 * @param Object settings
 * @constructor
 */
GroceryCrud = function GroceryCrud(gcrud_container, settings) {

    /**
     *
     * @type {jQuery}
     */
    this.$gc = gcrud_container;
    this.settings = settings;
}; // eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars


if ($.fn !== undefined) {
    require('../jquery-plugins/printThis');
    require('../jquery-plugins/transition');
    require('../jquery-plugins/modal');
    require('../jquery-plugins/chosen.jquery');
    require('../libraries/jquery-ui-timepicker');
}

//GroceryCrud public variables
GroceryCrud.prototype.insertFields = [];
GroceryCrud.prototype.url = '';
GroceryCrud.prototype.indexedColumns = {};
GroceryCrud.prototype.hasActions = '';
GroceryCrud.prototype.enumFields = [];
GroceryCrud.prototype.enumFieldsData = [];
GroceryCrud.prototype.dropdownFields = [];
GroceryCrud.prototype.dropdownFieldsData = [];
GroceryCrud.prototype.checkboxBooleanFields = [];
GroceryCrud.prototype.checkboxBooleanFieldsData = [];

GroceryCrud.prototype.relationNtoNFields = {};
GroceryCrud.prototype.relationNtoNData = {};
GroceryCrud.prototype.multipleSelectFields = {};
GroceryCrud.prototype.multipleSelectData = {};
GroceryCrud.prototype.texteditorFields = {};
GroceryCrud.prototype.callbackColumnFields = {};

GroceryCrud.prototype.components = {
    GroupPrimaryButton: null,
    GroupButtonsList: null,
    LinkButtonWrapper: null,
    FieldRowWrapper: null,
    ModalTitleWrapper: null
};

GroceryCrud.prototype.relationFields = [];
GroceryCrud.prototype.relationData = {};
GroceryCrud.prototype.uploadFields = [];
GroceryCrud.prototype.uploadFieldsData = {};
GroceryCrud.prototype.dateFields = [];
GroceryCrud.prototype.datetimeFields = [];
GroceryCrud.prototype.dateFormatter = null;
GroceryCrud.prototype.updateFields = [];
GroceryCrud.prototype.readFields = [];
GroceryCrud.prototype.cloneFields = [];
GroceryCrud.prototype.columns = [];
GroceryCrud.prototype.visibleColumns = [];
GroceryCrud.prototype.search_timer = null;
GroceryCrud.prototype.cachedInitialData = null;
GroceryCrud.prototype.primaryKeyField = null;
GroceryCrud.prototype.jsonData = {};
GroceryCrud.prototype.rowsData = null;
GroceryCrud.prototype.uniqueId = null;
GroceryCrud.prototype.dateFormat = null;
GroceryCrud.prototype.datagridStore = null;
GroceryCrud.prototype.hashEvent = null;
GroceryCrud.prototype.stringVariables = {
    subject: 'Record',
    subjectPlural: ''
};

GroceryCrud.prototype.init = function init() {
    this.getInitData();
};

GroceryCrud.prototype.componentsInit = function componentsInit() {
    if (this.cachedInitialData.config.skin === 'bootstrap-v4') {
        this.components.GroupButtonsList = _groupButtonsList4.default;
        this.components.GroupPrimaryButton = _groupPrimaryButton4.default;
        this.components.LinkButtonWrapper = _linkButtonWrapper4.default;
        this.components.FieldRowWrapper = _fieldRowWrapper4.default;
        this.components.ModalTitleWrapper = _modalTitleWrapper4.default;
    } else {
        this.components.GroupButtonsList = _groupButtonsList2.default;
        this.components.GroupPrimaryButton = _groupPrimaryButton2.default;
        this.components.LinkButtonWrapper = _linkButtonWrapper2.default;
        this.components.FieldRowWrapper = _fieldRowWrapper2.default;
        this.components.ModalTitleWrapper = _modalTitleWrapper2.default;
    }
};

GroceryCrud.prototype.initFacade = function initFacade() {
    Router.setRoutes.apply(this);
    this.componentsInit();
    this.datagridInit();

    jQueryPlugins.init();

    OperationAdd.listenerAddButton.apply(this);
    OperationsCommon.listenerSubmitForm.apply(this);
    OperationDelete.listenerDeleteSingleModal.apply(this);
    OperationDelete.listenerDeleteMultiple.apply(this);
    OperationDelete.listenerDeleteMultipleModal.apply(this);
    OperationsCommon.initReduxStore.apply(this);

    DatagridSearch.listenerSearchButton.apply(this);
    Grid.listenerColumnWithOrdering.apply(this);
    Grid.listenerPagingButtons.apply(this);
    DatagridHeaderActions.listenerPrintButton.apply(this);
    this.listenerPerPage();

    this.listenerOnScreenResize();

    this.initializeFieldTypesData();

    Column.initCachedData.apply(this);

    // All these MUST be after the initializeFieldTypesData and initCachedData
    DatagridColumns.setVisibleColumns.apply(this);
    this.renderSettingsButton.apply(this);
    this.enableFilteringComponent.apply(this);

    this.initializingData();

    Router.init.apply(this);
};

GroceryCrud.prototype.listenerOnScreenResize = function listenerOnScreenResize() {
    var resizerTimeout = null; // eslint-disable-line no-unused-vars
    if (window) {
        window.addEventListener('resize', function onWindowResize() {
            if (resizerTimeout !== null) {
                clearTimeout(resizerTimeout);
            }

            resizerTimeout = setTimeout(function windowResizeTimeout() {
                resizerTimeout = null;

                if (this.rowsData !== null) {
                    this.renderDatagridBody(this.rowsData);
                }

                this.enableFilteringComponent();
            }.bind(this), 250);
        }.bind(this));
    }
};

GroceryCrud.prototype._filteringOnSubmitCallback = function _filteringOnSubmitCallback(event) {
    var dataToSend = ajaxHelper.getMultilayerPostDataFromForm.apply(this, [$(event.target)]),
        hiddenFieldsHtml = '',
        numberOfFilters = 0;
    var per_page = Grid.getPerPage.apply(this),
        order_by = Grid.getOrderBy.apply(this),
        sorting = Grid.getSorting.apply(this);

    _.each(dataToSend, function foreachDataToSend(fieldValue, fieldName) {
        var className = /^extended_search/.test(fieldName) ? 'gc-extended-search-input' : '';

        if (/^extended_search\[\d+\]\[name\]$/.test(fieldName)) {
            numberOfFilters++;
        }

        hiddenFieldsHtml += '<input type="hidden" name="' + fieldName + '" value="' + fieldValue + '" class="' + className + '" />';
    });

    $('.gc-hidden-search-inputs').html(hiddenFieldsHtml);

    if (this.cachedInitialData.csrfToken) {
        dataToSend[this.cachedInitialData.csrfToken.inputName] = this.cachedInitialData.csrfToken.inputValue;
    }

    dataToSend.action = 'datagrid';
    dataToSend.page = '1';
    dataToSend.per_page = per_page;
    dataToSend.order_by = order_by;
    dataToSend.sorting = sorting;

    this.$gc.find('.page-number-input').val('1');
    this.$gc.find('.page-number-hidden').val('1');

    event.preventDefault();
    this.$gc.find('.gc-filtering-modal').gc_modal('hide');

    this.sendPostRequest({
        url: this.$gc.data('url'),
        dataToSend: dataToSend,
        successCallback: function successCallback(jsonResponse) {
            if (jsonResponse.csrfToken) {
                this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
            }

            this.renderDatagrid(jsonResponse);
            this.createDatagrid(jsonResponse);
            Grid.updateGridDetails.apply(this, [jsonResponse]);
            DatagridColumns.triggerColumnsRender.apply(this);
            this.$gc.find('.gc-filter-button').addClass('btn-success').removeClass('btn-outline-dark');
            this.$gc.find('.gc-remove-filter-container').removeClass('hidden');
            this.$gc.find('.gc-filter-text').addClass('hidden');
            this.$gc.find('.gc-filter-counter').removeClass('hidden');
            this.$gc.find('.gc-filter-counter-number').html(numberOfFilters.toString());

            if (numberOfFilters === 1) {
                this.$gc.find('.gc-filter-counter-text').removeClass('hidden');
                this.$gc.find('.gc-filter-counter-text-plural').addClass('hidden');
            } else {
                this.$gc.find('.gc-filter-counter-text').addClass('hidden');
                this.$gc.find('.gc-filter-counter-text-plural').removeClass('hidden');
            }
        }.bind(this)
    });
};

GroceryCrud.prototype.enableFilteringComponent = function enableFilteringComponent() {
    var _this = this;

    var gcInstance = this,
        searchableSelect = {
        onMount: function onSearchableMount() {
            setTimeout(function timeOutforSearchableSelect() {
                $(ReactDOM.findDOMNode(this)).chosen({
                    allow_single_deselect: true
                });
            }.bind(this), 500);
        },
        onUpdate: function onSearchableUpdate() {
            $(ReactDOM.findDOMNode(this)).trigger('chosen:updated');
        }
    },
        inputDatetime = {
        onMount: function onDateMount() {
            $(ReactDOM.findDOMNode(this)).datetimepicker({
                dateFormat: gcInstance.dateFormat
            });
        }
    },
        inputDate = {
        onMount: function onDateMount() {
            $(ReactDOM.findDOMNode(this)).datepicker({
                dateFormat: gcInstance.dateFormat
            });
        }
    };
    if (!this.settings.datagridSearchAllInput) {
        ReactDOM.render(React.createElement(_filtering2.default, {
            ModalTitle: function ModalTitle(props) {
                return React.createElement(_title2.default, {
                    ModalTitleWrapper: _this.components.ModalTitleWrapper,
                    title: props.title
                });
            },
            i18n: {
                basic_operator: i18n.t('filtering_operator'),
                and_statement: i18n.t('filtering_and_statement'),
                or_statement: i18n.t('filtering_or_statement'),
                filtering: i18n.t('filtering_text'),
                filter: i18n.t('filtering_filter_text'),
                cancel_filtering: i18n.t('filtering_cancel'),
                add_more: i18n.t('filtering_add_more'),
                remove_filter: i18n.t('filtering_remove_filter'),
                comparison_contains: i18n.t('filtering_contains'),
                comparison_starts_with: i18n.t('filtering_starts_with'),
                comparison_ends_with: i18n.t('filtering_ends_with'),
                comparison_equals: i18n.t('filtering_equals'),
                comparison_not_equals: i18n.t('filtering_not_equals'),
                comparison_is_empty: i18n.t('filtering_is_empty'),
                comparison_is_not_empty: i18n.t('filtering_is_not_empty'),
                comparison_greater_than: i18n.t('filtering_greater_than'),
                comparison_less_than: i18n.t('filtering_less_than'),
                comparison_greater_than_or_equal: i18n.t('filtering_greater_than_or_equal'),
                comparison_less_than_or_equal: i18n.t('filtering_less_than_or_equal'),
                comparison_has: i18n.t('filtering_has'),
                comparison_does_not_have: i18n.t('filtering_does_not_have')
            },
            screenSize: this.getScreenWidth(),
            fields: this.getFieldsForFiltering.apply(this),
            onSubmitCallback: this._filteringOnSubmitCallback.bind(this),
            onInputMount: {
                date: inputDate,
                datetime: inputDatetime,
                timestamp: inputDatetime,
                enum_searchable: searchableSelect,
                dropdown_search: searchableSelect,
                relational: searchableSelect,
                relational_n_n: searchableSelect
            }
        }), this.$gc.find('.gc-filtering-container')[0]);
    }
};

GroceryCrud.prototype.renderSettingsButton = function renderVisibleColumnsCheckboxes() {
    var _this2 = this;

    var refreshCallback = function refreshCallback() {
        Grid.searchAndOrderingTrigger.apply(_this2);
    },
        subMenuLeftDirection = !this.cachedInitialData.operations.exportData || !this.cachedInitialData.operations.print,
        clearFilteringCallback = function clearFilteringCallback() {
        _this2.$gc.find('.gc-searchable-input').val('');
        _this2.$gc.find('.gc-searchable-select').val('');
        _this2.$gc.find('.gc-searchable-checkbox').prop('checked', false);
        _this2.$gc.find('.gc-search-input').val('').blur();
        _this2.$gc.find('.gc-hidden-search-inputs').html('');

        Grid.searchAndOrderingTrigger.apply(_this2);
    },
        clearCacheCallback = function clearCacheCallback() {
        localStorageHelper.removeLocalStorageItem('gcrudInitialData_' + _this2.uniqueId);
        localStorageHelper.removeLocalStorageItem('gcrudVisibleColumns_' + _this2.uniqueId);
        localStorageHelper.removeLocalStorageItem('gcrudPreferences');
    },
        visibleColumnsCallback = function visibleColumnsCallback(visibleColumns) {
        var filteredVisibleColumns = DatagridColumns.filterVisibleColumns.apply(_this2, [visibleColumns]);
        DatagridColumns.triggerColumnsRender.apply(_this2, [filteredVisibleColumns]);
        DatagridColumns.setCacheForVisibleColumns.apply(_this2, [visibleColumns]);
        _this2.createDatagrid();
    },
        _components = this.components,
        GroupPrimaryButton = _components.GroupPrimaryButton,
        GroupButtonsList = _components.GroupButtonsList;


    ReactDOM.render(React.createElement(_settings2.default, {
        subMenuLeftDirection: subMenuLeftDirection,
        onRefreshCallback: refreshCallback,
        onClearFilteringCallback: clearFilteringCallback,
        onClearCacheCallback: clearCacheCallback,
        columns: this.columns,
        visibleColumns: this.visibleColumns,
        gcrudInstance: this,
        visibleColumnsCallbackOnChange: visibleColumnsCallback,
        i18n: this.cachedInitialData.i18n,
        GroupPrimaryButton: GroupPrimaryButton,
        GroupButtonsList: GroupButtonsList
    }), this.$gc.find('.gc-settings-button-container')[0]);
};

GroceryCrud.prototype.renderDatagrid = function rerenderDatagrid(data) {
    if (data !== undefined) {
        this.jsonData = data;
    }
};

GroceryCrud.prototype.getInitData = function getInitData() {


    this.uniqueId = this.$gc.data('unique-id');
    this.url = this.$gc.data('url');

    this.sendGetRequest({
        url: this.$gc.data('url'),
        dataToSend: {
            action: Constants.ACTION_INIT_DATA
        },
        successCallback: function successCallback(jsonResponse) {

            this.setInitVariables(jsonResponse);
            this.cachedInitialData = jsonResponse;

            this.initFacade();
        }.bind(this)
    });
};

GroceryCrud.prototype.dynamicTranslation = function dynamicTranslation(i18nStrings) {
    var pagingSubString;

    i18nStrings.confirm_delete_multiple = i18n.format(i18nStrings.confirm_delete_multiple, {
        items_amount: '<span class="gc-delete-count"></span>'
    });

    i18nStrings.paging_displaying = i18n.format(i18nStrings.paging_displaying, {
        start: '<span class="paging-starts">1</span>',
        end: '<span class="paging-ends">10</span>',
        results: '<span class="current-total-results"></span>'
    });

    pagingSubString = i18nStrings.paging_show_entries.match(/(.*)+\{paging\}(.*)+/);
    i18nStrings.paging_show_entries = {
        first: pagingSubString !== null ? pagingSubString[1] : '',
        second: pagingSubString !== null ? pagingSubString[2] : ''
    };

    i18nStrings.paging_filtered_from = i18n.format(i18nStrings.paging_filtered_from, {
        total_results: '<span class="full-total"></span>'
    });
};

// GC-195: Automatically render the submenu to the left if there is not enough space.
GroceryCrud.prototype.subMenuOverflowCheck = function subMenuOverflowCheck() {
    var settingsButtonOffset = this.$gc.find('.gc-settings-button').offset();
    if (settingsButtonOffset && settingsButtonOffset.left + 160 + 180 > $(window).width()) {
        this.$gc.find('.gc-settings-button').next().find('.dropdown-submenu').addClass('left-direction');
    }
};

GroceryCrud.prototype.datagridInit = function datagridInit() {
    var i18nStrings = this.cachedInitialData.i18n,
        initData = this.cachedInitialData;

    this.dynamicTranslation(i18nStrings);

    this.stringVariables.isBootstrapV4 = this.cachedInitialData.config.skin === 'bootstrap-v4';
    this.stringVariables.addUrl = '#/' + this.hashEvent.addItem;
    this.stringVariables.operationAddEnabled = initData.operations.add;
    this.stringVariables.operationExportEnabled = initData.operations.exportData;
    this.stringVariables.operationPrintEnabled = initData.operations.print;

    this.$gc.find(Constants.SELECTOR_SEARCH_ROW).append(this.handlebarsTemplate('.gc-header-actions-operations', {
        isBootstrapV4: this.stringVariables.isBootstrapV4,
        deleteMultiple: initData.operations.deleteMultiple,
        hasActionButtons: this.datagridHasActions.apply(this),
        i18n: i18nStrings
    }));

    this.$gc.find('.footer-tools').append(this.handlebarsTemplate('.gc-footer-template', {
        i18n: i18nStrings,
        isBootstrapV4: this.stringVariables.isBootstrapV4
    }));

    this.$gc.find(Constants.SELECTOR_DATAGRID_CONTAINER).prepend(this.handlebarsTemplate(Constants.HANDLEBARS_TEMPLATE_CAPTION_TITLE, {
        subject: this.cachedInitialData.subject.subject_single,
        subjectPlural: this.cachedInitialData.subject.subject_plural
    }));

    this.$gc.find(Constants.SELECTOR_HEADER_TOOLS).prepend(this.handlebarsTemplate(Constants.HANDLEBARS_ADD_BUTTON, {
        operationAddEnabled: this.stringVariables.operationAddEnabled,
        addUrl: this.stringVariables.addUrl,
        addItemString: i18n.format(i18nStrings.add_item, {
            subject: this.cachedInitialData.subject.subject_single
        })
    }));

    this.$gc.find('.gc-export-button-container').html(this.handlebarsTemplate(Constants.HANDLEBARS_EXPORT_BUTTON, {
        operationExportEnabled: this.stringVariables.operationExportEnabled,
        i18n: i18nStrings
    }));

    this.$gc.find('.gc-print-button-container').html(this.handlebarsTemplate(Constants.HANDLEBARS_PRINT_BUTTON, {
        operationPrintEnabled: this.stringVariables.operationPrintEnabled,
        i18n: i18nStrings
    }));

    this.$gc.find('.gc-search-filter-button-container').html(this.handlebarsTemplate('.search-button-template', {
        i18n: i18nStrings,
        searchAllButton: this.settings.datagridSearchAllInput
    }));

    this.subMenuOverflowCheck.apply(this);

    this.$gc.prepend(this.handlebarsTemplate(Constants.HANDLEBARS_INSERT_MODAL, {
        i18n: i18nStrings
    }));

    this.$gc.prepend(this.handlebarsTemplate(Constants.HANDLEBARS_DELETE_SINGLE_MODAL, {
        i18n: i18nStrings
    }));

    this.$gc.prepend(this.handlebarsTemplate(Constants.HANDLEBARS_DELETE_MUTLIPLE_MODAL, {
        i18n: i18nStrings
    }));

    this.$gc.find('.paging-entries-container').prepend(this.handlebarsTemplate('.paging-entries-template', {
        i18n: i18nStrings
    }));

    // After the paging is rendered we will also need to add the pagingComponent
    ReactDOM.render(React.createElement(_perPageDropdown2.default, { defaultPerPage: initData.paging.defaultPerPage, pagingOptions: initData.paging.pagingOptions }), this.$gc.find('.per-page-container')[0]);

    this.$gc.find('.displaying-paging-container').prepend(this.handlebarsTemplate('.displaying-paging-template', {
        i18n: i18nStrings
    }));

    ReactDOM.render(React.createElement(_title2.default, {
        ModalTitleWrapper: this.components.ModalTitleWrapper,
        title: i18nStrings.error_generic_title
    }), this.$gc.find('.gc-error-modal').find('.modal-header')[0]);

    ReactDOM.render(React.createElement(_title2.default, {
        ModalTitleWrapper: this.components.ModalTitleWrapper,
        title: i18nStrings.action_delete
    }), this.$gc.find('.delete-single-confirmation').find('.modal-header')[0]);

    ReactDOM.render(React.createElement(_title2.default, {
        ModalTitleWrapper: this.components.ModalTitleWrapper,
        title: i18nStrings.action_delete
    }), this.$gc.find('.gc-delete-multiple-confirmation').find('.modal-header')[0]);

    i18n.init(i18nStrings);
};

GroceryCrud.prototype.getFieldsForFiltering = function getFieldsForFiltering() {
    var fields = [],
        indexedColumns = {};
    var _cachedInitialData = this.cachedInitialData,
        fieldTypesColumns = _cachedInitialData.fieldTypesColumns,
        columns = _cachedInitialData.columns;


    columns.forEach(function (column) {
        indexedColumns[column.name] = column.displayAs;
    });

    Object.keys(fieldTypesColumns).forEach(function forEachFieldTypesColumns(fieldName) {
        if (indexedColumns[fieldName]) {
            fields.push({
                fieldName: fieldName,
                type: fieldTypesColumns[fieldName].dataType,
                displayAs: indexedColumns[fieldName],
                permittedValues: fieldTypesColumns[fieldName].permittedValues
            });
        }
    });

    return fields;
};

/**
 *
 * @param {String} selector
 * @returns {jQuery}
 */
GroceryCrud.prototype.find = function find(selector) {
    return this.$gc.find(selector);
};

GroceryCrud.prototype.setInitVariables = function setInitVariables(data) {
    this.columns = [];

    _.each(data.columns, function foreachColumns(column) {
        this.columns.push({
            columnName: column.name,
            displayAs: column.displayAs
        });

        this.indexedColumns[column.name] = column.displayAs;
    }.bind(this));
};

GroceryCrud.prototype.sendGetRequest = function sendGetRequest(options) {
    options.url = !_.isUndefined(options.url) ? options.url : this.$gc.data('url');

    return ajaxHelper.sendGetRequest.apply(this, [options]);
};

GroceryCrud.prototype.sendPostRequest = function sendPostRequest(options) {
    options.url = !_.isUndefined(options.url) ? options.url : this.$gc.data('url');

    return ajaxHelper.sendPostRequest.apply(this, [options]);
};

GroceryCrud.prototype.handlebarsTemplate = function handlebarsTemplate(stringSelector, templateObject) {

    var handlebarsTemplateCompiled = Handlebars.compile(this.$gc.find(stringSelector).html());

    return handlebarsTemplateCompiled(templateObject);
};

GroceryCrud.prototype.datagridHasActions = function datagridHasActions() {
    return this.cachedInitialData.operations.deleteSingle || this.cachedInitialData.operations.edit || this.cachedInitialData.operations.read || this.cachedInitialData.operations.actionButtons || this.settings.actionButtons.length > 0;
};

GroceryCrud.prototype.initializeFieldTypesData = function initializeFieldTypesData() {
    var fieldTypesAddForm = {},
        fieldTypesEditForm = {},
        fieldTypesCloneForm = {},
        fieldTypesReadForm = {},
        fieldTypesColumns = {};

    _.each(this.cachedInitialData.fieldTypes, function fieldTypesForEarch(fieldTypeObject, fieldName) {
        fieldTypesAddForm[fieldName] = fieldTypeObject;
        fieldTypesEditForm[fieldName] = fieldTypeObject;
        fieldTypesCloneForm[fieldName] = fieldTypeObject;
        fieldTypesReadForm[fieldName] = fieldTypeObject;
        fieldTypesColumns[fieldName] = fieldTypeObject;
    });

    // overriding the field types
    _.each(this.cachedInitialData.fieldTypesAddForm, function fieldTypesAddFormForEach(fieldTypeObject, fieldName) {
        fieldTypesAddForm[fieldName] = fieldTypeObject;
    });

    _.each(this.cachedInitialData.fieldTypesEditForm, function fieldTypesEditFormForEach(fieldTypeObject, fieldName) {
        fieldTypesEditForm[fieldName] = fieldTypeObject;
    });

    _.each(this.cachedInitialData.fieldTypesCloneForm, function fieldTypesCloneFormForEach(fieldTypeObject, fieldName) {
        fieldTypesCloneForm[fieldName] = fieldTypeObject;
    });

    _.each(this.cachedInitialData.fieldTypesReadForm, function fieldTypesReadFormForEach(fieldTypeObject, fieldName) {
        fieldTypesReadForm[fieldName] = fieldTypeObject;
    });

    _.each(this.cachedInitialData.fieldTypesColumns, function fieldTypesColumnsForEach(fieldTypeObject, fieldName) {
        fieldTypesColumns[fieldName] = fieldTypeObject;
    });

    this.cachedInitialData.fieldTypesAddForm = fieldTypesAddForm;
    this.cachedInitialData.fieldTypesEditForm = fieldTypesEditForm;
    this.cachedInitialData.fieldTypesCloneForm = fieldTypesCloneForm;
    this.cachedInitialData.fieldTypesReadForm = fieldTypesReadForm;
    this.cachedInitialData.fieldTypesColumns = fieldTypesColumns;

    switch (this.cachedInitialData.config.dateFormat) {
        case 'uk-date':
            this.dateFormat = 'dd/mm/yy';
            break;

        case 'us-date':
            this.dateFormat = 'mm/dd/yy';
            break;

        case 'sql-date':
            this.dateFormat = 'yy-mm-dd';
            break;
    }
};

/**
 * Having the first call into the backend in order to fill our datagrid with some data
 */
GroceryCrud.prototype.initializingData = function initializingData() {
    var dataToSend = {},
        cachedData,
        cachedPreferences,
        column_title,
        $columnToOrder,
        readOnlyAddFields = {},
        readOnlyEditFields = {},
        readOnlyCloneFields = {};

    Grid.setExportUrl.apply(this);
    dataToSend.action = Constants.ACTION_DATAGRID;

    if (this.cachedInitialData.csrfToken) {
        dataToSend[this.cachedInitialData.csrfToken.inputName] = this.cachedInitialData.csrfToken.inputValue;
    }

    this.hasActions = this.datagridHasActions.apply(this);

    _.each(this.cachedInitialData.readOnlyAddFields, function readOnlyAddFieldsForEarch(field) {
        readOnlyAddFields[field] = true;
    });
    this.cachedInitialData.readOnlyAddFields = readOnlyAddFields;

    _.each(this.cachedInitialData.readOnlyCloneFields, function readOnlyCloneFieldsForEarch(field) {
        readOnlyCloneFields[field] = true;
    });
    this.cachedInitialData.readOnlyCloneFields = readOnlyCloneFields;

    _.each(this.cachedInitialData.readOnlyEditFields, function readOnlyEditFieldsForEarch(field) {
        readOnlyEditFields[field] = true;
    });
    this.cachedInitialData.readOnlyEditFields = readOnlyEditFields;

    cachedData = localStorageHelper.getLocalStorageItem('gcrudInitialData_' + this.uniqueId);
    cachedPreferences = localStorageHelper.getLocalStorageItem('gcrudPreferences');

    if (cachedData) {
        cachedData = JSON.parse(cachedData);
        dataToSend.order_by = cachedData.order_by;
        dataToSend.sorting = cachedData.sorting;

        if (cachedPreferences) {
            cachedPreferences = JSON.parse(cachedPreferences);
            dataToSend.per_page = cachedPreferences.per_page;
            this.$gc.find('.per_page').val(dataToSend.per_page);
        }

        $columnToOrder = this.$gc.find('.column-with-ordering[data-order-by="' + dataToSend.order_by + '"]');
        column_title = $columnToOrder.addClass('active table-active ordering-' + dataToSend.sorting).text();

        if (dataToSend.order_by && dataToSend.sorting) {
            this.$gc.find('.gc-order-by-hidden').val(dataToSend.order_by);
            this.$gc.find('.gc-sorting-hidden').val(dataToSend.sorting);
        }

        column_title = $.trim(column_title);

        $columnToOrder.html('<div>' + column_title + '</div>');
    }

    this.sendPostRequest({
        url: this.$gc.data('url'),
        dataToSend: dataToSend,
        successCallback: function successCallback(jsonResponse) {
            var columnIndex, pagingEnds;

            if (jsonResponse.csrfToken) {
                this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
            }

            this.$gc.find('.current-total-results').html(jsonResponse.filtered_total);
            this.$gc.find('.full-total').html(jsonResponse.filtered_total);
            this.createDatagrid(jsonResponse);

            if (dataToSend.sorting !== undefined) {
                columnIndex = $columnToOrder.index() + 1;
                $columnToOrder.closest('.grocery-crud-table').find('thead tr td:nth-child(' + columnIndex + ')').addClass('active table-active');
            }

            if (jsonResponse.csrfToken) {
                this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
            }

            pagingEnds = dataToSend.per_page > jsonResponse.filtered_total ? jsonResponse.filtered_total : dataToSend.per_page;

            this.$gc.find('.paging-ends').html(pagingEnds);
            DatagridPaging.pagingCalculations.apply(this);
        }.bind(this),
        errorCallback: function datagridErrorCallback() {
            localStorageHelper.removeLocalStorageItem('gcrudInitialData_' + this.uniqueId);
        }.bind(this)
    });
};

GroceryCrud.prototype.transformRowsData = function transformRowsData(result) {
    var rows = [];

    _.each(result.data, function eachData(dataObject) {
        rows.push(Column.getRowsData.apply(this, [dataObject]));
    }.bind(this));

    return rows;
};

/**
 * Get the tbody from the response with HandleBars template
 * */
GroceryCrud.prototype.getTableBodyFromResponse = function getTableBodyFromResponse(result) {
    var row_html = this.$gc.find(Constants.HANDLEBARS_TEMPLATE_ROW).html(),
        row_template = Handlebars.compile(row_html),
        rows = this.transformRowsData(result);

    return row_template({ rows: rows });
};

GroceryCrud.prototype.onEditClick = function onEditClick(primaryKeyValue) {
    OperationEdit.onEditClick.apply(this, [primaryKeyValue]);
};

GroceryCrud.prototype.onCloneClick = function onCloneClick(primaryKeyValue) {
    OperationClone.onCloneClick.apply(this, [primaryKeyValue]);
};

GroceryCrud.prototype.onReadClick = function onReadClick(primaryKeyValue) {
    OperationRead.onReadClick.apply(this, [primaryKeyValue]);
};

GroceryCrud.prototype.onDeleteClick = function onDeleteClick(primaryKeyValue) {
    OperationDelete.onDeleteClick.apply(this, [primaryKeyValue]);
};

GroceryCrud.prototype.createDatagrid = function createDatagrid(data) {
    if (data !== undefined) {
        this.jsonData = data;
    }

    this.rowsData = this.transformRowsData(this.jsonData);

    this.renderDatagridBody.apply(this, [this.rowsData]);

    /*this.listenerActionKeys();
    OperationDelete.listenerSelectRow.apply(this);
    Grid.activateOrderingRows.apply(this);*/
};

GroceryCrud.prototype.getScreenWidth = function getScreenWidth() {
    if (window && window.matchMedia) {

        if (window.matchMedia('(max-width: 576px)').matches) {
            return 'xs';
        }

        if (window.matchMedia('(max-width: 768px)').matches) {
            return 's';
        }
    }

    return 'l';
};

GroceryCrud.prototype.renderDatagridBody = function renderDatagridBody(rows) {
    var _cachedInitialData$op = this.cachedInitialData.operations,
        edit = _cachedInitialData$op.edit,
        read = _cachedInitialData$op.read,
        deleteSingle = _cachedInitialData$op.deleteSingle,
        deleteMultiple = _cachedInitialData$op.deleteMultiple,
        clone = _cachedInitialData$op.clone,
        _components2 = this.components,
        GroupPrimaryButton = _components2.GroupPrimaryButton,
        GroupButtonsList = _components2.GroupButtonsList,
        LinkButtonWrapper = _components2.LinkButtonWrapper;


    ReactDOM.render(React.createElement(_datagridTbody2.default, {
        rows: rows,
        options: {
            deleteMultiple: deleteMultiple,
            hasEdit: edit,
            hasClone: clone,
            hasDelete: deleteSingle,
            hasRead: read,
            hasActionButtons: this.hasActions
        },
        urlUniqueHash: this.hashEvent.urlUniqueHash,
        orderBy: Grid.getOrderBy.apply(this),
        columns: this.columns,
        onEditClick: this.onEditClick.bind(this),
        onCloneClick: this.onCloneClick.bind(this),
        onRowCheckboxClick: this.hideShowDeleteButton.bind(this),
        onReadClick: this.onReadClick.bind(this),
        onDeleteClick: this.onDeleteClick.bind(this),
        actionButtons: this.settings.actionButtons,
        screenSize: this.getScreenWidth(),
        i18n: this.cachedInitialData.i18n,
        LinkButtonWrapper: LinkButtonWrapper,
        GroupPrimaryButton: GroupPrimaryButton,
        GroupButtonsList: GroupButtonsList
    }), this.$gc.find('.gc-tbody')[0]);
};

GroceryCrud.prototype.listenerActionKeys = function listenerActionKeys() {
    this.$gc.find('.gc-action').click(function clickActionButton(event) {
        var $currentButton = $(event.currentTarget),
            primaryKeyValue = $currentButton.data('primary-key-value'),
            actionButtonKey = $currentButton.data('action-key');

        /* actionButtons Data is looking like this
             {
             iconCssClass: 'fa fa-smile-o',
             label: 'Smiley',
             onClick: function smileyCallback() {}
             }
         */
        this.settings.actionButtons[actionButtonKey].actionCallback.apply(this, [$currentButton, primaryKeyValue, this]);
    }.bind(this));
};

GroceryCrud.prototype.clearFilteringCache = function clearFilteringCache() {
    var $searchAllInput = this.$gc.find('.search-button > input.gc-search-input');

    this.$gc.find(Constants.SELECTOR_HIDDEN_PAGE_NUMBER).val('1');
    this.$gc.find(Constants.SELECTOR_PAGE_NUMBER_INPUT).val('1');
    this.$gc.find('.grocery-crud-table tr:first').find(Constants.SELECTOR_ACTIVE).removeClass('active table-active ordering-desc ordering-asc');
    this.$gc.find('thead').find('td.active').removeClass('active table-active');
    this.$gc.find('thead .value-not-empty').removeClass('value-not-empty').val('');

    if ($searchAllInput.val() !== '') {
        $searchAllInput.val('').trigger('blur');
    }

    Grid.searchAndOrderingTrigger.apply(this);
};

GroceryCrud.prototype.appendSearchClearButtons = function appendSearchClearButtons() {
    var datagrid_object = this;

    this.$gc.find('.clear-search').remove();

    this.$gc.find(Constants.SELECTOR_SEARCH_FIELD_INPUT).each(function forEachSearchableInput() {
        $(this).removeClass('value-not-empty');
        if ($(this).val() === '') {
            return true;
        }
        $(this).addClass('value-not-empty');
        $(this).after('<i class="fa fa-times clear-search"></i>');

        datagrid_object.$gc.find('.clear-search').click(function clearSearch() {
            $(this).closest('td').find('.gc-searchable-input').val('').trigger('keyup');
        });
    });
};

GroceryCrud.prototype.listenerPerPage = function listenerPerPage() {
    this.$gc.find('.' + Constants.CLASS_PER_PAGE).change(function perPageOnChange() {
        this.$gc.find('.page-number-hidden').val('1');
        Grid.searchAndOrderingTrigger.apply(this);
    }.bind(this));
};

GroceryCrud.prototype.clearFilteringListener = function clearFilteringListener($settingsContainer) {
    $settingsContainer.find('.clear-filtering').click(function clearFilteringClickButton() {
        this.clearFilteringCache();
    }.bind(this));
};

GroceryCrud.prototype.hideShowDeleteButton = function hideShowDeleteButton() {

    if (this.$gc.find('.gc-select-row:checked').length > 0) {
        this.$gc.find('.delete-selected-button').removeClass('hidden');
    } else {
        this.$gc.find('.delete-selected-button').addClass('hidden');
    }
};

exports.GroceryCrud = GroceryCrud;

},{"../../../../React-Components/gce-crud-forms/modal/title.jsx":33,"../../../../React-Components/gce-datagrid-settings/gce-datagrid-settings/settings.jsx":34,"../../../../React-Components/gce-react-datagrid-filtering/filtering":50,"../../../../React-Components/gce-react-datagrid/datagrid-tbody.jsx":65,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/field-row-wrapper":66,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/group-buttons-list.jsx":67,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/group-primary-button.jsx":69,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/link-button-wrapper.jsx":70,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/modal-title-wrapper":71,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/field-row-wrapper":72,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/group-buttons-list.jsx":73,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/group-primary-button.jsx":74,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/link-button-wrapper.jsx":75,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/modal-title-wrapper":76,"../helpers/ajax-helper":79,"../helpers/local-storage-helper":80,"../jquery-plugins/chosen.jquery":81,"../jquery-plugins/modal":82,"../jquery-plugins/printThis":83,"../jquery-plugins/transition":84,"../libraries/HandlebarsExtended":85,"../libraries/jquery-ui-timepicker":86,"../modules/jquery/jquery-plugins":88,"../modules/react/jsx/datagrid/footer/per-page-dropdown.jsx":89,"../sections/constants":90,"../sections/datagrid/column":91,"../sections/datagrid/datagrid.columns":92,"../sections/datagrid/datagrid.paging":95,"../sections/i18n":97,"../sections/routes/router":105,"./../sections/datagrid/datagrid.grid.js":93,"./../sections/datagrid/datagrid.header-actions.js":94,"./../sections/datagrid/datagrid.search.js":96,"./../sections/operations/add.js":98,"./../sections/operations/clone.js":99,"./../sections/operations/common.js":100,"./../sections/operations/delete.js":101,"./../sections/operations/edit.js":102,"./../sections/operations/read.js":103,"underscore":198}],78:[function(require,module,exports){
'use strict';

var GroceryCrud = require('./grocery-crud').GroceryCrud,
    $ = jQuery;

$.fn.groceryCrud = function jQueryFnDatagrid(options) {
    var settings = $.extend({
        actionButtons: [],
        hashEvents: true,
        datagridSearchAllInput: false
    }, options);

    this.each(function forEachDatagrid() {
        new GroceryCrud($(this), settings).init();
    });

    return this;
};

},{"./grocery-crud":77}],79:[function(require,module,exports){
'use strict';

var $ = jQuery,
    _ = require('underscore'),
    Constants = require('../sections/constants').Constants,
    ajaxHelper = Object.create({
    setLoading: function setLoading() {
        this.$gc.find('.loading-opacity').css('width', this.$gc.width() + 15 + 'px').css('height', this.$gc.height() + 'px').removeClass('hidden');
    },
    unsetLoading: function unsetLoading() {
        this.$gc.find('.loading-opacity').addClass('hidden').css('width', '0px').css('height', '0px');
    },
    sendGetRequest: function sendGetRequest(options) {
        return ajaxHelper.sendAjaxRequest.apply(this, [options, 'get']);
    },
    sendPostRequest: function sendPostRequest(options) {
        return ajaxHelper.sendAjaxRequest.apply(this, [options, 'post']);
    },
    ajaxOnFail: function ajaxOnFail(errorAsString, textStatus, errorThrown) {
        ajaxHelper.unsetLoading.apply(this);
        this.$gc.find('.gc-error-modal').find('.gc-error-body').html(this.handlebarsTemplate('.gc-modal-error-text-template', {
            textStatus: textStatus,
            errorThrown: errorThrown,
            errorAsString: errorAsString
        }));

        if (/\<(html|script|body|style|link)\>/i.test(errorAsString)) {
            this.$gc.find('.gc-error-html-preview-button').addClass('hidden');
        } else {
            this.$gc.find('.gc-error-html-preview-button').removeClass('hidden');

            this.$gc.find('.gc-error-html-preview-button').click(function errorHTMLPreviewClick() {
                this.$gc.find('.gc-code-error-response').addClass('hidden');
                this.$gc.find('.gc-error-message-html').removeClass('hidden');
                this.$gc.find('.gc-error-message-html').html(errorAsString);
                this.$gc.find('.gc-error-html-preview-button').addClass('hidden');
            }.bind(this));
        }

        this.$gc.find('.gc-error-modal').gc_modal({
            backdrop: false
        });
    },
    sendAjaxRequest: function sendAjaxRequest(options, requestMethod) {
        return $.ajax({
            beforeSend: ajaxHelper.setLoading.bind(this),
            data: options.dataToSend,
            method: requestMethod,
            dataType: 'json',
            url: options.url
        }).done(function ajaxCallDone(data) {
            ajaxHelper.unsetLoading.apply(this);

            if (data.status === Constants.RESPONSE.FAILURE) {
                ajaxHelper.showErrorModal.apply(this, [data.message]);
            } else {
                options.successCallback(data);
            }
        }.bind(this)).fail(function ajaxOnFail(jqXHR, textStatus, errorThrown) {
            var errorAsString = jqXHR.responseText;

            ajaxHelper.ajaxOnFail.apply(this, [errorAsString, textStatus, errorThrown]);

            if (options.errorCallback !== undefined) {
                options.errorCallback(errorAsString);
            }
        }.bind(this));
    },
    showErrorModal: function showErrorModal(errorMessage) {
        this.$gc.find('.gc-error-modal').find('.gc-error-body').html(errorMessage);

        this.$gc.find('.gc-error-modal').gc_modal({
            backdrop: false
        });
    },
    getUrl: function getUrl(action, data_to_send) {
        var url = this.url;

        if (action) {
            url += /\?/.test(url) ? '&' : '?';
            url += 'action=' + action;
        }

        if (data_to_send === undefined) {
            return url;
        }

        _.each(data_to_send, function forEachDataToSend(_field_value, _field_name) {
            if (_field_value instanceof Array) {
                _.each(_field_value, function forEachFields(_array_value) {
                    url += '&' + _field_name + '[]=' + _array_value;
                });
            } else if (_field_value instanceof Object) {
                _.each(_field_value, function forEachFields(objectFieldValue, objectFieldName) {
                    url += '&' + _field_name + '[' + objectFieldName + ']=' + objectFieldValue;
                });
            } else {
                url += '&' + _field_name + '=' + (_.isUndefined(_field_value) ? '' : _field_value);
            }
        });

        return url;
    },
    getPostDataFromForm: function getPostDataFromForm($jqueryForm) {
        var postData = {};
        _.each($jqueryForm.serializeArray(), function eachFormFields(field) {
            var dataType = this.cachedInitialData.fieldTypes[field.name].dataType;
            if (dataType === 'relational_n_n' || dataType === 'native_relational_n_n') {
                if (postData[field.name] === undefined) {
                    postData[field.name] = [field.value];
                } else {
                    postData[field.name].push(field.value);
                }
            } else {
                postData[field.name] = field.value;
            }
        }.bind(this));

        return postData;
    },
    getMultilayerPostDataFromForm: function getMultilayerPostDataFromForm($jqueryForm) {
        var postData = {};
        var formData = $jqueryForm.serializeArray();

        formData.forEach(function foreachFormData(item) {
            postData[item.name] = item.value;
        });

        return postData;
    }
});

exports.ajaxHelper = ajaxHelper;

},{"../sections/constants":90,"underscore":198}],80:[function(require,module,exports){
'use strict';

var localStorageHelper = Object.create({

    // By default this is empty as some browsers doesn't support localStorage cache
    setLocalStorageItem: function setLocalStorageItem(__item, __value) {},

    // By default this is empty as some browsers doesn't support localStorage cache
    removeLocalStorageItem: function removeLocalStorageItem(__item) {},

    // By default this is empty as some browsers doesn't support localStorage cache
    getLocalStorageItem: function getLocalStorageItem(__item) {
        return null;
    },

    // The below function is copied from the modernizr local storage support
    browserSupportsLocalStorage: function browserSupportsLocalStorage() {
        var mod = 'modernizr';
        try {
            localStorage.setItem(mod, mod);
            localStorage.removeItem(mod);
            return true;
        } catch (e) {
            return false;
        }
    },

    // Changing the default empty values of the functions to support local storage. The below function
    // is called only once for optimizing reasons
    setLocalStorageCache: function setLocalStorageCache() {
        if (this.browserSupportsLocalStorage()) {
            //if browser is supporting local storage overrides the empty functions
            this.setLocalStorageItem = function setLocalStorageItem(item, value) {
                localStorage.setItem(item, value);
            };
            this.removeLocalStorageItem = function removeLocalStorageItem(item) {
                localStorage.removeItem(item);
            };
            this.getLocalStorageItem = function getLocalStorageItem(item) {
                return localStorage.getItem(item);
            };
        }
    }
});

localStorageHelper.setLocalStorageCache();

exports.localStorageHelper = localStorageHelper;

},{}],81:[function(require,module,exports){
"use strict";

/*!
Chosen, a Select Box Enhancer for jQuery and Prototype
by Patrick Filler for Harvest, http://getharvest.com

Version 1.6.2
Full source at https://github.com/harvesthq/chosen
Copyright (c) 2011-2016 Harvest http://getharvest.com

MIT License, https://github.com/harvesthq/chosen/blob/master/LICENSE.md
This file is generated by `grunt build`, do not edit it by hand.
*/

(function () {
  var $,
      AbstractChosen,
      Chosen,
      SelectParser,
      _ref,
      __hasProp = {}.hasOwnProperty,
      __extends = function __extends(child, parent) {
    for (var key in parent) {
      if (__hasProp.call(parent, key)) child[key] = parent[key];
    }function ctor() {
      this.constructor = child;
    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
  };

  SelectParser = function () {
    function SelectParser() {
      this.options_index = 0;
      this.parsed = [];
    }

    SelectParser.prototype.add_node = function (child) {
      if (child.nodeName.toUpperCase() === "OPTGROUP") {
        return this.add_group(child);
      } else {
        return this.add_option(child);
      }
    };

    SelectParser.prototype.add_group = function (group) {
      var group_position, option, _i, _len, _ref, _results;
      group_position = this.parsed.length;
      this.parsed.push({
        array_index: group_position,
        group: true,
        label: this.escapeExpression(group.label),
        title: group.title ? group.title : void 0,
        children: 0,
        disabled: group.disabled,
        classes: group.className
      });
      _ref = group.childNodes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        _results.push(this.add_option(option, group_position, group.disabled));
      }
      return _results;
    };

    SelectParser.prototype.add_option = function (option, group_position, group_disabled) {
      if (option.nodeName.toUpperCase() === "OPTION") {
        if (option.text !== "") {
          if (group_position != null) {
            this.parsed[group_position].children += 1;
          }
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            value: option.value,
            text: option.text,
            html: option.innerHTML,
            title: option.title ? option.title : void 0,
            selected: option.selected,
            disabled: group_disabled === true ? group_disabled : option.disabled,
            group_array_index: group_position,
            group_label: group_position != null ? this.parsed[group_position].label : null,
            classes: option.className,
            style: option.style.cssText
          });
        } else {
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            empty: true
          });
        }
        return this.options_index += 1;
      }
    };

    SelectParser.prototype.escapeExpression = function (text) {
      var map, unsafe_chars;
      if (text == null || text === false) {
        return "";
      }
      if (!/[\&\<\>\"\'\`]/.test(text)) {
        return text;
      }
      map = {
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
      };
      unsafe_chars = /&(?!\w+;)|[\<\>\"\'\`]/g;
      return text.replace(unsafe_chars, function (chr) {
        return map[chr] || "&amp;";
      });
    };

    return SelectParser;
  }();

  SelectParser.select_to_array = function (select) {
    var child, parser, _i, _len, _ref;
    parser = new SelectParser();
    _ref = select.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      parser.add_node(child);
    }
    return parser.parsed;
  };

  AbstractChosen = function () {
    function AbstractChosen(form_field, options) {
      this.form_field = form_field;
      this.options = options != null ? options : {};
      if (!AbstractChosen.browser_is_supported()) {
        return;
      }
      this.is_multiple = this.form_field.multiple;
      this.set_default_text();
      this.set_default_values();
      this.setup();
      this.set_up_html();
      this.register_observers();
      this.on_ready();
    }

    AbstractChosen.prototype.set_default_values = function () {
      var _this = this;
      this.click_test_action = function (evt) {
        return _this.test_active_click(evt);
      };
      this.activate_action = function (evt) {
        return _this.activate_field(evt);
      };
      this.active_field = false;
      this.mouse_on_container = false;
      this.results_showing = false;
      this.result_highlighted = null;
      this.allow_single_deselect = this.options.allow_single_deselect != null && this.form_field.options[0] != null && this.form_field.options[0].text === "" ? this.options.allow_single_deselect : false;
      this.disable_search_threshold = this.options.disable_search_threshold || 0;
      this.disable_search = this.options.disable_search || false;
      this.enable_split_word_search = this.options.enable_split_word_search != null ? this.options.enable_split_word_search : true;
      this.group_search = this.options.group_search != null ? this.options.group_search : true;
      this.search_contains = this.options.search_contains || false;
      this.single_backstroke_delete = this.options.single_backstroke_delete != null ? this.options.single_backstroke_delete : true;
      this.max_selected_options = this.options.max_selected_options || Infinity;
      this.inherit_select_classes = this.options.inherit_select_classes || false;
      this.display_selected_options = this.options.display_selected_options != null ? this.options.display_selected_options : true;
      this.display_disabled_options = this.options.display_disabled_options != null ? this.options.display_disabled_options : true;
      this.include_group_label_in_selected = this.options.include_group_label_in_selected || false;
      this.max_shown_results = this.options.max_shown_results || Number.POSITIVE_INFINITY;
      return this.case_sensitive_search = this.options.case_sensitive_search || false;
    };

    AbstractChosen.prototype.set_default_text = function () {
      if (this.form_field.getAttribute("data-placeholder")) {
        this.default_text = this.form_field.getAttribute("data-placeholder");
      } else if (this.is_multiple) {
        this.default_text = this.options.placeholder_text_multiple || this.options.placeholder_text || AbstractChosen.default_multiple_text;
      } else {
        this.default_text = this.options.placeholder_text_single || this.options.placeholder_text || AbstractChosen.default_single_text;
      }
      return this.results_none_found = this.form_field.getAttribute("data-no_results_text") || this.options.no_results_text || AbstractChosen.default_no_result_text;
    };

    AbstractChosen.prototype.choice_label = function (item) {
      if (this.include_group_label_in_selected && item.group_label != null) {
        return "<b class='group-name'>" + item.group_label + "</b>" + item.html;
      } else {
        return item.html;
      }
    };

    AbstractChosen.prototype.mouse_enter = function () {
      return this.mouse_on_container = true;
    };

    AbstractChosen.prototype.mouse_leave = function () {
      return this.mouse_on_container = false;
    };

    AbstractChosen.prototype.input_focus = function (evt) {
      var _this = this;
      if (this.is_multiple) {
        if (!this.active_field) {
          return setTimeout(function () {
            return _this.container_mousedown();
          }, 50);
        }
      } else {
        if (!this.active_field) {
          return this.activate_field();
        }
      }
    };

    AbstractChosen.prototype.input_blur = function (evt) {
      var _this = this;
      if (!this.mouse_on_container) {
        this.active_field = false;
        return setTimeout(function () {
          return _this.blur_test();
        }, 100);
      }
    };

    AbstractChosen.prototype.results_option_build = function (options) {
      var content, data, data_content, shown_results, _i, _len, _ref;
      content = '';
      shown_results = 0;
      _ref = this.results_data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        data = _ref[_i];
        data_content = '';
        if (data.group) {
          data_content = this.result_add_group(data);
        } else {
          data_content = this.result_add_option(data);
        }
        if (data_content !== '') {
          shown_results++;
          content += data_content;
        }
        if (options != null ? options.first : void 0) {
          if (data.selected && this.is_multiple) {
            this.choice_build(data);
          } else if (data.selected && !this.is_multiple) {
            this.single_set_selected_text(this.choice_label(data));
          }
        }
        if (shown_results >= this.max_shown_results) {
          break;
        }
      }
      return content;
    };

    AbstractChosen.prototype.result_add_option = function (option) {
      var classes, option_el;
      if (!option.search_match) {
        return '';
      }
      if (!this.include_option_in_results(option)) {
        return '';
      }
      classes = [];
      if (!option.disabled && !(option.selected && this.is_multiple)) {
        classes.push("active-result");
      }
      if (option.disabled && !(option.selected && this.is_multiple)) {
        classes.push("disabled-result");
      }
      if (option.selected) {
        classes.push("result-selected");
      }
      if (option.group_array_index != null) {
        classes.push("group-option");
      }
      if (option.classes !== "") {
        classes.push(option.classes);
      }
      option_el = document.createElement("li");
      option_el.className = classes.join(" ");
      option_el.style.cssText = option.style;
      option_el.setAttribute("data-option-array-index", option.array_index);
      option_el.innerHTML = option.search_text;
      if (option.title) {
        option_el.title = option.title;
      }
      return this.outerHTML(option_el);
    };

    AbstractChosen.prototype.result_add_group = function (group) {
      var classes, group_el;
      if (!(group.search_match || group.group_match)) {
        return '';
      }
      if (!(group.active_options > 0)) {
        return '';
      }
      classes = [];
      classes.push("group-result");
      if (group.classes) {
        classes.push(group.classes);
      }
      group_el = document.createElement("li");
      group_el.className = classes.join(" ");
      group_el.innerHTML = group.search_text;
      if (group.title) {
        group_el.title = group.title;
      }
      return this.outerHTML(group_el);
    };

    AbstractChosen.prototype.results_update_field = function () {
      this.set_default_text();
      if (!this.is_multiple) {
        this.results_reset_cleanup();
      }
      this.result_clear_highlight();
      this.results_build();
      if (this.results_showing) {
        return this.winnow_results();
      }
    };

    AbstractChosen.prototype.reset_single_select_options = function () {
      var result, _i, _len, _ref, _results;
      _ref = this.results_data;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        result = _ref[_i];
        if (result.selected) {
          _results.push(result.selected = false);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    AbstractChosen.prototype.results_toggle = function () {
      if (this.results_showing) {
        return this.results_hide();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.results_search = function (evt) {
      if (this.results_showing) {
        return this.winnow_results();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.winnow_results = function () {
      var escapedSearchText, option, regex, results, results_group, searchText, startpos, text, zregex, _i, _len, _ref;
      this.no_results_clear();
      results = 0;
      searchText = this.get_search_text();
      escapedSearchText = searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      zregex = new RegExp(escapedSearchText, 'i');
      regex = this.get_search_regex(escapedSearchText);
      _ref = this.results_data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        option.search_match = false;
        results_group = null;
        if (this.include_option_in_results(option)) {
          if (option.group) {
            option.group_match = false;
            option.active_options = 0;
          }
          if (option.group_array_index != null && this.results_data[option.group_array_index]) {
            results_group = this.results_data[option.group_array_index];
            if (results_group.active_options === 0 && results_group.search_match) {
              results += 1;
            }
            results_group.active_options += 1;
          }
          option.search_text = option.group ? option.label : option.html;
          if (!(option.group && !this.group_search)) {
            option.search_match = this.search_string_match(option.search_text, regex);
            if (option.search_match && !option.group) {
              results += 1;
            }
            if (option.search_match) {
              if (searchText.length) {
                startpos = option.search_text.search(zregex);
                text = option.search_text.substr(0, startpos + searchText.length) + '</em>' + option.search_text.substr(startpos + searchText.length);
                option.search_text = text.substr(0, startpos) + '<em>' + text.substr(startpos);
              }
              if (results_group != null) {
                results_group.group_match = true;
              }
            } else if (option.group_array_index != null && this.results_data[option.group_array_index].search_match) {
              option.search_match = true;
            }
          }
        }
      }
      this.result_clear_highlight();
      if (results < 1 && searchText.length) {
        this.update_results_content("");
        return this.no_results(searchText);
      } else {
        this.update_results_content(this.results_option_build());
        return this.winnow_results_set_highlight();
      }
    };

    AbstractChosen.prototype.get_search_regex = function (escaped_search_string) {
      var regex_anchor, regex_flag;
      regex_anchor = this.search_contains ? "" : "^";
      regex_flag = this.case_sensitive_search ? "" : "i";
      return new RegExp(regex_anchor + escaped_search_string, regex_flag);
    };

    AbstractChosen.prototype.search_string_match = function (search_string, regex) {
      var part, parts, _i, _len;
      if (regex.test(search_string)) {
        return true;
      } else if (this.enable_split_word_search && (search_string.indexOf(" ") >= 0 || search_string.indexOf("[") === 0)) {
        parts = search_string.replace(/\[|\]/g, "").split(" ");
        if (parts.length) {
          for (_i = 0, _len = parts.length; _i < _len; _i++) {
            part = parts[_i];
            if (regex.test(part)) {
              return true;
            }
          }
        }
      }
    };

    AbstractChosen.prototype.choices_count = function () {
      var option, _i, _len, _ref;
      if (this.selected_option_count != null) {
        return this.selected_option_count;
      }
      this.selected_option_count = 0;
      _ref = this.form_field.options;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        if (option.selected) {
          this.selected_option_count += 1;
        }
      }
      return this.selected_option_count;
    };

    AbstractChosen.prototype.choices_click = function (evt) {
      evt.preventDefault();
      if (!(this.results_showing || this.is_disabled)) {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.keyup_checker = function (evt) {
      var stroke, _ref;
      stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
      this.search_field_scale();
      switch (stroke) {
        case 8:
          if (this.is_multiple && this.backstroke_length < 1 && this.choices_count() > 0) {
            return this.keydown_backstroke();
          } else if (!this.pending_backstroke) {
            this.result_clear_highlight();
            return this.results_search();
          }
          break;
        case 13:
          evt.preventDefault();
          if (this.results_showing) {
            return this.result_select(evt);
          }
          break;
        case 27:
          if (this.results_showing) {
            this.results_hide();
          }
          return true;
        case 9:
        case 38:
        case 40:
        case 16:
        case 91:
        case 17:
        case 18:
          break;
        default:
          return this.results_search();
      }
    };

    AbstractChosen.prototype.clipboard_event_checker = function (evt) {
      var _this = this;
      return setTimeout(function () {
        return _this.results_search();
      }, 50);
    };

    AbstractChosen.prototype.container_width = function () {
      if (this.options.width != null) {
        return this.options.width;
      } else {
        return "" + this.form_field.offsetWidth + "px";
      }
    };

    AbstractChosen.prototype.include_option_in_results = function (option) {
      if (this.is_multiple && !this.display_selected_options && option.selected) {
        return false;
      }
      if (!this.display_disabled_options && option.disabled) {
        return false;
      }
      if (option.empty) {
        return false;
      }
      return true;
    };

    AbstractChosen.prototype.search_results_touchstart = function (evt) {
      this.touch_started = true;
      return this.search_results_mouseover(evt);
    };

    AbstractChosen.prototype.search_results_touchmove = function (evt) {
      this.touch_started = false;
      return this.search_results_mouseout(evt);
    };

    AbstractChosen.prototype.search_results_touchend = function (evt) {
      if (this.touch_started) {
        return this.search_results_mouseup(evt);
      }
    };

    AbstractChosen.prototype.outerHTML = function (element) {
      var tmp;
      if (element.outerHTML) {
        return element.outerHTML;
      }
      tmp = document.createElement("div");
      tmp.appendChild(element);
      return tmp.innerHTML;
    };

    AbstractChosen.browser_is_supported = function () {
      if ("Microsoft Internet Explorer" === window.navigator.appName) {
        return document.documentMode >= 8;
      }
      if (/iP(od|hone)/i.test(window.navigator.userAgent) || /IEMobile/i.test(window.navigator.userAgent) || /Windows Phone/i.test(window.navigator.userAgent) || /BlackBerry/i.test(window.navigator.userAgent) || /BB10/i.test(window.navigator.userAgent) || /Android.*Mobile/i.test(window.navigator.userAgent)) {
        return false;
      }
      return true;
    };

    AbstractChosen.default_multiple_text = "Select Some Options";

    AbstractChosen.default_single_text = "Select an Option";

    AbstractChosen.default_no_result_text = "No results match";

    return AbstractChosen;
  }();

  $ = jQuery;

  $.fn.extend({
    chosen: function chosen(options) {
      if (!AbstractChosen.browser_is_supported()) {
        return this;
      }
      return this.each(function (input_field) {
        var $this, chosen;
        $this = $(this);
        chosen = $this.data('chosen');
        if (options === 'destroy') {
          if (chosen instanceof Chosen) {
            chosen.destroy();
          }
          return;
        }
        if (!(chosen instanceof Chosen)) {
          $this.data('chosen', new Chosen(this, options));
        }
      });
    }
  });

  Chosen = function (_super) {
    __extends(Chosen, _super);

    function Chosen() {
      _ref = Chosen.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Chosen.prototype.setup = function () {
      this.form_field_jq = $(this.form_field);
      this.current_selectedIndex = this.form_field.selectedIndex;
      return this.is_rtl = this.form_field_jq.hasClass("chosen-rtl");
    };

    Chosen.prototype.set_up_html = function () {
      var container_classes, container_props;
      container_classes = ["chosen-container"];
      container_classes.push("chosen-container-" + (this.is_multiple ? "multi" : "single"));
      if (this.inherit_select_classes && this.form_field.className) {
        container_classes.push(this.form_field.className);
      }
      if (this.is_rtl) {
        container_classes.push("chosen-rtl");
      }
      container_props = {
        'class': container_classes.join(' '),
        'style': "width: " + this.container_width() + ";",
        'title': this.form_field.title
      };
      if (this.form_field.id.length) {
        container_props.id = this.form_field.id.replace(/[^\w]/g, '_') + "_chosen";
      }
      this.container = $("<div />", container_props);
      if (this.is_multiple) {
        this.container.html('<ul class="chosen-choices"><li class="search-field"><input type="text" value="' + this.default_text + '" class="default" autocomplete="off" style="width:25px;" /></li></ul><div class="chosen-drop"><ul class="chosen-results"></ul></div>');
      } else {
        this.container.html('<a class="chosen-single chosen-default"><span>' + this.default_text + '</span><div><b></b></div></a><div class="chosen-drop"><div class="chosen-search"><input type="text" autocomplete="off" /></div><ul class="chosen-results"></ul></div>');
      }
      this.form_field_jq.hide().after(this.container);
      this.dropdown = this.container.find('div.chosen-drop').first();
      this.search_field = this.container.find('input').first();
      this.search_results = this.container.find('ul.chosen-results').first();
      this.search_field_scale();
      this.search_no_results = this.container.find('li.no-results').first();
      if (this.is_multiple) {
        this.search_choices = this.container.find('ul.chosen-choices').first();
        this.search_container = this.container.find('li.search-field').first();
      } else {
        this.search_container = this.container.find('div.chosen-search').first();
        this.selected_item = this.container.find('.chosen-single').first();
      }
      this.results_build();
      this.set_tab_index();
      return this.set_label_behavior();
    };

    Chosen.prototype.on_ready = function () {
      return this.form_field_jq.trigger("chosen:ready", {
        chosen: this
      });
    };

    Chosen.prototype.register_observers = function () {
      var _this = this;
      this.container.bind('touchstart.chosen', function (evt) {
        _this.container_mousedown(evt);
        return evt.preventDefault();
      });
      this.container.bind('touchend.chosen', function (evt) {
        _this.container_mouseup(evt);
        return evt.preventDefault();
      });
      this.container.bind('mousedown.chosen', function (evt) {
        _this.container_mousedown(evt);
      });
      this.container.bind('mouseup.chosen', function (evt) {
        _this.container_mouseup(evt);
      });
      this.container.bind('mouseenter.chosen', function (evt) {
        _this.mouse_enter(evt);
      });
      this.container.bind('mouseleave.chosen', function (evt) {
        _this.mouse_leave(evt);
      });
      this.search_results.bind('mouseup.chosen', function (evt) {
        _this.search_results_mouseup(evt);
      });
      this.search_results.bind('mouseover.chosen', function (evt) {
        _this.search_results_mouseover(evt);
      });
      this.search_results.bind('mouseout.chosen', function (evt) {
        _this.search_results_mouseout(evt);
      });
      this.search_results.bind('mousewheel.chosen DOMMouseScroll.chosen', function (evt) {
        _this.search_results_mousewheel(evt);
      });
      this.search_results.bind('touchstart.chosen', function (evt) {
        _this.search_results_touchstart(evt);
      });
      this.search_results.bind('touchmove.chosen', function (evt) {
        _this.search_results_touchmove(evt);
      });
      this.search_results.bind('touchend.chosen', function (evt) {
        _this.search_results_touchend(evt);
      });
      this.form_field_jq.bind("chosen:updated.chosen", function (evt) {
        _this.results_update_field(evt);
      });
      this.form_field_jq.bind("chosen:activate.chosen", function (evt) {
        _this.activate_field(evt);
      });
      this.form_field_jq.bind("chosen:open.chosen", function (evt) {
        _this.container_mousedown(evt);
      });
      this.form_field_jq.bind("chosen:close.chosen", function (evt) {
        _this.input_blur(evt);
      });
      this.search_field.bind('blur.chosen', function (evt) {
        _this.input_blur(evt);
      });
      this.search_field.bind('keyup.chosen', function (evt) {
        _this.keyup_checker(evt);
      });
      this.search_field.bind('keydown.chosen', function (evt) {
        _this.keydown_checker(evt);
      });
      this.search_field.bind('focus.chosen', function (evt) {
        _this.input_focus(evt);
      });
      this.search_field.bind('cut.chosen', function (evt) {
        _this.clipboard_event_checker(evt);
      });
      this.search_field.bind('paste.chosen', function (evt) {
        _this.clipboard_event_checker(evt);
      });
      if (this.is_multiple) {
        return this.search_choices.bind('click.chosen', function (evt) {
          _this.choices_click(evt);
        });
      } else {
        return this.container.bind('click.chosen', function (evt) {
          evt.preventDefault();
        });
      }
    };

    Chosen.prototype.destroy = function () {
      $(this.container[0].ownerDocument).unbind("click.chosen", this.click_test_action);
      if (this.search_field[0].tabIndex) {
        this.form_field_jq[0].tabIndex = this.search_field[0].tabIndex;
      }
      this.container.remove();
      this.form_field_jq.removeData('chosen');
      return this.form_field_jq.show();
    };

    Chosen.prototype.search_field_disabled = function () {
      this.is_disabled = this.form_field_jq[0].disabled;
      if (this.is_disabled) {
        this.container.addClass('chosen-disabled');
        this.search_field[0].disabled = true;
        if (!this.is_multiple) {
          this.selected_item.unbind("focus.chosen", this.activate_action);
        }
        return this.close_field();
      } else {
        this.container.removeClass('chosen-disabled');
        this.search_field[0].disabled = false;
        if (!this.is_multiple) {
          return this.selected_item.bind("focus.chosen", this.activate_action);
        }
      }
    };

    Chosen.prototype.container_mousedown = function (evt) {
      if (!this.is_disabled) {
        if (evt && evt.type === "mousedown" && !this.results_showing) {
          evt.preventDefault();
        }
        if (!(evt != null && $(evt.target).hasClass("search-choice-close"))) {
          if (!this.active_field) {
            if (this.is_multiple) {
              this.search_field.val("");
            }
            $(this.container[0].ownerDocument).bind('click.chosen', this.click_test_action);
            this.results_show();
          } else if (!this.is_multiple && evt && ($(evt.target)[0] === this.selected_item[0] || $(evt.target).parents("a.chosen-single").length)) {
            evt.preventDefault();
            this.results_toggle();
          }
          return this.activate_field();
        }
      }
    };

    Chosen.prototype.container_mouseup = function (evt) {
      if (evt.target.nodeName === "ABBR" && !this.is_disabled) {
        return this.results_reset(evt);
      }
    };

    Chosen.prototype.search_results_mousewheel = function (evt) {
      var delta;
      if (evt.originalEvent) {
        delta = evt.originalEvent.deltaY || -evt.originalEvent.wheelDelta || evt.originalEvent.detail;
      }
      if (delta != null) {
        evt.preventDefault();
        if (evt.type === 'DOMMouseScroll') {
          delta = delta * 40;
        }
        return this.search_results.scrollTop(delta + this.search_results.scrollTop());
      }
    };

    Chosen.prototype.blur_test = function (evt) {
      if (!this.active_field && this.container.hasClass("chosen-container-active")) {
        return this.close_field();
      }
    };

    Chosen.prototype.close_field = function () {
      $(this.container[0].ownerDocument).unbind("click.chosen", this.click_test_action);
      this.active_field = false;
      this.results_hide();
      this.container.removeClass("chosen-container-active");
      this.clear_backstroke();
      this.show_search_field_default();
      return this.search_field_scale();
    };

    Chosen.prototype.activate_field = function () {
      this.container.addClass("chosen-container-active");
      this.active_field = true;
      this.search_field.val(this.search_field.val());
      return this.search_field.focus();
    };

    Chosen.prototype.test_active_click = function (evt) {
      var active_container;
      active_container = $(evt.target).closest('.chosen-container');
      if (active_container.length && this.container[0] === active_container[0]) {
        return this.active_field = true;
      } else {
        return this.close_field();
      }
    };

    Chosen.prototype.results_build = function () {
      this.parsing = true;
      this.selected_option_count = null;
      this.results_data = SelectParser.select_to_array(this.form_field);
      if (this.is_multiple) {
        this.search_choices.find("li.search-choice").remove();
      } else if (!this.is_multiple) {
        this.single_set_selected_text();
        if (this.disable_search || this.form_field.options.length <= this.disable_search_threshold) {
          this.search_field[0].readOnly = true;
          this.container.addClass("chosen-container-single-nosearch");
        } else {
          this.search_field[0].readOnly = false;
          this.container.removeClass("chosen-container-single-nosearch");
        }
      }
      this.update_results_content(this.results_option_build({
        first: true
      }));
      this.search_field_disabled();
      this.show_search_field_default();
      this.search_field_scale();
      return this.parsing = false;
    };

    Chosen.prototype.result_do_highlight = function (el) {
      var high_bottom, high_top, maxHeight, visible_bottom, visible_top;
      if (el.length) {
        this.result_clear_highlight();
        this.result_highlight = el;
        this.result_highlight.addClass("highlighted");
        maxHeight = parseInt(this.search_results.css("maxHeight"), 10);
        visible_top = this.search_results.scrollTop();
        visible_bottom = maxHeight + visible_top;
        high_top = this.result_highlight.position().top + this.search_results.scrollTop();
        high_bottom = high_top + this.result_highlight.outerHeight();
        if (high_bottom >= visible_bottom) {
          return this.search_results.scrollTop(high_bottom - maxHeight > 0 ? high_bottom - maxHeight : 0);
        } else if (high_top < visible_top) {
          return this.search_results.scrollTop(high_top);
        }
      }
    };

    Chosen.prototype.result_clear_highlight = function () {
      if (this.result_highlight) {
        this.result_highlight.removeClass("highlighted");
      }
      return this.result_highlight = null;
    };

    Chosen.prototype.results_show = function () {
      if (this.is_multiple && this.max_selected_options <= this.choices_count()) {
        this.form_field_jq.trigger("chosen:maxselected", {
          chosen: this
        });
        return false;
      }
      this.container.addClass("chosen-with-drop");
      this.results_showing = true;
      this.search_field.focus();
      this.search_field.val(this.search_field.val());
      this.winnow_results();
      return this.form_field_jq.trigger("chosen:showing_dropdown", {
        chosen: this
      });
    };

    Chosen.prototype.update_results_content = function (content) {
      return this.search_results.html(content);
    };

    Chosen.prototype.results_hide = function () {
      if (this.results_showing) {
        this.result_clear_highlight();
        this.container.removeClass("chosen-with-drop");
        this.form_field_jq.trigger("chosen:hiding_dropdown", {
          chosen: this
        });
      }
      return this.results_showing = false;
    };

    Chosen.prototype.set_tab_index = function (el) {
      var ti;
      if (this.form_field.tabIndex) {
        ti = this.form_field.tabIndex;
        this.form_field.tabIndex = -1;
        return this.search_field[0].tabIndex = ti;
      }
    };

    Chosen.prototype.set_label_behavior = function () {
      var _this = this;
      this.form_field_label = this.form_field_jq.parents("label");
      if (!this.form_field_label.length && this.form_field.id.length) {
        this.form_field_label = $("label[for='" + this.form_field.id + "']");
      }
      if (this.form_field_label.length > 0) {
        return this.form_field_label.bind('click.chosen', function (evt) {
          if (_this.is_multiple) {
            return _this.container_mousedown(evt);
          } else {
            return _this.activate_field();
          }
        });
      }
    };

    Chosen.prototype.show_search_field_default = function () {
      if (this.is_multiple && this.choices_count() < 1 && !this.active_field) {
        this.search_field.val(this.default_text);
        return this.search_field.addClass("default");
      } else {
        this.search_field.val("");
        return this.search_field.removeClass("default");
      }
    };

    Chosen.prototype.search_results_mouseup = function (evt) {
      var target;
      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target.length) {
        this.result_highlight = target;
        this.result_select(evt);
        return this.search_field.focus();
      }
    };

    Chosen.prototype.search_results_mouseover = function (evt) {
      var target;
      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target) {
        return this.result_do_highlight(target);
      }
    };

    Chosen.prototype.search_results_mouseout = function (evt) {
      if ($(evt.target).hasClass("active-result" || $(evt.target).parents('.active-result').first())) {
        return this.result_clear_highlight();
      }
    };

    Chosen.prototype.choice_build = function (item) {
      var choice,
          close_link,
          _this = this;
      choice = $('<li />', {
        "class": "search-choice"
      }).html("<span>" + this.choice_label(item) + "</span>");
      if (item.disabled) {
        choice.addClass('search-choice-disabled');
      } else {
        close_link = $('<a />', {
          "class": 'search-choice-close',
          'data-option-array-index': item.array_index
        });
        close_link.bind('click.chosen', function (evt) {
          return _this.choice_destroy_link_click(evt);
        });
        choice.append(close_link);
      }
      return this.search_container.before(choice);
    };

    Chosen.prototype.choice_destroy_link_click = function (evt) {
      evt.preventDefault();
      evt.stopPropagation();
      if (!this.is_disabled) {
        return this.choice_destroy($(evt.target));
      }
    };

    Chosen.prototype.choice_destroy = function (link) {
      if (this.result_deselect(link[0].getAttribute("data-option-array-index"))) {
        this.show_search_field_default();
        if (this.is_multiple && this.choices_count() > 0 && this.search_field.val().length < 1) {
          this.results_hide();
        }
        link.parents('li').first().remove();
        return this.search_field_scale();
      }
    };

    Chosen.prototype.results_reset = function () {
      this.reset_single_select_options();
      this.form_field.options[0].selected = true;
      this.single_set_selected_text();
      this.show_search_field_default();
      this.results_reset_cleanup();
      this.form_field_jq.trigger("change");
      if (this.active_field) {
        return this.results_hide();
      }
    };

    Chosen.prototype.results_reset_cleanup = function () {
      this.current_selectedIndex = this.form_field.selectedIndex;
      return this.selected_item.find("abbr").remove();
    };

    Chosen.prototype.result_select = function (evt) {
      var high, item;
      if (this.result_highlight) {
        high = this.result_highlight;
        this.result_clear_highlight();
        if (this.is_multiple && this.max_selected_options <= this.choices_count()) {
          this.form_field_jq.trigger("chosen:maxselected", {
            chosen: this
          });
          return false;
        }
        if (this.is_multiple) {
          high.removeClass("active-result");
        } else {
          this.reset_single_select_options();
        }
        high.addClass("result-selected");
        item = this.results_data[high[0].getAttribute("data-option-array-index")];
        item.selected = true;
        this.form_field.options[item.options_index].selected = true;
        this.selected_option_count = null;
        if (this.is_multiple) {
          this.choice_build(item);
        } else {
          this.single_set_selected_text(this.choice_label(item));
        }
        if (!((evt.metaKey || evt.ctrlKey) && this.is_multiple)) {
          this.results_hide();
        }
        this.show_search_field_default();
        if (this.is_multiple || this.form_field.selectedIndex !== this.current_selectedIndex) {
          this.form_field_jq.trigger("change", {
            'selected': this.form_field.options[item.options_index].value
          });
        }
        this.current_selectedIndex = this.form_field.selectedIndex;
        evt.preventDefault();
        return this.search_field_scale();
      }
    };

    Chosen.prototype.single_set_selected_text = function (text) {
      if (text == null) {
        text = this.default_text;
      }
      if (text === this.default_text) {
        this.selected_item.addClass("chosen-default");
      } else {
        this.single_deselect_control_build();
        this.selected_item.removeClass("chosen-default");
      }
      return this.selected_item.find("span").html(text);
    };

    Chosen.prototype.result_deselect = function (pos) {
      var result_data;
      result_data = this.results_data[pos];
      if (!this.form_field.options[result_data.options_index].disabled) {
        result_data.selected = false;
        this.form_field.options[result_data.options_index].selected = false;
        this.selected_option_count = null;
        this.result_clear_highlight();
        if (this.results_showing) {
          this.winnow_results();
        }
        this.form_field_jq.trigger("change", {
          deselected: this.form_field.options[result_data.options_index].value
        });
        this.search_field_scale();
        return true;
      } else {
        return false;
      }
    };

    Chosen.prototype.single_deselect_control_build = function () {
      if (!this.allow_single_deselect) {
        return;
      }
      if (!this.selected_item.find("abbr").length) {
        this.selected_item.find("span").first().after("<abbr class=\"search-choice-close\"></abbr>");
      }
      return this.selected_item.addClass("chosen-single-with-deselect");
    };

    Chosen.prototype.get_search_text = function () {
      return $('<div/>').text($.trim(this.search_field.val())).html();
    };

    Chosen.prototype.winnow_results_set_highlight = function () {
      var do_high, selected_results;
      selected_results = !this.is_multiple ? this.search_results.find(".result-selected.active-result") : [];
      do_high = selected_results.length ? selected_results.first() : this.search_results.find(".active-result").first();
      if (do_high != null) {
        return this.result_do_highlight(do_high);
      }
    };

    Chosen.prototype.no_results = function (terms) {
      var no_results_html;
      no_results_html = $('<li class="no-results">' + this.results_none_found + ' "<span></span>"</li>');
      no_results_html.find("span").first().html(terms);
      this.search_results.append(no_results_html);
      return this.form_field_jq.trigger("chosen:no_results", {
        chosen: this
      });
    };

    Chosen.prototype.no_results_clear = function () {
      return this.search_results.find(".no-results").remove();
    };

    Chosen.prototype.keydown_arrow = function () {
      var next_sib;
      if (this.results_showing && this.result_highlight) {
        next_sib = this.result_highlight.nextAll("li.active-result").first();
        if (next_sib) {
          return this.result_do_highlight(next_sib);
        }
      } else {
        return this.results_show();
      }
    };

    Chosen.prototype.keyup_arrow = function () {
      var prev_sibs;
      if (!this.results_showing && !this.is_multiple) {
        return this.results_show();
      } else if (this.result_highlight) {
        prev_sibs = this.result_highlight.prevAll("li.active-result");
        if (prev_sibs.length) {
          return this.result_do_highlight(prev_sibs.first());
        } else {
          if (this.choices_count() > 0) {
            this.results_hide();
          }
          return this.result_clear_highlight();
        }
      }
    };

    Chosen.prototype.keydown_backstroke = function () {
      var next_available_destroy;
      if (this.pending_backstroke) {
        this.choice_destroy(this.pending_backstroke.find("a").first());
        return this.clear_backstroke();
      } else {
        next_available_destroy = this.search_container.siblings("li.search-choice").last();
        if (next_available_destroy.length && !next_available_destroy.hasClass("search-choice-disabled")) {
          this.pending_backstroke = next_available_destroy;
          if (this.single_backstroke_delete) {
            return this.keydown_backstroke();
          } else {
            return this.pending_backstroke.addClass("search-choice-focus");
          }
        }
      }
    };

    Chosen.prototype.clear_backstroke = function () {
      if (this.pending_backstroke) {
        this.pending_backstroke.removeClass("search-choice-focus");
      }
      return this.pending_backstroke = null;
    };

    Chosen.prototype.keydown_checker = function (evt) {
      var stroke, _ref1;
      stroke = (_ref1 = evt.which) != null ? _ref1 : evt.keyCode;
      this.search_field_scale();
      if (stroke !== 8 && this.pending_backstroke) {
        this.clear_backstroke();
      }
      switch (stroke) {
        case 8:
          this.backstroke_length = this.search_field.val().length;
          break;
        case 9:
          if (this.results_showing && !this.is_multiple) {
            this.result_select(evt);
          }
          this.mouse_on_container = false;
          break;
        case 13:
          if (this.results_showing) {
            evt.preventDefault();
          }
          break;
        case 32:
          if (this.disable_search) {
            evt.preventDefault();
          }
          break;
        case 38:
          evt.preventDefault();
          this.keyup_arrow();
          break;
        case 40:
          evt.preventDefault();
          this.keydown_arrow();
          break;
      }
    };

    Chosen.prototype.search_field_scale = function () {
      var div, f_width, h, style, style_block, styles, w, _i, _len;
      if (this.is_multiple) {
        h = 0;
        w = 0;
        style_block = "position:absolute; left: -1000px; top: -1000px; display:none;";
        styles = ['font-size', 'font-style', 'font-weight', 'font-family', 'line-height', 'text-transform', 'letter-spacing'];
        for (_i = 0, _len = styles.length; _i < _len; _i++) {
          style = styles[_i];
          style_block += style + ":" + this.search_field.css(style) + ";";
        }
        div = $('<div />', {
          'style': style_block
        });
        div.text(this.search_field.val());
        $('body').append(div);
        w = div.width() + 25;
        div.remove();
        f_width = this.container.outerWidth();
        if (w > f_width - 10) {
          w = f_width - 10;
        }
        return this.search_field.css({
          'width': w + 'px'
        });
      }
    };

    return Chosen;
  }(AbstractChosen);
}).call(undefined);

},{}],82:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* ========================================================================
 * Bootstrap: modal.js v3.3.6
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var GC_Modal = function GC_Modal(element, options) {
    this.options = options;
    this.$body = $(document.body);
    this.$element = $(element);
    this.$dialog = this.$element.find('.modal-dialog');
    this.$backdrop = null;
    this.isShown = null;
    this.originalBodyPad = null;
    this.scrollbarWidth = 0;
    this.ignoreBackdropClick = false;

    if (this.options.remote) {
      this.$element.find('.modal-content').load(this.options.remote, $.proxy(function () {
        this.$element.trigger('loaded.bs.modal');
      }, this));
    }
  };

  GC_Modal.VERSION = '3.3.6';

  GC_Modal.TRANSITION_DURATION = 300;
  GC_Modal.BACKDROP_TRANSITION_DURATION = 150;

  GC_Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  };

  GC_Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget);
  };

  GC_Modal.prototype.show = function (_relatedTarget) {
    var that = this,
        e = $.Event('show.bs.modal', { relatedTarget: _relatedTarget }),
        maxHeight = Math.max(250, $(window).height() - 200),
        minHeight = 250;

    this.$element.trigger(e);

    if (this.isShown || e.isDefaultPrevented()) return;

    this.isShown = true;

    this.checkScrollbar();
    this.setScrollbar();
    this.$body.addClass('modal-open');

    this.$element.find('.modal-body').css('min-height', minHeight + 'px').css('max-height', maxHeight + 'px');

    this.escape();
    this.resize();

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this));

    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true;
      });
    });

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade');

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body); // don't move modals dom position
      }

      that.$element.show().scrollTop(0);

      that.adjustDialog();

      if (transition) {
        that.$element[0].offsetWidth; // force reflow
      }

      that.$element.removeClass('gc-visible-but-hidden');
      that.$element.addClass('in').addClass('show').css('display', 'block');

      that.enforceFocus();

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget });

      transition ? that.$dialog // wait for modal to slide in
      .one('bsTransitionEnd', function () {
        that.$element.trigger('focus').trigger(e);
      }).emulateTransitionEnd(GC_Modal.TRANSITION_DURATION) : that.$element.trigger('focus').trigger(e);
    });
  };

  GC_Modal.prototype.hide = function (e) {
    if (e) e.preventDefault();

    e = $.Event('hide.bs.modal');

    this.$element.trigger(e);

    if (!this.isShown || e.isDefaultPrevented()) return;

    this.isShown = false;

    this.escape();
    this.resize();

    $(document).off('focusin.bs.modal');

    this.$element.removeClass('in').removeClass('show').off('click.dismiss.bs.modal').off('mouseup.dismiss.bs.modal').css('display', 'none');

    this.$dialog.off('mousedown.dismiss.bs.modal');

    $.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', $.proxy(this.hideGC_Modal, this)).emulateTransitionEnd(GC_Modal.TRANSITION_DURATION) : this.hideGC_Modal();
  };

  GC_Modal.prototype.enforceFocus = function () {
    $(document).off('focusin.bs.modal') // guard against infinite focus loop
    .on('focusin.bs.modal', $.proxy(function (e) {
      if (this.$element[0] !== e.target && !this.$element.has(e.target).length && !$(e.target.parentNode).hasClass('cke_dialog_ui_input_select') && !$(e.target.parentNode).hasClass('cke_dialog_ui_input_text')) {
        this.$element.trigger('focus');
      }
    }, this));
  };

  GC_Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide();
      }, this));
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal');
    }
  };

  GC_Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this));
    } else {
      $(window).off('resize.bs.modal');
    }
  };

  GC_Modal.prototype.hideGC_Modal = function () {
    var that = this;
    this.$element.hide();
    this.backdrop(function () {
      that.$body.removeClass('modal-open');
      that.resetAdjustments();
      that.resetScrollbar();
      that.$element.trigger('hidden.bs.modal');
    });
  };

  GC_Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove();
    this.$backdrop = null;
  };

  GC_Modal.prototype.backdrop = function (callback) {
    var that = this;
    var animate = this.$element.hasClass('fade') ? 'fade' : '';

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate;

      this.$backdrop = $(document.createElement('div')).addClass('modal-backdrop ' + animate).appendTo(this.$body);

      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false;
          return;
        }
        if (e.target !== e.currentTarget) return;
        this.options.backdrop == 'static' ? this.$element[0].focus() : this.hide();
      }, this));

      if (doAnimate) this.$backdrop[0].offsetWidth; // force reflow

      this.$backdrop.addClass('in').addClass('show').css('display', 'block');

      if (!callback) return;

      doAnimate ? this.$backdrop.one('bsTransitionEnd', callback).emulateTransitionEnd(GC_Modal.BACKDROP_TRANSITION_DURATION) : callback();
    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in').removeClass('show').css('display', 'none');

      var callbackRemove = function callbackRemove() {
        that.removeBackdrop();
        callback && callback();
      };
      $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one('bsTransitionEnd', callbackRemove).emulateTransitionEnd(GC_Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
    } else if (callback) {
      callback();
    }
  };

  // these following methods are used to handle overflowing modals

  GC_Modal.prototype.handleUpdate = function () {
    this.adjustDialog();
  };

  GC_Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;

    this.$element.css({
      paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
    });
  };

  GC_Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    });
  };

  GC_Modal.prototype.checkScrollbar = function () {
    var fullWindowWidth = window.innerWidth;
    if (!fullWindowWidth) {
      // workaround for missing window.innerWidth in IE8
      var documentElementRect = document.documentElement.getBoundingClientRect();
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
    }
    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
    this.scrollbarWidth = this.measureScrollbar();
  };

  GC_Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt(this.$body.css('padding-right') || 0, 10);
    this.originalBodyPad = document.body.style.paddingRight || '';
    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth);
  };

  GC_Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', this.originalBodyPad);
  };

  GC_Modal.prototype.measureScrollbar = function () {
    // thx walsh
    var scrollDiv = document.createElement('div');
    scrollDiv.className = 'modal-scrollbar-measure';
    this.$body.append(scrollDiv);
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    this.$body[0].removeChild(scrollDiv);
    return scrollbarWidth;
  };

  // MODAL PLUGIN DEFINITION
  // =======================

  function GC_Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.modal');
      var options = $.extend({}, GC_Modal.DEFAULTS, $this.data(), (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' && option);

      if (!data) $this.data('bs.modal', data = new GC_Modal(this, options));
      if (typeof option == 'string') data[option](_relatedTarget);else if (options.show) data.show(_relatedTarget);
    });
  }

  $.fn.gc_modal = GC_Plugin;
  $.fn.gc_modal.Constructor = GC_Modal;

  // MODAL DATA-API
  // ==============

  if (typeof document !== 'undefined') {

    $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
      var $this = $(this);
      var href = $this.attr('href');
      var $target = $($this.attr('data-target') || href && href.replace(/.*(?=#[^\s]+$)/, '')); // strip for ie7
      var option = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data());

      if ($this.is('a')) e.preventDefault();

      $target.one('show.bs.modal', function (showEvent) {
        if (showEvent.isDefaultPrevented()) return; // only register focus restorer if modal will actually get shown
        $target.one('hidden.bs.modal', function () {
          $this.is(':visible') && $this.trigger('focus');
        });
      });
      GC_Plugin.call($target, option, this);
    });

    $(window).resize(function () {
      var maxHeight = Math.max(250, $(window).height() - 200),
          minHeight = 250;
      $('.gc-container').find('.modal-body').css('max-height', maxHeight + 'px').css('min-height', minHeight + 'px');
    });
  }
}(jQuery);

},{}],83:[function(require,module,exports){
"use strict";

/*
 * printThis v1.5
 * @desc Printing plug-in for jQuery
 * @author Jason Day
 *
 * Resources (based on) :
 *              jPrintArea: http://plugins.jquery.com/project/jPrintArea
 *              jqPrint: https://github.com/permanenttourist/jquery.jqprint
 *              Ben Nadal: http://www.bennadel.com/blog/1591-Ask-Ben-Print-Part-Of-A-Web-Page-With-jQuery.htm
 *
 * Licensed under the MIT licence:
 *              http://www.opensource.org/licenses/mit-license.php
 *
 * (c) Jason Day 2015
 *
 * Usage:
 *
 *  $("#mySelector").printThis({
 *      debug: false,               * show the iframe for debugging
 *      importCSS: true,            * import page CSS
 *      importStyle: false,         * import style tags
 *      printContainer: true,       * grab outer container as well as the contents of the selector
 *      loadCSS: "path/to/my.css",  * path to additional css file - us an array [] for multiple
 *      pageTitle: "",              * add title to print page
 *      removeInline: false,        * remove all inline styles from print elements
 *      printDelay: 333,            * variable print delay
 *      header: null,               * prefix to html
 *      formValues: true            * preserve input/form values
 *  });
 *
 * Notes:
 *  - the loadCSS will load additional css (with or without @media print) into the iframe, adjusting layout
 */
(function ($) {

    var opt;
    $.fn.printThis = function (options) {
        opt = $.extend({}, $.fn.printThis.defaults, options);
        var $element = this instanceof jQuery ? this : $(this);

        var strFrameName = "printThis-" + new Date().getTime();

        if (window.location.hostname !== document.domain && navigator.userAgent.match(/msie/i)) {
            // Ugly IE hacks due to IE not inheriting document.domain from parent
            // checks if document.domain is set by comparing the host name against document.domain
            var iframeSrc = "javascript:document.write(\"<head><script>document.domain=\\\"" + document.domain + "\\\";</script></head><body></body>\")";
            var printI = document.createElement('iframe');
            printI.name = "printIframe";
            printI.id = strFrameName;
            printI.className = "MSIE";
            document.body.appendChild(printI);
            printI.src = iframeSrc;
        } else {
            // other browsers inherit document.domain, and IE works if document.domain is not explicitly set
            var $frame = $("<iframe id='" + strFrameName + "' name='printIframe' />");
            $frame.appendTo("body");
        }

        var $iframe = $("#" + strFrameName);

        // show frame if in debug mode
        if (!opt.debug) $iframe.css({
            position: "absolute",
            width: "0px",
            height: "0px",
            left: "-600px",
            top: "-600px"
        });

        // $iframe.ready() and $iframe.load were inconsistent between browsers
        setTimeout(function () {

            // Add doctype to fix the style difference between printing and render
            function setDocType($iframe, doctype) {
                var win, doc;
                win = $iframe.get(0);
                win = win.contentWindow || win.contentDocument || win;
                doc = win.document || win.contentDocument || win;
                doc.open();
                doc.write(doctype);
                doc.close();
            }
            if (opt.doctypeString) {
                setDocType($iframe, opt.doctypeString);
            }

            var $doc = $iframe.contents(),
                $head = $doc.find("head"),
                $body = $doc.find("body");

            // add base tag to ensure elements use the parent domain
            $head.append('<base href="' + document.location.protocol + '//' + document.location.host + '">');

            // import page stylesheets
            if (opt.importCSS) $("link[rel=stylesheet]").each(function () {
                var href = $(this).attr("href");
                if (href) {
                    var media = $(this).attr("media") || "all";
                    $head.append("<link type='text/css' rel='stylesheet' href='" + href + "' media='" + media + "'>");
                }
            });

            // import style tags
            if (opt.importStyle) $("style").each(function () {
                $(this).clone().appendTo($head);
                //$head.append($(this));
            });

            //add title of the page
            if (opt.pageTitle) $head.append("<title>" + opt.pageTitle + "</title>");

            // import additional stylesheet(s)
            if (opt.loadCSS) {
                if ($.isArray(opt.loadCSS)) {
                    jQuery.each(opt.loadCSS, function (index, value) {
                        $head.append("<link type='text/css' rel='stylesheet' href='" + this + "'>");
                    });
                } else {
                    $head.append("<link type='text/css' rel='stylesheet' href='" + opt.loadCSS + "'>");
                }
            }

            // print header
            if (opt.header) $body.append(opt.header);

            // grab $.selector as container
            if (opt.printContainer) $body.append($element.outer());

            // otherwise just print interior elements of container
            else $element.each(function () {
                    $body.append($(this).html());
                });

            // capture form/field values
            if (opt.formValues) {
                // loop through inputs
                var $input = $element.find('input');
                if ($input.length) {
                    $input.each(function () {
                        var $this = $(this),
                            $name = $(this).attr('name'),
                            $checker = $this.is(':checkbox') || $this.is(':radio'),
                            $iframeInput = $doc.find('input[name="' + $name + '"]'),
                            $value = $this.val();

                        //order matters here
                        if (!$checker) {
                            $iframeInput.val($value);
                        } else if ($this.is(':checked')) {
                            if ($this.is(':checkbox')) {
                                $iframeInput.attr('checked', 'checked');
                            } else if ($this.is(':radio')) {
                                $doc.find('input[name="' + $name + '"][value=' + $value + ']').attr('checked', 'checked');
                            }
                        }
                    });
                }

                //loop through selects
                var $select = $element.find('select');
                if ($select.length) {
                    $select.each(function () {
                        var $this = $(this),
                            $name = $(this).attr('name'),
                            $value = $this.val();
                        $doc.find('select[name="' + $name + '"]').val($value);
                    });
                }

                //loop through textareas
                var $textarea = $element.find('textarea');
                if ($textarea.length) {
                    $textarea.each(function () {
                        var $this = $(this),
                            $name = $(this).attr('name'),
                            $value = $this.val();
                        $doc.find('textarea[name="' + $name + '"]').val($value);
                    });
                }
            } // end capture form/field values

            // remove inline styles
            if (opt.removeInline) {
                // $.removeAttr available jQuery 1.7+
                if ($.isFunction($.removeAttr)) {
                    $doc.find("body *").removeAttr("style");
                } else {
                    $doc.find("body *").attr("style", "");
                }
            }

            setTimeout(function () {
                if ($iframe.hasClass("MSIE")) {
                    // check if the iframe was created with the ugly hack
                    // and perform another ugly hack out of neccessity
                    window.frames["printIframe"].focus();
                    $head.append("<script>  window.print(); </script>");
                } else {
                    // proper method
                    if (document.queryCommandSupported("print")) {
                        $iframe[0].contentWindow.document.execCommand("print", false, null);
                    } else {
                        $iframe[0].contentWindow.focus();
                        $iframe[0].contentWindow.print();
                    }
                }

                //remove iframe after print
                if (!opt.debug) {
                    setTimeout(function () {
                        $iframe.remove();
                    }, 1000);
                }
            }, opt.printDelay);
        }, 333);
    };

    // defaults
    $.fn.printThis.defaults = {
        debug: false, // show the iframe for debugging
        importCSS: true, // import parent page css
        importStyle: false, // import style tags
        printContainer: true, // print outer container/$.selector
        loadCSS: "", // load an additional css file - load multiple stylesheets with an array []
        pageTitle: "", // add title to print page
        removeInline: false, // remove all inline styles
        printDelay: 333, // variable print delay
        header: null, // prefix to html
        formValues: true, // preserve input/form values
        doctypeString: '<!DOCTYPE html>' // html doctype
    };
})(jQuery);

// $.selector container
jQuery.fn.outer = function () {
    return $($("<div></div>").html(this.clone())).html();
};

},{}],84:[function(require,module,exports){
'use strict';

/* ========================================================================
 * Bootstrap: transition.js v3.3.5
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+function ($) {
    'use strict';

    // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
    // ============================================================

    function transitionEnd() {
        var el = document.createElement('bootstrap');

        var transEndEventNames = {
            WebkitTransition: 'webkitTransitionEnd',
            MozTransition: 'transitionend',
            OTransition: 'oTransitionEnd otransitionend',
            transition: 'transitionend'
        };

        for (var name in transEndEventNames) {
            if (el.style[name] !== undefined) {
                return { end: transEndEventNames[name] };
            }
        }

        return false; // explicit for ie8 (  ._.)
    }

    // http://blog.alexmaccaw.com/css-transitions
    $.fn.emulateTransitionEnd = function (duration) {
        var called = false;
        var $el = this;
        $(this).one('bsTransitionEnd', function () {
            called = true;
        });
        var callback = function callback() {
            if (!called) $($el).trigger($.support.transition.end);
        };
        setTimeout(callback, duration);
        return this;
    };

    $(function () {
        $.support.transition = transitionEnd();

        if (!$.support.transition) return;

        $.event.special.bsTransitionEnd = {
            bindType: $.support.transition.end,
            delegateType: $.support.transition.end,
            handle: function handle(e) {
                if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
            }
        };
    });
}(jQuery);

},{}],85:[function(require,module,exports){
'use strict';

var Handlebars = require('handlebars');

Handlebars.registerHelper('ifCond', function (v1, operator, v2, options) {

    switch (operator) {
        case '==':
            return v1 == v2 ? options.fn(this) : options.inverse(this);
        case '===':
            return v1 === v2 ? options.fn(this) : options.inverse(this);
        case '<':
            return v1 < v2 ? options.fn(this) : options.inverse(this);
        case '<=':
            return v1 <= v2 ? options.fn(this) : options.inverse(this);
        case '>':
            return v1 > v2 ? options.fn(this) : options.inverse(this);
        case '>=':
            return v1 >= v2 ? options.fn(this) : options.inverse(this);
        case '&&':
            return v1 && v2 ? options.fn(this) : options.inverse(this);
        case '||':
            return v1 || v2 ? options.fn(this) : options.inverse(this);
        default:
            return options.inverse(this);
    }
});

exports.Handlebars = Handlebars;

},{"handlebars":153}],86:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! jQuery Timepicker Addon - v1.6.3 - 2016-04-20
* http://trentrichardson.com/examples/timepicker
* Copyright (c) 2016 Trent Richardson; Licensed MIT */
(function (factory) {
	if (typeof define === 'function' && define.amd) {
		define(['jquery', 'jquery-ui'], factory);
	} else {
		factory(jQuery);
	}
})(function ($) {

	/*
 * Lets not redefine timepicker, Prevent "Uncaught RangeError: Maximum call stack size exceeded"
 */
	$.ui = $.ui || {};
	$.ui.timepicker = $.ui.timepicker || {};
	if ($.ui.timepicker.version) {
		return;
	}

	/*
 * Extend jQueryUI, get it started with our version number
 */
	$.extend($.ui, {
		timepicker: {
			version: "1.6.3"
		}
	});

	/*
 * Timepicker manager.
 * Use the singleton instance of this class, $.timepicker, to interact with the time picker.
 * Settings for (groups of) time pickers are maintained in an instance object,
 * allowing multiple different settings on the same page.
 */
	var Timepicker = function Timepicker() {
		this.regional = []; // Available regional settings, indexed by language code
		this.regional[''] = { // Default regional settings
			currentText: 'Now',
			closeText: 'Done',
			amNames: ['AM', 'A'],
			pmNames: ['PM', 'P'],
			timeFormat: 'HH:mm',
			timeSuffix: '',
			timeOnlyTitle: 'Choose Time',
			timeText: 'Time',
			hourText: 'Hour',
			minuteText: 'Minute',
			secondText: 'Second',
			millisecText: 'Millisecond',
			microsecText: 'Microsecond',
			timezoneText: 'Time Zone',
			isRTL: false
		};
		this._defaults = { // Global defaults for all the datetime picker instances
			showButtonPanel: true,
			timeOnly: false,
			timeOnlyShowDate: false,
			showHour: null,
			showMinute: null,
			showSecond: null,
			showMillisec: null,
			showMicrosec: null,
			showTimezone: null,
			showTime: true,
			stepHour: 1,
			stepMinute: 1,
			stepSecond: 1,
			stepMillisec: 1,
			stepMicrosec: 1,
			hour: 0,
			minute: 0,
			second: 0,
			millisec: 0,
			microsec: 0,
			timezone: null,
			hourMin: 0,
			minuteMin: 0,
			secondMin: 0,
			millisecMin: 0,
			microsecMin: 0,
			hourMax: 23,
			minuteMax: 59,
			secondMax: 59,
			millisecMax: 999,
			microsecMax: 999,
			minDateTime: null,
			maxDateTime: null,
			maxTime: null,
			minTime: null,
			onSelect: null,
			hourGrid: 0,
			minuteGrid: 0,
			secondGrid: 0,
			millisecGrid: 0,
			microsecGrid: 0,
			alwaysSetTime: true,
			separator: ' ',
			altFieldTimeOnly: true,
			altTimeFormat: null,
			altSeparator: null,
			altTimeSuffix: null,
			altRedirectFocus: true,
			pickerTimeFormat: null,
			pickerTimeSuffix: null,
			showTimepicker: true,
			timezoneList: null,
			addSliderAccess: false,
			sliderAccessArgs: null,
			controlType: 'slider',
			oneLine: false,
			defaultValue: null,
			parse: 'strict',
			afterInject: null
		};
		$.extend(this._defaults, this.regional['']);
	};

	$.extend(Timepicker.prototype, {
		$input: null,
		$altInput: null,
		$timeObj: null,
		inst: null,
		hour_slider: null,
		minute_slider: null,
		second_slider: null,
		millisec_slider: null,
		microsec_slider: null,
		timezone_select: null,
		maxTime: null,
		minTime: null,
		hour: 0,
		minute: 0,
		second: 0,
		millisec: 0,
		microsec: 0,
		timezone: null,
		hourMinOriginal: null,
		minuteMinOriginal: null,
		secondMinOriginal: null,
		millisecMinOriginal: null,
		microsecMinOriginal: null,
		hourMaxOriginal: null,
		minuteMaxOriginal: null,
		secondMaxOriginal: null,
		millisecMaxOriginal: null,
		microsecMaxOriginal: null,
		ampm: '',
		formattedDate: '',
		formattedTime: '',
		formattedDateTime: '',
		timezoneList: null,
		units: ['hour', 'minute', 'second', 'millisec', 'microsec'],
		support: {},
		control: null,

		/*
  * Override the default settings for all instances of the time picker.
  * @param  {Object} settings  object - the new settings to use as defaults (anonymous object)
  * @return {Object} the manager object
  */
		setDefaults: function setDefaults(settings) {
			extendRemove(this._defaults, settings || {});
			return this;
		},

		/*
  * Create a new Timepicker instance
  */
		_newInst: function _newInst($input, opts) {
			var tp_inst = new Timepicker(),
			    inlineSettings = {},
			    fns = {},
			    overrides,
			    i;

			for (var attrName in this._defaults) {
				if (this._defaults.hasOwnProperty(attrName)) {
					var attrValue = $input.attr('time:' + attrName);
					if (attrValue) {
						try {
							inlineSettings[attrName] = eval(attrValue);
						} catch (err) {
							inlineSettings[attrName] = attrValue;
						}
					}
				}
			}

			overrides = {
				beforeShow: function beforeShow(input, dp_inst) {
					if ($.isFunction(tp_inst._defaults.evnts.beforeShow)) {
						return tp_inst._defaults.evnts.beforeShow.call($input[0], input, dp_inst, tp_inst);
					}
				},
				onChangeMonthYear: function onChangeMonthYear(year, month, dp_inst) {
					// Update the time as well : this prevents the time from disappearing from the $input field.
					// tp_inst._updateDateTime(dp_inst);
					if ($.isFunction(tp_inst._defaults.evnts.onChangeMonthYear)) {
						tp_inst._defaults.evnts.onChangeMonthYear.call($input[0], year, month, dp_inst, tp_inst);
					}
				},
				onClose: function onClose(dateText, dp_inst) {
					if (tp_inst.timeDefined === true && $input.val() !== '') {
						tp_inst._updateDateTime(dp_inst);
					}
					if ($.isFunction(tp_inst._defaults.evnts.onClose)) {
						tp_inst._defaults.evnts.onClose.call($input[0], dateText, dp_inst, tp_inst);
					}
				}
			};
			for (i in overrides) {
				if (overrides.hasOwnProperty(i)) {
					fns[i] = opts[i] || this._defaults[i] || null;
				}
			}

			tp_inst._defaults = $.extend({}, this._defaults, inlineSettings, opts, overrides, {
				evnts: fns,
				timepicker: tp_inst // add timepicker as a property of datepicker: $.datepicker._get(dp_inst, 'timepicker');
			});
			tp_inst.amNames = $.map(tp_inst._defaults.amNames, function (val) {
				return val.toUpperCase();
			});
			tp_inst.pmNames = $.map(tp_inst._defaults.pmNames, function (val) {
				return val.toUpperCase();
			});

			// detect which units are supported
			tp_inst.support = detectSupport(tp_inst._defaults.timeFormat + (tp_inst._defaults.pickerTimeFormat ? tp_inst._defaults.pickerTimeFormat : '') + (tp_inst._defaults.altTimeFormat ? tp_inst._defaults.altTimeFormat : ''));

			// controlType is string - key to our this._controls
			if (typeof tp_inst._defaults.controlType === 'string') {
				if (tp_inst._defaults.controlType === 'slider' && typeof $.ui.slider === 'undefined') {
					tp_inst._defaults.controlType = 'select';
				}
				tp_inst.control = tp_inst._controls[tp_inst._defaults.controlType];
			}
			// controlType is an object and must implement create, options, value methods
			else {
					tp_inst.control = tp_inst._defaults.controlType;
				}

			// prep the timezone options
			var timezoneList = [-720, -660, -600, -570, -540, -480, -420, -360, -300, -270, -240, -210, -180, -120, -60, 0, 60, 120, 180, 210, 240, 270, 300, 330, 345, 360, 390, 420, 480, 525, 540, 570, 600, 630, 660, 690, 720, 765, 780, 840];
			if (tp_inst._defaults.timezoneList !== null) {
				timezoneList = tp_inst._defaults.timezoneList;
			}
			var tzl = timezoneList.length,
			    tzi = 0,
			    tzv = null;
			if (tzl > 0 && _typeof(timezoneList[0]) !== 'object') {
				for (; tzi < tzl; tzi++) {
					tzv = timezoneList[tzi];
					timezoneList[tzi] = { value: tzv, label: $.timepicker.timezoneOffsetString(tzv, tp_inst.support.iso8601) };
				}
			}
			tp_inst._defaults.timezoneList = timezoneList;

			// set the default units
			tp_inst.timezone = tp_inst._defaults.timezone !== null ? $.timepicker.timezoneOffsetNumber(tp_inst._defaults.timezone) : new Date().getTimezoneOffset() * -1;
			tp_inst.hour = tp_inst._defaults.hour < tp_inst._defaults.hourMin ? tp_inst._defaults.hourMin : tp_inst._defaults.hour > tp_inst._defaults.hourMax ? tp_inst._defaults.hourMax : tp_inst._defaults.hour;
			tp_inst.minute = tp_inst._defaults.minute < tp_inst._defaults.minuteMin ? tp_inst._defaults.minuteMin : tp_inst._defaults.minute > tp_inst._defaults.minuteMax ? tp_inst._defaults.minuteMax : tp_inst._defaults.minute;
			tp_inst.second = tp_inst._defaults.second < tp_inst._defaults.secondMin ? tp_inst._defaults.secondMin : tp_inst._defaults.second > tp_inst._defaults.secondMax ? tp_inst._defaults.secondMax : tp_inst._defaults.second;
			tp_inst.millisec = tp_inst._defaults.millisec < tp_inst._defaults.millisecMin ? tp_inst._defaults.millisecMin : tp_inst._defaults.millisec > tp_inst._defaults.millisecMax ? tp_inst._defaults.millisecMax : tp_inst._defaults.millisec;
			tp_inst.microsec = tp_inst._defaults.microsec < tp_inst._defaults.microsecMin ? tp_inst._defaults.microsecMin : tp_inst._defaults.microsec > tp_inst._defaults.microsecMax ? tp_inst._defaults.microsecMax : tp_inst._defaults.microsec;
			tp_inst.ampm = '';
			tp_inst.$input = $input;

			if (tp_inst._defaults.altField) {
				tp_inst.$altInput = $(tp_inst._defaults.altField);
				if (tp_inst._defaults.altRedirectFocus === true) {
					tp_inst.$altInput.css({
						cursor: 'pointer'
					}).focus(function () {
						$input.trigger("focus");
					});
				}
			}

			if (tp_inst._defaults.minDate === 0 || tp_inst._defaults.minDateTime === 0) {
				tp_inst._defaults.minDate = new Date();
			}
			if (tp_inst._defaults.maxDate === 0 || tp_inst._defaults.maxDateTime === 0) {
				tp_inst._defaults.maxDate = new Date();
			}

			// datepicker needs minDate/maxDate, timepicker needs minDateTime/maxDateTime..
			if (tp_inst._defaults.minDate !== undefined && tp_inst._defaults.minDate instanceof Date) {
				tp_inst._defaults.minDateTime = new Date(tp_inst._defaults.minDate.getTime());
			}
			if (tp_inst._defaults.minDateTime !== undefined && tp_inst._defaults.minDateTime instanceof Date) {
				tp_inst._defaults.minDate = new Date(tp_inst._defaults.minDateTime.getTime());
			}
			if (tp_inst._defaults.maxDate !== undefined && tp_inst._defaults.maxDate instanceof Date) {
				tp_inst._defaults.maxDateTime = new Date(tp_inst._defaults.maxDate.getTime());
			}
			if (tp_inst._defaults.maxDateTime !== undefined && tp_inst._defaults.maxDateTime instanceof Date) {
				tp_inst._defaults.maxDate = new Date(tp_inst._defaults.maxDateTime.getTime());
			}
			tp_inst.$input.bind('focus', function () {
				tp_inst._onFocus();
			});

			return tp_inst;
		},

		/*
  * add our sliders to the calendar
  */
		_addTimePicker: function _addTimePicker(dp_inst) {
			var currDT = $.trim(this.$altInput && this._defaults.altFieldTimeOnly ? this.$input.val() + ' ' + this.$altInput.val() : this.$input.val());

			this.timeDefined = this._parseTime(currDT);
			this._limitMinMaxDateTime(dp_inst, false);
			this._injectTimePicker();
			this._afterInject();
		},

		/*
  * parse the time string from input value or _setTime
  */
		_parseTime: function _parseTime(timeString, withDate) {
			if (!this.inst) {
				this.inst = $.datepicker._getInst(this.$input[0]);
			}

			if (withDate || !this._defaults.timeOnly) {
				var dp_dateFormat = $.datepicker._get(this.inst, 'dateFormat');
				try {
					var parseRes = parseDateTimeInternal(dp_dateFormat, this._defaults.timeFormat, timeString, $.datepicker._getFormatConfig(this.inst), this._defaults);
					if (!parseRes.timeObj) {
						return false;
					}
					$.extend(this, parseRes.timeObj);
				} catch (err) {
					$.timepicker.log("Error parsing the date/time string: " + err + "\ndate/time string = " + timeString + "\ntimeFormat = " + this._defaults.timeFormat + "\ndateFormat = " + dp_dateFormat);
					return false;
				}
				return true;
			} else {
				var timeObj = $.datepicker.parseTime(this._defaults.timeFormat, timeString, this._defaults);
				if (!timeObj) {
					return false;
				}
				$.extend(this, timeObj);
				return true;
			}
		},

		/*
  * Handle callback option after injecting timepicker
  */
		_afterInject: function _afterInject() {
			var o = this.inst.settings;
			if ($.isFunction(o.afterInject)) {
				o.afterInject.call(this);
			}
		},

		/*
  * generate and inject html for timepicker into ui datepicker
  */
		_injectTimePicker: function _injectTimePicker() {
			var $dp = this.inst.dpDiv,
			    o = this.inst.settings,
			    tp_inst = this,
			    litem = '',
			    uitem = '',
			    show = null,
			    max = {},
			    gridSize = {},
			    size = null,
			    i = 0,
			    l = 0;

			// Prevent displaying twice
			if ($dp.find("div.ui-timepicker-div").length === 0 && o.showTimepicker) {
				var noDisplay = ' ui_tpicker_unit_hide',
				    html = '<div class="ui-timepicker-div' + (o.isRTL ? ' ui-timepicker-rtl' : '') + (o.oneLine && o.controlType === 'select' ? ' ui-timepicker-oneLine' : '') + '"><dl>' + '<dt class="ui_tpicker_time_label' + (o.showTime ? '' : noDisplay) + '">' + o.timeText + '</dt>' + '<dd class="ui_tpicker_time ' + (o.showTime ? '' : noDisplay) + '"><input class="ui_tpicker_time_input" ' + (o.timeInput ? '' : 'disabled') + '/></dd>';

				// Create the markup
				for (i = 0, l = this.units.length; i < l; i++) {
					litem = this.units[i];
					uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1);
					show = o['show' + uitem] !== null ? o['show' + uitem] : this.support[litem];

					// Added by Peter Medeiros:
					// - Figure out what the hour/minute/second max should be based on the step values.
					// - Example: if stepMinute is 15, then minMax is 45.
					max[litem] = parseInt(o[litem + 'Max'] - (o[litem + 'Max'] - o[litem + 'Min']) % o['step' + uitem], 10);
					gridSize[litem] = 0;

					html += '<dt class="ui_tpicker_' + litem + '_label' + (show ? '' : noDisplay) + '">' + o[litem + 'Text'] + '</dt>' + '<dd class="ui_tpicker_' + litem + (show ? '' : noDisplay) + '"><div class="ui_tpicker_' + litem + '_slider' + (show ? '' : noDisplay) + '"></div>';

					if (show && o[litem + 'Grid'] > 0) {
						html += '<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>';

						if (litem === 'hour') {
							for (var h = o[litem + 'Min']; h <= max[litem]; h += parseInt(o[litem + 'Grid'], 10)) {
								gridSize[litem]++;
								var tmph = $.datepicker.formatTime(this.support.ampm ? 'hht' : 'HH', { hour: h }, o);
								html += '<td data-for="' + litem + '">' + tmph + '</td>';
							}
						} else {
							for (var m = o[litem + 'Min']; m <= max[litem]; m += parseInt(o[litem + 'Grid'], 10)) {
								gridSize[litem]++;
								html += '<td data-for="' + litem + '">' + (m < 10 ? '0' : '') + m + '</td>';
							}
						}

						html += '</tr></table></div>';
					}
					html += '</dd>';
				}

				// Timezone
				var showTz = o.showTimezone !== null ? o.showTimezone : this.support.timezone;
				html += '<dt class="ui_tpicker_timezone_label' + (showTz ? '' : noDisplay) + '">' + o.timezoneText + '</dt>';
				html += '<dd class="ui_tpicker_timezone' + (showTz ? '' : noDisplay) + '"></dd>';

				// Create the elements from string
				html += '</dl></div>';
				var $tp = $(html);

				// if we only want time picker...
				if (o.timeOnly === true) {
					$tp.prepend('<div class="ui-widget-header ui-helper-clearfix ui-corner-all">' + '<div class="ui-datepicker-title">' + o.timeOnlyTitle + '</div>' + '</div>');
					$dp.find('.ui-datepicker-header, .ui-datepicker-calendar').hide();
				}

				// add sliders, adjust grids, add events
				for (i = 0, l = tp_inst.units.length; i < l; i++) {
					litem = tp_inst.units[i];
					uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1);
					show = o['show' + uitem] !== null ? o['show' + uitem] : this.support[litem];

					// add the slider
					tp_inst[litem + '_slider'] = tp_inst.control.create(tp_inst, $tp.find('.ui_tpicker_' + litem + '_slider'), litem, tp_inst[litem], o[litem + 'Min'], max[litem], o['step' + uitem]);

					// adjust the grid and add click event
					if (show && o[litem + 'Grid'] > 0) {
						size = 100 * gridSize[litem] * o[litem + 'Grid'] / (max[litem] - o[litem + 'Min']);
						$tp.find('.ui_tpicker_' + litem + ' table').css({
							width: size + "%",
							marginLeft: o.isRTL ? '0' : size / (-2 * gridSize[litem]) + "%",
							marginRight: o.isRTL ? size / (-2 * gridSize[litem]) + "%" : '0',
							borderCollapse: 'collapse'
						}).find("td").click(function (e) {
							var $t = $(this),
							    h = $t.html(),
							    n = parseInt(h.replace(/[^0-9]/g), 10),
							    ap = h.replace(/[^apm]/ig),
							    f = $t.data('for'); // loses scope, so we use data-for

							if (f === 'hour') {
								if (ap.indexOf('p') !== -1 && n < 12) {
									n += 12;
								} else {
									if (ap.indexOf('a') !== -1 && n === 12) {
										n = 0;
									}
								}
							}

							tp_inst.control.value(tp_inst, tp_inst[f + '_slider'], litem, n);

							tp_inst._onTimeChange();
							tp_inst._onSelectHandler();
						}).css({
							cursor: 'pointer',
							width: 100 / gridSize[litem] + '%',
							textAlign: 'center',
							overflow: 'hidden'
						});
					} // end if grid > 0
				} // end for loop

				// Add timezone options
				this.timezone_select = $tp.find('.ui_tpicker_timezone').append('<select></select>').find("select");
				$.fn.append.apply(this.timezone_select, $.map(o.timezoneList, function (val, idx) {
					return $("<option />").val((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === "object" ? val.value : val).text((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === "object" ? val.label : val);
				}));
				if (typeof this.timezone !== "undefined" && this.timezone !== null && this.timezone !== "") {
					var local_timezone = new Date(this.inst.selectedYear, this.inst.selectedMonth, this.inst.selectedDay, 12).getTimezoneOffset() * -1;
					if (local_timezone === this.timezone) {
						selectLocalTimezone(tp_inst);
					} else {
						this.timezone_select.val(this.timezone);
					}
				} else {
					if (typeof this.hour !== "undefined" && this.hour !== null && this.hour !== "") {
						this.timezone_select.val(o.timezone);
					} else {
						selectLocalTimezone(tp_inst);
					}
				}
				this.timezone_select.change(function () {
					tp_inst._onTimeChange();
					tp_inst._onSelectHandler();
					tp_inst._afterInject();
				});
				// End timezone options

				// inject timepicker into datepicker
				var $buttonPanel = $dp.find('.ui-datepicker-buttonpane');
				if ($buttonPanel.length) {
					$buttonPanel.before($tp);
				} else {
					$dp.append($tp);
				}

				this.$timeObj = $tp.find('.ui_tpicker_time_input');
				this.$timeObj.change(function () {
					var timeFormat = tp_inst.inst.settings.timeFormat;
					var parsedTime = $.datepicker.parseTime(timeFormat, this.value);
					var update = new Date();
					if (parsedTime) {
						update.setHours(parsedTime.hour);
						update.setMinutes(parsedTime.minute);
						update.setSeconds(parsedTime.second);
						$.datepicker._setTime(tp_inst.inst, update);
					} else {
						this.value = tp_inst.formattedTime;
						this.blur();
					}
				});

				if (this.inst !== null) {
					var timeDefined = this.timeDefined;
					this._onTimeChange();
					this.timeDefined = timeDefined;
				}

				// slideAccess integration: http://trentrichardson.com/2011/11/11/jquery-ui-sliders-and-touch-accessibility/
				if (this._defaults.addSliderAccess) {
					var sliderAccessArgs = this._defaults.sliderAccessArgs,
					    rtl = this._defaults.isRTL;
					sliderAccessArgs.isRTL = rtl;

					setTimeout(function () {
						// fix for inline mode
						if ($tp.find('.ui-slider-access').length === 0) {
							$tp.find('.ui-slider:visible').sliderAccess(sliderAccessArgs);

							// fix any grids since sliders are shorter
							var sliderAccessWidth = $tp.find('.ui-slider-access:eq(0)').outerWidth(true);
							if (sliderAccessWidth) {
								$tp.find('table:visible').each(function () {
									var $g = $(this),
									    oldWidth = $g.outerWidth(),
									    oldMarginLeft = $g.css(rtl ? 'marginRight' : 'marginLeft').toString().replace('%', ''),
									    newWidth = oldWidth - sliderAccessWidth,
									    newMarginLeft = oldMarginLeft * newWidth / oldWidth + '%',
									    css = { width: newWidth, marginRight: 0, marginLeft: 0 };
									css[rtl ? 'marginRight' : 'marginLeft'] = newMarginLeft;
									$g.css(css);
								});
							}
						}
					}, 10);
				}
				// end slideAccess integration

				tp_inst._limitMinMaxDateTime(this.inst, true);
			}
		},

		/*
  * This function tries to limit the ability to go outside the
  * min/max date range
  */
		_limitMinMaxDateTime: function _limitMinMaxDateTime(dp_inst, adjustSliders) {
			var o = this._defaults,
			    dp_date = new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay);

			if (!this._defaults.showTimepicker) {
				return;
			} // No time so nothing to check here

			if ($.datepicker._get(dp_inst, 'minDateTime') !== null && $.datepicker._get(dp_inst, 'minDateTime') !== undefined && dp_date) {
				var minDateTime = $.datepicker._get(dp_inst, 'minDateTime'),
				    minDateTimeDate = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), 0, 0, 0, 0);

				if (this.hourMinOriginal === null || this.minuteMinOriginal === null || this.secondMinOriginal === null || this.millisecMinOriginal === null || this.microsecMinOriginal === null) {
					this.hourMinOriginal = o.hourMin;
					this.minuteMinOriginal = o.minuteMin;
					this.secondMinOriginal = o.secondMin;
					this.millisecMinOriginal = o.millisecMin;
					this.microsecMinOriginal = o.microsecMin;
				}

				if (dp_inst.settings.timeOnly || minDateTimeDate.getTime() === dp_date.getTime()) {
					this._defaults.hourMin = minDateTime.getHours();
					if (this.hour <= this._defaults.hourMin) {
						this.hour = this._defaults.hourMin;
						this._defaults.minuteMin = minDateTime.getMinutes();
						if (this.minute <= this._defaults.minuteMin) {
							this.minute = this._defaults.minuteMin;
							this._defaults.secondMin = minDateTime.getSeconds();
							if (this.second <= this._defaults.secondMin) {
								this.second = this._defaults.secondMin;
								this._defaults.millisecMin = minDateTime.getMilliseconds();
								if (this.millisec <= this._defaults.millisecMin) {
									this.millisec = this._defaults.millisecMin;
									this._defaults.microsecMin = minDateTime.getMicroseconds();
								} else {
									if (this.microsec < this._defaults.microsecMin) {
										this.microsec = this._defaults.microsecMin;
									}
									this._defaults.microsecMin = this.microsecMinOriginal;
								}
							} else {
								this._defaults.millisecMin = this.millisecMinOriginal;
								this._defaults.microsecMin = this.microsecMinOriginal;
							}
						} else {
							this._defaults.secondMin = this.secondMinOriginal;
							this._defaults.millisecMin = this.millisecMinOriginal;
							this._defaults.microsecMin = this.microsecMinOriginal;
						}
					} else {
						this._defaults.minuteMin = this.minuteMinOriginal;
						this._defaults.secondMin = this.secondMinOriginal;
						this._defaults.millisecMin = this.millisecMinOriginal;
						this._defaults.microsecMin = this.microsecMinOriginal;
					}
				} else {
					this._defaults.hourMin = this.hourMinOriginal;
					this._defaults.minuteMin = this.minuteMinOriginal;
					this._defaults.secondMin = this.secondMinOriginal;
					this._defaults.millisecMin = this.millisecMinOriginal;
					this._defaults.microsecMin = this.microsecMinOriginal;
				}
			}

			if ($.datepicker._get(dp_inst, 'maxDateTime') !== null && $.datepicker._get(dp_inst, 'maxDateTime') !== undefined && dp_date) {
				var maxDateTime = $.datepicker._get(dp_inst, 'maxDateTime'),
				    maxDateTimeDate = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), 0, 0, 0, 0);

				if (this.hourMaxOriginal === null || this.minuteMaxOriginal === null || this.secondMaxOriginal === null || this.millisecMaxOriginal === null) {
					this.hourMaxOriginal = o.hourMax;
					this.minuteMaxOriginal = o.minuteMax;
					this.secondMaxOriginal = o.secondMax;
					this.millisecMaxOriginal = o.millisecMax;
					this.microsecMaxOriginal = o.microsecMax;
				}

				if (dp_inst.settings.timeOnly || maxDateTimeDate.getTime() === dp_date.getTime()) {
					this._defaults.hourMax = maxDateTime.getHours();
					if (this.hour >= this._defaults.hourMax) {
						this.hour = this._defaults.hourMax;
						this._defaults.minuteMax = maxDateTime.getMinutes();
						if (this.minute >= this._defaults.minuteMax) {
							this.minute = this._defaults.minuteMax;
							this._defaults.secondMax = maxDateTime.getSeconds();
							if (this.second >= this._defaults.secondMax) {
								this.second = this._defaults.secondMax;
								this._defaults.millisecMax = maxDateTime.getMilliseconds();
								if (this.millisec >= this._defaults.millisecMax) {
									this.millisec = this._defaults.millisecMax;
									this._defaults.microsecMax = maxDateTime.getMicroseconds();
								} else {
									if (this.microsec > this._defaults.microsecMax) {
										this.microsec = this._defaults.microsecMax;
									}
									this._defaults.microsecMax = this.microsecMaxOriginal;
								}
							} else {
								this._defaults.millisecMax = this.millisecMaxOriginal;
								this._defaults.microsecMax = this.microsecMaxOriginal;
							}
						} else {
							this._defaults.secondMax = this.secondMaxOriginal;
							this._defaults.millisecMax = this.millisecMaxOriginal;
							this._defaults.microsecMax = this.microsecMaxOriginal;
						}
					} else {
						this._defaults.minuteMax = this.minuteMaxOriginal;
						this._defaults.secondMax = this.secondMaxOriginal;
						this._defaults.millisecMax = this.millisecMaxOriginal;
						this._defaults.microsecMax = this.microsecMaxOriginal;
					}
				} else {
					this._defaults.hourMax = this.hourMaxOriginal;
					this._defaults.minuteMax = this.minuteMaxOriginal;
					this._defaults.secondMax = this.secondMaxOriginal;
					this._defaults.millisecMax = this.millisecMaxOriginal;
					this._defaults.microsecMax = this.microsecMaxOriginal;
				}
			}

			if (dp_inst.settings.minTime !== null) {
				var tempMinTime = new Date("01/01/1970 " + dp_inst.settings.minTime);
				if (this.hour < tempMinTime.getHours()) {
					this.hour = this._defaults.hourMin = tempMinTime.getHours();
					this.minute = this._defaults.minuteMin = tempMinTime.getMinutes();
				} else if (this.hour === tempMinTime.getHours() && this.minute < tempMinTime.getMinutes()) {
					this.minute = this._defaults.minuteMin = tempMinTime.getMinutes();
				} else {
					if (this._defaults.hourMin < tempMinTime.getHours()) {
						this._defaults.hourMin = tempMinTime.getHours();
						this._defaults.minuteMin = tempMinTime.getMinutes();
					} else if (this._defaults.hourMin === tempMinTime.getHours() === this.hour && this._defaults.minuteMin < tempMinTime.getMinutes()) {
						this._defaults.minuteMin = tempMinTime.getMinutes();
					} else {
						this._defaults.minuteMin = 0;
					}
				}
			}

			if (dp_inst.settings.maxTime !== null) {
				var tempMaxTime = new Date("01/01/1970 " + dp_inst.settings.maxTime);
				if (this.hour > tempMaxTime.getHours()) {
					this.hour = this._defaults.hourMax = tempMaxTime.getHours();
					this.minute = this._defaults.minuteMax = tempMaxTime.getMinutes();
				} else if (this.hour === tempMaxTime.getHours() && this.minute > tempMaxTime.getMinutes()) {
					this.minute = this._defaults.minuteMax = tempMaxTime.getMinutes();
				} else {
					if (this._defaults.hourMax > tempMaxTime.getHours()) {
						this._defaults.hourMax = tempMaxTime.getHours();
						this._defaults.minuteMax = tempMaxTime.getMinutes();
					} else if (this._defaults.hourMax === tempMaxTime.getHours() === this.hour && this._defaults.minuteMax > tempMaxTime.getMinutes()) {
						this._defaults.minuteMax = tempMaxTime.getMinutes();
					} else {
						this._defaults.minuteMax = 59;
					}
				}
			}

			if (adjustSliders !== undefined && adjustSliders === true) {
				var hourMax = parseInt(this._defaults.hourMax - (this._defaults.hourMax - this._defaults.hourMin) % this._defaults.stepHour, 10),
				    minMax = parseInt(this._defaults.minuteMax - (this._defaults.minuteMax - this._defaults.minuteMin) % this._defaults.stepMinute, 10),
				    secMax = parseInt(this._defaults.secondMax - (this._defaults.secondMax - this._defaults.secondMin) % this._defaults.stepSecond, 10),
				    millisecMax = parseInt(this._defaults.millisecMax - (this._defaults.millisecMax - this._defaults.millisecMin) % this._defaults.stepMillisec, 10),
				    microsecMax = parseInt(this._defaults.microsecMax - (this._defaults.microsecMax - this._defaults.microsecMin) % this._defaults.stepMicrosec, 10);

				if (this.hour_slider) {
					this.control.options(this, this.hour_slider, 'hour', { min: this._defaults.hourMin, max: hourMax, step: this._defaults.stepHour });
					this.control.value(this, this.hour_slider, 'hour', this.hour - this.hour % this._defaults.stepHour);
				}
				if (this.minute_slider) {
					this.control.options(this, this.minute_slider, 'minute', { min: this._defaults.minuteMin, max: minMax, step: this._defaults.stepMinute });
					this.control.value(this, this.minute_slider, 'minute', this.minute - this.minute % this._defaults.stepMinute);
				}
				if (this.second_slider) {
					this.control.options(this, this.second_slider, 'second', { min: this._defaults.secondMin, max: secMax, step: this._defaults.stepSecond });
					this.control.value(this, this.second_slider, 'second', this.second - this.second % this._defaults.stepSecond);
				}
				if (this.millisec_slider) {
					this.control.options(this, this.millisec_slider, 'millisec', { min: this._defaults.millisecMin, max: millisecMax, step: this._defaults.stepMillisec });
					this.control.value(this, this.millisec_slider, 'millisec', this.millisec - this.millisec % this._defaults.stepMillisec);
				}
				if (this.microsec_slider) {
					this.control.options(this, this.microsec_slider, 'microsec', { min: this._defaults.microsecMin, max: microsecMax, step: this._defaults.stepMicrosec });
					this.control.value(this, this.microsec_slider, 'microsec', this.microsec - this.microsec % this._defaults.stepMicrosec);
				}
			}
		},

		/*
  * when a slider moves, set the internal time...
  * on time change is also called when the time is updated in the text field
  */
		_onTimeChange: function _onTimeChange() {
			if (!this._defaults.showTimepicker) {
				return;
			}
			var hour = this.hour_slider ? this.control.value(this, this.hour_slider, 'hour') : false,
			    minute = this.minute_slider ? this.control.value(this, this.minute_slider, 'minute') : false,
			    second = this.second_slider ? this.control.value(this, this.second_slider, 'second') : false,
			    millisec = this.millisec_slider ? this.control.value(this, this.millisec_slider, 'millisec') : false,
			    microsec = this.microsec_slider ? this.control.value(this, this.microsec_slider, 'microsec') : false,
			    timezone = this.timezone_select ? this.timezone_select.val() : false,
			    o = this._defaults,
			    pickerTimeFormat = o.pickerTimeFormat || o.timeFormat,
			    pickerTimeSuffix = o.pickerTimeSuffix || o.timeSuffix;

			if ((typeof hour === 'undefined' ? 'undefined' : _typeof(hour)) === 'object') {
				hour = false;
			}
			if ((typeof minute === 'undefined' ? 'undefined' : _typeof(minute)) === 'object') {
				minute = false;
			}
			if ((typeof second === 'undefined' ? 'undefined' : _typeof(second)) === 'object') {
				second = false;
			}
			if ((typeof millisec === 'undefined' ? 'undefined' : _typeof(millisec)) === 'object') {
				millisec = false;
			}
			if ((typeof microsec === 'undefined' ? 'undefined' : _typeof(microsec)) === 'object') {
				microsec = false;
			}
			if ((typeof timezone === 'undefined' ? 'undefined' : _typeof(timezone)) === 'object') {
				timezone = false;
			}

			if (hour !== false) {
				hour = parseInt(hour, 10);
			}
			if (minute !== false) {
				minute = parseInt(minute, 10);
			}
			if (second !== false) {
				second = parseInt(second, 10);
			}
			if (millisec !== false) {
				millisec = parseInt(millisec, 10);
			}
			if (microsec !== false) {
				microsec = parseInt(microsec, 10);
			}
			if (timezone !== false) {
				timezone = timezone.toString();
			}

			var ampm = o[hour < 12 ? 'amNames' : 'pmNames'][0];

			// If the update was done in the input field, the input field should not be updated.
			// If the update was done using the sliders, update the input field.
			var hasChanged = hour !== parseInt(this.hour, 10) || // sliders should all be numeric
			minute !== parseInt(this.minute, 10) || second !== parseInt(this.second, 10) || millisec !== parseInt(this.millisec, 10) || microsec !== parseInt(this.microsec, 10) || this.ampm.length > 0 && hour < 12 !== ($.inArray(this.ampm.toUpperCase(), this.amNames) !== -1) || this.timezone !== null && timezone !== this.timezone.toString() // could be numeric or "EST" format, so use toString()
			;

			if (hasChanged) {

				if (hour !== false) {
					this.hour = hour;
				}
				if (minute !== false) {
					this.minute = minute;
				}
				if (second !== false) {
					this.second = second;
				}
				if (millisec !== false) {
					this.millisec = millisec;
				}
				if (microsec !== false) {
					this.microsec = microsec;
				}
				if (timezone !== false) {
					this.timezone = timezone;
				}

				if (!this.inst) {
					this.inst = $.datepicker._getInst(this.$input[0]);
				}

				this._limitMinMaxDateTime(this.inst, true);
			}
			if (this.support.ampm) {
				this.ampm = ampm;
			}

			// Updates the time within the timepicker
			this.formattedTime = $.datepicker.formatTime(o.timeFormat, this, o);
			if (this.$timeObj) {
				if (pickerTimeFormat === o.timeFormat) {
					this.$timeObj.val(this.formattedTime + pickerTimeSuffix);
				} else {
					this.$timeObj.val($.datepicker.formatTime(pickerTimeFormat, this, o) + pickerTimeSuffix);
				}
				if (this.$timeObj[0].setSelectionRange) {
					var sPos = this.$timeObj[0].selectionStart;
					var ePos = this.$timeObj[0].selectionEnd;
					this.$timeObj[0].setSelectionRange(sPos, ePos);
				}
			}

			this.timeDefined = true;
			if (hasChanged) {
				this._updateDateTime();
				//this.$input.focus(); // may automatically open the picker on setDate
			}
		},

		/*
  * call custom onSelect.
  * bind to sliders slidestop, and grid click.
  */
		_onSelectHandler: function _onSelectHandler() {
			var onSelect = this._defaults.onSelect || this.inst.settings.onSelect;
			var inputEl = this.$input ? this.$input[0] : null;
			if (onSelect && inputEl) {
				onSelect.apply(inputEl, [this.formattedDateTime, this]);
			}
		},

		/*
  * update our input with the new date time..
  */
		_updateDateTime: function _updateDateTime(dp_inst) {
			dp_inst = this.inst || dp_inst;
			var dtTmp = dp_inst.currentYear > 0 ? new Date(dp_inst.currentYear, dp_inst.currentMonth, dp_inst.currentDay) : new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay),
			    dt = $.datepicker._daylightSavingAdjust(dtTmp),

			//dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay)),
			//dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.currentYear, dp_inst.currentMonth, dp_inst.currentDay)),
			dateFmt = $.datepicker._get(dp_inst, 'dateFormat'),
			    formatCfg = $.datepicker._getFormatConfig(dp_inst),
			    timeAvailable = dt !== null && this.timeDefined;
			this.formattedDate = $.datepicker.formatDate(dateFmt, dt === null ? new Date() : dt, formatCfg);
			var formattedDateTime = this.formattedDate;

			// if a slider was changed but datepicker doesn't have a value yet, set it
			if (dp_inst.lastVal === "") {
				dp_inst.currentYear = dp_inst.selectedYear;
				dp_inst.currentMonth = dp_inst.selectedMonth;
				dp_inst.currentDay = dp_inst.selectedDay;
			}

			/*
   * remove following lines to force every changes in date picker to change the input value
   * Bug descriptions: when an input field has a default value, and click on the field to pop up the date picker.
   * If the user manually empty the value in the input field, the date picker will never change selected value.
   */
			//if (dp_inst.lastVal !== undefined && (dp_inst.lastVal.length > 0 && this.$input.val().length === 0)) {
			//	return;
			//}

			if (this._defaults.timeOnly === true && this._defaults.timeOnlyShowDate === false) {
				formattedDateTime = this.formattedTime;
			} else if (this._defaults.timeOnly !== true && (this._defaults.alwaysSetTime || timeAvailable) || this._defaults.timeOnly === true && this._defaults.timeOnlyShowDate === true) {
				formattedDateTime += this._defaults.separator + this.formattedTime + this._defaults.timeSuffix;
			}

			this.formattedDateTime = formattedDateTime;

			if (!this._defaults.showTimepicker) {
				this.$input.val(this.formattedDate);
			} else if (this.$altInput && this._defaults.timeOnly === false && this._defaults.altFieldTimeOnly === true) {
				this.$altInput.val(this.formattedTime);
				this.$input.val(this.formattedDate);
			} else if (this.$altInput) {
				this.$input.val(formattedDateTime);
				var altFormattedDateTime = '',
				    altSeparator = this._defaults.altSeparator !== null ? this._defaults.altSeparator : this._defaults.separator,
				    altTimeSuffix = this._defaults.altTimeSuffix !== null ? this._defaults.altTimeSuffix : this._defaults.timeSuffix;

				if (!this._defaults.timeOnly) {
					if (this._defaults.altFormat) {
						altFormattedDateTime = $.datepicker.formatDate(this._defaults.altFormat, dt === null ? new Date() : dt, formatCfg);
					} else {
						altFormattedDateTime = this.formattedDate;
					}

					if (altFormattedDateTime) {
						altFormattedDateTime += altSeparator;
					}
				}

				if (this._defaults.altTimeFormat !== null) {
					altFormattedDateTime += $.datepicker.formatTime(this._defaults.altTimeFormat, this, this._defaults) + altTimeSuffix;
				} else {
					altFormattedDateTime += this.formattedTime + altTimeSuffix;
				}
				this.$altInput.val(altFormattedDateTime);
			} else {
				this.$input.val(formattedDateTime);
			}

			this.$input.trigger("change");
		},

		_onFocus: function _onFocus() {
			if (!this.$input.val() && this._defaults.defaultValue) {
				this.$input.val(this._defaults.defaultValue);
				var inst = $.datepicker._getInst(this.$input.get(0)),
				    tp_inst = $.datepicker._get(inst, 'timepicker');
				if (tp_inst) {
					if (tp_inst._defaults.timeOnly && inst.input.val() !== inst.lastVal) {
						try {
							$.datepicker._updateDatepicker(inst);
						} catch (err) {
							$.timepicker.log(err);
						}
					}
				}
			}
		},

		/*
  * Small abstraction to control types
  * We can add more, just be sure to follow the pattern: create, options, value
  */
		_controls: {
			// slider methods
			slider: {
				create: function create(tp_inst, obj, unit, val, min, max, step) {
					var rtl = tp_inst._defaults.isRTL; // if rtl go -60->0 instead of 0->60
					return obj.prop('slide', null).slider({
						orientation: "horizontal",
						value: rtl ? val * -1 : val,
						min: rtl ? max * -1 : min,
						max: rtl ? min * -1 : max,
						step: step,
						slide: function slide(event, ui) {
							tp_inst.control.value(tp_inst, $(this), unit, rtl ? ui.value * -1 : ui.value);
							tp_inst._onTimeChange();
						},
						stop: function stop(event, ui) {
							tp_inst._onSelectHandler();
						}
					});
				},
				options: function options(tp_inst, obj, unit, opts, val) {
					if (tp_inst._defaults.isRTL) {
						if (typeof opts === 'string') {
							if (opts === 'min' || opts === 'max') {
								if (val !== undefined) {
									return obj.slider(opts, val * -1);
								}
								return Math.abs(obj.slider(opts));
							}
							return obj.slider(opts);
						}
						var min = opts.min,
						    max = opts.max;
						opts.min = opts.max = null;
						if (min !== undefined) {
							opts.max = min * -1;
						}
						if (max !== undefined) {
							opts.min = max * -1;
						}
						return obj.slider(opts);
					}
					if (typeof opts === 'string' && val !== undefined) {
						return obj.slider(opts, val);
					}
					return obj.slider(opts);
				},
				value: function value(tp_inst, obj, unit, val) {
					if (tp_inst._defaults.isRTL) {
						if (val !== undefined) {
							return obj.slider('value', val * -1);
						}
						return Math.abs(obj.slider('value'));
					}
					if (val !== undefined) {
						return obj.slider('value', val);
					}
					return obj.slider('value');
				}
			},
			// select methods
			select: {
				create: function create(tp_inst, obj, unit, val, min, max, step) {
					var sel = '<select class="ui-timepicker-select ui-state-default ui-corner-all" data-unit="' + unit + '" data-min="' + min + '" data-max="' + max + '" data-step="' + step + '">',
					    format = tp_inst._defaults.pickerTimeFormat || tp_inst._defaults.timeFormat;

					for (var i = min; i <= max; i += step) {
						sel += '<option value="' + i + '"' + (i === val ? ' selected' : '') + '>';
						if (unit === 'hour') {
							sel += $.datepicker.formatTime($.trim(format.replace(/[^ht ]/ig, '')), { hour: i }, tp_inst._defaults);
						} else if (unit === 'millisec' || unit === 'microsec' || i >= 10) {
							sel += i;
						} else {
							sel += '0' + i.toString();
						}
						sel += '</option>';
					}
					sel += '</select>';

					obj.children('select').remove();

					$(sel).appendTo(obj).change(function (e) {
						tp_inst._onTimeChange();
						tp_inst._onSelectHandler();
						tp_inst._afterInject();
					});

					return obj;
				},
				options: function options(tp_inst, obj, unit, opts, val) {
					var o = {},
					    $t = obj.children('select');
					if (typeof opts === 'string') {
						if (val === undefined) {
							return $t.data(opts);
						}
						o[opts] = val;
					} else {
						o = opts;
					}
					return tp_inst.control.create(tp_inst, obj, $t.data('unit'), $t.val(), o.min >= 0 ? o.min : $t.data('min'), o.max || $t.data('max'), o.step || $t.data('step'));
				},
				value: function value(tp_inst, obj, unit, val) {
					var $t = obj.children('select');
					if (val !== undefined) {
						return $t.val(val);
					}
					return $t.val();
				}
			} // end _controls

		} });

	$.fn.extend({
		/*
  * shorthand just to use timepicker.
  */
		timepicker: function timepicker(o) {
			o = o || {};
			var tmp_args = Array.prototype.slice.call(arguments);

			if ((typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object') {
				tmp_args[0] = $.extend(o, {
					timeOnly: true
				});
			}

			return $(this).each(function () {
				$.fn.datetimepicker.apply($(this), tmp_args);
			});
		},

		/*
  * extend timepicker to datepicker
  */
		datetimepicker: function datetimepicker(o) {
			o = o || {};
			var tmp_args = arguments;

			if (typeof o === 'string') {
				if (o === 'getDate' || o === 'option' && tmp_args.length === 2 && typeof tmp_args[1] === 'string') {
					return $.fn.datepicker.apply($(this[0]), tmp_args);
				} else {
					return this.each(function () {
						var $t = $(this);
						$t.datepicker.apply($t, tmp_args);
					});
				}
			} else {
				return this.each(function () {
					var $t = $(this);
					$t.datepicker($.timepicker._newInst($t, o)._defaults);
				});
			}
		}
	});

	/*
 * Public Utility to parse date and time
 */
	$.datepicker = $.datepicker || {};
	$.datepicker.parseDateTime = function (dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
		var parseRes = parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings);
		if (parseRes.timeObj) {
			var t = parseRes.timeObj;
			parseRes.date.setHours(t.hour, t.minute, t.second, t.millisec);
			parseRes.date.setMicroseconds(t.microsec);
		}

		return parseRes.date;
	};

	/*
 * Public utility to parse time
 */
	$.datepicker.parseTime = function (timeFormat, timeString, options) {
		var o = extendRemove(extendRemove({}, $.timepicker._defaults), options || {}),
		    iso8601 = timeFormat.replace(/\'.*?\'/g, '').indexOf('Z') !== -1;

		// Strict parse requires the timeString to match the timeFormat exactly
		var strictParse = function strictParse(f, s, o) {

			// pattern for standard and localized AM/PM markers
			var getPatternAmpm = function getPatternAmpm(amNames, pmNames) {
				var markers = [];
				if (amNames) {
					$.merge(markers, amNames);
				}
				if (pmNames) {
					$.merge(markers, pmNames);
				}
				markers = $.map(markers, function (val) {
					return val.replace(/[.*+?|()\[\]{}\\]/g, '\\$&');
				});
				return '(' + markers.join('|') + ')?';
			};

			// figure out position of time elements.. cause js cant do named captures
			var getFormatPositions = function getFormatPositions(timeFormat) {
				var finds = timeFormat.toLowerCase().match(/(h{1,2}|m{1,2}|s{1,2}|l{1}|c{1}|t{1,2}|z|'.*?')/g),
				    orders = {
					h: -1,
					m: -1,
					s: -1,
					l: -1,
					c: -1,
					t: -1,
					z: -1
				};

				if (finds) {
					for (var i = 0; i < finds.length; i++) {
						if (orders[finds[i].toString().charAt(0)] === -1) {
							orders[finds[i].toString().charAt(0)] = i + 1;
						}
					}
				}
				return orders;
			};

			var regstr = '^' + f.toString().replace(/([hH]{1,2}|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|'.*?')/g, function (match) {
				var ml = match.length;
				switch (match.charAt(0).toLowerCase()) {
					case 'h':
						return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
					case 'm':
						return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
					case 's':
						return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
					case 'l':
						return '(\\d?\\d?\\d)';
					case 'c':
						return '(\\d?\\d?\\d)';
					case 'z':
						return '(z|[-+]\\d\\d:?\\d\\d|\\S+)?';
					case 't':
						return getPatternAmpm(o.amNames, o.pmNames);
					default:
						// literal escaped in quotes
						return '(' + match.replace(/\'/g, "").replace(/(\.|\$|\^|\\|\/|\(|\)|\[|\]|\?|\+|\*)/g, function (m) {
							return "\\" + m;
						}) + ')?';
				}
			}).replace(/\s/g, '\\s?') + o.timeSuffix + '$',
			    order = getFormatPositions(f),
			    ampm = '',
			    treg;

			treg = s.match(new RegExp(regstr, 'i'));

			var resTime = {
				hour: 0,
				minute: 0,
				second: 0,
				millisec: 0,
				microsec: 0
			};

			if (treg) {
				if (order.t !== -1) {
					if (treg[order.t] === undefined || treg[order.t].length === 0) {
						ampm = '';
						resTime.ampm = '';
					} else {
						ampm = $.inArray(treg[order.t].toUpperCase(), $.map(o.amNames, function (x, i) {
							return x.toUpperCase();
						})) !== -1 ? 'AM' : 'PM';
						resTime.ampm = o[ampm === 'AM' ? 'amNames' : 'pmNames'][0];
					}
				}

				if (order.h !== -1) {
					if (ampm === 'AM' && treg[order.h] === '12') {
						resTime.hour = 0; // 12am = 0 hour
					} else {
						if (ampm === 'PM' && treg[order.h] !== '12') {
							resTime.hour = parseInt(treg[order.h], 10) + 12; // 12pm = 12 hour, any other pm = hour + 12
						} else {
							resTime.hour = Number(treg[order.h]);
						}
					}
				}

				if (order.m !== -1) {
					resTime.minute = Number(treg[order.m]);
				}
				if (order.s !== -1) {
					resTime.second = Number(treg[order.s]);
				}
				if (order.l !== -1) {
					resTime.millisec = Number(treg[order.l]);
				}
				if (order.c !== -1) {
					resTime.microsec = Number(treg[order.c]);
				}
				if (order.z !== -1 && treg[order.z] !== undefined) {
					resTime.timezone = $.timepicker.timezoneOffsetNumber(treg[order.z]);
				}

				return resTime;
			}
			return false;
		}; // end strictParse

		// First try JS Date, if that fails, use strictParse
		var looseParse = function looseParse(f, s, o) {
			try {
				var d = new Date('2012-01-01 ' + s);
				if (isNaN(d.getTime())) {
					d = new Date('2012-01-01T' + s);
					if (isNaN(d.getTime())) {
						d = new Date('01/01/2012 ' + s);
						if (isNaN(d.getTime())) {
							throw "Unable to parse time with native Date: " + s;
						}
					}
				}

				return {
					hour: d.getHours(),
					minute: d.getMinutes(),
					second: d.getSeconds(),
					millisec: d.getMilliseconds(),
					microsec: d.getMicroseconds(),
					timezone: d.getTimezoneOffset() * -1
				};
			} catch (err) {
				try {
					return strictParse(f, s, o);
				} catch (err2) {
					$.timepicker.log("Unable to parse \ntimeString: " + s + "\ntimeFormat: " + f);
				}
			}
			return false;
		}; // end looseParse

		if (typeof o.parse === "function") {
			return o.parse(timeFormat, timeString, o);
		}
		if (o.parse === 'loose') {
			return looseParse(timeFormat, timeString, o);
		}
		return strictParse(timeFormat, timeString, o);
	};

	/**
  * Public utility to format the time
  * @param {string} format format of the time
  * @param {Object} time Object not a Date for timezones
  * @param {Object} [options] essentially the regional[].. amNames, pmNames, ampm
  * @returns {string} the formatted time
  */
	$.datepicker.formatTime = function (format, time, options) {
		options = options || {};
		options = $.extend({}, $.timepicker._defaults, options);
		time = $.extend({
			hour: 0,
			minute: 0,
			second: 0,
			millisec: 0,
			microsec: 0,
			timezone: null
		}, time);

		var tmptime = format,
		    ampmName = options.amNames[0],
		    hour = parseInt(time.hour, 10);

		if (hour > 11) {
			ampmName = options.pmNames[0];
		}

		tmptime = tmptime.replace(/(?:HH?|hh?|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|'.*?')/g, function (match) {
			switch (match) {
				case 'HH':
					return ('0' + hour).slice(-2);
				case 'H':
					return hour;
				case 'hh':
					return ('0' + convert24to12(hour)).slice(-2);
				case 'h':
					return convert24to12(hour);
				case 'mm':
					return ('0' + time.minute).slice(-2);
				case 'm':
					return time.minute;
				case 'ss':
					return ('0' + time.second).slice(-2);
				case 's':
					return time.second;
				case 'l':
					return ('00' + time.millisec).slice(-3);
				case 'c':
					return ('00' + time.microsec).slice(-3);
				case 'z':
					return $.timepicker.timezoneOffsetString(time.timezone === null ? options.timezone : time.timezone, false);
				case 'Z':
					return $.timepicker.timezoneOffsetString(time.timezone === null ? options.timezone : time.timezone, true);
				case 'T':
					return ampmName.charAt(0).toUpperCase();
				case 'TT':
					return ampmName.toUpperCase();
				case 't':
					return ampmName.charAt(0).toLowerCase();
				case 'tt':
					return ampmName.toLowerCase();
				default:
					return match.replace(/'/g, "");
			}
		});

		return tmptime;
	};

	/*
 * the bad hack :/ override datepicker so it doesn't close on select
 // inspired: http://stackoverflow.com/questions/1252512/jquery-datepicker-prevent-closing-picker-when-clicking-a-date/1762378#1762378
 */
	$.datepicker._base_selectDate = $.datepicker._selectDate;
	$.datepicker._selectDate = function (id, dateStr) {
		var inst = this._getInst($(id)[0]),
		    tp_inst = this._get(inst, 'timepicker'),
		    was_inline;

		if (tp_inst && inst.settings.showTimepicker) {
			tp_inst._limitMinMaxDateTime(inst, true);
			was_inline = inst.inline;
			inst.inline = inst.stay_open = true;
			//This way the onSelect handler called from calendarpicker get the full dateTime
			this._base_selectDate(id, dateStr);
			inst.inline = was_inline;
			inst.stay_open = false;
			this._notifyChange(inst);
			this._updateDatepicker(inst);
		} else {
			this._base_selectDate(id, dateStr);
		}
	};

	/*
 * second bad hack :/ override datepicker so it triggers an event when changing the input field
 * and does not redraw the datepicker on every selectDate event
 */
	$.datepicker._base_updateDatepicker = $.datepicker._updateDatepicker;
	$.datepicker._updateDatepicker = function (inst) {

		// don't popup the datepicker if there is another instance already opened
		var input = inst.input[0];
		if ($.datepicker._curInst && $.datepicker._curInst !== inst && $.datepicker._datepickerShowing && $.datepicker._lastInput !== input) {
			return;
		}

		if (typeof inst.stay_open !== 'boolean' || inst.stay_open === false) {

			this._base_updateDatepicker(inst);

			// Reload the time control when changing something in the input text field.
			var tp_inst = this._get(inst, 'timepicker');
			if (tp_inst) {
				tp_inst._addTimePicker(inst);
			}
		}
	};

	/*
 * third bad hack :/ override datepicker so it allows spaces and colon in the input field
 */
	$.datepicker._base_doKeyPress = $.datepicker._doKeyPress;
	$.datepicker._doKeyPress = function (event) {
		var inst = $.datepicker._getInst(event.target),
		    tp_inst = $.datepicker._get(inst, 'timepicker');

		if (tp_inst) {
			if ($.datepicker._get(inst, 'constrainInput')) {
				var ampm = tp_inst.support.ampm,
				    tz = tp_inst._defaults.showTimezone !== null ? tp_inst._defaults.showTimezone : tp_inst.support.timezone,
				    dateChars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat')),
				    datetimeChars = tp_inst._defaults.timeFormat.toString().replace(/[hms]/g, '').replace(/TT/g, ampm ? 'APM' : '').replace(/Tt/g, ampm ? 'AaPpMm' : '').replace(/tT/g, ampm ? 'AaPpMm' : '').replace(/T/g, ampm ? 'AP' : '').replace(/tt/g, ampm ? 'apm' : '').replace(/t/g, ampm ? 'ap' : '') + " " + tp_inst._defaults.separator + tp_inst._defaults.timeSuffix + (tz ? tp_inst._defaults.timezoneList.join('') : '') + tp_inst._defaults.amNames.join('') + tp_inst._defaults.pmNames.join('') + dateChars,
				    chr = String.fromCharCode(event.charCode === undefined ? event.keyCode : event.charCode);
				return event.ctrlKey || chr < ' ' || !dateChars || datetimeChars.indexOf(chr) > -1;
			}
		}

		return $.datepicker._base_doKeyPress(event);
	};

	/*
 * Fourth bad hack :/ override _updateAlternate function used in inline mode to init altField
 * Update any alternate field to synchronise with the main field.
 */
	$.datepicker._base_updateAlternate = $.datepicker._updateAlternate;
	$.datepicker._updateAlternate = function (inst) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var altField = tp_inst._defaults.altField;
			if (altField) {
				// update alternate field too
				var altFormat = tp_inst._defaults.altFormat || tp_inst._defaults.dateFormat,
				    date = this._getDate(inst),
				    formatCfg = $.datepicker._getFormatConfig(inst),
				    altFormattedDateTime = '',
				    altSeparator = tp_inst._defaults.altSeparator ? tp_inst._defaults.altSeparator : tp_inst._defaults.separator,
				    altTimeSuffix = tp_inst._defaults.altTimeSuffix ? tp_inst._defaults.altTimeSuffix : tp_inst._defaults.timeSuffix,
				    altTimeFormat = tp_inst._defaults.altTimeFormat !== null ? tp_inst._defaults.altTimeFormat : tp_inst._defaults.timeFormat;

				altFormattedDateTime += $.datepicker.formatTime(altTimeFormat, tp_inst, tp_inst._defaults) + altTimeSuffix;
				if (!tp_inst._defaults.timeOnly && !tp_inst._defaults.altFieldTimeOnly && date !== null) {
					if (tp_inst._defaults.altFormat) {
						altFormattedDateTime = $.datepicker.formatDate(tp_inst._defaults.altFormat, date, formatCfg) + altSeparator + altFormattedDateTime;
					} else {
						altFormattedDateTime = tp_inst.formattedDate + altSeparator + altFormattedDateTime;
					}
				}
				$(altField).val(inst.input.val() ? altFormattedDateTime : "");
			}
		} else {
			$.datepicker._base_updateAlternate(inst);
		}
	};

	/*
 * Override key up event to sync manual input changes.
 */
	$.datepicker._base_doKeyUp = $.datepicker._doKeyUp;
	$.datepicker._doKeyUp = function (event) {
		var inst = $.datepicker._getInst(event.target),
		    tp_inst = $.datepicker._get(inst, 'timepicker');

		if (tp_inst) {
			if (tp_inst._defaults.timeOnly && inst.input.val() !== inst.lastVal) {
				try {
					$.datepicker._updateDatepicker(inst);
				} catch (err) {
					$.timepicker.log(err);
				}
			}
		}

		return $.datepicker._base_doKeyUp(event);
	};

	/*
 * override "Today" button to also grab the time and set it to input field.
 */
	$.datepicker._base_gotoToday = $.datepicker._gotoToday;
	$.datepicker._gotoToday = function (id) {
		var inst = this._getInst($(id)[0]);
		this._base_gotoToday(id);
		var tp_inst = this._get(inst, 'timepicker');
		if (!tp_inst) {
			return;
		}

		var tzoffset = $.timepicker.timezoneOffsetNumber(tp_inst.timezone);
		var now = new Date();
		now.setMinutes(now.getMinutes() + now.getTimezoneOffset() + parseInt(tzoffset, 10));
		this._setTime(inst, now);
		this._setDate(inst, now);
		tp_inst._onSelectHandler();
	};

	/*
 * Disable & enable the Time in the datetimepicker
 */
	$.datepicker._disableTimepickerDatepicker = function (target) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');
		$(target).datepicker('getDate'); // Init selected[Year|Month|Day]
		if (tp_inst) {
			inst.settings.showTimepicker = false;
			tp_inst._defaults.showTimepicker = false;
			tp_inst._updateDateTime(inst);
		}
	};

	$.datepicker._enableTimepickerDatepicker = function (target) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');
		$(target).datepicker('getDate'); // Init selected[Year|Month|Day]
		if (tp_inst) {
			inst.settings.showTimepicker = true;
			tp_inst._defaults.showTimepicker = true;
			tp_inst._addTimePicker(inst); // Could be disabled on page load
			tp_inst._updateDateTime(inst);
		}
	};

	/*
 * Create our own set time function
 */
	$.datepicker._setTime = function (inst, date) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var defaults = tp_inst._defaults;

			// calling _setTime with no date sets time to defaults
			tp_inst.hour = date ? date.getHours() : defaults.hour;
			tp_inst.minute = date ? date.getMinutes() : defaults.minute;
			tp_inst.second = date ? date.getSeconds() : defaults.second;
			tp_inst.millisec = date ? date.getMilliseconds() : defaults.millisec;
			tp_inst.microsec = date ? date.getMicroseconds() : defaults.microsec;

			//check if within min/max times..
			tp_inst._limitMinMaxDateTime(inst, true);

			tp_inst._onTimeChange();
			tp_inst._updateDateTime(inst);
		}
	};

	/*
 * Create new public method to set only time, callable as $().datepicker('setTime', date)
 */
	$.datepicker._setTimeDatepicker = function (target, date, withDate) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			this._setDateFromField(inst);
			var tp_date;
			if (date) {
				if (typeof date === "string") {
					tp_inst._parseTime(date, withDate);
					tp_date = new Date();
					tp_date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
					tp_date.setMicroseconds(tp_inst.microsec);
				} else {
					tp_date = new Date(date.getTime());
					tp_date.setMicroseconds(date.getMicroseconds());
				}
				if (tp_date.toString() === 'Invalid Date') {
					tp_date = undefined;
				}
				this._setTime(inst, tp_date);
			}
		}
	};

	/*
 * override setDate() to allow setting time too within Date object
 */
	$.datepicker._base_setDateDatepicker = $.datepicker._setDateDatepicker;
	$.datepicker._setDateDatepicker = function (target, _date) {
		var inst = this._getInst(target);
		var date = _date;
		if (!inst) {
			return;
		}

		if (typeof _date === 'string') {
			date = new Date(_date);
			if (!date.getTime()) {
				this._base_setDateDatepicker.apply(this, arguments);
				date = $(target).datepicker('getDate');
			}
		}

		var tp_inst = this._get(inst, 'timepicker');
		var tp_date;
		if (date instanceof Date) {
			tp_date = new Date(date.getTime());
			tp_date.setMicroseconds(date.getMicroseconds());
		} else {
			tp_date = date;
		}

		// This is important if you are using the timezone option, javascript's Date
		// object will only return the timezone offset for the current locale, so we
		// adjust it accordingly.  If not using timezone option this won't matter..
		// If a timezone is different in tp, keep the timezone as is
		if (tp_inst && tp_date) {
			// look out for DST if tz wasn't specified
			if (!tp_inst.support.timezone && tp_inst._defaults.timezone === null) {
				tp_inst.timezone = tp_date.getTimezoneOffset() * -1;
			}
			date = $.timepicker.timezoneAdjust(date, $.timepicker.timezoneOffsetString(-date.getTimezoneOffset()), tp_inst.timezone);
			tp_date = $.timepicker.timezoneAdjust(tp_date, $.timepicker.timezoneOffsetString(-tp_date.getTimezoneOffset()), tp_inst.timezone);
		}

		this._updateDatepicker(inst);
		this._base_setDateDatepicker.apply(this, arguments);
		this._setTimeDatepicker(target, tp_date, true);
	};

	/*
 * override getDate() to allow getting time too within Date object
 */
	$.datepicker._base_getDateDatepicker = $.datepicker._getDateDatepicker;
	$.datepicker._getDateDatepicker = function (target, noDefault) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			// if it hasn't yet been defined, grab from field
			if (inst.lastVal === undefined) {
				this._setDateFromField(inst, noDefault);
			}

			var date = this._getDate(inst);

			var currDT = null;

			if (tp_inst.$altInput && tp_inst._defaults.altFieldTimeOnly) {
				currDT = tp_inst.$input.val() + ' ' + tp_inst.$altInput.val();
			} else if (tp_inst.$input.get(0).tagName !== 'INPUT' && tp_inst.$altInput) {
				/**
     * in case the datetimepicker has been applied to a non-input tag for inline UI,
     * and the user has not configured the plugin to display only time in altInput,
     * pick current date time from the altInput (and hope for the best, for now, until "ER1" is applied)
     *
     * @todo ER1. Since altInput can have a totally difference format, convert it to standard format by reading input format from "altFormat" and "altTimeFormat" option values
     */
				currDT = tp_inst.$altInput.val();
			} else {
				currDT = tp_inst.$input.val();
			}

			if (date && tp_inst._parseTime(currDT, !inst.settings.timeOnly)) {
				date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
				date.setMicroseconds(tp_inst.microsec);

				// This is important if you are using the timezone option, javascript's Date
				// object will only return the timezone offset for the current locale, so we
				// adjust it accordingly.  If not using timezone option this won't matter..
				if (tp_inst.timezone != null) {
					// look out for DST if tz wasn't specified
					if (!tp_inst.support.timezone && tp_inst._defaults.timezone === null) {
						tp_inst.timezone = date.getTimezoneOffset() * -1;
					}
					date = $.timepicker.timezoneAdjust(date, tp_inst.timezone, $.timepicker.timezoneOffsetString(-date.getTimezoneOffset()));
				}
			}
			return date;
		}
		return this._base_getDateDatepicker(target, noDefault);
	};

	/*
 * override parseDate() because UI 1.8.14 throws an error about "Extra characters"
 * An option in datapicker to ignore extra format characters would be nicer.
 */
	$.datepicker._base_parseDate = $.datepicker.parseDate;
	$.datepicker.parseDate = function (format, value, settings) {
		var date;
		try {
			date = this._base_parseDate(format, value, settings);
		} catch (err) {
			// Hack!  The error message ends with a colon, a space, and
			// the "extra" characters.  We rely on that instead of
			// attempting to perfectly reproduce the parsing algorithm.
			if (err.indexOf(":") >= 0) {
				date = this._base_parseDate(format, value.substring(0, value.length - (err.length - err.indexOf(':') - 2)), settings);
				$.timepicker.log("Error parsing the date string: " + err + "\ndate string = " + value + "\ndate format = " + format);
			} else {
				throw err;
			}
		}
		return date;
	};

	/*
 * override formatDate to set date with time to the input
 */
	$.datepicker._base_formatDate = $.datepicker._formatDate;
	$.datepicker._formatDate = function (inst, day, month, year) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			tp_inst._updateDateTime(inst);
			return tp_inst.$input.val();
		}
		return this._base_formatDate(inst);
	};

	/*
 * override options setter to add time to maxDate(Time) and minDate(Time). MaxDate
 */
	$.datepicker._base_optionDatepicker = $.datepicker._optionDatepicker;
	$.datepicker._optionDatepicker = function (target, name, value) {
		var inst = this._getInst(target),
		    name_clone;
		if (!inst) {
			return null;
		}

		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var min = null,
			    max = null,
			    onselect = null,
			    overrides = tp_inst._defaults.evnts,
			    fns = {},
			    prop,
			    ret,
			    oldVal,
			    $target;
			if (typeof name === 'string') {
				// if min/max was set with the string
				if (name === 'minDate' || name === 'minDateTime') {
					min = value;
				} else if (name === 'maxDate' || name === 'maxDateTime') {
					max = value;
				} else if (name === 'onSelect') {
					onselect = value;
				} else if (overrides.hasOwnProperty(name)) {
					if (typeof value === 'undefined') {
						return overrides[name];
					}
					fns[name] = value;
					name_clone = {}; //empty results in exiting function after overrides updated
				}
			} else if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
				//if min/max was set with the JSON
				if (name.minDate) {
					min = name.minDate;
				} else if (name.minDateTime) {
					min = name.minDateTime;
				} else if (name.maxDate) {
					max = name.maxDate;
				} else if (name.maxDateTime) {
					max = name.maxDateTime;
				}
				for (prop in overrides) {
					if (overrides.hasOwnProperty(prop) && name[prop]) {
						fns[prop] = name[prop];
					}
				}
			}
			for (prop in fns) {
				if (fns.hasOwnProperty(prop)) {
					overrides[prop] = fns[prop];
					if (!name_clone) {
						name_clone = $.extend({}, name);
					}
					delete name_clone[prop];
				}
			}
			if (name_clone && isEmptyObject(name_clone)) {
				return;
			}
			if (min) {
				//if min was set
				if (min === 0) {
					min = new Date();
				} else {
					min = new Date(min);
				}
				tp_inst._defaults.minDate = min;
				tp_inst._defaults.minDateTime = min;
			} else if (max) {
				//if max was set
				if (max === 0) {
					max = new Date();
				} else {
					max = new Date(max);
				}
				tp_inst._defaults.maxDate = max;
				tp_inst._defaults.maxDateTime = max;
			} else if (onselect) {
				tp_inst._defaults.onSelect = onselect;
			}

			// Datepicker will override our date when we call _base_optionDatepicker when
			// calling minDate/maxDate, so we will first grab the value, call
			// _base_optionDatepicker, then set our value back.
			if (min || max) {
				$target = $(target);
				oldVal = $target.datetimepicker('getDate');
				ret = this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value);
				$target.datetimepicker('setDate', oldVal);
				return ret;
			}
		}
		if (value === undefined) {
			return this._base_optionDatepicker.call($.datepicker, target, name);
		}
		return this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value);
	};

	/*
 * jQuery isEmptyObject does not check hasOwnProperty - if someone has added to the object prototype,
 * it will return false for all objects
 */
	var isEmptyObject = function isEmptyObject(obj) {
		var prop;
		for (prop in obj) {
			if (obj.hasOwnProperty(prop)) {
				return false;
			}
		}
		return true;
	};

	/*
 * jQuery extend now ignores nulls!
 */
	var extendRemove = function extendRemove(target, props) {
		$.extend(target, props);
		for (var name in props) {
			if (props[name] === null || props[name] === undefined) {
				target[name] = props[name];
			}
		}
		return target;
	};

	/*
 * Determine by the time format which units are supported
 * Returns an object of booleans for each unit
 */
	var detectSupport = function detectSupport(timeFormat) {
		var tf = timeFormat.replace(/'.*?'/g, '').toLowerCase(),
		    // removes literals
		isIn = function isIn(f, t) {
			// does the format contain the token?
			return f.indexOf(t) !== -1 ? true : false;
		};
		return {
			hour: isIn(tf, 'h'),
			minute: isIn(tf, 'm'),
			second: isIn(tf, 's'),
			millisec: isIn(tf, 'l'),
			microsec: isIn(tf, 'c'),
			timezone: isIn(tf, 'z'),
			ampm: isIn(tf, 't') && isIn(timeFormat, 'h'),
			iso8601: isIn(timeFormat, 'Z')
		};
	};

	/*
 * Converts 24 hour format into 12 hour
 * Returns 12 hour without leading 0
 */
	var convert24to12 = function convert24to12(hour) {
		hour %= 12;

		if (hour === 0) {
			hour = 12;
		}

		return String(hour);
	};

	var computeEffectiveSetting = function computeEffectiveSetting(settings, property) {
		return settings && settings[property] ? settings[property] : $.timepicker._defaults[property];
	};

	/*
 * Splits datetime string into date and time substrings.
 * Throws exception when date can't be parsed
 * Returns {dateString: dateString, timeString: timeString}
 */
	var splitDateTime = function splitDateTime(dateTimeString, timeSettings) {
		// The idea is to get the number separator occurrences in datetime and the time format requested (since time has
		// fewer unknowns, mostly numbers and am/pm). We will use the time pattern to split.
		var separator = computeEffectiveSetting(timeSettings, 'separator'),
		    format = computeEffectiveSetting(timeSettings, 'timeFormat'),
		    timeParts = format.split(separator),
		    // how many occurrences of separator may be in our format?
		timePartsLen = timeParts.length,
		    allParts = dateTimeString.split(separator),
		    allPartsLen = allParts.length;

		if (allPartsLen > 1) {
			return {
				dateString: allParts.splice(0, allPartsLen - timePartsLen).join(separator),
				timeString: allParts.splice(0, timePartsLen).join(separator)
			};
		}

		return {
			dateString: dateTimeString,
			timeString: ''
		};
	};

	/*
 * Internal function to parse datetime interval
 * Returns: {date: Date, timeObj: Object}, where
 *   date - parsed date without time (type Date)
 *   timeObj = {hour: , minute: , second: , millisec: , microsec: } - parsed time. Optional
 */
	var parseDateTimeInternal = function parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
		var date, parts, parsedTime;

		parts = splitDateTime(dateTimeString, timeSettings);
		date = $.datepicker._base_parseDate(dateFormat, parts.dateString, dateSettings);

		if (parts.timeString === '') {
			return {
				date: date
			};
		}

		parsedTime = $.datepicker.parseTime(timeFormat, parts.timeString, timeSettings);

		if (!parsedTime) {
			throw 'Wrong time format';
		}

		return {
			date: date,
			timeObj: parsedTime
		};
	};

	/*
 * Internal function to set timezone_select to the local timezone
 */
	var selectLocalTimezone = function selectLocalTimezone(tp_inst, date) {
		if (tp_inst && tp_inst.timezone_select) {
			var now = date || new Date();
			tp_inst.timezone_select.val(-now.getTimezoneOffset());
		}
	};

	/*
 * Create a Singleton Instance
 */
	$.timepicker = new Timepicker();

	/**
  * Get the timezone offset as string from a date object (eg '+0530' for UTC+5.5)
  * @param {number} tzMinutes if not a number, less than -720 (-1200), or greater than 840 (+1400) this value is returned
  * @param {boolean} iso8601 if true formats in accordance to iso8601 "+12:45"
  * @return {string}
  */
	$.timepicker.timezoneOffsetString = function (tzMinutes, iso8601) {
		if (isNaN(tzMinutes) || tzMinutes > 840 || tzMinutes < -720) {
			return tzMinutes;
		}

		var off = tzMinutes,
		    minutes = off % 60,
		    hours = (off - minutes) / 60,
		    iso = iso8601 ? ':' : '',
		    tz = (off >= 0 ? '+' : '-') + ('0' + Math.abs(hours)).slice(-2) + iso + ('0' + Math.abs(minutes)).slice(-2);

		if (tz === '+00:00') {
			return 'Z';
		}
		return tz;
	};

	/**
  * Get the number in minutes that represents a timezone string
  * @param  {string} tzString formatted like "+0500", "-1245", "Z"
  * @return {number} the offset minutes or the original string if it doesn't match expectations
  */
	$.timepicker.timezoneOffsetNumber = function (tzString) {
		var normalized = tzString.toString().replace(':', ''); // excuse any iso8601, end up with "+1245"

		if (normalized.toUpperCase() === 'Z') {
			// if iso8601 with Z, its 0 minute offset
			return 0;
		}

		if (!/^(\-|\+)\d{4}$/.test(normalized)) {
			// possibly a user defined tz, so just give it back
			return parseInt(tzString, 10);
		}

		return (normalized.substr(0, 1) === '-' ? -1 : 1) * ( // plus or minus
		parseInt(normalized.substr(1, 2), 10) * 60 + // hours (converted to minutes)
		parseInt(normalized.substr(3, 2), 10)); // minutes
	};

	/**
  * No way to set timezone in js Date, so we must adjust the minutes to compensate. (think setDate, getDate)
  * @param  {Date} date
  * @param  {string} fromTimezone formatted like "+0500", "-1245"
  * @param  {string} toTimezone formatted like "+0500", "-1245"
  * @return {Date}
  */
	$.timepicker.timezoneAdjust = function (date, fromTimezone, toTimezone) {
		var fromTz = $.timepicker.timezoneOffsetNumber(fromTimezone);
		var toTz = $.timepicker.timezoneOffsetNumber(toTimezone);
		if (!isNaN(toTz)) {
			date.setMinutes(date.getMinutes() + -fromTz - -toTz);
		}
		return date;
	};

	/**
  * Calls `timepicker()` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * n.b. The input value must be correctly formatted (reformatting is not supported)
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the timepicker() call
  * @return {jQuery}
  */
	$.timepicker.timeRange = function (startTime, endTime, options) {
		return $.timepicker.handleRange('timepicker', startTime, endTime, options);
	};

	/**
  * Calls `datetimepicker` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
  *   a boolean value that can be used to reformat the input values to the `dateFormat`.
  * @param  {string} method Can be used to specify the type of picker to be added
  * @return {jQuery}
  */
	$.timepicker.datetimeRange = function (startTime, endTime, options) {
		$.timepicker.handleRange('datetimepicker', startTime, endTime, options);
	};

	/**
  * Calls `datepicker` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
  *   a boolean value that can be used to reformat the input values to the `dateFormat`.
  * @return {jQuery}
  */
	$.timepicker.dateRange = function (startTime, endTime, options) {
		$.timepicker.handleRange('datepicker', startTime, endTime, options);
	};

	/**
  * Calls `method` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * @param  {string} method Can be used to specify the type of picker to be added
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
  *   a boolean value that can be used to reformat the input values to the `dateFormat`.
  * @return {jQuery}
  */
	$.timepicker.handleRange = function (method, startTime, endTime, options) {
		options = $.extend({}, {
			minInterval: 0, // min allowed interval in milliseconds
			maxInterval: 0, // max allowed interval in milliseconds
			start: {}, // options for start picker
			end: {} // options for end picker
		}, options);

		// for the mean time this fixes an issue with calling getDate with timepicker()
		var timeOnly = false;
		if (method === 'timepicker') {
			timeOnly = true;
			method = 'datetimepicker';
		}

		function checkDates(changed, other) {
			var startdt = startTime[method]('getDate'),
			    enddt = endTime[method]('getDate'),
			    changeddt = changed[method]('getDate');

			if (startdt !== null) {
				var minDate = new Date(startdt.getTime()),
				    maxDate = new Date(startdt.getTime());

				minDate.setMilliseconds(minDate.getMilliseconds() + options.minInterval);
				maxDate.setMilliseconds(maxDate.getMilliseconds() + options.maxInterval);

				if (options.minInterval > 0 && minDate > enddt) {
					// minInterval check
					endTime[method]('setDate', minDate);
				} else if (options.maxInterval > 0 && maxDate < enddt) {
					// max interval check
					endTime[method]('setDate', maxDate);
				} else if (startdt > enddt) {
					other[method]('setDate', changeddt);
				}
			}
		}

		function selected(changed, other, option) {
			if (!changed.val()) {
				return;
			}
			var date = changed[method].call(changed, 'getDate');
			if (date !== null && options.minInterval > 0) {
				if (option === 'minDate') {
					date.setMilliseconds(date.getMilliseconds() + options.minInterval);
				}
				if (option === 'maxDate') {
					date.setMilliseconds(date.getMilliseconds() - options.minInterval);
				}
			}

			if (date.getTime) {
				other[method].call(other, 'option', option, date);
			}
		}

		$.fn[method].call(startTime, $.extend({
			timeOnly: timeOnly,
			onClose: function onClose(dateText, inst) {
				checkDates($(this), endTime);
			},
			onSelect: function onSelect(selectedDateTime) {
				selected($(this), endTime, 'minDate');
			}
		}, options, options.start));
		$.fn[method].call(endTime, $.extend({
			timeOnly: timeOnly,
			onClose: function onClose(dateText, inst) {
				checkDates($(this), startTime);
			},
			onSelect: function onSelect(selectedDateTime) {
				selected($(this), startTime, 'maxDate');
			}
		}, options, options.end));

		checkDates(startTime, endTime);

		selected(startTime, endTime, 'minDate');
		selected(endTime, startTime, 'maxDate');

		return $([startTime.get(0), endTime.get(0)]);
	};

	/**
  * Log error or data to the console during error or debugging
  * @param  {Object} err pass any type object to log to the console during error or debugging
  * @return {void}
  */
	$.timepicker.log = function () {
		// Older IE (9, maybe 10) throw error on accessing `window.console.log.apply`, so check first.
		if (window.console && window.console.log && window.console.log.apply) {
			window.console.log.apply(window.console, Array.prototype.slice.call(arguments));
		}
	};

	/*
  * Add util object to allow access to private methods for testability.
  */
	$.timepicker._util = {
		_extendRemove: extendRemove,
		_isEmptyObject: isEmptyObject,
		_convert24to12: convert24to12,
		_detectSupport: detectSupport,
		_selectLocalTimezone: selectLocalTimezone,
		_computeEffectiveSetting: computeEffectiveSetting,
		_splitDateTime: splitDateTime,
		_parseDateTimeInternal: parseDateTimeInternal
	};

	/*
 * Microsecond support
 */
	if (!Date.prototype.getMicroseconds) {
		Date.prototype.microseconds = 0;
		Date.prototype.getMicroseconds = function () {
			return this.microseconds;
		};
		Date.prototype.setMicroseconds = function (m) {
			this.setMilliseconds(this.getMilliseconds() + Math.floor(m / 1000));
			this.microseconds = m % 1000;
			return this;
		};
	}

	/*
 * Keep up with the version
 */
	$.timepicker.version = "1.6.3";
});

},{}],87:[function(require,module,exports){
'use strict';

require('../datagrid/jquery.gcrud.datagrid.js');
jQuery(document).ready(function GroceryCRUDOnDocumentReady() {
    jQuery('.gc-container').groceryCrud();
});

},{"../datagrid/jquery.gcrud.datagrid.js":78}],88:[function(require,module,exports){
'use strict';

var $ = jQuery,
    i18n = require('../../sections/i18n').i18n,
    ajaxHelper = require('../../helpers/ajax-helper').ajaxHelper,
    jQueryPlugins = Object.create({
    init: function jQueryPluginsInit() {
        $.datepicker.setDefaults({
            constrainInput: false,
            showButtonPanel: true,
            changeMonth: true,
            changeYear: true,
            closeText: i18n.t('calendar_close_text'),
            prevText: i18n.t('calendar_prev_text'),
            nextText: i18n.t('calendar_next_text'),
            currentText: i18n.t('calendar_current_text'),
            monthNames: i18n.t('calendar_month_names'),
            monthNamesShort: i18n.t('calendar_month_names_short'),
            dayNames: i18n.t('calendar_day_names'),
            dayNamesShort: i18n.t('calendar_day_names_short'),
            dayNamesMin: i18n.t('calendar_day_names_min'),
            weekHeader: i18n.t('calendar_week_header')
        });

        $.timepicker.setDefaults({
            timeFormat: 'HH:mm:ss',
            timeText: i18n.t('time_text'),
            hourText: i18n.t('time_hour_text'),
            minuteText: i18n.t('time_minute_text'),
            secondText: i18n.t('time_second_text')
        });
    },
    datepicker: function datepicker($selector, gcInstance) {
        $selector.datepicker({
            dateFormat: gcInstance !== undefined ? gcInstance.dateFormat : 'yy-mm-dd'
        });
    },
    datetimepicker: function datetimepicker($selector, gcInstance) {
        $selector.datetimepicker({
            dateFormat: gcInstance !== undefined ? gcInstance.dateFormat : 'yy-mm-dd'
        });
    },
    texteditor: function texteditor($selector) {
        $selector.ckeditor();
    },
    updateTexteditor: function texteditor(fieldName, fieldValue) {
        if (typeof CKEDITOR.instances[fieldName] !== 'undefined') {
            CKEDITOR.instances[fieldName].setData(fieldValue);
        }
    },
    destroyTexteditor: function destroyTexteditor(fieldName) {
        if (typeof CKEDITOR.instances[fieldName] !== 'undefined') {
            CKEDITOR.instances[fieldName].destroy();
        }
    },
    searchableSelect: function searchableSelect($selector, isReadOnly) {
        $selector.chosen('destroy');

        // Timeout as jquery Chosen is dynamically checking for select width
        setTimeout(function timeOutforSearchableSelect() {
            // Removing hidden class in order to calculate the width with chosen
            if (isReadOnly) {
                $selector.removeClass('hidden');
            }
            $selector.chosen({
                allow_single_deselect: true
            });
            if (isReadOnly) {
                // Put back the hidden class for read Only
                $selector.addClass('hidden');
                $selector.next().addClass('hidden');
            } else {
                $selector.next().removeClass('hidden');
            }
        }, 1000);
    },
    searchableSelectUpdate: function searchableSelectUpdate($selector, isReadOnly) {
        if (isReadOnly) {
            $selector.next().addClass('hidden');
        } else {
            $selector.trigger('chosen:updated');
            $selector.next().removeClass('hidden');
        }
    },
    searchableAjaxSelect: function searchableAjaxSelect($selector, gcInstance) {

        setTimeout(function timeOutSearchableAjaxSelect() {
            $selector.select2({
                ajax: {
                    url: ajaxHelper.getUrl.apply(gcInstance, ['ajax-search']),
                    dataType: 'json',
                    method: 'post',
                    delay: 250,
                    data: function getDataParameters(params) {
                        return {
                            search_value: params.term,
                            field_name: 'country',
                            page: params.page
                        };
                    },
                    processResults: function ajaxProcessResults(data, params) {
                        params.page = params.page || 1;
                        return {
                            results: data.items,
                            pagination: {
                                more: params.page * 30 < data.total_count
                            }
                        };
                    },
                    cache: true
                },
                allowClear: true,
                placeholder: 'Select an option',
                escapeMarkup: function escapeMarkupMakeItWork(markup) {
                    return markup;
                },
                minimumInputLength: 1,
                templateResult: function templateResult(item) {
                    return item.title || '';
                },
                templateSelection: function templateSelection(item) {
                    return item.title || '';
                }
            });
            $selector.select2({
                data: [{
                    id: '',
                    title: ''
                }, {
                    id: 'GR',
                    title: 'Greece'
                }]
            });
        }, 1000);
    },
    searchableAjaxSelectUpdate: function searchableAjaxSelectUpdate($selector) {
        $selector.trigger('change');
    }
});

exports.jQueryPlugins = jQueryPlugins;

},{"../../helpers/ajax-helper":79,"../../sections/i18n":97}],89:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PerPageDropdown = function (_React$Component) {
    _inherits(PerPageDropdown, _React$Component);

    function PerPageDropdown() {
        _classCallCheck(this, PerPageDropdown);

        return _possibleConstructorReturn(this, (PerPageDropdown.__proto__ || Object.getPrototypeOf(PerPageDropdown)).apply(this, arguments));
    }

    _createClass(PerPageDropdown, [{
        key: "render",
        value: function render() {
            var _props = this.props,
                defaultPerPage = _props.defaultPerPage,
                pagingOptions = _props.pagingOptions;


            return React.createElement(
                "select",
                { name: "per_page", className: "per_page form-control", defaultValue: defaultPerPage },
                pagingOptions.map(function PerPageDropDownForEach(fieldValue) {
                    return React.createElement(
                        "option",
                        { value: fieldValue, key: fieldValue },
                        fieldValue
                    );
                })
            );
        }
    }]);

    return PerPageDropdown;
}(React.Component);

exports.default = PerPageDropdown;

},{}],90:[function(require,module,exports){
'use strict';

var Constants = {
    PAGING: {
        CLASS_PER_PAGE: 'per_page'
    },

    RESPONSE: {
        SUCCESS: 'success',
        FAILURE: 'failure'
    },

    FIELD_TYPE_RELATION: 'relational',
    FIELD_TYPE_RELATION_NATIVE: 'relational_native',
    FIELD_TYPE_RELATION_N_TO_N: 'relational_n_n',
    FIELD_TYPE_NATIVE_RELATION_N_TO_N: 'native_relational_n_n',
    FIELD_TYPE_DATE: 'date',
    FIELD_TYPE_DATETIME: 'datetime',
    FIELD_TYPE_TIMESTAMP: 'timestamp',
    SELECTOR_STRING_VARIABLES: '.string-variables',
    SELECTOR_GRID_TABLE: '.grocery-crud-table',
    SELECTOR_PAGE_NUMBER_INPUT: '.page-number-input',
    SELECTOR_HIDDEN_PAGE_NUMBER: '.page-number-hidden',
    SELECTOR_ACTIVE: '.active',
    SELECTOR_VISIBLE_COLUMN_CHECKBOX: 'input[type=checkbox]',
    SELECTOR_DATAGRID_CONTAINER: '.gc-grid-container',
    SELECTOR_HEADER_TOOLS: '.header-tools',
    SELECTOR_SETTINGS: '.gc-settings-container',
    SELECTOR_MODAL_FORM: '.gc-form-operation-modal',
    SELECTOR_MODAL_ADD_FORM_CONTAINER: '.gc-insert-modal',
    SELECTOR_MODAL_EDIT_FORM_CONTAINER: '.gc-update-modal',
    SELECTOR_MODAL_READ_FORM_CONTAINER: '.gc-read-modal',
    SELECTOR_SEARCH_ROW: '.gc-search-row',

    SELECTOR_SEARCH_FIELD_INPUT: '.gc-searchable-input',

    SELECTOR_FORM: 'form',
    SELECTOR_COLUMNS_TR: '.header-columns',

    CLASS_DISABLED: 'disabled',
    CLASS_COLUMN_ON_HOVER: 'bg-info',
    CLASS_PAGING_PREVIOUS: 'paging-previous',
    CLASS_PAGING_NEXT: 'paging-next',
    CLASS_PAGING_FIRST: 'paging-first',
    CLASS_PAGING_LAST: 'paging-last',
    CLASS_PER_PAGE: 'per_page',

    ACTION_DATAGRID: 'datagrid',
    ACTION_PRINT: 'print',
    ACTION_ADD_FORM: 'add-form',
    ACTION_EDIT_FORM: 'edit-form',
    ACTION_CLONE_FORM: 'clone-form',
    ACTION_READ_FORM: 'read-form',
    ACTION_INSERT: 'insert',
    ACTION_CLONE: 'clone',
    ACTION_UPDATE: 'update',
    ACTION_READ: 'read',
    ACTION_REMOVE_ONE: 'remove-one',
    ACTION_REMOVE_MULTIPLE: 'remove-multiple',
    ACTION_INIT_DATA: 'initial',

    SELECTOR_BUTTON_ADD: '.button-add',

    FIELD_NAME_ACTION: 'action',

    HANDLEBARS_TEMPLATE_ROW: '.gc-table-row',
    HANDLEBARS_TEMPLATE_HEADER_COLUMNS: '.gc-table-header-columns',
    HANDLEBARS_TEMPLATE_CAPTION_TITLE: '.gc-table-title-caption',
    HANDLEBARS_ADD_BUTTON: '.gc-add-button',
    HANDLEBARS_ACTIONS_TITLE: '.gc-header-actions-title',
    HANDLEBARS_EXPORT_BUTTON: '.gc-export-button',
    HANDLEBARS_PRINT_BUTTON: '.gc-print-button',
    HANDLEBARS_INSERT_MODAL: '.gc-insert-modal-template',
    HANDLEBARS_READ_MODAL: '.gc-read-modal-template',
    HANDLEBARS_READ_FIELD_ROW: '.gc-read-field-row',
    HANDLEBARS_ERROR: '.gc-error',
    HANDLEBARS_SETTINGS_BUTTONS: '.gc-settings-buttons-template',
    HANDLEBARS_DELETE_SINGLE_MODAL: '.gc-confirm-delete-single',
    HANDLEBARS_DELETE_MUTLIPLE_MODAL: '.gc-confirm-delete-multiple',
    HANDLEBARS_PRINT_CONTAINER: '.gc-print-template',
    HANDLEBARS_PRINT_HEADER: '.gc-print-header',

    SELECTOR_PAGING_PREVIOUS: '.paging-previous',
    SELECTOR_PAGING_NEXT: '.paging-next',
    SELECTOR_PAGING_FIRST: '.paging-first',
    SELECTOR_PAGING_LAST: '.paging-last',

    CANCEL_BUTTON: '.gc-cancel-button',

    SELECTOR_DELETE_BUTTON: '.gc-delete-single',
    SELECTOR_DELETE_CONFIRMATION_BUTTON: '.delete-single-confirmation-button',
    SELECTOR_DELETE_FORM_MODAL: '.delete-single-confirmation',

    SELECTOR_MULTIPLE_DELETE_FORM_MODAL: '.gc-delete-multiple-confirmation',
    SELECTOR_MULTIPLE_DELETE_CONFIRMATION_BUTTON: '.delete-multiple-confirmation-button',

    SELECTOR_DELETE_CHECKBOX: 'input.gc-select-row',
    SELECTOR_DELETE_CHECKBOX_CHECKED: 'input.gc-select-row:checked',

    SELECTOR_EDIT_BUTTON: '.gc-edit-button',
    SELECTOR_READ_BUTTON: '.gc-read-button',

    SELECTOR_MODAL_BODY: '.modal-body',

    SELECTOR_TYPE_DATE_INPUT: '.gc-date',
    SELECTOR_TYPE_DATETIME_INPUT: '.gc-datetime'
};

exports.Constants = Constants;

},{}],91:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RelationNtoN = require('../types/relation-n-n').RelationNtoN,
    Relation = require('../types/relation').Relation,
    Enum = require('../types/enum').Enum,
    Dropdown = require('../types/dropdown').Dropdown,
    MultipleSelect = require('../types/multiple-select').MultipleSelect,
    CheckboxBoolean = require('../types/checkbox-boolean').CheckboxBoolean,
    DateAndTime = require('../types/date-and-time').DateAndTime,
    Upload = require('../types/upload').Upload,
    Texteditor = require('../types/texteditor').Texteditor,
    CallbackColumn = require('../types/callback-column').CallbackColumn,
    Column = Object.create({
    initCachedData: function initCachedData() {
        RelationNtoN.initData.apply(this);
        Relation.initData.apply(this);
        Enum.initData.apply(this);
        DateAndTime.initData.apply(this);
        Upload.initData.apply(this);
        Dropdown.initData.apply(this);
        CheckboxBoolean.initData.apply(this);
        MultipleSelect.initData.apply(this);
        Texteditor.initData.apply(this);
        CallbackColumn.initData.apply(this);
    },
    getRowsData: function getRowsData(dataObject) {
        var rowData = {};

        rowData.backendActionButtons = dataObject.grocery_crud_extras.actionButtons;
        rowData.primaryKeyValue = dataObject.grocery_crud_extras.primaryKeyValue;

        rowData.columnsData = [];
        _underscore2.default.each(this.visibleColumns, function eachVisibleColumns(columnName) {
            var rowValue = dataObject[columnName],
                isHtml = false;
            if (rowValue === null || rowValue === undefined) {
                rowValue = '';
            }
            if (RelationNtoN.isNtoN.apply(this, [columnName])) {
                rowValue = RelationNtoN.transformData.apply(this, [columnName, rowValue]);
            } else if (Upload.isUploadType.apply(this, [columnName])) {
                rowValue = Upload.formatUpload.apply(this, [columnName, rowValue]);
                isHtml = true;
            } else if (Dropdown.isDropdown.apply(this, [columnName])) {
                rowValue = Dropdown.formatValue.apply(this, [columnName, rowValue]);
            } else if (CheckboxBoolean.isCheckboxBoolean.apply(this, [columnName])) {
                rowValue = CheckboxBoolean.formatValue.apply(this, [rowValue]);
                isHtml = true;
            } else if (Relation.isRelational.apply(this, [columnName])) {
                rowValue = Relation.transformData.apply(this, [columnName, rowValue]);
            } else if (MultipleSelect.isThisType.apply(this, [columnName])) {
                rowValue = MultipleSelect.transformData.apply(this, [columnName, rowValue]);
            } else if (Texteditor.isThisType.apply(this, [columnName])) {
                isHtml = true;
            } else if (CallbackColumn.isThisType.apply(this, [columnName])) {
                isHtml = true;
            }

            rowData.columnsData.push({
                name: columnName,
                value: rowValue,
                isHtml: isHtml
            });
        }.bind(this));

        return rowData;
    }
});

exports.Column = Column;

},{"../types/callback-column":106,"../types/checkbox-boolean":107,"../types/date-and-time":108,"../types/dropdown":109,"../types/enum":110,"../types/multiple-select":111,"../types/relation":113,"../types/relation-n-n":112,"../types/texteditor":114,"../types/upload":115,"underscore":198}],92:[function(require,module,exports){
'use strict';

var Grid = require('./datagrid.grid.js').Grid,
    jQueryPlugins = require('../../modules/jquery/jquery-plugins').jQueryPlugins,
    localStorageHelper = require('../../helpers/local-storage-helper').localStorageHelper,
    Handlebars = require('handlebars'),
    Constants = require('../constants').Constants,
    DatagridColumns = Object.create({
    setVisibleColumns: function setVisibleColumns() {
        var visibleColumnsCache = void 0,
            visibleColumns = void 0;

        visibleColumnsCache = DatagridColumns.getCacheForVisibleColumns.apply(this);

        if (visibleColumnsCache) {
            // @todo: Handle JSON.parse
            visibleColumnsCache = JSON.parse(visibleColumnsCache);
        }

        if (visibleColumnsCache) {
            visibleColumns = DatagridColumns.filterVisibleColumns.apply(this, [visibleColumnsCache]);

            // In case we don't have any visible columns then add all the columns as checked
            if (visibleColumns.length === 0) {
                visibleColumns = this.columns;
            }
        } else {
            visibleColumns = this.columns;
        }

        DatagridColumns.triggerColumnsRender.apply(this, [visibleColumns]);
    },
    filterVisibleColumns: function filterVisibleColumns(visibleColumns) {
        var filteredVisibleColumns = this.columns.filter(function (column) {
            return visibleColumns.indexOf(column.columnName) > -1;
        });

        if (filteredVisibleColumns.length === 0) {
            filteredVisibleColumns = this.columns;
        }

        return filteredVisibleColumns;
    },
    templateObjectFieldTypes: function templateObjectFieldTypes(column) {
        var field = void 0,
            isEnum = void 0,
            isDate = void 0,
            isDatetime = void 0,
            isDropdown = void 0,
            isRelational = void 0,
            isNtoNRelational = void 0,
            isSearchable = void 0,
            isBoolean = void 0;

        field = this.cachedInitialData.fieldTypes[column.columnName];

        if (field === undefined) {
            throw new Error('Can\'t find column name: "' + column.columnName + '" in fieldTypes. ' + 'This is usually an error that you will see when you\'ve added a field name that doesn\'t exist ' + 'in the database.');
        }

        isEnum = field.dataType === 'enum' || field.dataType === 'enum_searchable';
        isDate = field.dataType === 'date';
        isDatetime = field.dataType === 'datetime' || field.dataType === 'timestamp';
        isDropdown = field.dataType === 'dropdown' || field.dataType === 'dropdown_search' || field.dataType === 'multiselect_searchable' || field.dataType === 'multiselect_native';
        isRelational = field.dataType === 'relational' || field.dataType === 'relational_native';
        isNtoNRelational = field.dataType === 'relational_n_n' || field.dataType === 'native_relational_n_n';
        isSearchable = field.dataType === 'relational_n_n' || field.dataType === 'relational';
        isBoolean = field.dataType === 'checkbox_boolean';

        return {
            column_name: column.columnName,
            display_name: column.displayAs,
            columnInfo: field,
            isEnum: isEnum,
            isDropdown: isDropdown,
            isRelational: isRelational,
            isNtoNRelational: isNtoNRelational,
            isDate: isDate,
            isDatetime: isDatetime,
            isSearchable: isSearchable,
            isBoolean: isBoolean,
            knownField: isEnum || isDropdown || isRelational || isNtoNRelational || isDate || isDatetime || isBoolean,
            hasOrdering: !isRelational && !isDropdown
        };
    },
    triggerColumnsRender: function triggerColumnsRender(visibleColumnsRaw) {
        var columnsTemplate = void 0,
            templateObject = void 0,
            searchColumnsTemplate = void 0,
            i18nStrings = this.cachedInitialData.i18n,
            visibleColumns = void 0;

        Handlebars.registerHelper('ifCond', function (v1, v2, options) {
            if (v1 === v2) {
                return options.fn(this);
            }
            return options.inverse(this);
        });

        Handlebars.registerHelper('ifNot', function (v1, v2, options) {
            if (v1 !== v2) {
                return options.fn(this);
            }
            return options.inverse(this);
        });

        templateObject = {
            table_columns: [],
            i18n: i18nStrings,
            hasActions: this.datagridHasActions.apply(this),
            searchByColumn: !Grid.hasExtendedSearch.apply(this)
        };

        if (visibleColumnsRaw) {
            visibleColumns = visibleColumnsRaw;
        } else if (this.visibleColumns.length > 0) {
            visibleColumns = DatagridColumns.filterVisibleColumns.apply(this, [this.visibleColumns]);
        } else {
            throw new Error('Unexpected error!');
        }

        templateObject.table_columns = visibleColumns.map(DatagridColumns.templateObjectFieldTypes.bind(this));
        this.visibleColumns = visibleColumns.map(function (column) {
            return column.columnName;
        });

        columnsTemplate = Handlebars.compile(this.$gc.find(Constants.HANDLEBARS_TEMPLATE_HEADER_COLUMNS).html());
        searchColumnsTemplate = Handlebars.compile(this.$gc.find('.gc-search-columns').html(), {
            i18n: i18nStrings
        });

        this.$gc.find('.gc-search-column').remove();
        this.$gc.find(Constants.SELECTOR_COLUMNS_TR).html(columnsTemplate(templateObject));
        this.$gc.find('.gc-search-row').append(searchColumnsTemplate(templateObject));

        if (this.$gc.find('.gc-searchable-date').length > 0) {
            jQueryPlugins.datepicker(this.$gc.find('.gc-searchable-date'), this);
        }
        if (this.$gc.find('.gc-searchable-datetime').length > 0) {
            jQueryPlugins.datetimepicker(this.$gc.find('.gc-searchable-datetime'), this);
        }
        if (this.$gc.find('.gc-with-search-plugin').length > 0) {
            jQueryPlugins.searchableSelect(this.$gc.find('.gc-with-search-plugin'));
        }

        Grid.activateOrderingColumn.apply(this);
        Grid.activateOrderingRows.apply(this);

        Grid.listenerColumnWithOrdering.apply(this);
        Grid.listenerSearchInput.apply(this);
    },
    setCacheForVisibleColumns: function setCacheForVisibleColumns(visibleColumns) {
        localStorageHelper.setLocalStorageItem('gcrudVisibleColumns_' + this.uniqueId, JSON.stringify(visibleColumns));
    },
    getCacheForVisibleColumns: function getCacheForVisibleColumns() {
        return localStorageHelper.getLocalStorageItem('gcrudVisibleColumns_' + this.uniqueId);
    }
});

exports.DatagridColumns = DatagridColumns;

},{"../../helpers/local-storage-helper":80,"../../modules/jquery/jquery-plugins":88,"../constants":90,"./datagrid.grid.js":93,"handlebars":153}],93:[function(require,module,exports){
'use strict';

var $ = jQuery,
    localStorageHelper = require('../../helpers/local-storage-helper').localStorageHelper,
    ajaxHelper = require('../../helpers/ajax-helper').ajaxHelper,
    DatagridPaging = require('./datagrid.paging').DatagridPaging,
    Constants = require('../constants').Constants,
    Grid = Object.create({
    searchAndOrderingTrigger: function searchAndOrderingTrigger(highlightRowId) {
        var datagrid_object = this,
            gcrud_container = datagrid_object.$gc,
            ajax_list_url = gcrud_container.data('url');
        var dataToSend = void 0;

        DatagridPaging.pagingCalculations.apply(this);

        dataToSend = Grid.getDataToSend.apply(this);

        localStorageHelper.setLocalStorageItem('gcrudInitialData_' + this.uniqueId, JSON.stringify({
            order_by: dataToSend.order_by,
            sorting: dataToSend.sorting
        }));

        localStorageHelper.setLocalStorageItem('gcrudPreferences', JSON.stringify({
            per_page: dataToSend.per_page
        }));

        Grid.setExportUrl.apply(this, [dataToSend]);
        dataToSend.action = 'datagrid';

        if (this.cachedInitialData.csrfToken) {
            dataToSend[this.cachedInitialData.csrfToken.inputName] = this.cachedInitialData.csrfToken.inputValue;
        }

        this.sendPostRequest({
            url: ajax_list_url,
            dataToSend: dataToSend,
            successCallback: function ajaxSuccessCallback(jsonResponse) {
                if (jsonResponse.csrfToken) {
                    this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
                }

                this.createDatagrid(jsonResponse);
                Grid.updateGridDetails.apply(this, [jsonResponse, highlightRowId]);
            }.bind(this),
            errorCallback: function datagridErrorCallback() {
                localStorageHelper.removeLocalStorageItem('gcrudInitialData_' + this.uniqueId);
            }.bind(this)
        });
    },
    setExportUrl: function setExportUrl(data_to_send) {
        this.$gc.find('.gc-export').attr('href', ajaxHelper.getUrl.apply(this, ['export', data_to_send]));
    },
    getSearchData: function getSearchData() {
        var $search_all_input = this.$gc.find('.search-button > input.gc-search-input');

        var search_fields = [],
            search_texts = [],
            search = {};

        this.$gc.find('.gc-search-row').find('.gc-searchable-input,.gc-searchable-select').each(function forEachSearchableInput() {
            var searchValue = $(this).val();

            if (searchValue !== '') {
                search_fields.push($(this).attr('name'));
                search_texts.push(searchValue);
            }
        });

        this.$gc.find('.gc-search-row').find('input.gc-searchable-checkbox').each(function forEachSearchableInput() {
            if ($(this).is(':checked')) {
                search_fields.push($(this).attr('name'));
                search_texts.push('1');
            }
        });

        if (search_fields.length > 0 && $search_all_input.length > 0) {
            $search_all_input.val('');
            $search_all_input.trigger('blur');
        }

        if ($search_all_input.length > 0 && $search_all_input.val() !== '') {
            //Let's take advantage that JavaScript is not strong type!
            search_fields = '';
            search_texts = $search_all_input.val();
            search._gcrud_search_all = $search_all_input.val();
        } else {
            search_fields.forEach(function forEachSearchFields(searchfieldName, searchIndex) {
                search[searchfieldName] = search_texts[searchIndex];
            });
        }

        return search;
    },
    getOrderBy: function getOrderBy() {
        var order_by = this.$gc.find('.gc-order-by-hidden').val();

        if (order_by) {
            return order_by;
        }

        return this.$gc.find('.column-with-ordering.active:first').data('order-by');
    },
    getSorting: function getSorting() {
        var $columnWithOrdering = void 0,
            sorting = this.$gc.find('.gc-sorting-hidden').val();

        if (sorting) {
            return sorting;
        }

        $columnWithOrdering = this.$gc.find('.column-with-ordering.active:first');

        if ($columnWithOrdering.hasClass('ordering-desc')) {
            sorting = 'desc';
        } else if ($columnWithOrdering.hasClass('ordering-asc')) {
            sorting = 'asc';
        }

        return sorting;
    },
    getPerPage: function getPerPage() {
        return this.$gc.find('.per_page').val();
    },
    getPage: function getPage() {
        return this.$gc.find('input[name="page_number"]').val();
    },
    getBasicOperator: function getBasicOperator() {
        var $inputBasicOperator = this.$gc.find('.gc-hidden-search-inputs').find('input[name="basic_operator"]');

        if ($inputBasicOperator.length > 0) {
            return $inputBasicOperator.val();
        }

        return null;
    },
    getExtendedSearch: function getExtendedSearch() {
        var $searchInputs = this.$gc.find('.gc-hidden-search-inputs').find('.gc-extended-search-input');
        var searchInputs = {};

        if ($searchInputs.length === 0) {
            return null;
        }

        $searchInputs.each(function forEachSearchInputs() {
            searchInputs[$(this).attr('name')] = $(this).val();
        });

        return searchInputs;
    },
    hasExtendedSearch: function hasExtendedSearch() {
        return this.$gc.find('.gc-hidden-search-inputs').find('.gc-extended-search-input').length > 0;
    },
    getDataToSend: function getDataToSend() {
        var page = Grid.getPage.apply(this),
            per_page = Grid.getPerPage.apply(this),
            order_by = Grid.getOrderBy.apply(this),
            sorting = Grid.getSorting.apply(this),
            search = Grid.getSearchData.apply(this),
            basic_operator = Grid.getBasicOperator.apply(this),
            extended_search = Grid.getExtendedSearch.apply(this);

        return {
            page: page,
            per_page: per_page,
            order_by: order_by,
            sorting: sorting,
            search: search,
            basic_operator: basic_operator,
            extended_search: extended_search
        };
    },
    activateOrderingRows: function activateOrderingRows() {
        var $active_column = this.$gc.find('.column-with-ordering.active:first'),
            columnIndex = $active_column.index() + 1;

        if ($active_column.length > 0) {
            this.$gc.find('.grocery-crud-table').find('thead tr td:nth-child(' + columnIndex + ')').addClass('active table-active');
        }
    },
    updateGridDetails: function updateGridDetails(jsonResponse, highlightRowId) {
        var per_page_value = this.$gc.find('.per_page').val();
        var paging_ends = void 0;

        this.$gc.find('.select-all-none').prop('checked', false);
        this.$gc.find('.current-total-results').html(jsonResponse.filtered_total);

        if (jsonResponse.filtered_total > 10) {
            paging_ends = parseInt(this.$gc.find('input[name="page_number"]').val(), 10) * per_page_value;

            if (paging_ends > jsonResponse.filtered_total) {
                paging_ends = jsonResponse.filtered_total;
            }
            this.$gc.find('.paging-ends').html(paging_ends);
        } else {
            this.$gc.find('.paging-ends').html(jsonResponse.filtered_total);
        }

        if (jsonResponse.csrfToken) {
            this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
        }

        this.$gc.find('.paging-starts').html((parseInt(this.$gc.find('input[name="page_number"]').val(), 10) - 1) * per_page_value + 1);

        Grid.activateOrderingRows.apply(this);

        if (jsonResponse.filtered_total < parseInt(this.$gc.find('.full-total').html(), 10)) {
            this.$gc.find('.full-total-container').removeClass('hidden');
        } else {
            this.$gc.find('.full-total-container').addClass('hidden');
        }

        this.appendSearchClearButtons();
        DatagridPaging.pagingCalculations.apply(this);
        this.hideShowDeleteButton();
        if (highlightRowId) {
            this.$gc.find('tr[data-id=' + highlightRowId + ']').addClass('flash animated');
            setTimeout(function timeoutRemoveFlashing() {
                this.$gc.find('tr[data-id=' + highlightRowId + ']').removeClass('flash animated');
            }.bind(this), 1000);
        }
    },
    listenerPagingButtons: function listenerPagingButtons() {
        var datagrid_object = this,
            selectors_for_all_buttons = Constants.SELECTOR_PAGING_PREVIOUS + ', ' + Constants.SELECTOR_PAGING_NEXT + ', ' + Constants.SELECTOR_PAGING_FIRST + ',' + Constants.SELECTOR_PAGING_LAST,
            page_number_input_hidden = datagrid_object.$gc.find('.page-number-hidden');

        this.$gc.find(selectors_for_all_buttons).click(function forEachButtonsSelectors(event) {
            event.preventDefault();

            //If it is disabled then do nothing!
            if ($(this).hasClass(Constants.CLASS_DISABLED)) {
                return;
            }

            if ($(this).hasClass(Constants.CLASS_PAGING_PREVIOUS)) {
                page_number_input_hidden.val(parseInt(page_number_input_hidden.val(), 10) - 1);
            } else if ($(this).hasClass(Constants.CLASS_PAGING_NEXT)) {
                page_number_input_hidden.val(parseInt(page_number_input_hidden.val(), 10) + 1);
            } else if ($(this).hasClass(Constants.CLASS_PAGING_FIRST)) {
                page_number_input_hidden.val('1');
            } else if ($(this).hasClass(Constants.CLASS_PAGING_LAST)) {
                page_number_input_hidden.val(DatagridPaging.getMaxPaging.apply(datagrid_object));
            }
            Grid.searchAndOrderingTrigger.apply(datagrid_object);
        });

        this.$gc.find(Constants.SELECTOR_PAGE_NUMBER_INPUT).change(function pageNumberInputOnChange() {
            if (!isNaN(parseInt($(this).val(), 10))) {
                page_number_input_hidden.val(parseInt($(this).val(), 10));
            } else {
                page_number_input_hidden.val('1');
            }

            Grid.searchAndOrderingTrigger.apply(datagrid_object);
        });
    },
    activateOrderingColumn: function activateOrderingColumn() {
        var order_by = this.$gc.find('.gc-order-by-hidden').val(),
            sorting = this.$gc.find('.gc-sorting-hidden').val();
        if (order_by && sorting) {
            this.$gc.find('.column-with-ordering[data-order-by="' + order_by + '"]').addClass('active table-active');
            this.$gc.find('.column-with-ordering[data-order-by="' + order_by + '"]').addClass('ordering-' + sorting);
        }
    },
    listenerColumnWithOrdering: function listenerColumnWithOrdering() {
        var datagrid_object = this;

        this.$gc.find('.column-with-ordering').click(function onColumnOrderingClick() {
            var gcrud_container = $(this).closest('.gc-container'),
                $table = $(this).closest('.grocery-crud-table'),
                sorting = void 0;

            $table.find('thead').find('th.active, td.active').removeClass('active table-active');

            $(this).parent().find('.column-with-ordering').each(function foreachColumnsWithOrdering() {
                $(this).html('<div>' + $.trim($(this).text()) + '</div>');
            });

            $(this).addClass('active table-active');

            if ($(this).hasClass('ordering-asc')) {
                $table.find('th').removeClass('ordering-desc').removeClass('ordering-asc');
                $(this).addClass('ordering-desc').removeClass('ordering-asc');
                sorting = 'desc';
            } else {
                $table.find('th').removeClass('ordering-desc').removeClass('ordering-asc');
                $(this).addClass('ordering-asc').removeClass('ordering-desc');
                sorting = 'asc';
            }

            gcrud_container.find('input[name="page_number"]').val('1');

            gcrud_container.find('.gc-order-by-hidden').val($(this).data('order-by'));
            gcrud_container.find('.gc-sorting-hidden').val(sorting);

            Grid.searchAndOrderingTrigger.apply(datagrid_object);
        });
    },
    listenerSearchInput: function listenerSearchInput() {
        var datagrid_object = this;

        this.$gc.find('.gc-searchable-input').on('keyup change', function onChangeSearchInput(event) {
            //If the key is Enter or empty, then don't wait! Just start searching...
            var timerTimeout = event.keyCode === 9 || event.keyCode === 13 || $(this).val() === '' ? 1 : 1000;

            if (datagrid_object.search_timer !== null) {
                clearTimeout(datagrid_object.search_timer);
            }
            datagrid_object.search_timer = setTimeout(function searchTimerTimeoutCallback() {
                datagrid_object.$gc.find('.page-number-hidden').val('1');
                Grid.searchAndOrderingTrigger.apply(datagrid_object);
            }, timerTimeout);
        });

        this.$gc.find('.gc-searchable-select,.gc-searchable-checkbox').change(function onChangeSearchInput() {
            this.$gc.find('.page-number-hidden').val('1');
            Grid.searchAndOrderingTrigger.apply(this);
        }.bind(this));

        this.$gc.find('.gc-date-operator').change(function onChangeSearchInput() {
            Grid.searchAndOrderingTrigger.apply(this);
        }.bind(this));
    }
});

Grid.CLASS_PER_PAGE = 'per_page';

exports.Grid = Grid;

},{"../../helpers/ajax-helper":79,"../../helpers/local-storage-helper":80,"../constants":90,"./datagrid.paging":95}],94:[function(require,module,exports){
'use strict';

var $ = jQuery,
    ajaxHelper = require('../../helpers/ajax-helper').ajaxHelper,
    Handlebars = require('handlebars'),
    _ = require('underscore'),
    Constants = require('../constants').Constants,
    Grid = require('./datagrid.grid').Grid,
    DatagridHeaderActions = Object.create({
    listenerPrintButton: function listenerPrintButton() {
        var printContainerHtml = Handlebars.compile(this.$gc.find(Constants.HANDLEBARS_PRINT_CONTAINER).html())();

        this.$gc.find('.gc-print').click(function printButtonOnClick(event) {
            var dataToSend = Grid.getDataToSend.apply(this);

            event.preventDefault();

            this.sendGetRequest({
                url: ajaxHelper.getUrl.apply(this, [DatagridHeaderActions.ACTION_PRINT, dataToSend]),
                successCallback: function successCallback(jsonResponse) {
                    var $printContainer = $(printContainerHtml);

                    if (jsonResponse.csrfToken) {
                        this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
                    }

                    $printContainer.find('thead').html(DatagridHeaderActions.getPrintTableHeader.apply(this));

                    $printContainer.find('tbody').html(this.getTableBodyFromResponse(jsonResponse)).closest('#table-container').printThis();
                }.bind(this)
            });
        }.bind(this));
    },
    getPrintTableHeader: function getPrintTableHeader() {
        var headerColumns = [];
        _.each(this.visibleColumns, function eachVisibleColumns(columnName) {
            headerColumns.push({
                name: columnName,
                displayAs: this.indexedColumns[columnName]
            });
        }.bind(this));

        return Handlebars.compile(this.$gc.find(Constants.HANDLEBARS_PRINT_HEADER).html())({
            headerColumns: headerColumns
        });
    }
});

DatagridHeaderActions.ACTION_PRINT = 'print';

exports.DatagridHeaderActions = DatagridHeaderActions;

},{"../../helpers/ajax-helper":79,"../constants":90,"./datagrid.grid":93,"handlebars":153,"underscore":198}],95:[function(require,module,exports){
'use strict';

var $ = jQuery,
    Constants = require('../constants').Constants,
    DatagridPaging = Object.create({
    getMaxPaging: function getMaxPaging() {
        var total_results = parseInt(this.$gc.find('.current-total-results').html(), 10),
            per_page = parseInt(this.$gc.find('.' + Constants.CLASS_PER_PAGE).val(), 10),
            max_paging = total_results === 0 ? 1 : Math.ceil(total_results / per_page);

        return max_paging;
    },
    pagingCalculations: function pagingCalculations() {
        var page_number_value = parseInt(this.$gc.find('.page-number-hidden').val(), 10),
            max_paging = DatagridPaging.getMaxPaging.apply(this);

        if (page_number_value <= 0) {
            page_number_value = 1;
            this.$gc.find('.page-number-hidden').val('1');
            this.$gc.find(Constants.SELECTOR_PAGE_NUMBER_INPUT).val('1');
        }

        if (page_number_value === 1) {
            this.$gc.find('.paging-first').addClass(Constants.CLASS_DISABLED);
            this.$gc.find('.paging-previous').addClass(Constants.CLASS_DISABLED);
        } else {
            this.$gc.find('.paging-first').removeClass(Constants.CLASS_DISABLED);
            this.$gc.find('.paging-previous').removeClass(Constants.CLASS_DISABLED);
        }

        if (page_number_value + 1 > max_paging) {
            this.$gc.find('.paging-last').addClass(Constants.CLASS_DISABLED);
            this.$gc.find('.paging-next').addClass(Constants.CLASS_DISABLED);
        } else {
            this.$gc.find('.paging-last').removeClass(Constants.CLASS_DISABLED);
            this.$gc.find('.paging-next').removeClass(Constants.CLASS_DISABLED);
        }

        this.$gc.find(Constants.SELECTOR_PAGE_NUMBER_INPUT).val(page_number_value);

        if (page_number_value > max_paging) {
            this.$gc.find('.page-number-hidden').val(max_paging);
            this.$gc.find(Constants.SELECTOR_PAGE_NUMBER_INPUT).val(max_paging);
        }
    }
});

exports.DatagridPaging = DatagridPaging;

},{"../constants":90}],96:[function(require,module,exports){
'use strict';

var $ = jQuery,
    Grid = require('./datagrid.grid.js').Grid,
    DatagridColumns = require('./datagrid.columns').DatagridColumns,
    DatagridSearch = Object.create({
    listenerSearchButton: function listenerSearchButton() {
        var datagrid_object = this;

        if (this.settings.datagridSearchAllInput) {
            DatagridSearch.searchAllButton.apply(this);
        } else {
            this.$gc.find('.gc-filter-button').click(function searchButtonOnClick(event) {
                event.preventDefault();
                this.$gc.find('.gc-filtering-modal').gc_modal({
                    backdrop: true
                });
            }.bind(this));

            this.$gc.find('.gc-remove-filter-button').click(function removeFiltersButtonOnClick(event) {
                event.preventDefault();
                this.$gc.find('.gc-hidden-search-inputs').html('');
                DatagridColumns.triggerColumnsRender.apply(this);
                Grid.searchAndOrderingTrigger.apply(this);
                this.$gc.find('.gc-remove-filter-container').addClass('hidden');
                this.$gc.find('.gc-filter-button').removeClass('btn-success').addClass('btn-outline-dark');
                this.$gc.find('.gc-filter-text').removeClass('hidden');
                this.$gc.find('.gc-filter-counter').addClass('hidden');
            }.bind(this));
        }

        this.$gc.find('.search-button>input.gc-search-input').change(function searchInputOnChange() {
            datagrid_object.$gc.find('.search-button .clear-all-search').remove();

            if ($(this).val() !== '') {
                $(this).after('<i class="fa fa-times clear-all-search"></i>');

                datagrid_object.$gc.find('.search-button .clear-all-search').click(function searchClearAllOnClick() {
                    datagrid_object.$gc.find('.search-button>input.gc-search-input').val('').trigger('change');
                });
            }

            datagrid_object.$gc.find('.page-number-hidden').val('1');
            datagrid_object.$gc.find('.gc-searchable-input').val('');
            Grid.searchAndOrderingTrigger.apply(datagrid_object);
        });

        this.$gc.find('.search-button>input.gc-search-input').blur(function searchInputOnBlur() {
            var search_button = $(this).closest('.search-button');

            if ($(this).val() === '' && search_button.hasClass('search-button-big')) {
                //Make sure that we are blur :)
                datagrid_object.$gc.find('.search-button .clear-all-search').remove();
                $(this).removeClass('gc-search-input-big');
                search_button.removeClass('search-button-big');
                search_button.removeClass('btn-default').addClass('btn-primary');
            }
        });
    },
    searchAllButton: function searchAllButton() {
        this.$gc.find('.search-button').click(function searchButtonOnClick(event) {
            var $search_button = $(this);

            event.preventDefault();

            $search_button.removeClass('btn-primary').addClass('btn-default');
            $search_button.find('input.gc-search-input').addClass('gc-search-input-big');

            setTimeout(function timeoutCallback() {
                $search_button.find('input.gc-search-input').focus();
            }, 400);

            $(this).addClass('search-button-big');
        });
    }
});

exports.DatagridSearch = DatagridSearch;

},{"./datagrid.columns":92,"./datagrid.grid.js":93}],97:[function(require,module,exports){
'use strict';

var _ = require('underscore'),
    i18n = Object.create({
    translations: {},
    init: function initI18n(i18nVariables) {
        this.translations = i18nVariables;
    },
    t: function t(translation) {
        if (this.translations[translation]) {
            return this.translations[translation];
        }
        return translation;
    },
    format: function format(strRaw, args) {
        var str = strRaw;
        if (!args && !args.length) {
            return str;
        }
        _.each(args, function eachArgs(arg, argName) {
            str = str.replace(RegExp('\\{' + argName + '\\}', 'gi'), arg);
        });
        return str;
    }
});

exports.i18n = i18n;

},{"underscore":198}],98:[function(require,module,exports){
'use strict';

var Constants = require('../constants').Constants,
    hasher = require('hasher'),
    OperationsCommon = require('./common').OperationsCommon,
    OperationAdd = Object.create({
    actionAdd: function eventAdd() {
        OperationsCommon.operationDispatch.apply(this, [{
            action: Constants.ACTION_ADD_FORM,
            fieldsListName: 'insertFields',
            fieldList: 'addFields',
            readOnlyFields: 'readOnlyAddFields',
            cache: true,
            callbackAfterRender: OperationAdd.callbackAfterModal.bind(this)
        }]);
    },
    callbackAfterModal: function callbackAfterModal() {
        this.$gc.find(Constants.SELECTOR_MODAL_FORM).find('input, textarea').first().focus();
    },
    listenerAddButton: function listenerAddButton() {

        OperationsCommon.hideModalOnClose.apply(this, [Constants.SELECTOR_MODAL_FORM]);
        // GC-174: Ugly workaround to also have an event to add an empty hash on error close
        OperationsCommon.hideModalOnClose.apply(this, ['.gc-error-modal']);

        this.$gc.find(Constants.SELECTOR_BUTTON_ADD).click(function addButtonClick(event) {
            event.preventDefault();

            if (this.settings.hashEvents) {
                hasher.setHash(this.hashEvent.addItem);
            } else {
                OperationAdd.actionAdd.apply(this);
            }
        }.bind(this));
    }
});

exports.OperationAdd = OperationAdd;

},{"../constants":90,"./common":100,"hasher":165}],99:[function(require,module,exports){
'use strict';

var Constants = require('../constants').Constants,
    hasher = require('hasher'),
    OperationsCommon = require('./common').OperationsCommon,
    OperationClone = Object.create({
    actionClone: function eventEdit(primaryKeyValue) {

        OperationsCommon.operationDispatch.apply(this, [{
            action: Constants.ACTION_CLONE_FORM,
            fieldsListName: 'cloneFields',
            fieldList: 'cloneFields',
            fieldTypes: 'fieldTypesCloneForm',
            readOnlyFields: 'readOnlyCloneFields',
            primaryKeyValue: primaryKeyValue
        }]);
    },
    onCloneClick: function onCloneClick(primaryKeyValue) {
        if (this.settings.hashEvents) {
            hasher.setHash(this.hashEvent.cloneItem + '/' + primaryKeyValue);
        } else {
            OperationClone.actionClone.apply(this, [primaryKeyValue]);
        }
    }
});

exports.OperationClone = OperationClone;

},{"../constants":90,"./common":100,"hasher":165}],100:[function(require,module,exports){
'use strict';

var _fieldList = require('../../../../../React-Components/gce-crud-forms/field-list.jsx');

var _fieldList2 = _interopRequireDefault(_fieldList);

var _title = require('../../../../../React-Components/gce-crud-forms/modal/title.jsx');

var _title2 = _interopRequireDefault(_title);

var _fieldInput = require('../../../../../React-Components/gce-crud-forms/field-input.jsx');

var _fieldInput2 = _interopRequireDefault(_fieldInput);

var _redux = require('redux');

var _reducer = require('./reducer.js');

var _reducer2 = _interopRequireDefault(_reducer);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var $ = jQuery,
    ajaxHelper = require('../../helpers/ajax-helper').ajaxHelper,
    Grid = require('./../datagrid/datagrid.grid.js').Grid,
    i18n = require('./../i18n').i18n,
    hasher = require('hasher'),
    Constants = require('../constants').Constants,
    OperationsCommon = Object.create({
    getFormDomContainer: function getFormDomContainer() {
        if (this.$formDomContainer === undefined) {
            this.$formDomContainer = this.find(Constants.SELECTOR_MODAL_FORM).find(Constants.SELECTOR_MODAL_BODY)[0];
        }
        return this.$formDomContainer;
    },
    getModalTitleDom: function getModalTitleDom() {
        if (this.$modalTitleDom === undefined) {
            this.$modalTitleDom = this.find(Constants.SELECTOR_MODAL_FORM).find('.modal-header')[0];
        }
        return this.$modalTitleDom;
    },
    operationDispatch: function operationDispatch(optionsRaw) {
        var options = _underscore2.default.extend({
            action: Constants.ACTION_ADD_FORM,
            fieldsListName: 'insertFields',
            fieldList: 'addFields',
            fieldTypes: 'fieldTypesAddForm',
            primaryKeyValue: null,
            cache: false,
            readOnlyFields: null,
            isReadOnly: false,
            callbackAfterRender: function callbackAfterRender() {
                return;
            }
        }, optionsRaw);

        if (options.cache && this[options.fieldsListName].length > 0) {
            OperationsCommon.showModal.apply(this, [options]);
        } else {
            OperationsCommon.collectDataAndDispatch.apply(this, [options]);
        }
    },
    displayAs: function displayAs(fieldName, fieldList) {
        return _underscore2.default.find(fieldList, function (column) {
            return column.name === fieldName;
        });
    },
    collectDataAndDispatch: function collectData(options) {
        var dataToSend = {
            action: options.action
        };

        if (options.primaryKeyValue !== null) {
            dataToSend.pk_value = options.primaryKeyValue;
        }

        this.sendGetRequest({
            url: this.$gc.data('url'),
            dataToSend: dataToSend,
            successCallback: function successCallback(jsonResponse) {
                var fieldList = this.cachedInitialData[options.fieldList],
                    readOnlyFieldList = options.readOnlyFields !== null ? this.cachedInitialData[options.readOnlyFields] : {};

                this[options.fieldsListName] = [];

                if (jsonResponse.csrfToken) {
                    this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
                }

                _underscore2.default.each(fieldList, function jsonResponseForEach(field) {
                    var fieldName = field.name,
                        fieldType = this.cachedInitialData[options.fieldTypes][fieldName];

                    if (fieldType === undefined) {
                        throw new Error('Can\'t find field name: "' + fieldName + '" in fieldTypes. ' + 'This is usually an error that you will see when you\'ve added a field name that doesn\'t exist ' + 'in the database.');
                    }

                    this[options.fieldsListName].push({
                        fieldName: fieldName,
                        displayAs: OperationsCommon.displayAs.apply(this, [fieldName, fieldList]).displayAs,
                        fieldValue: jsonResponse.data[fieldName],
                        fieldType: this.cachedInitialData[options.fieldTypes][fieldName].dataType,
                        fieldValues: this.cachedInitialData[options.fieldTypes][fieldName].permittedValues,
                        defaultValue: this.cachedInitialData[options.fieldTypes][fieldName].defaultValue,
                        showDefaultValue: options.action === 'add-form',
                        isNullable: this.cachedInitialData[options.fieldTypes][fieldName].isNullable,
                        isRequired: this.cachedInitialData[options.fieldTypes][fieldName].isRequired,
                        isReadOnly: readOnlyFieldList[fieldName] || options.isReadOnly || this.cachedInitialData[options.fieldTypes][fieldName].isReadOnly,
                        options: this.cachedInitialData[options.fieldTypes][fieldName].options ? this.cachedInitialData[options.fieldTypes][fieldName].options : null
                    });
                }.bind(this));

                OperationsCommon.showModal.apply(this, [options]);
            }.bind(this)
        });
    },
    showModal: function showModal(options) {
        this.$gc.find(Constants.SELECTOR_MODAL_FORM).find(Constants.SELECTOR_FORM).data('action', options.action);

        this.$gc.find(Constants.SELECTOR_MODAL_FORM).find(Constants.SELECTOR_FORM).data('primary-key-value', options.primaryKeyValue !== null ? options.primaryKeyValue : '');

        this.store.dispatch({
            type: options.action,
            fields: this[options.fieldsListName]
        });

        this.$gc.find(Constants.SELECTOR_MODAL_FORM).gc_modal({
            backdrop: false
        });

        if (options.action === 'read-form') {
            this.$gc.find('.options-on-save').hide();
            this.$gc.find('.save-changes').hide();
        } else {
            this.$gc.find('.options-on-save').show();
            this.$gc.find('.save-changes').show();
        }

        options.callbackAfterRender();
    },
    getTitle: function getTitle(titleType) {
        var subjectSingle = this.cachedInitialData.subject.subject_single;

        switch (titleType) {
            case Constants.ACTION_ADD_FORM:
                return i18n.format(i18n.t('add_item'), {
                    subject: subjectSingle
                });
            case Constants.ACTION_EDIT_FORM:
                return i18n.format(i18n.t('edit_item'), {
                    subject: subjectSingle
                });

            case Constants.ACTION_READ_FORM:
                return i18n.format(i18n.t('view_item'), {
                    subject: subjectSingle
                });

            case Constants.ACTION_CLONE_FORM:
                return i18n.format(i18n.t('add_item'), {
                    subject: subjectSingle
                });

            default:
                return titleType;
        }
    },
    initReduxStore: function initReduxStore() {
        this.store = (0, _redux.createStore)(_reducer2.default, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
        this.renderFieldList = function renderFieldList() {
            var currentState = this.store.getState(),
                title = OperationsCommon.getTitle.apply(this, [currentState.type]),
                _components = this.components,
                FieldRowWrapper = _components.FieldRowWrapper,
                ModalTitleWrapper = _components.ModalTitleWrapper;


            ReactDOM.render(React.createElement(_title2.default, {
                title: title,
                ModalTitleWrapper: ModalTitleWrapper
            }), OperationsCommon.getModalTitleDom.apply(this));
            ReactDOM.render(React.createElement(_fieldList2.default, {
                fields: currentState.fields,
                gcrudInstance: this,
                FieldInputComponent: _fieldInput2.default,
                FieldRowWrapper: FieldRowWrapper
            }), OperationsCommon.getFormDomContainer.apply(this));
        }.bind(this);
        this.store.subscribe(this.renderFieldList);
    },
    hideModalOnClose: function hideModalOnClose(selectorString) {
        this.$gc.find(selectorString).on('hidden.bs.modal', function onModalHideOnClose() {
            if (this.settings.hashEvents) {
                hasher.setHash('!');
            }
        }.bind(this));
    },
    listenerSubmitForm: function listenerInsertForm() {
        this.$gc.find(Constants.SELECTOR_MODAL_FORM).find(Constants.SELECTOR_FORM).submit(function SubmitAddForm(event) {
            var dataToSend = void 0;
            var currentAction = $(event.currentTarget).data('action');

            event.preventDefault();

            dataToSend = {
                data: ajaxHelper.getPostDataFromForm.apply(this, [this.$gc.find(Constants.SELECTOR_MODAL_FORM).find(Constants.SELECTOR_FORM)])
            };

            if (currentAction === Constants.ACTION_ADD_FORM) {
                dataToSend.action = Constants.ACTION_INSERT;
            } else if (currentAction === Constants.ACTION_EDIT_FORM) {
                dataToSend.action = Constants.ACTION_UPDATE;
                dataToSend.pk_value = $(event.currentTarget).data('primary-key-value');
            } else if (currentAction === Constants.ACTION_CLONE_FORM) {
                dataToSend.action = Constants.ACTION_CLONE;
            }

            if (this.cachedInitialData.csrfToken) {
                dataToSend[this.cachedInitialData.csrfToken.inputName] = this.cachedInitialData.csrfToken.inputValue;
            }

            this.sendPostRequest({
                url: this.$gc.data('url'),
                dataToSend: dataToSend,
                successCallback: function successCallback(jsonResponse) {
                    var rowToHighlight = void 0,
                        errors = void 0;

                    if (jsonResponse.csrfToken) {
                        this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
                    }

                    if (jsonResponse.status === 'success') {
                        rowToHighlight = dataToSend.action === Constants.ACTION_INSERT ? jsonResponse.insertId : dataToSend.pk_value;
                        if (this.$gc.find('.close-modal-on-save').is(':checked')) {
                            this.$gc.find(Constants.SELECTOR_MODAL_FORM).gc_modal('hide');
                        }
                        Grid.searchAndOrderingTrigger.apply(this, [rowToHighlight]);
                    } else if (jsonResponse.status === 'error') {
                        errors = [];
                        _underscore2.default.each(jsonResponse.errors, function forEachErrors(error) {
                            errors = _underscore2.default.union(errors, error);
                        });

                        this.$gc.find('.gc-error-modal').find('.gc-error-body').html('- ' + errors.join('<br/>- '));

                        this.$gc.find('.gc-error-modal').gc_modal({
                            backdrop: true
                        });
                    }
                }.bind(this)
            });
        }.bind(this));
    }
});

exports.OperationsCommon = OperationsCommon;

},{"../../../../../React-Components/gce-crud-forms/field-input.jsx":2,"../../../../../React-Components/gce-crud-forms/field-list.jsx":3,"../../../../../React-Components/gce-crud-forms/modal/title.jsx":33,"../../helpers/ajax-helper":79,"../constants":90,"./../datagrid/datagrid.grid.js":93,"./../i18n":97,"./reducer.js":104,"hasher":165,"redux":189,"underscore":198}],101:[function(require,module,exports){
'use strict';

var $ = jQuery,
    _ = require('underscore'),
    Grid = require('./../datagrid/datagrid.grid.js').Grid,
    Constants = require('../constants').Constants,
    OperationsCommon = require('./common').OperationsCommon,
    hasher = require('hasher'),
    OperationDelete = Object.create({
    actionDelete: function actionDelete(primaryKeyValue) {
        var confirmationTable;
        this.$gc.find(Constants.SELECTOR_DELETE_CONFIRMATION_BUTTON).data('delete-id', primaryKeyValue);

        confirmationTable = OperationDelete.confirmationTable.apply(this, [[primaryKeyValue]]);

        this.$gc.find('.delete-single-confirmation').find('.content-to-delete').html(confirmationTable);

        this.$gc.find(Constants.SELECTOR_DELETE_FORM_MODAL).gc_modal();
        this.$gc.find(Constants.SELECTOR_DELETE_FORM_MODAL).find(Constants.CANCEL_BUTTON).focus();
    },
    listenerDeleteMultiple: function listenerDeleteMultiple() {
        //Select All/None
        this.$gc.find('.select-all-none').click(function selectAllNoneOnClick(event) {
            if ($(event.currentTarget).is(':checked')) {
                this.$gc.find('.gc-select-row').each(function forEachSelectRow() {
                    $(this).prop('checked', true).closest('tr').addClass('warning');
                });
            } else {
                this.$gc.find('.gc-select-row').each(function forEachSelectRow() {
                    $(this).prop('checked', false).closest('tr').removeClass('warning');
                });
            }

            this.hideShowDeleteButton();
        }.bind(this));

        this.$gc.find('.delete-selected-button').click(function deleteSelectedButtonOnClick(event) {
            var multipleIds = OperationDelete.getMultipleDeleteIds.apply(this),
                confirmationTable;

            this.$gc.find('.gc-delete-count').html(multipleIds.length);

            confirmationTable = OperationDelete.confirmationTable.apply(this, [multipleIds]);

            this.$gc.find('.gc-delete-multiple-confirmation').find('.content-to-delete').html(confirmationTable);

            this.$gc.find(Constants.SELECTOR_MULTIPLE_DELETE_FORM_MODAL).gc_modal();

            event.preventDefault();
        }.bind(this));
    },
    confirmationTable: function confirmationTable(dataIds) {
        var $table = this.$gc.find('.grocery-crud-table'),
            $headerTr = $table.find('.header-columns').clone(),
            tableOutput,
            dataRows = '';

        _.each(dataIds, function foreachDataIds(dataId) {
            var $tr = $table.find('tr[data-id="' + dataId + '"]').clone();
            if ($tr.length === 0) {
                return false;
            }
            $tr.find('td.gc-row-checkbox').remove();
            $tr.find('td.gc-actions').remove();
            $tr.find('td').removeClass();
            dataRows += '<tr>' + $tr.html() + '</tr>';
        });

        $headerTr.find('.header-actions').remove();
        $headerTr.find('th>i').remove();
        $headerTr.find('th').removeClass();

        tableOutput = '<table class="table table-bordered table-hover">';
        tableOutput += '<tr>' + $headerTr.html() + '</tr>';
        tableOutput += dataRows;
        tableOutput += '</table>';

        return tableOutput;
    },
    onDeleteClick: function onDeleteClick(primaryKeyValue) {
        OperationDelete.actionDelete.apply(this, [primaryKeyValue]);
    },
    listenerDeleteSingleModal: function listenerDeleteSingleModal() {
        this.$gc.find(Constants.SELECTOR_DELETE_CONFIRMATION_BUTTON).click(function deleteConfirmationClick(event) {
            var dataToSend = {
                primaryKeyValue: $(event.currentTarget).data('delete-id'),
                action: Constants.ACTION_REMOVE_ONE
            };

            if (this.cachedInitialData.csrfToken) {
                dataToSend[this.cachedInitialData.csrfToken.inputName] = this.cachedInitialData.csrfToken.inputValue;
            }

            this.sendPostRequest({
                url: this.$gc.data('url'),
                dataToSend: dataToSend,
                successCallback: function successCallback(jsonResponse) {
                    var $fullTotal, total;

                    if (jsonResponse.csrfToken) {
                        this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
                    }

                    if (jsonResponse.status === Constants.RESPONSE.SUCCESS) {
                        $fullTotal = this.$gc.find('.full-total');
                        this.$gc.find(Constants.SELECTOR_DELETE_FORM_MODAL).gc_modal('hide');

                        total = parseInt($fullTotal.text(), 10) - 1;
                        if (total < 0) {
                            total = 0;
                        }

                        $fullTotal.html('' + total);

                        setTimeout(function searchAndOrderingTimeout() {
                            Grid.searchAndOrderingTrigger.apply(this);
                        }.bind(this), 200);
                    }
                }.bind(this)
            });
        }.bind(this));
    },
    listenerDeleteMultipleModal: function listenerDeleteSingleModal() {
        this.$gc.find(Constants.SELECTOR_MULTIPLE_DELETE_CONFIRMATION_BUTTON).click(function deleteMultipleConfirmationClick() {
            var dataToSend = {
                primaryKeys: OperationDelete.getMultipleDeleteIds.apply(this),
                action: Constants.ACTION_REMOVE_MULTIPLE
            },
                idsToDelete = dataToSend.primaryKeys.length;

            if (this.cachedInitialData.csrfToken) {
                dataToSend[this.cachedInitialData.csrfToken.inputName] = this.cachedInitialData.csrfToken.inputValue;
            }

            this.sendPostRequest({
                dataToSend: dataToSend,
                successCallback: function successCallback(jsonResponse) {
                    if (jsonResponse.csrfToken) {
                        this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
                    }

                    if (jsonResponse.status === 'success') {
                        this.$gc.find(Constants.SELECTOR_MULTIPLE_DELETE_FORM_MODAL).gc_modal('hide');
                        this.$gc.find('.full-total').html(parseInt(this.$gc.find('.full-total').text(), 10) - idsToDelete);
                        Grid.searchAndOrderingTrigger.apply(this);
                    }
                }.bind(this)
            });
        }.bind(this));
    },
    getMultipleDeleteIds: function getMultipleDeleteIds() {
        var deleteIds = [];

        this.$gc.find(Constants.SELECTOR_DELETE_CHECKBOX_CHECKED).each(function forEachGetMultipleIds() {
            deleteIds.push($(this).data('id'));
        });

        return deleteIds;
    },
    listenerSelectRow: function listenerSelectRow() {
        var datagrid_object = this;

        datagrid_object.$gc.find('.gc-select-row').click(function selectRowOnClick() {
            if ($(this).is(':checked')) {
                $(this).closest('tr').addClass('warning');
            } else {
                $(this).closest('tr').removeClass('warning');
            }

            datagrid_object.hideShowDeleteButton();
        });
    }
});

exports.OperationDelete = OperationDelete;

},{"../constants":90,"./../datagrid/datagrid.grid.js":93,"./common":100,"hasher":165,"underscore":198}],102:[function(require,module,exports){
'use strict';

var Constants = require('../constants').Constants,
    hasher = require('hasher'),
    OperationsCommon = require('./common').OperationsCommon,
    OperationEdit = Object.create({
    actionEdit: function eventEdit(primaryKeyValue) {

        OperationsCommon.operationDispatch.apply(this, [{
            action: Constants.ACTION_EDIT_FORM,
            fieldsListName: 'updateFields',
            fieldList: 'editFields',
            fieldTypes: 'fieldTypesEditForm',
            readOnlyFields: 'readOnlyEditFields',
            cache: false,
            primaryKeyValue: primaryKeyValue
        }]);
    },
    onEditClick: function onEditClick(primaryKeyValue) {
        if (this.settings.hashEvents) {
            hasher.setHash(this.hashEvent.editItem + '/' + primaryKeyValue);
        } else {
            OperationEdit.actionEdit.apply(this, [primaryKeyValue]);
        }
    }
});

exports.OperationEdit = OperationEdit;

},{"../constants":90,"./common":100,"hasher":165}],103:[function(require,module,exports){
'use strict';

var Constants = require('../constants').Constants,
    hasher = require('hasher'),
    OperationsCommon = require('./common').OperationsCommon,
    OperationRead = Object.create({
    actionRead: function actionRead(primaryKeyValue) {
        OperationsCommon.operationDispatch.apply(this, [{
            action: Constants.ACTION_READ_FORM,
            fieldsListName: 'readFields',
            fieldList: 'readFields',
            fieldTypes: 'fieldTypesReadForm',
            cache: false,
            isReadOnly: true,
            primaryKeyValue: primaryKeyValue
        }]);
    },
    onReadClick: function onReadClick(primaryKeyValue) {
        if (this.settings.hashEvents) {
            hasher.setHash(this.hashEvent.readItem + '/' + primaryKeyValue);
        } else {
            OperationRead.actionRead.apply(this, [primaryKeyValue]);
        }
    }
});

exports.OperationRead = OperationRead;

},{"../constants":90,"./common":100,"hasher":165}],104:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var action = arguments[1];

    if (!state) {
        return {
            type: action.type,
            fields: []
        };
    }

    return action;
};

},{}],105:[function(require,module,exports){
'use strict';

var hasher = require('hasher'),
    thisIncrease = 0,
    crossroads = require('crossroads'),
    OperationAdd = require('../operations/add').OperationAdd,
    OperationEdit = require('../operations/edit').OperationEdit,
    OperationClone = require('../operations/clone').OperationClone,
    OperationRead = require('../operations/read').OperationRead,
    Router = {
    setRoutes: function setRoutes() {
        var startingString = '';

        if (thisIncrease > 0) {
            startingString = thisIncrease + '/';
        }

        this.hashEvent = {};
        this.hashEvent.addItem = startingString + 'add';
        this.hashEvent.editItem = startingString + 'edit';
        this.hashEvent.cloneItem = startingString + 'clone';
        this.hashEvent.readItem = startingString + 'read';
        this.hashEvent.deleteItem = startingString + 'delete';
        this.hashEvent.urlUniqueHash = startingString;
    },
    init: function init() {
        var parseHash = function parseHash(newHash) {
            crossroads.parse(newHash);
        };

        // This line is in order to call the route as many times as we want!
        crossroads.ignoreState = true;

        if (this.settings.hashEvents) {
            crossroads.addRoute(this.hashEvent.addItem, function operationAddRoute() {
                OperationAdd.actionAdd.apply(this);
            }.bind(this));

            crossroads.addRoute(this.hashEvent.editItem + '/{primaryKeyValue}', function operationEditRoute(primaryKeyValue) {
                OperationEdit.actionEdit.apply(this, [primaryKeyValue]);
            }.bind(this));

            crossroads.addRoute(this.hashEvent.cloneItem + '/{primaryKeyValue}', function operationCloneRoute(primaryKeyValue) {
                OperationClone.actionClone.apply(this, [primaryKeyValue]);
            }.bind(this));

            crossroads.addRoute(this.hashEvent.readItem + '/{primaryKeyValue}', function operationReadRoute(primaryKeyValue) {
                OperationRead.actionRead.apply(this, [primaryKeyValue]);
            }.bind(this));
        }

        if (thisIncrease === 0) {
            hasher.initialized.add(parseHash);
            hasher.changed.add(parseHash);

            // start listening for history changes
            hasher.init();
        }

        thisIncrease++;
    }
};

exports.Router = Object.create(Router);

},{"../operations/add":98,"../operations/clone":99,"../operations/edit":102,"../operations/read":103,"crossroads":120,"hasher":165}],106:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CallbackColumn = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (fieldData.dataType === 'callback_column') {
                this.callbackColumnFields[fieldName] = true;
            }
        }.bind(this));
    },
    isThisType: function isThisType(fieldName) {
        return this.callbackColumnFields[fieldName];
    }
});

exports.CallbackColumn = CallbackColumn;

},{"underscore":198}],107:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CheckboxBoolean = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (fieldData.dataType === 'checkbox_boolean') {
                this.checkboxBooleanFields.push(fieldName);
                this.checkboxBooleanFieldsData[fieldName] = {};

                this.checkboxBooleanFieldsData[fieldName] = fieldData.permittedValues;
            }
        }.bind(this));
    },
    isCheckboxBoolean: function isCheckboxBoolean(fieldName) {
        if (this.checkboxBooleanFields.length === 0) {
            return false;
        }

        if (this.checkboxBooleanFields.indexOf(fieldName) > -1) {
            return true;
        }

        return false;
    },
    formatValue: function formatValue(fieldValue) {
        if (fieldValue === '1') {
            return '<i class="fa fa-check"></i>';
        }

        return '';
    }
});

exports.CheckboxBoolean = CheckboxBoolean;

},{"underscore":198}],108:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Constants = require('../constants').Constants,
    DateAndTime = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (fieldData.dataType === Constants.FIELD_TYPE_DATE) {
                this.dateFields.push(fieldName);
            } else if (/^(datetime|timestamp)$/i.test(fieldData.dataType)) {
                this.datetimeFields.push(fieldName);
            }
        }.bind(this));
    },
    getFormatter: function getFormatter() {
        if (this.dateFormatter === null) {

            if (typeof Intl !== 'undefined') {
                this.dateFormatter = new Intl.DateTimeFormat(DateAndTime.getLocale());
            } else {
                this.dateFormatter = {
                    format: function format(myDate) {
                        return myDate.toLocaleDateString();
                    }
                };
            }
        }

        return this.dateFormatter;
    },
    formatDateLocale: function formatDateLocale(rawDate) {
        var myDate, formatter;

        if (rawDate === '0000-00-00') {
            return '';
        }

        myDate = new Date(rawDate);
        formatter = DateAndTime.getFormatter.apply(this);

        if (!DateAndTime.isValidDate(myDate)) {
            return '';
        }

        return formatter.format(myDate);
    },
    formatDatetimeLocale: function formatDatetimeLocale(rawDate) {
        var myDate, formatter;

        if (rawDate === '0000-00-00 00:00:00') {
            return '';
        }

        myDate = new Date(rawDate);
        formatter = DateAndTime.getFormatter.apply(this);

        if (!DateAndTime.isValidDate(myDate)) {
            return '';
        }

        return formatter.format(myDate) + ' ' + myDate.toLocaleTimeString();
    },
    getLocale: function getLocale() {
        if (navigator.languages !== undefined) {
            return navigator.languages[0];
        }

        return navigator.language;
    },
    isValidDate: function isValidDate(myDate) {
        if (Object.prototype.toString.call(myDate) === '[object Date]') {
            return !isNaN(myDate.getTime());
        }

        return false;
    },
    isDatetime: function isNtoN(fieldName) {
        if (this.datetimeFields.length === 0) {
            return false;
        }

        return this.datetimeFields.indexOf(fieldName) > -1;
    },
    isDate: function isNtoN(fieldName) {
        if (this.dateFields.length === 0) {
            return false;
        }

        return this.dateFields.indexOf(fieldName) > -1;
    }
});

exports.DateAndTime = DateAndTime;

},{"../constants":90,"underscore":198}],109:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Dropdown = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (/^dropdown(_search)?$/.test(fieldData.dataType)) {
                this.dropdownFields.push(fieldName);
                this.dropdownFieldsData[fieldName] = {};

                this.dropdownFieldsData[fieldName] = fieldData.permittedValues;
            }
        }.bind(this));
    },
    isDropdown: function isDropdown(fieldName) {
        if (this.dropdownFields.length === 0) {
            return false;
        }

        if (this.dropdownFields.indexOf(fieldName) > -1) {
            return true;
        }

        return false;
    },
    formatValue: function formatValue(fieldName, fieldValue) {
        var data;

        if (!fieldValue) {
            return '';
        }

        data = this.dropdownFieldsData[fieldName];

        if (!_underscore2.default.isUndefined(data[fieldValue])) {
            return data[fieldValue];
        }

        return fieldValue;
    }
});

exports.Dropdown = Dropdown;

},{"underscore":198}],110:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Enum = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (fieldData.dataType === 'enum') {
                this.enumFields.push(fieldName);
                this.enumFieldsData[fieldName] = {};

                this.enumFieldsData[fieldName] = fieldData.permittedValues;
            }
        }.bind(this));
    },
    isEnum: function isEnum(fieldName) {
        if (this.enumFields.length === 0) {
            return false;
        }

        if (this.enumFields.indexOf(fieldName) > -1) {
            return true;
        }

        return false;
    }
});

exports.Enum = Enum;

},{"underscore":198}],111:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MultipleSelect = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (fieldData.dataType === 'multiselect_searchable' || fieldData.dataType === 'multiselect_native') {

                this.multipleSelectFields[fieldName] = true;
                this.multipleSelectData[fieldName] = {};

                _underscore2.default.each(fieldData.permittedValues, function foreachData(dataLabel, dataIndex) {
                    this.multipleSelectData[fieldName][dataIndex] = dataLabel;
                }.bind(this));
            }
        }.bind(this));
    },
    isThisType: function isThisType(fieldName) {
        return this.multipleSelectFields[fieldName];
    },
    transformData: function transformData(fieldName, fieldData) {
        var finalString = void 0,
            finalArray = [];
        _underscore2.default.each(fieldData.split(','), function foreachTransformData(dataValue) {
            if (this.multipleSelectData[fieldName][dataValue] !== undefined) {
                finalArray.push(this.multipleSelectData[fieldName][dataValue]);
            }
        }.bind(this));

        finalString = finalArray.join(',');

        return finalString;
    }
});

exports.MultipleSelect = MultipleSelect;

},{"underscore":198}],112:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Constants = require('../constants').Constants,
    RelationNtoN = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (fieldData.dataType === Constants.FIELD_TYPE_RELATION_N_TO_N || fieldData.dataType === Constants.FIELD_TYPE_NATIVE_RELATION_N_TO_N || fieldData.dataType === Constants.FIELD_TYPE_SEARCHABLE_N_TO_N) {

                this.relationNtoNFields[fieldName] = true;
                this.relationNtoNData[fieldName] = {};

                _underscore2.default.each(fieldData.permittedValues, function foreachData(data) {
                    this.relationNtoNData[fieldName][data.id] = data.title;
                }.bind(this));
            }
        }.bind(this));
    },
    isNtoN: function isNtoN(fieldName) {
        return this.relationNtoNFields[fieldName];
    },
    transformData: function transformData(fieldName, fieldData) {
        var finalString = '';
        _underscore2.default.each(fieldData, function foreachTransformData(dataValue) {
            if (this.relationNtoNData[fieldName][dataValue] !== undefined) {
                finalString += this.relationNtoNData[fieldName][dataValue] + ', ';
            }
        }.bind(this));

        if (finalString.length > 1) {
            finalString = finalString.substr(0, finalString.length - 2);
        }

        return finalString;
    }
});

exports.RelationNtoN = RelationNtoN;

},{"../constants":90,"underscore":198}],113:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Constants = require('../constants').Constants,
    Relation = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (fieldData.dataType === Constants.FIELD_TYPE_RELATION || fieldData.dataType === Constants.FIELD_TYPE_RELATION_NATIVE) {
                this.relationFields.push(fieldName);
                this.relationData[fieldName] = {};

                _underscore2.default.each(fieldData.permittedValues, function foreachData(data) {
                    this.relationData[fieldName][data.id] = data.title;
                }.bind(this));
            }
        }.bind(this));
    },
    isRelational: function isRelational(fieldName) {
        if (this.relationFields.length === 0) {
            return false;
        }

        if (this.relationFields.indexOf(fieldName) > -1) {
            return true;
        }

        return false;
    },
    transformData: function transformData(fieldName, fieldData) {
        if (this.relationData[fieldName][fieldData] !== undefined) {
            return this.relationData[fieldName][fieldData];
        }

        return fieldData;
    }
});

exports.Relation = Relation;

},{"../constants":90,"underscore":198}],114:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Texteditor = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (fieldData.dataType === 'texteditor') {
                this.texteditorFields[fieldName] = true;
            }
        }.bind(this));
    },
    isThisType: function isThisType(fieldName) {
        return this.texteditorFields[fieldName];
    }
});

exports.Texteditor = Texteditor;

},{"underscore":198}],115:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Upload = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (fieldData.dataType === 'upload') {
                this.uploadFields.push(fieldName);

                this.uploadFieldsData[fieldName] = fieldData.options;
            }
        }.bind(this));
    },
    isUploadType: function isUploadType(fieldName) {
        if (this.uploadFields.length === 0) {
            return false;
        }

        return this.uploadFields.indexOf(fieldName) > -1;
    },
    formatUpload: function formatUpload(fieldName, fieldValue) {
        var url;

        if (!fieldValue) {
            return '';
        }

        url = this.uploadFieldsData[fieldName].publicPath + '/' + fieldValue;

        return '<a href="' + url + '" target="_blank">' + fieldValue + '</a>';
    }
});

exports.Upload = Upload;

},{"underscore":198}],116:[function(require,module,exports){
(function (process,__filename){
/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 1.0.1 Copyright (c) 2011-2016, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                if (callback) {
                    process.nextTick(function () {
                        callback.apply(null, deps);
                    });
                }
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

}).call(this,require('_process'),"/node_modules/amdefine/amdefine.js")

},{"_process":178,"path":177}],117:[function(require,module,exports){

},{}],118:[function(require,module,exports){
/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());

},{}],119:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],120:[function(require,module,exports){
/** @license
 * crossroads <http://millermedeiros.github.com/crossroads.js/>
 * Author: Miller Medeiros | MIT License
 * v0.12.2 (2015/07/31 18:37)
 */

(function () {
var factory = function (signals) {

    var crossroads,
        _hasOptionalGroupBug,
        UNDEF;

    // Helpers -----------
    //====================

    // IE 7-8 capture optional groups as empty strings while other browsers
    // capture as `undefined`
    _hasOptionalGroupBug = (/t(.+)?/).exec('t')[1] === '';

    function arrayIndexOf(arr, val) {
        if (arr.indexOf) {
            return arr.indexOf(val);
        } else {
            //Array.indexOf doesn't work on IE 6-7
            var n = arr.length;
            while (n--) {
                if (arr[n] === val) {
                    return n;
                }
            }
            return -1;
        }
    }

    function arrayRemove(arr, item) {
        var i = arrayIndexOf(arr, item);
        if (i !== -1) {
            arr.splice(i, 1);
        }
    }

    function isKind(val, kind) {
        return '[object '+ kind +']' === Object.prototype.toString.call(val);
    }

    function isRegExp(val) {
        return isKind(val, 'RegExp');
    }

    function isArray(val) {
        return isKind(val, 'Array');
    }

    function isFunction(val) {
        return typeof val === 'function';
    }

    //borrowed from AMD-utils
    function typecastValue(val) {
        var r;
        if (val === null || val === 'null') {
            r = null;
        } else if (val === 'true') {
            r = true;
        } else if (val === 'false') {
            r = false;
        } else if (val === UNDEF || val === 'undefined') {
            r = UNDEF;
        } else if (val === '' || isNaN(val)) {
            //isNaN('') returns false
            r = val;
        } else {
            //parseFloat(null || '') returns NaN
            r = parseFloat(val);
        }
        return r;
    }

    function typecastArrayValues(values) {
        var n = values.length,
            result = [];
        while (n--) {
            result[n] = typecastValue(values[n]);
        }
        return result;
    }

    // borrowed from MOUT
    function decodeQueryString(queryStr, shouldTypecast) {
        var queryArr = (queryStr || '').replace('?', '').split('&'),
            reg = /([^=]+)=(.+)/,
            i = -1,
            obj = {},
            equalIndex, cur, pValue, pName;

        while ((cur = queryArr[++i])) {
            equalIndex = cur.indexOf('=');
            pName = cur.substring(0, equalIndex);
            pValue = decodeURIComponent(cur.substring(equalIndex + 1));
            if (shouldTypecast !== false) {
                pValue = typecastValue(pValue);
            }
            if (pName in obj){
                if(isArray(obj[pName])){
                    obj[pName].push(pValue);
                } else {
                    obj[pName] = [obj[pName], pValue];
                }
            } else {
                obj[pName] = pValue;
           }
        }
        return obj;
    }


    // Crossroads --------
    //====================

    /**
     * @constructor
     */
    function Crossroads() {
        this.bypassed = new signals.Signal();
        this.routed = new signals.Signal();
        this._routes = [];
        this._prevRoutes = [];
        this._piped = [];
        this.resetState();
    }

    Crossroads.prototype = {

        greedy : false,

        greedyEnabled : true,

        ignoreCase : true,

        ignoreState : false,

        shouldTypecast : false,

        normalizeFn : null,

        resetState : function(){
            this._prevRoutes.length = 0;
            this._prevMatchedRequest = null;
            this._prevBypassedRequest = null;
        },

        create : function () {
            return new Crossroads();
        },

        addRoute : function (pattern, callback, priority) {
            var route = new Route(pattern, callback, priority, this);
            this._sortedInsert(route);
            return route;
        },

        removeRoute : function (route) {
            arrayRemove(this._routes, route);
            route._destroy();
        },

        removeAllRoutes : function () {
            var n = this.getNumRoutes();
            while (n--) {
                this._routes[n]._destroy();
            }
            this._routes.length = 0;
        },

        parse : function (request, defaultArgs) {
            request = request || '';
            defaultArgs = defaultArgs || [];

            // should only care about different requests if ignoreState isn't true
            if ( !this.ignoreState &&
                (request === this._prevMatchedRequest ||
                 request === this._prevBypassedRequest) ) {
                return;
            }

            var routes = this._getMatchedRoutes(request),
                i = 0,
                n = routes.length,
                cur;

            if (n) {
                this._prevMatchedRequest = request;

                this._notifyPrevRoutes(routes, request);
                this._prevRoutes = routes;
                //should be incremental loop, execute routes in order
                while (i < n) {
                    cur = routes[i];
                    cur.route.matched.dispatch.apply(cur.route.matched, defaultArgs.concat(cur.params));
                    cur.isFirst = !i;
                    this.routed.dispatch.apply(this.routed, defaultArgs.concat([request, cur]));
                    i += 1;
                }
            } else {
                this._prevBypassedRequest = request;
                this.bypassed.dispatch.apply(this.bypassed, defaultArgs.concat([request]));
            }

            this._pipeParse(request, defaultArgs);
        },

        _notifyPrevRoutes : function(matchedRoutes, request) {
            var i = 0, prev;
            while (prev = this._prevRoutes[i++]) {
                //check if switched exist since route may be disposed
                if(prev.route.switched && this._didSwitch(prev.route, matchedRoutes)) {
                    prev.route.switched.dispatch(request);
                }
            }
        },

        _didSwitch : function (route, matchedRoutes){
            var matched,
                i = 0;
            while (matched = matchedRoutes[i++]) {
                // only dispatch switched if it is going to a different route
                if (matched.route === route) {
                    return false;
                }
            }
            return true;
        },

        _pipeParse : function(request, defaultArgs) {
            var i = 0, route;
            while (route = this._piped[i++]) {
                route.parse(request, defaultArgs);
            }
        },

        getNumRoutes : function () {
            return this._routes.length;
        },

        _sortedInsert : function (route) {
            //simplified insertion sort
            var routes = this._routes,
                n = routes.length;
            do { --n; } while (routes[n] && route._priority <= routes[n]._priority);
            routes.splice(n+1, 0, route);
        },

        _getMatchedRoutes : function (request) {
            var res = [],
                routes = this._routes,
                n = routes.length,
                route;
            //should be decrement loop since higher priorities are added at the end of array
            while (route = routes[--n]) {
                if ((!res.length || this.greedy || route.greedy) && route.match(request)) {
                    res.push({
                        route : route,
                        params : route._getParamsArray(request)
                    });
                }
                if (!this.greedyEnabled && res.length) {
                    break;
                }
            }
            return res;
        },

        pipe : function (otherRouter) {
            this._piped.push(otherRouter);
        },

        unpipe : function (otherRouter) {
            arrayRemove(this._piped, otherRouter);
        },

        toString : function () {
            return '[crossroads numRoutes:'+ this.getNumRoutes() +']';
        }
    };

    //"static" instance
    crossroads = new Crossroads();
    crossroads.VERSION = '0.12.2';

    crossroads.NORM_AS_ARRAY = function (req, vals) {
        return [vals.vals_];
    };

    crossroads.NORM_AS_OBJECT = function (req, vals) {
        return [vals];
    };


    // Route --------------
    //=====================

    /**
     * @constructor
     */
    function Route(pattern, callback, priority, router) {
        var isRegexPattern = isRegExp(pattern),
            patternLexer = router.patternLexer;
        this._router = router;
        this._pattern = pattern;
        this._paramsIds = isRegexPattern? null : patternLexer.getParamIds(pattern);
        this._optionalParamsIds = isRegexPattern? null : patternLexer.getOptionalParamsIds(pattern);
        this._matchRegexp = isRegexPattern? pattern : patternLexer.compilePattern(pattern, router.ignoreCase);
        this.matched = new signals.Signal();
        this.switched = new signals.Signal();
        if (callback) {
            this.matched.add(callback);
        }
        this._priority = priority || 0;
    }

    Route.prototype = {

        greedy : false,

        rules : void(0),

        match : function (request) {
            request = request || '';
            return this._matchRegexp.test(request) && this._validateParams(request); //validate params even if regexp because of `request_` rule.
        },

        _validateParams : function (request) {
            var rules = this.rules,
                values = this._getParamsObject(request),
                key;
            for (key in rules) {
                // normalize_ isn't a validation rule... (#39)
                if(key !== 'normalize_' && rules.hasOwnProperty(key) && ! this._isValidParam(request, key, values)){
                    return false;
                }
            }
            return true;
        },

        _isValidParam : function (request, prop, values) {
            var validationRule = this.rules[prop],
                val = values[prop],
                isValid = false,
                isQuery = (prop.indexOf('?') === 0);

            if (val == null && this._optionalParamsIds && arrayIndexOf(this._optionalParamsIds, prop) !== -1) {
                isValid = true;
            }
            else if (isRegExp(validationRule)) {
                if (isQuery) {
                    val = values[prop +'_']; //use raw string
                }
                isValid = validationRule.test(val);
            }
            else if (isArray(validationRule)) {
                if (isQuery) {
                    val = values[prop +'_']; //use raw string
                }
                isValid = this._isValidArrayRule(validationRule, val);
            }
            else if (isFunction(validationRule)) {
                isValid = validationRule(val, request, values);
            }

            return isValid; //fail silently if validationRule is from an unsupported type
        },

        _isValidArrayRule : function (arr, val) {
            if (! this._router.ignoreCase) {
                return arrayIndexOf(arr, val) !== -1;
            }

            if (typeof val === 'string') {
                val = val.toLowerCase();
            }

            var n = arr.length,
                item,
                compareVal;

            while (n--) {
                item = arr[n];
                compareVal = (typeof item === 'string')? item.toLowerCase() : item;
                if (compareVal === val) {
                    return true;
                }
            }
            return false;
        },

        _getParamsObject : function (request) {
            var shouldTypecast = this._router.shouldTypecast,
                values = this._router.patternLexer.getParamValues(request, this._matchRegexp, shouldTypecast),
                o = {},
                n = values.length,
                param, val;
            while (n--) {
                val = values[n];
                if (this._paramsIds) {
                    param = this._paramsIds[n];
                    if (param.indexOf('?') === 0 && val) {
                        //make a copy of the original string so array and
                        //RegExp validation can be applied properly
                        o[param +'_'] = val;
                        //update vals_ array as well since it will be used
                        //during dispatch
                        val = decodeQueryString(val, shouldTypecast);
                        values[n] = val;
                    }
                    // IE will capture optional groups as empty strings while other
                    // browsers will capture `undefined` so normalize behavior.
                    // see: #gh-58, #gh-59, #gh-60
                    if ( _hasOptionalGroupBug && val === '' && arrayIndexOf(this._optionalParamsIds, param) !== -1 ) {
                        val = void(0);
                        values[n] = val;
                    }
                    o[param] = val;
                }
                //alias to paths and for RegExp pattern
                o[n] = val;
            }
            o.request_ = shouldTypecast? typecastValue(request) : request;
            o.vals_ = values;
            return o;
        },

        _getParamsArray : function (request) {
            var norm = this.rules? this.rules.normalize_ : null,
                params;
            norm = norm || this._router.normalizeFn; // default normalize
            if (norm && isFunction(norm)) {
                params = norm(request, this._getParamsObject(request));
            } else {
                params = this._getParamsObject(request).vals_;
            }
            return params;
        },

        interpolate : function(replacements) {
            var str = this._router.patternLexer.interpolate(this._pattern, replacements);
            if (! this._validateParams(str) ) {
                throw new Error('Generated string doesn\'t validate against `Route.rules`.');
            }
            return str;
        },

        dispose : function () {
            this._router.removeRoute(this);
        },

        _destroy : function () {
            this.matched.dispose();
            this.switched.dispose();
            this.matched = this.switched = this._pattern = this._matchRegexp = null;
        },

        toString : function () {
            return '[Route pattern:"'+ this._pattern +'", numListeners:'+ this.matched.getNumListeners() +']';
        }

    };



    // Pattern Lexer ------
    //=====================

    Crossroads.prototype.patternLexer = (function () {

        var
            //match chars that should be escaped on string regexp
            ESCAPE_CHARS_REGEXP = /[\\.+*?\^$\[\](){}\/'#]/g,

            //trailing slashes (begin/end of string)
            LOOSE_SLASHES_REGEXP = /^\/|\/$/g,
            LEGACY_SLASHES_REGEXP = /\/$/g,

            //params - everything between `{ }` or `: :`
            PARAMS_REGEXP = /(?:\{|:)([^}:]+)(?:\}|:)/g,

            //used to save params during compile (avoid escaping things that
            //shouldn't be escaped).
            TOKENS = {
                'OS' : {
                    //optional slashes
                    //slash between `::` or `}:` or `\w:` or `:{?` or `}{?` or `\w{?`
                    rgx : /([:}]|\w(?=\/))\/?(:|(?:\{\?))/g,
                    save : '$1{{id}}$2',
                    res : '\\/?'
                },
                'RS' : {
                    //required slashes
                    //used to insert slash between `:{` and `}{`
                    rgx : /([:}])\/?(\{)/g,
                    save : '$1{{id}}$2',
                    res : '\\/'
                },
                'RQ' : {
                    //required query string - everything in between `{? }`
                    rgx : /\{\?([^}]+)\}/g,
                    //everything from `?` till `#` or end of string
                    res : '\\?([^#]+)'
                },
                'OQ' : {
                    //optional query string - everything in between `:? :`
                    rgx : /:\?([^:]+):/g,
                    //everything from `?` till `#` or end of string
                    res : '(?:\\?([^#]*))?'
                },
                'OR' : {
                    //optional rest - everything in between `: *:`
                    rgx : /:([^:]+)\*:/g,
                    res : '(.*)?' // optional group to avoid passing empty string as captured
                },
                'RR' : {
                    //rest param - everything in between `{ *}`
                    rgx : /\{([^}]+)\*\}/g,
                    res : '(.+)'
                },
                // required/optional params should come after rest segments
                'RP' : {
                    //required params - everything between `{ }`
                    rgx : /\{([^}]+)\}/g,
                    res : '([^\\/?]+)'
                },
                'OP' : {
                    //optional params - everything between `: :`
                    rgx : /:([^:]+):/g,
                    res : '([^\\/?]+)?\/?'
                }
            },

            LOOSE_SLASH = 1,
            STRICT_SLASH = 2,
            LEGACY_SLASH = 3,

            _slashMode = LOOSE_SLASH;


        function precompileTokens(){
            var key, cur;
            for (key in TOKENS) {
                if (TOKENS.hasOwnProperty(key)) {
                    cur = TOKENS[key];
                    cur.id = '__CR_'+ key +'__';
                    cur.save = ('save' in cur)? cur.save.replace('{{id}}', cur.id) : cur.id;
                    cur.rRestore = new RegExp(cur.id, 'g');
                }
            }
        }
        precompileTokens();


        function captureVals(regex, pattern) {
            var vals = [], match;
            // very important to reset lastIndex since RegExp can have "g" flag
            // and multiple runs might affect the result, specially if matching
            // same string multiple times on IE 7-8
            regex.lastIndex = 0;
            while (match = regex.exec(pattern)) {
                vals.push(match[1]);
            }
            return vals;
        }

        function getParamIds(pattern) {
            return captureVals(PARAMS_REGEXP, pattern);
        }

        function getOptionalParamsIds(pattern) {
            return captureVals(TOKENS.OP.rgx, pattern);
        }

        function compilePattern(pattern, ignoreCase) {
            pattern = pattern || '';

            if(pattern){
                if (_slashMode === LOOSE_SLASH) {
                    pattern = pattern.replace(LOOSE_SLASHES_REGEXP, '');
                }
                else if (_slashMode === LEGACY_SLASH) {
                    pattern = pattern.replace(LEGACY_SLASHES_REGEXP, '');
                }

                //save tokens
                pattern = replaceTokens(pattern, 'rgx', 'save');
                //regexp escape
                pattern = pattern.replace(ESCAPE_CHARS_REGEXP, '\\$&');
                //restore tokens
                pattern = replaceTokens(pattern, 'rRestore', 'res');

                if (_slashMode === LOOSE_SLASH) {
                    pattern = '\\/?'+ pattern;
                }
            }

            if (_slashMode !== STRICT_SLASH) {
                //single slash is treated as empty and end slash is optional
                pattern += '\\/?';
            }
            return new RegExp('^'+ pattern + '$', ignoreCase? 'i' : '');
        }

        function replaceTokens(pattern, regexpName, replaceName) {
            var cur, key;
            for (key in TOKENS) {
                if (TOKENS.hasOwnProperty(key)) {
                    cur = TOKENS[key];
                    pattern = pattern.replace(cur[regexpName], cur[replaceName]);
                }
            }
            return pattern;
        }

        function getParamValues(request, regexp, shouldTypecast) {
            var vals = regexp.exec(request);
            if (vals) {
                vals.shift();
                if (shouldTypecast) {
                    vals = typecastArrayValues(vals);
                }
            }
            return vals;
        }

        function interpolate(pattern, replacements) {
            // default to an empty object because pattern might have just
            // optional arguments
            replacements = replacements || {};
            if (typeof pattern !== 'string') {
                throw new Error('Route pattern should be a string.');
            }

            var replaceFn = function(match, prop){
                    var val;
                    prop = (prop.substr(0, 1) === '?')? prop.substr(1) : prop;
                    if (replacements[prop] != null) {
                        if (typeof replacements[prop] === 'object') {
                            var queryParts = [], rep;
                            for(var key in replacements[prop]) {
                                rep = replacements[prop][key];
                                if (isArray(rep)) {
                                    for (var k in rep) {
                                        if ( key.slice(-2) == '[]' ) {
                                            queryParts.push(encodeURI(key.slice(0, -2)) + '[]=' + encodeURI(rep[k]));
                                        } else {
                                            queryParts.push(encodeURI(key + '=' + rep[k]));
                                        }
                                    }
                                }
                                else {
                                    queryParts.push(encodeURI(key + '=' + rep));
                                }
                            }
                            val = '?' + queryParts.join('&');
                        } else {
                            // make sure value is a string see #gh-54
                            val = String(replacements[prop]);
                        }

                        if (match.indexOf('*') === -1 && val.indexOf('/') !== -1) {
                            throw new Error('Invalid value "'+ val +'" for segment "'+ match +'".');
                        }
                    }
                    else if (match.indexOf('{') !== -1) {
                        throw new Error('The segment '+ match +' is required.');
                    }
                    else {
                        val = '';
                    }
                    return val;
                };

            if (! TOKENS.OS.trail) {
                TOKENS.OS.trail = new RegExp('(?:'+ TOKENS.OS.id +')+$');
            }

            return pattern
                        .replace(TOKENS.OS.rgx, TOKENS.OS.save)
                        .replace(PARAMS_REGEXP, replaceFn)
                        .replace(TOKENS.OS.trail, '') // remove trailing
                        .replace(TOKENS.OS.rRestore, '/'); // add slash between segments
        }

        //API
        return {
            strict : function(){
                _slashMode = STRICT_SLASH;
            },
            loose : function(){
                _slashMode = LOOSE_SLASH;
            },
            legacy : function(){
                _slashMode = LEGACY_SLASH;
            },
            getParamIds : getParamIds,
            getOptionalParamsIds : getOptionalParamsIds,
            getParamValues : getParamValues,
            compilePattern : compilePattern,
            interpolate : interpolate
        };

    }());


    return crossroads;
};

if (typeof define === 'function' && define.amd) {
    define(['signals'], factory);
} else if (typeof module !== 'undefined' && module.exports) { //Node
    module.exports = factory(require('signals'));
} else {
    /*jshint sub:true */
    window['crossroads'] = factory(window['signals']);
}

}());


},{"signals":191}],121:[function(require,module,exports){
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;
},{}],122:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if ("production" !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
},{}],123:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var emptyFunction = require('./emptyFunction');

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if ("production" !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
},{"./emptyFunction":121}],124:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _handlebarsRuntime = require('./handlebars.runtime');

var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);

// Compiler imports

var _handlebarsCompilerAst = require('./handlebars/compiler/ast');

var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);

var _handlebarsCompilerBase = require('./handlebars/compiler/base');

var _handlebarsCompilerCompiler = require('./handlebars/compiler/compiler');

var _handlebarsCompilerJavascriptCompiler = require('./handlebars/compiler/javascript-compiler');

var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);

var _handlebarsCompilerVisitor = require('./handlebars/compiler/visitor');

var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);

var _handlebarsNoConflict = require('./handlebars/no-conflict');

var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

var _create = _handlebarsRuntime2['default'].create;
function create() {
  var hb = _create();

  hb.compile = function (input, options) {
    return _handlebarsCompilerCompiler.compile(input, options, hb);
  };
  hb.precompile = function (input, options) {
    return _handlebarsCompilerCompiler.precompile(input, options, hb);
  };

  hb.AST = _handlebarsCompilerAst2['default'];
  hb.Compiler = _handlebarsCompilerCompiler.Compiler;
  hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
  hb.Parser = _handlebarsCompilerBase.parser;
  hb.parse = _handlebarsCompilerBase.parse;

  return hb;
}

var inst = create();
inst.create = create;

_handlebarsNoConflict2['default'](inst);

inst.Visitor = _handlebarsCompilerVisitor2['default'];

inst['default'] = inst;

exports['default'] = inst;
module.exports = exports['default'];


},{"./handlebars.runtime":125,"./handlebars/compiler/ast":127,"./handlebars/compiler/base":128,"./handlebars/compiler/compiler":130,"./handlebars/compiler/javascript-compiler":132,"./handlebars/compiler/visitor":135,"./handlebars/no-conflict":149}],125:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _handlebarsBase = require('./handlebars/base');

var base = _interopRequireWildcard(_handlebarsBase);

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)

var _handlebarsSafeString = require('./handlebars/safe-string');

var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

var _handlebarsException = require('./handlebars/exception');

var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

var _handlebarsUtils = require('./handlebars/utils');

var Utils = _interopRequireWildcard(_handlebarsUtils);

var _handlebarsRuntime = require('./handlebars/runtime');

var runtime = _interopRequireWildcard(_handlebarsRuntime);

var _handlebarsNoConflict = require('./handlebars/no-conflict');

var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
function create() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = _handlebarsSafeString2['default'];
  hb.Exception = _handlebarsException2['default'];
  hb.Utils = Utils;
  hb.escapeExpression = Utils.escapeExpression;

  hb.VM = runtime;
  hb.template = function (spec) {
    return runtime.template(spec, hb);
  };

  return hb;
}

var inst = create();
inst.create = create;

_handlebarsNoConflict2['default'](inst);

inst['default'] = inst;

exports['default'] = inst;
module.exports = exports['default'];


},{"./handlebars/base":126,"./handlebars/exception":139,"./handlebars/no-conflict":149,"./handlebars/runtime":150,"./handlebars/safe-string":151,"./handlebars/utils":152}],126:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.HandlebarsEnvironment = HandlebarsEnvironment;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _helpers = require('./helpers');

var _decorators = require('./decorators');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var VERSION = '4.0.11';
exports.VERSION = VERSION;
var COMPILER_REVISION = 7;

exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '== 1.x.x',
  5: '== 2.0.0-alpha.x',
  6: '>= 2.0.0-beta.1',
  7: '>= 4.0.0'
};

exports.REVISION_CHANGES = REVISION_CHANGES;
var objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials, decorators) {
  this.helpers = helpers || {};
  this.partials = partials || {};
  this.decorators = decorators || {};

  _helpers.registerDefaultHelpers(this);
  _decorators.registerDefaultDecorators(this);
}

HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: _logger2['default'],
  log: _logger2['default'].log,

  registerHelper: function registerHelper(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple helpers');
      }
      _utils.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn;
    }
  },
  unregisterHelper: function unregisterHelper(name) {
    delete this.helpers[name];
  },

  registerPartial: function registerPartial(name, partial) {
    if (_utils.toString.call(name) === objectType) {
      _utils.extend(this.partials, name);
    } else {
      if (typeof partial === 'undefined') {
        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
      }
      this.partials[name] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name) {
    delete this.partials[name];
  },

  registerDecorator: function registerDecorator(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple decorators');
      }
      _utils.extend(this.decorators, name);
    } else {
      this.decorators[name] = fn;
    }
  },
  unregisterDecorator: function unregisterDecorator(name) {
    delete this.decorators[name];
  }
};

var log = _logger2['default'].log;

exports.log = log;
exports.createFrame = _utils.createFrame;
exports.logger = _logger2['default'];


},{"./decorators":137,"./exception":139,"./helpers":140,"./logger":148,"./utils":152}],127:[function(require,module,exports){
'use strict';

exports.__esModule = true;
var AST = {
  // Public API used to evaluate derived attributes regarding AST nodes
  helpers: {
    // a mustache is definitely a helper if:
    // * it is an eligible helper, and
    // * it has at least one parameter or hash segment
    helperExpression: function helperExpression(node) {
      return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
    },

    scopedId: function scopedId(path) {
      return (/^\.|this\b/.test(path.original)
      );
    },

    // an ID is simple if it only has one part, and that part is not
    // `..` or `this`.
    simpleId: function simpleId(path) {
      return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
    }
  }
};

// Must be exported as an object rather than the root of the module as the jison lexer
// must modify the object to operate properly.
exports['default'] = AST;
module.exports = exports['default'];


},{}],128:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.parse = parse;
// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _parser = require('./parser');

var _parser2 = _interopRequireDefault(_parser);

var _whitespaceControl = require('./whitespace-control');

var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);

var _helpers = require('./helpers');

var Helpers = _interopRequireWildcard(_helpers);

var _utils = require('../utils');

exports.parser = _parser2['default'];

var yy = {};
_utils.extend(yy, Helpers);

function parse(input, options) {
  // Just return if an already-compiled AST was passed in.
  if (input.type === 'Program') {
    return input;
  }

  _parser2['default'].yy = yy;

  // Altering the shared object here, but this is ok as parser is a sync operation
  yy.locInfo = function (locInfo) {
    return new yy.SourceLocation(options && options.srcName, locInfo);
  };

  var strip = new _whitespaceControl2['default'](options);
  return strip.accept(_parser2['default'].parse(input));
}


},{"../utils":152,"./helpers":131,"./parser":133,"./whitespace-control":136}],129:[function(require,module,exports){
/* global define */
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

var SourceNode = undefined;

try {
  /* istanbul ignore next */
  if (typeof define !== 'function' || !define.amd) {
    // We don't support this in AMD environments. For these environments, we asusme that
    // they are running on the browser and thus have no need for the source-map library.
    var SourceMap = require('source-map');
    SourceNode = SourceMap.SourceNode;
  }
} catch (err) {}
/* NOP */

/* istanbul ignore if: tested but not covered in istanbul due to dist build  */
if (!SourceNode) {
  SourceNode = function (line, column, srcFile, chunks) {
    this.src = '';
    if (chunks) {
      this.add(chunks);
    }
  };
  /* istanbul ignore next */
  SourceNode.prototype = {
    add: function add(chunks) {
      if (_utils.isArray(chunks)) {
        chunks = chunks.join('');
      }
      this.src += chunks;
    },
    prepend: function prepend(chunks) {
      if (_utils.isArray(chunks)) {
        chunks = chunks.join('');
      }
      this.src = chunks + this.src;
    },
    toStringWithSourceMap: function toStringWithSourceMap() {
      return { code: this.toString() };
    },
    toString: function toString() {
      return this.src;
    }
  };
}

function castChunk(chunk, codeGen, loc) {
  if (_utils.isArray(chunk)) {
    var ret = [];

    for (var i = 0, len = chunk.length; i < len; i++) {
      ret.push(codeGen.wrap(chunk[i], loc));
    }
    return ret;
  } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
    // Handle primitives that the SourceNode will throw up on
    return chunk + '';
  }
  return chunk;
}

function CodeGen(srcFile) {
  this.srcFile = srcFile;
  this.source = [];
}

CodeGen.prototype = {
  isEmpty: function isEmpty() {
    return !this.source.length;
  },
  prepend: function prepend(source, loc) {
    this.source.unshift(this.wrap(source, loc));
  },
  push: function push(source, loc) {
    this.source.push(this.wrap(source, loc));
  },

  merge: function merge() {
    var source = this.empty();
    this.each(function (line) {
      source.add(['  ', line, '\n']);
    });
    return source;
  },

  each: function each(iter) {
    for (var i = 0, len = this.source.length; i < len; i++) {
      iter(this.source[i]);
    }
  },

  empty: function empty() {
    var loc = this.currentLocation || { start: {} };
    return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
  },
  wrap: function wrap(chunk) {
    var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];

    if (chunk instanceof SourceNode) {
      return chunk;
    }

    chunk = castChunk(chunk, this, loc);

    return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
  },

  functionCall: function functionCall(fn, type, params) {
    params = this.generateList(params);
    return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
  },

  quotedString: function quotedString(str) {
    return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
    .replace(/\u2029/g, '\\u2029') + '"';
  },

  objectLiteral: function objectLiteral(obj) {
    var pairs = [];

    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        var value = castChunk(obj[key], this);
        if (value !== 'undefined') {
          pairs.push([this.quotedString(key), ':', value]);
        }
      }
    }

    var ret = this.generateList(pairs);
    ret.prepend('{');
    ret.add('}');
    return ret;
  },

  generateList: function generateList(entries) {
    var ret = this.empty();

    for (var i = 0, len = entries.length; i < len; i++) {
      if (i) {
        ret.add(',');
      }

      ret.add(castChunk(entries[i], this));
    }

    return ret;
  },

  generateArray: function generateArray(entries) {
    var ret = this.generateList(entries);
    ret.prepend('[');
    ret.add(']');

    return ret;
  }
};

exports['default'] = CodeGen;
module.exports = exports['default'];


},{"../utils":152,"source-map":154}],130:[function(require,module,exports){
/* eslint-disable new-cap */

'use strict';

exports.__esModule = true;
exports.Compiler = Compiler;
exports.precompile = precompile;
exports.compile = compile;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

var _utils = require('../utils');

var _ast = require('./ast');

var _ast2 = _interopRequireDefault(_ast);

var slice = [].slice;

function Compiler() {}

// the foundHelper register will disambiguate helper lookup from finding a
// function in a context. This is necessary for mustache compatibility, which
// requires that context functions in blocks are evaluated by blockHelperMissing,
// and then proceed as if the resulting value was provided to blockHelperMissing.

Compiler.prototype = {
  compiler: Compiler,

  equals: function equals(other) {
    var len = this.opcodes.length;
    if (other.opcodes.length !== len) {
      return false;
    }

    for (var i = 0; i < len; i++) {
      var opcode = this.opcodes[i],
          otherOpcode = other.opcodes[i];
      if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
        return false;
      }
    }

    // We know that length is the same between the two arrays because they are directly tied
    // to the opcode behavior above.
    len = this.children.length;
    for (var i = 0; i < len; i++) {
      if (!this.children[i].equals(other.children[i])) {
        return false;
      }
    }

    return true;
  },

  guid: 0,

  compile: function compile(program, options) {
    this.sourceNode = [];
    this.opcodes = [];
    this.children = [];
    this.options = options;
    this.stringParams = options.stringParams;
    this.trackIds = options.trackIds;

    options.blockParams = options.blockParams || [];

    // These changes will propagate to the other compiler components
    var knownHelpers = options.knownHelpers;
    options.knownHelpers = {
      'helperMissing': true,
      'blockHelperMissing': true,
      'each': true,
      'if': true,
      'unless': true,
      'with': true,
      'log': true,
      'lookup': true
    };
    if (knownHelpers) {
      for (var _name in knownHelpers) {
        /* istanbul ignore else */
        if (_name in knownHelpers) {
          this.options.knownHelpers[_name] = knownHelpers[_name];
        }
      }
    }

    return this.accept(program);
  },

  compileProgram: function compileProgram(program) {
    var childCompiler = new this.compiler(),
        // eslint-disable-line new-cap
    result = childCompiler.compile(program, this.options),
        guid = this.guid++;

    this.usePartial = this.usePartial || result.usePartial;

    this.children[guid] = result;
    this.useDepths = this.useDepths || result.useDepths;

    return guid;
  },

  accept: function accept(node) {
    /* istanbul ignore next: Sanity code */
    if (!this[node.type]) {
      throw new _exception2['default']('Unknown type: ' + node.type, node);
    }

    this.sourceNode.unshift(node);
    var ret = this[node.type](node);
    this.sourceNode.shift();
    return ret;
  },

  Program: function Program(program) {
    this.options.blockParams.unshift(program.blockParams);

    var body = program.body,
        bodyLength = body.length;
    for (var i = 0; i < bodyLength; i++) {
      this.accept(body[i]);
    }

    this.options.blockParams.shift();

    this.isSimple = bodyLength === 1;
    this.blockParams = program.blockParams ? program.blockParams.length : 0;

    return this;
  },

  BlockStatement: function BlockStatement(block) {
    transformLiteralToPath(block);

    var program = block.program,
        inverse = block.inverse;

    program = program && this.compileProgram(program);
    inverse = inverse && this.compileProgram(inverse);

    var type = this.classifySexpr(block);

    if (type === 'helper') {
      this.helperSexpr(block, program, inverse);
    } else if (type === 'simple') {
      this.simpleSexpr(block);

      // now that the simple mustache is resolved, we need to
      // evaluate it by executing `blockHelperMissing`
      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);
      this.opcode('emptyHash');
      this.opcode('blockValue', block.path.original);
    } else {
      this.ambiguousSexpr(block, program, inverse);

      // now that the simple mustache is resolved, we need to
      // evaluate it by executing `blockHelperMissing`
      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);
      this.opcode('emptyHash');
      this.opcode('ambiguousBlockValue');
    }

    this.opcode('append');
  },

  DecoratorBlock: function DecoratorBlock(decorator) {
    var program = decorator.program && this.compileProgram(decorator.program);
    var params = this.setupFullMustacheParams(decorator, program, undefined),
        path = decorator.path;

    this.useDecorators = true;
    this.opcode('registerDecorator', params.length, path.original);
  },

  PartialStatement: function PartialStatement(partial) {
    this.usePartial = true;

    var program = partial.program;
    if (program) {
      program = this.compileProgram(partial.program);
    }

    var params = partial.params;
    if (params.length > 1) {
      throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
    } else if (!params.length) {
      if (this.options.explicitPartialContext) {
        this.opcode('pushLiteral', 'undefined');
      } else {
        params.push({ type: 'PathExpression', parts: [], depth: 0 });
      }
    }

    var partialName = partial.name.original,
        isDynamic = partial.name.type === 'SubExpression';
    if (isDynamic) {
      this.accept(partial.name);
    }

    this.setupFullMustacheParams(partial, program, undefined, true);

    var indent = partial.indent || '';
    if (this.options.preventIndent && indent) {
      this.opcode('appendContent', indent);
      indent = '';
    }

    this.opcode('invokePartial', isDynamic, partialName, indent);
    this.opcode('append');
  },
  PartialBlockStatement: function PartialBlockStatement(partialBlock) {
    this.PartialStatement(partialBlock);
  },

  MustacheStatement: function MustacheStatement(mustache) {
    this.SubExpression(mustache);

    if (mustache.escaped && !this.options.noEscape) {
      this.opcode('appendEscaped');
    } else {
      this.opcode('append');
    }
  },
  Decorator: function Decorator(decorator) {
    this.DecoratorBlock(decorator);
  },

  ContentStatement: function ContentStatement(content) {
    if (content.value) {
      this.opcode('appendContent', content.value);
    }
  },

  CommentStatement: function CommentStatement() {},

  SubExpression: function SubExpression(sexpr) {
    transformLiteralToPath(sexpr);
    var type = this.classifySexpr(sexpr);

    if (type === 'simple') {
      this.simpleSexpr(sexpr);
    } else if (type === 'helper') {
      this.helperSexpr(sexpr);
    } else {
      this.ambiguousSexpr(sexpr);
    }
  },
  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
    var path = sexpr.path,
        name = path.parts[0],
        isBlock = program != null || inverse != null;

    this.opcode('getContext', path.depth);

    this.opcode('pushProgram', program);
    this.opcode('pushProgram', inverse);

    path.strict = true;
    this.accept(path);

    this.opcode('invokeAmbiguous', name, isBlock);
  },

  simpleSexpr: function simpleSexpr(sexpr) {
    var path = sexpr.path;
    path.strict = true;
    this.accept(path);
    this.opcode('resolvePossibleLambda');
  },

  helperSexpr: function helperSexpr(sexpr, program, inverse) {
    var params = this.setupFullMustacheParams(sexpr, program, inverse),
        path = sexpr.path,
        name = path.parts[0];

    if (this.options.knownHelpers[name]) {
      this.opcode('invokeKnownHelper', params.length, name);
    } else if (this.options.knownHelpersOnly) {
      throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
    } else {
      path.strict = true;
      path.falsy = true;

      this.accept(path);
      this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
    }
  },

  PathExpression: function PathExpression(path) {
    this.addDepth(path.depth);
    this.opcode('getContext', path.depth);

    var name = path.parts[0],
        scoped = _ast2['default'].helpers.scopedId(path),
        blockParamId = !path.depth && !scoped && this.blockParamIndex(name);

    if (blockParamId) {
      this.opcode('lookupBlockParam', blockParamId, path.parts);
    } else if (!name) {
      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
      this.opcode('pushContext');
    } else if (path.data) {
      this.options.data = true;
      this.opcode('lookupData', path.depth, path.parts, path.strict);
    } else {
      this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
    }
  },

  StringLiteral: function StringLiteral(string) {
    this.opcode('pushString', string.value);
  },

  NumberLiteral: function NumberLiteral(number) {
    this.opcode('pushLiteral', number.value);
  },

  BooleanLiteral: function BooleanLiteral(bool) {
    this.opcode('pushLiteral', bool.value);
  },

  UndefinedLiteral: function UndefinedLiteral() {
    this.opcode('pushLiteral', 'undefined');
  },

  NullLiteral: function NullLiteral() {
    this.opcode('pushLiteral', 'null');
  },

  Hash: function Hash(hash) {
    var pairs = hash.pairs,
        i = 0,
        l = pairs.length;

    this.opcode('pushHash');

    for (; i < l; i++) {
      this.pushParam(pairs[i].value);
    }
    while (i--) {
      this.opcode('assignToHash', pairs[i].key);
    }
    this.opcode('popHash');
  },

  // HELPERS
  opcode: function opcode(name) {
    this.opcodes.push({ opcode: name, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc });
  },

  addDepth: function addDepth(depth) {
    if (!depth) {
      return;
    }

    this.useDepths = true;
  },

  classifySexpr: function classifySexpr(sexpr) {
    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);

    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);

    // a mustache is an eligible helper if:
    // * its id is simple (a single part, not `this` or `..`)
    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);

    // if a mustache is an eligible helper but not a definite
    // helper, it is ambiguous, and will be resolved in a later
    // pass or at runtime.
    var isEligible = !isBlockParam && (isHelper || isSimple);

    // if ambiguous, we can possibly resolve the ambiguity now
    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
    if (isEligible && !isHelper) {
      var _name2 = sexpr.path.parts[0],
          options = this.options;

      if (options.knownHelpers[_name2]) {
        isHelper = true;
      } else if (options.knownHelpersOnly) {
        isEligible = false;
      }
    }

    if (isHelper) {
      return 'helper';
    } else if (isEligible) {
      return 'ambiguous';
    } else {
      return 'simple';
    }
  },

  pushParams: function pushParams(params) {
    for (var i = 0, l = params.length; i < l; i++) {
      this.pushParam(params[i]);
    }
  },

  pushParam: function pushParam(val) {
    var value = val.value != null ? val.value : val.original || '';

    if (this.stringParams) {
      if (value.replace) {
        value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
      }

      if (val.depth) {
        this.addDepth(val.depth);
      }
      this.opcode('getContext', val.depth || 0);
      this.opcode('pushStringParam', value, val.type);

      if (val.type === 'SubExpression') {
        // SubExpressions get evaluated and passed in
        // in string params mode.
        this.accept(val);
      }
    } else {
      if (this.trackIds) {
        var blockParamIndex = undefined;
        if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
          blockParamIndex = this.blockParamIndex(val.parts[0]);
        }
        if (blockParamIndex) {
          var blockParamChild = val.parts.slice(1).join('.');
          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
        } else {
          value = val.original || value;
          if (value.replace) {
            value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
          }

          this.opcode('pushId', val.type, value);
        }
      }
      this.accept(val);
    }
  },

  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
    var params = sexpr.params;
    this.pushParams(params);

    this.opcode('pushProgram', program);
    this.opcode('pushProgram', inverse);

    if (sexpr.hash) {
      this.accept(sexpr.hash);
    } else {
      this.opcode('emptyHash', omitEmpty);
    }

    return params;
  },

  blockParamIndex: function blockParamIndex(name) {
    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
      var blockParams = this.options.blockParams[depth],
          param = blockParams && _utils.indexOf(blockParams, name);
      if (blockParams && param >= 0) {
        return [depth, param];
      }
    }
  }
};

function precompile(input, options, env) {
  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
  }

  options = options || {};
  if (!('data' in options)) {
    options.data = true;
  }
  if (options.compat) {
    options.useDepths = true;
  }

  var ast = env.parse(input, options),
      environment = new env.Compiler().compile(ast, options);
  return new env.JavaScriptCompiler().compile(environment, options);
}

function compile(input, options, env) {
  if (options === undefined) options = {};

  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
  }

  options = _utils.extend({}, options);
  if (!('data' in options)) {
    options.data = true;
  }
  if (options.compat) {
    options.useDepths = true;
  }

  var compiled = undefined;

  function compileInput() {
    var ast = env.parse(input, options),
        environment = new env.Compiler().compile(ast, options),
        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
    return env.template(templateSpec);
  }

  // Template is only compiled on first use and cached after that point.
  function ret(context, execOptions) {
    if (!compiled) {
      compiled = compileInput();
    }
    return compiled.call(this, context, execOptions);
  }
  ret._setup = function (setupOptions) {
    if (!compiled) {
      compiled = compileInput();
    }
    return compiled._setup(setupOptions);
  };
  ret._child = function (i, data, blockParams, depths) {
    if (!compiled) {
      compiled = compileInput();
    }
    return compiled._child(i, data, blockParams, depths);
  };
  return ret;
}

function argEquals(a, b) {
  if (a === b) {
    return true;
  }

  if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
    for (var i = 0; i < a.length; i++) {
      if (!argEquals(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
}

function transformLiteralToPath(sexpr) {
  if (!sexpr.path.parts) {
    var literal = sexpr.path;
    // Casting to string here to make false and 0 literal values play nicely with the rest
    // of the system.
    sexpr.path = {
      type: 'PathExpression',
      data: false,
      depth: 0,
      parts: [literal.original + ''],
      original: literal.original + '',
      loc: literal.loc
    };
  }
}


},{"../exception":139,"../utils":152,"./ast":127}],131:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.SourceLocation = SourceLocation;
exports.id = id;
exports.stripFlags = stripFlags;
exports.stripComment = stripComment;
exports.preparePath = preparePath;
exports.prepareMustache = prepareMustache;
exports.prepareRawBlock = prepareRawBlock;
exports.prepareBlock = prepareBlock;
exports.prepareProgram = prepareProgram;
exports.preparePartialBlock = preparePartialBlock;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

function validateClose(open, close) {
  close = close.path ? close.path.original : close;

  if (open.path.original !== close) {
    var errorNode = { loc: open.path.loc };

    throw new _exception2['default'](open.path.original + " doesn't match " + close, errorNode);
  }
}

function SourceLocation(source, locInfo) {
  this.source = source;
  this.start = {
    line: locInfo.first_line,
    column: locInfo.first_column
  };
  this.end = {
    line: locInfo.last_line,
    column: locInfo.last_column
  };
}

function id(token) {
  if (/^\[.*\]$/.test(token)) {
    return token.substr(1, token.length - 2);
  } else {
    return token;
  }
}

function stripFlags(open, close) {
  return {
    open: open.charAt(2) === '~',
    close: close.charAt(close.length - 3) === '~'
  };
}

function stripComment(comment) {
  return comment.replace(/^\{\{~?\!-?-?/, '').replace(/-?-?~?\}\}$/, '');
}

function preparePath(data, parts, loc) {
  loc = this.locInfo(loc);

  var original = data ? '@' : '',
      dig = [],
      depth = 0,
      depthString = '';

  for (var i = 0, l = parts.length; i < l; i++) {
    var part = parts[i].part,

    // If we have [] syntax then we do not treat path references as operators,
    // i.e. foo.[this] resolves to approximately context.foo['this']
    isLiteral = parts[i].original !== part;
    original += (parts[i].separator || '') + part;

    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
      if (dig.length > 0) {
        throw new _exception2['default']('Invalid path: ' + original, { loc: loc });
      } else if (part === '..') {
        depth++;
        depthString += '../';
      }
    } else {
      dig.push(part);
    }
  }

  return {
    type: 'PathExpression',
    data: data,
    depth: depth,
    parts: dig,
    original: original,
    loc: loc
  };
}

function prepareMustache(path, params, hash, open, strip, locInfo) {
  // Must use charAt to support IE pre-10
  var escapeFlag = open.charAt(3) || open.charAt(2),
      escaped = escapeFlag !== '{' && escapeFlag !== '&';

  var decorator = /\*/.test(open);
  return {
    type: decorator ? 'Decorator' : 'MustacheStatement',
    path: path,
    params: params,
    hash: hash,
    escaped: escaped,
    strip: strip,
    loc: this.locInfo(locInfo)
  };
}

function prepareRawBlock(openRawBlock, contents, close, locInfo) {
  validateClose(openRawBlock, close);

  locInfo = this.locInfo(locInfo);
  var program = {
    type: 'Program',
    body: contents,
    strip: {},
    loc: locInfo
  };

  return {
    type: 'BlockStatement',
    path: openRawBlock.path,
    params: openRawBlock.params,
    hash: openRawBlock.hash,
    program: program,
    openStrip: {},
    inverseStrip: {},
    closeStrip: {},
    loc: locInfo
  };
}

function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
  if (close && close.path) {
    validateClose(openBlock, close);
  }

  var decorator = /\*/.test(openBlock.open);

  program.blockParams = openBlock.blockParams;

  var inverse = undefined,
      inverseStrip = undefined;

  if (inverseAndProgram) {
    if (decorator) {
      throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);
    }

    if (inverseAndProgram.chain) {
      inverseAndProgram.program.body[0].closeStrip = close.strip;
    }

    inverseStrip = inverseAndProgram.strip;
    inverse = inverseAndProgram.program;
  }

  if (inverted) {
    inverted = inverse;
    inverse = program;
    program = inverted;
  }

  return {
    type: decorator ? 'DecoratorBlock' : 'BlockStatement',
    path: openBlock.path,
    params: openBlock.params,
    hash: openBlock.hash,
    program: program,
    inverse: inverse,
    openStrip: openBlock.strip,
    inverseStrip: inverseStrip,
    closeStrip: close && close.strip,
    loc: this.locInfo(locInfo)
  };
}

function prepareProgram(statements, loc) {
  if (!loc && statements.length) {
    var firstLoc = statements[0].loc,
        lastLoc = statements[statements.length - 1].loc;

    /* istanbul ignore else */
    if (firstLoc && lastLoc) {
      loc = {
        source: firstLoc.source,
        start: {
          line: firstLoc.start.line,
          column: firstLoc.start.column
        },
        end: {
          line: lastLoc.end.line,
          column: lastLoc.end.column
        }
      };
    }
  }

  return {
    type: 'Program',
    body: statements,
    strip: {},
    loc: loc
  };
}

function preparePartialBlock(open, program, close, locInfo) {
  validateClose(open, close);

  return {
    type: 'PartialBlockStatement',
    name: open.path,
    params: open.params,
    hash: open.hash,
    program: program,
    openStrip: open.strip,
    closeStrip: close && close.strip,
    loc: this.locInfo(locInfo)
  };
}


},{"../exception":139}],132:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _base = require('../base');

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

var _utils = require('../utils');

var _codeGen = require('./code-gen');

var _codeGen2 = _interopRequireDefault(_codeGen);

function Literal(value) {
  this.value = value;
}

function JavaScriptCompiler() {}

JavaScriptCompiler.prototype = {
  // PUBLIC API: You can override these methods in a subclass to provide
  // alternative compiled forms for name lookup and buffering semantics
  nameLookup: function nameLookup(parent, name /* , type*/) {
    if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
      return [parent, '.', name];
    } else {
      return [parent, '[', JSON.stringify(name), ']'];
    }
  },
  depthedLookup: function depthedLookup(name) {
    return [this.aliasable('container.lookup'), '(depths, "', name, '")'];
  },

  compilerInfo: function compilerInfo() {
    var revision = _base.COMPILER_REVISION,
        versions = _base.REVISION_CHANGES[revision];
    return [revision, versions];
  },

  appendToBuffer: function appendToBuffer(source, location, explicit) {
    // Force a source as this simplifies the merge logic.
    if (!_utils.isArray(source)) {
      source = [source];
    }
    source = this.source.wrap(source, location);

    if (this.environment.isSimple) {
      return ['return ', source, ';'];
    } else if (explicit) {
      // This is a case where the buffer operation occurs as a child of another
      // construct, generally braces. We have to explicitly output these buffer
      // operations to ensure that the emitted code goes in the correct location.
      return ['buffer += ', source, ';'];
    } else {
      source.appendToBuffer = true;
      return source;
    }
  },

  initializeBuffer: function initializeBuffer() {
    return this.quotedString('');
  },
  // END PUBLIC API

  compile: function compile(environment, options, context, asObject) {
    this.environment = environment;
    this.options = options;
    this.stringParams = this.options.stringParams;
    this.trackIds = this.options.trackIds;
    this.precompile = !asObject;

    this.name = this.environment.name;
    this.isChild = !!context;
    this.context = context || {
      decorators: [],
      programs: [],
      environments: []
    };

    this.preamble();

    this.stackSlot = 0;
    this.stackVars = [];
    this.aliases = {};
    this.registers = { list: [] };
    this.hashes = [];
    this.compileStack = [];
    this.inlineStack = [];
    this.blockParams = [];

    this.compileChildren(environment, options);

    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
    this.useBlockParams = this.useBlockParams || environment.useBlockParams;

    var opcodes = environment.opcodes,
        opcode = undefined,
        firstLoc = undefined,
        i = undefined,
        l = undefined;

    for (i = 0, l = opcodes.length; i < l; i++) {
      opcode = opcodes[i];

      this.source.currentLocation = opcode.loc;
      firstLoc = firstLoc || opcode.loc;
      this[opcode.opcode].apply(this, opcode.args);
    }

    // Flush any trailing content that might be pending.
    this.source.currentLocation = firstLoc;
    this.pushSource('');

    /* istanbul ignore next */
    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
      throw new _exception2['default']('Compile completed with content left on stack');
    }

    if (!this.decorators.isEmpty()) {
      this.useDecorators = true;

      this.decorators.prepend('var decorators = container.decorators;\n');
      this.decorators.push('return fn;');

      if (asObject) {
        this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
      } else {
        this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
        this.decorators.push('}\n');
        this.decorators = this.decorators.merge();
      }
    } else {
      this.decorators = undefined;
    }

    var fn = this.createFunctionContext(asObject);
    if (!this.isChild) {
      var ret = {
        compiler: this.compilerInfo(),
        main: fn
      };

      if (this.decorators) {
        ret.main_d = this.decorators; // eslint-disable-line camelcase
        ret.useDecorators = true;
      }

      var _context = this.context;
      var programs = _context.programs;
      var decorators = _context.decorators;

      for (i = 0, l = programs.length; i < l; i++) {
        if (programs[i]) {
          ret[i] = programs[i];
          if (decorators[i]) {
            ret[i + '_d'] = decorators[i];
            ret.useDecorators = true;
          }
        }
      }

      if (this.environment.usePartial) {
        ret.usePartial = true;
      }
      if (this.options.data) {
        ret.useData = true;
      }
      if (this.useDepths) {
        ret.useDepths = true;
      }
      if (this.useBlockParams) {
        ret.useBlockParams = true;
      }
      if (this.options.compat) {
        ret.compat = true;
      }

      if (!asObject) {
        ret.compiler = JSON.stringify(ret.compiler);

        this.source.currentLocation = { start: { line: 1, column: 0 } };
        ret = this.objectLiteral(ret);

        if (options.srcName) {
          ret = ret.toStringWithSourceMap({ file: options.destName });
          ret.map = ret.map && ret.map.toString();
        } else {
          ret = ret.toString();
        }
      } else {
        ret.compilerOptions = this.options;
      }

      return ret;
    } else {
      return fn;
    }
  },

  preamble: function preamble() {
    // track the last context pushed into place to allow skipping the
    // getContext opcode when it would be a noop
    this.lastContext = 0;
    this.source = new _codeGen2['default'](this.options.srcName);
    this.decorators = new _codeGen2['default'](this.options.srcName);
  },

  createFunctionContext: function createFunctionContext(asObject) {
    var varDeclarations = '';

    var locals = this.stackVars.concat(this.registers.list);
    if (locals.length > 0) {
      varDeclarations += ', ' + locals.join(', ');
    }

    // Generate minimizer alias mappings
    //
    // When using true SourceNodes, this will update all references to the given alias
    // as the source nodes are reused in situ. For the non-source node compilation mode,
    // aliases will not be used, but this case is already being run on the client and
    // we aren't concern about minimizing the template size.
    var aliasCount = 0;
    for (var alias in this.aliases) {
      // eslint-disable-line guard-for-in
      var node = this.aliases[alias];

      if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {
        varDeclarations += ', alias' + ++aliasCount + '=' + alias;
        node.children[0] = 'alias' + aliasCount;
      }
    }

    var params = ['container', 'depth0', 'helpers', 'partials', 'data'];

    if (this.useBlockParams || this.useDepths) {
      params.push('blockParams');
    }
    if (this.useDepths) {
      params.push('depths');
    }

    // Perform a second pass over the output to merge content when possible
    var source = this.mergeSource(varDeclarations);

    if (asObject) {
      params.push(source);

      return Function.apply(this, params);
    } else {
      return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
    }
  },
  mergeSource: function mergeSource(varDeclarations) {
    var isSimple = this.environment.isSimple,
        appendOnly = !this.forceBuffer,
        appendFirst = undefined,
        sourceSeen = undefined,
        bufferStart = undefined,
        bufferEnd = undefined;
    this.source.each(function (line) {
      if (line.appendToBuffer) {
        if (bufferStart) {
          line.prepend('  + ');
        } else {
          bufferStart = line;
        }
        bufferEnd = line;
      } else {
        if (bufferStart) {
          if (!sourceSeen) {
            appendFirst = true;
          } else {
            bufferStart.prepend('buffer += ');
          }
          bufferEnd.add(';');
          bufferStart = bufferEnd = undefined;
        }

        sourceSeen = true;
        if (!isSimple) {
          appendOnly = false;
        }
      }
    });

    if (appendOnly) {
      if (bufferStart) {
        bufferStart.prepend('return ');
        bufferEnd.add(';');
      } else if (!sourceSeen) {
        this.source.push('return "";');
      }
    } else {
      varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());

      if (bufferStart) {
        bufferStart.prepend('return buffer + ');
        bufferEnd.add(';');
      } else {
        this.source.push('return buffer;');
      }
    }

    if (varDeclarations) {
      this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
    }

    return this.source.merge();
  },

  // [blockValue]
  //
  // On stack, before: hash, inverse, program, value
  // On stack, after: return value of blockHelperMissing
  //
  // The purpose of this opcode is to take a block of the form
  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
  // replace it on the stack with the result of properly
  // invoking blockHelperMissing.
  blockValue: function blockValue(name) {
    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
        params = [this.contextName(0)];
    this.setupHelperArgs(name, 0, params);

    var blockName = this.popStack();
    params.splice(1, 0, blockName);

    this.push(this.source.functionCall(blockHelperMissing, 'call', params));
  },

  // [ambiguousBlockValue]
  //
  // On stack, before: hash, inverse, program, value
  // Compiler value, before: lastHelper=value of last found helper, if any
  // On stack, after, if no lastHelper: same as [blockValue]
  // On stack, after, if lastHelper: value
  ambiguousBlockValue: function ambiguousBlockValue() {
    // We're being a bit cheeky and reusing the options value from the prior exec
    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
        params = [this.contextName(0)];
    this.setupHelperArgs('', 0, params, true);

    this.flushInline();

    var current = this.topStack();
    params.splice(1, 0, current);

    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
  },

  // [appendContent]
  //
  // On stack, before: ...
  // On stack, after: ...
  //
  // Appends the string value of `content` to the current buffer
  appendContent: function appendContent(content) {
    if (this.pendingContent) {
      content = this.pendingContent + content;
    } else {
      this.pendingLocation = this.source.currentLocation;
    }

    this.pendingContent = content;
  },

  // [append]
  //
  // On stack, before: value, ...
  // On stack, after: ...
  //
  // Coerces `value` to a String and appends it to the current buffer.
  //
  // If `value` is truthy, or 0, it is coerced into a string and appended
  // Otherwise, the empty string is appended
  append: function append() {
    if (this.isInline()) {
      this.replaceStack(function (current) {
        return [' != null ? ', current, ' : ""'];
      });

      this.pushSource(this.appendToBuffer(this.popStack()));
    } else {
      var local = this.popStack();
      this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
      if (this.environment.isSimple) {
        this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
      }
    }
  },

  // [appendEscaped]
  //
  // On stack, before: value, ...
  // On stack, after: ...
  //
  // Escape `value` and append it to the buffer
  appendEscaped: function appendEscaped() {
    this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
  },

  // [getContext]
  //
  // On stack, before: ...
  // On stack, after: ...
  // Compiler value, after: lastContext=depth
  //
  // Set the value of the `lastContext` compiler value to the depth
  getContext: function getContext(depth) {
    this.lastContext = depth;
  },

  // [pushContext]
  //
  // On stack, before: ...
  // On stack, after: currentContext, ...
  //
  // Pushes the value of the current context onto the stack.
  pushContext: function pushContext() {
    this.pushStackLiteral(this.contextName(this.lastContext));
  },

  // [lookupOnContext]
  //
  // On stack, before: ...
  // On stack, after: currentContext[name], ...
  //
  // Looks up the value of `name` on the current context and pushes
  // it onto the stack.
  lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
    var i = 0;

    if (!scoped && this.options.compat && !this.lastContext) {
      // The depthed query is expected to handle the undefined logic for the root level that
      // is implemented below, so we evaluate that directly in compat mode
      this.push(this.depthedLookup(parts[i++]));
    } else {
      this.pushContext();
    }

    this.resolvePath('context', parts, i, falsy, strict);
  },

  // [lookupBlockParam]
  //
  // On stack, before: ...
  // On stack, after: blockParam[name], ...
  //
  // Looks up the value of `parts` on the given block param and pushes
  // it onto the stack.
  lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
    this.useBlockParams = true;

    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
    this.resolvePath('context', parts, 1);
  },

  // [lookupData]
  //
  // On stack, before: ...
  // On stack, after: data, ...
  //
  // Push the data lookup operator
  lookupData: function lookupData(depth, parts, strict) {
    if (!depth) {
      this.pushStackLiteral('data');
    } else {
      this.pushStackLiteral('container.data(data, ' + depth + ')');
    }

    this.resolvePath('data', parts, 0, true, strict);
  },

  resolvePath: function resolvePath(type, parts, i, falsy, strict) {
    // istanbul ignore next

    var _this = this;

    if (this.options.strict || this.options.assumeObjects) {
      this.push(strictLookup(this.options.strict && strict, this, parts, type));
      return;
    }

    var len = parts.length;
    for (; i < len; i++) {
      /* eslint-disable no-loop-func */
      this.replaceStack(function (current) {
        var lookup = _this.nameLookup(current, parts[i], type);
        // We want to ensure that zero and false are handled properly if the context (falsy flag)
        // needs to have the special handling for these values.
        if (!falsy) {
          return [' != null ? ', lookup, ' : ', current];
        } else {
          // Otherwise we can use generic falsy handling
          return [' && ', lookup];
        }
      });
      /* eslint-enable no-loop-func */
    }
  },

  // [resolvePossibleLambda]
  //
  // On stack, before: value, ...
  // On stack, after: resolved value, ...
  //
  // If the `value` is a lambda, replace it on the stack by
  // the return value of the lambda
  resolvePossibleLambda: function resolvePossibleLambda() {
    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
  },

  // [pushStringParam]
  //
  // On stack, before: ...
  // On stack, after: string, currentContext, ...
  //
  // This opcode is designed for use in string mode, which
  // provides the string value of a parameter along with its
  // depth rather than resolving it immediately.
  pushStringParam: function pushStringParam(string, type) {
    this.pushContext();
    this.pushString(type);

    // If it's a subexpression, the string result
    // will be pushed after this opcode.
    if (type !== 'SubExpression') {
      if (typeof string === 'string') {
        this.pushString(string);
      } else {
        this.pushStackLiteral(string);
      }
    }
  },

  emptyHash: function emptyHash(omitEmpty) {
    if (this.trackIds) {
      this.push('{}'); // hashIds
    }
    if (this.stringParams) {
      this.push('{}'); // hashContexts
      this.push('{}'); // hashTypes
    }
    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
  },
  pushHash: function pushHash() {
    if (this.hash) {
      this.hashes.push(this.hash);
    }
    this.hash = { values: [], types: [], contexts: [], ids: [] };
  },
  popHash: function popHash() {
    var hash = this.hash;
    this.hash = this.hashes.pop();

    if (this.trackIds) {
      this.push(this.objectLiteral(hash.ids));
    }
    if (this.stringParams) {
      this.push(this.objectLiteral(hash.contexts));
      this.push(this.objectLiteral(hash.types));
    }

    this.push(this.objectLiteral(hash.values));
  },

  // [pushString]
  //
  // On stack, before: ...
  // On stack, after: quotedString(string), ...
  //
  // Push a quoted version of `string` onto the stack
  pushString: function pushString(string) {
    this.pushStackLiteral(this.quotedString(string));
  },

  // [pushLiteral]
  //
  // On stack, before: ...
  // On stack, after: value, ...
  //
  // Pushes a value onto the stack. This operation prevents
  // the compiler from creating a temporary variable to hold
  // it.
  pushLiteral: function pushLiteral(value) {
    this.pushStackLiteral(value);
  },

  // [pushProgram]
  //
  // On stack, before: ...
  // On stack, after: program(guid), ...
  //
  // Push a program expression onto the stack. This takes
  // a compile-time guid and converts it into a runtime-accessible
  // expression.
  pushProgram: function pushProgram(guid) {
    if (guid != null) {
      this.pushStackLiteral(this.programExpression(guid));
    } else {
      this.pushStackLiteral(null);
    }
  },

  // [registerDecorator]
  //
  // On stack, before: hash, program, params..., ...
  // On stack, after: ...
  //
  // Pops off the decorator's parameters, invokes the decorator,
  // and inserts the decorator into the decorators list.
  registerDecorator: function registerDecorator(paramSize, name) {
    var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
        options = this.setupHelperArgs(name, paramSize);

    this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
  },

  // [invokeHelper]
  //
  // On stack, before: hash, inverse, program, params..., ...
  // On stack, after: result of helper invocation
  //
  // Pops off the helper's parameters, invokes the helper,
  // and pushes the helper's return value onto the stack.
  //
  // If the helper is not found, `helperMissing` is called.
  invokeHelper: function invokeHelper(paramSize, name, isSimple) {
    var nonHelper = this.popStack(),
        helper = this.setupHelper(paramSize, name),
        simple = isSimple ? [helper.name, ' || '] : '';

    var lookup = ['('].concat(simple, nonHelper);
    if (!this.options.strict) {
      lookup.push(' || ', this.aliasable('helpers.helperMissing'));
    }
    lookup.push(')');

    this.push(this.source.functionCall(lookup, 'call', helper.callParams));
  },

  // [invokeKnownHelper]
  //
  // On stack, before: hash, inverse, program, params..., ...
  // On stack, after: result of helper invocation
  //
  // This operation is used when the helper is known to exist,
  // so a `helperMissing` fallback is not required.
  invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
    var helper = this.setupHelper(paramSize, name);
    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
  },

  // [invokeAmbiguous]
  //
  // On stack, before: hash, inverse, program, params..., ...
  // On stack, after: result of disambiguation
  //
  // This operation is used when an expression like `{{foo}}`
  // is provided, but we don't know at compile-time whether it
  // is a helper or a path.
  //
  // This operation emits more code than the other options,
  // and can be avoided by passing the `knownHelpers` and
  // `knownHelpersOnly` flags at compile-time.
  invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
    this.useRegister('helper');

    var nonHelper = this.popStack();

    this.emptyHash();
    var helper = this.setupHelper(0, name, helperCall);

    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
    if (!this.options.strict) {
      lookup[0] = '(helper = ';
      lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));
    }

    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
  },

  // [invokePartial]
  //
  // On stack, before: context, ...
  // On stack after: result of partial invocation
  //
  // This operation pops off a context, invokes a partial with that context,
  // and pushes the result of the invocation back.
  invokePartial: function invokePartial(isDynamic, name, indent) {
    var params = [],
        options = this.setupParams(name, 1, params);

    if (isDynamic) {
      name = this.popStack();
      delete options.name;
    }

    if (indent) {
      options.indent = JSON.stringify(indent);
    }
    options.helpers = 'helpers';
    options.partials = 'partials';
    options.decorators = 'container.decorators';

    if (!isDynamic) {
      params.unshift(this.nameLookup('partials', name, 'partial'));
    } else {
      params.unshift(name);
    }

    if (this.options.compat) {
      options.depths = 'depths';
    }
    options = this.objectLiteral(options);
    params.push(options);

    this.push(this.source.functionCall('container.invokePartial', '', params));
  },

  // [assignToHash]
  //
  // On stack, before: value, ..., hash, ...
  // On stack, after: ..., hash, ...
  //
  // Pops a value off the stack and assigns it to the current hash
  assignToHash: function assignToHash(key) {
    var value = this.popStack(),
        context = undefined,
        type = undefined,
        id = undefined;

    if (this.trackIds) {
      id = this.popStack();
    }
    if (this.stringParams) {
      type = this.popStack();
      context = this.popStack();
    }

    var hash = this.hash;
    if (context) {
      hash.contexts[key] = context;
    }
    if (type) {
      hash.types[key] = type;
    }
    if (id) {
      hash.ids[key] = id;
    }
    hash.values[key] = value;
  },

  pushId: function pushId(type, name, child) {
    if (type === 'BlockParam') {
      this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
    } else if (type === 'PathExpression') {
      this.pushString(name);
    } else if (type === 'SubExpression') {
      this.pushStackLiteral('true');
    } else {
      this.pushStackLiteral('null');
    }
  },

  // HELPERS

  compiler: JavaScriptCompiler,

  compileChildren: function compileChildren(environment, options) {
    var children = environment.children,
        child = undefined,
        compiler = undefined;

    for (var i = 0, l = children.length; i < l; i++) {
      child = children[i];
      compiler = new this.compiler(); // eslint-disable-line new-cap

      var existing = this.matchExistingProgram(child);

      if (existing == null) {
        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
        var index = this.context.programs.length;
        child.index = index;
        child.name = 'program' + index;
        this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
        this.context.decorators[index] = compiler.decorators;
        this.context.environments[index] = child;

        this.useDepths = this.useDepths || compiler.useDepths;
        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
        child.useDepths = this.useDepths;
        child.useBlockParams = this.useBlockParams;
      } else {
        child.index = existing.index;
        child.name = 'program' + existing.index;

        this.useDepths = this.useDepths || existing.useDepths;
        this.useBlockParams = this.useBlockParams || existing.useBlockParams;
      }
    }
  },
  matchExistingProgram: function matchExistingProgram(child) {
    for (var i = 0, len = this.context.environments.length; i < len; i++) {
      var environment = this.context.environments[i];
      if (environment && environment.equals(child)) {
        return environment;
      }
    }
  },

  programExpression: function programExpression(guid) {
    var child = this.environment.children[guid],
        programParams = [child.index, 'data', child.blockParams];

    if (this.useBlockParams || this.useDepths) {
      programParams.push('blockParams');
    }
    if (this.useDepths) {
      programParams.push('depths');
    }

    return 'container.program(' + programParams.join(', ') + ')';
  },

  useRegister: function useRegister(name) {
    if (!this.registers[name]) {
      this.registers[name] = true;
      this.registers.list.push(name);
    }
  },

  push: function push(expr) {
    if (!(expr instanceof Literal)) {
      expr = this.source.wrap(expr);
    }

    this.inlineStack.push(expr);
    return expr;
  },

  pushStackLiteral: function pushStackLiteral(item) {
    this.push(new Literal(item));
  },

  pushSource: function pushSource(source) {
    if (this.pendingContent) {
      this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
      this.pendingContent = undefined;
    }

    if (source) {
      this.source.push(source);
    }
  },

  replaceStack: function replaceStack(callback) {
    var prefix = ['('],
        stack = undefined,
        createdStack = undefined,
        usedLiteral = undefined;

    /* istanbul ignore next */
    if (!this.isInline()) {
      throw new _exception2['default']('replaceStack on non-inline');
    }

    // We want to merge the inline statement into the replacement statement via ','
    var top = this.popStack(true);

    if (top instanceof Literal) {
      // Literals do not need to be inlined
      stack = [top.value];
      prefix = ['(', stack];
      usedLiteral = true;
    } else {
      // Get or create the current stack name for use by the inline
      createdStack = true;
      var _name = this.incrStack();

      prefix = ['((', this.push(_name), ' = ', top, ')'];
      stack = this.topStack();
    }

    var item = callback.call(this, stack);

    if (!usedLiteral) {
      this.popStack();
    }
    if (createdStack) {
      this.stackSlot--;
    }
    this.push(prefix.concat(item, ')'));
  },

  incrStack: function incrStack() {
    this.stackSlot++;
    if (this.stackSlot > this.stackVars.length) {
      this.stackVars.push('stack' + this.stackSlot);
    }
    return this.topStackName();
  },
  topStackName: function topStackName() {
    return 'stack' + this.stackSlot;
  },
  flushInline: function flushInline() {
    var inlineStack = this.inlineStack;
    this.inlineStack = [];
    for (var i = 0, len = inlineStack.length; i < len; i++) {
      var entry = inlineStack[i];
      /* istanbul ignore if */
      if (entry instanceof Literal) {
        this.compileStack.push(entry);
      } else {
        var stack = this.incrStack();
        this.pushSource([stack, ' = ', entry, ';']);
        this.compileStack.push(stack);
      }
    }
  },
  isInline: function isInline() {
    return this.inlineStack.length;
  },

  popStack: function popStack(wrapped) {
    var inline = this.isInline(),
        item = (inline ? this.inlineStack : this.compileStack).pop();

    if (!wrapped && item instanceof Literal) {
      return item.value;
    } else {
      if (!inline) {
        /* istanbul ignore next */
        if (!this.stackSlot) {
          throw new _exception2['default']('Invalid stack pop');
        }
        this.stackSlot--;
      }
      return item;
    }
  },

  topStack: function topStack() {
    var stack = this.isInline() ? this.inlineStack : this.compileStack,
        item = stack[stack.length - 1];

    /* istanbul ignore if */
    if (item instanceof Literal) {
      return item.value;
    } else {
      return item;
    }
  },

  contextName: function contextName(context) {
    if (this.useDepths && context) {
      return 'depths[' + context + ']';
    } else {
      return 'depth' + context;
    }
  },

  quotedString: function quotedString(str) {
    return this.source.quotedString(str);
  },

  objectLiteral: function objectLiteral(obj) {
    return this.source.objectLiteral(obj);
  },

  aliasable: function aliasable(name) {
    var ret = this.aliases[name];
    if (ret) {
      ret.referenceCount++;
      return ret;
    }

    ret = this.aliases[name] = this.source.wrap(name);
    ret.aliasable = true;
    ret.referenceCount = 1;

    return ret;
  },

  setupHelper: function setupHelper(paramSize, name, blockHelper) {
    var params = [],
        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
    var foundHelper = this.nameLookup('helpers', name, 'helper'),
        callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : (container.nullContext || {})');

    return {
      params: params,
      paramsInit: paramsInit,
      name: foundHelper,
      callParams: [callContext].concat(params)
    };
  },

  setupParams: function setupParams(helper, paramSize, params) {
    var options = {},
        contexts = [],
        types = [],
        ids = [],
        objectArgs = !params,
        param = undefined;

    if (objectArgs) {
      params = [];
    }

    options.name = this.quotedString(helper);
    options.hash = this.popStack();

    if (this.trackIds) {
      options.hashIds = this.popStack();
    }
    if (this.stringParams) {
      options.hashTypes = this.popStack();
      options.hashContexts = this.popStack();
    }

    var inverse = this.popStack(),
        program = this.popStack();

    // Avoid setting fn and inverse if neither are set. This allows
    // helpers to do a check for `if (options.fn)`
    if (program || inverse) {
      options.fn = program || 'container.noop';
      options.inverse = inverse || 'container.noop';
    }

    // The parameters go on to the stack in order (making sure that they are evaluated in order)
    // so we need to pop them off the stack in reverse order
    var i = paramSize;
    while (i--) {
      param = this.popStack();
      params[i] = param;

      if (this.trackIds) {
        ids[i] = this.popStack();
      }
      if (this.stringParams) {
        types[i] = this.popStack();
        contexts[i] = this.popStack();
      }
    }

    if (objectArgs) {
      options.args = this.source.generateArray(params);
    }

    if (this.trackIds) {
      options.ids = this.source.generateArray(ids);
    }
    if (this.stringParams) {
      options.types = this.source.generateArray(types);
      options.contexts = this.source.generateArray(contexts);
    }

    if (this.options.data) {
      options.data = 'data';
    }
    if (this.useBlockParams) {
      options.blockParams = 'blockParams';
    }
    return options;
  },

  setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
    var options = this.setupParams(helper, paramSize, params);
    options = this.objectLiteral(options);
    if (useRegister) {
      this.useRegister('options');
      params.push('options');
      return ['options=', options];
    } else if (params) {
      params.push(options);
      return '';
    } else {
      return options;
    }
  }
};

(function () {
  var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');

  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

  for (var i = 0, l = reservedWords.length; i < l; i++) {
    compilerWords[reservedWords[i]] = true;
  }
})();

JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
  return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
};

function strictLookup(requireTerminal, compiler, parts, type) {
  var stack = compiler.popStack(),
      i = 0,
      len = parts.length;
  if (requireTerminal) {
    len--;
  }

  for (; i < len; i++) {
    stack = compiler.nameLookup(stack, parts[i], type);
  }

  if (requireTerminal) {
    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];
  } else {
    return stack;
  }
}

exports['default'] = JavaScriptCompiler;
module.exports = exports['default'];


},{"../base":126,"../exception":139,"../utils":152,"./code-gen":129}],133:[function(require,module,exports){
// File ignored in coverage tests via setting in .istanbul.yml
/* Jison generated parser */
"use strict";

exports.__esModule = true;
var handlebars = (function () {
    var parser = { trace: function trace() {},
        yy: {},
        symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition_plus0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
        terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
        productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 1], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$
        /**/) {

            var $0 = $$.length - 1;
            switch (yystate) {
                case 1:
                    return $$[$0 - 1];
                    break;
                case 2:
                    this.$ = yy.prepareProgram($$[$0]);
                    break;
                case 3:
                    this.$ = $$[$0];
                    break;
                case 4:
                    this.$ = $$[$0];
                    break;
                case 5:
                    this.$ = $$[$0];
                    break;
                case 6:
                    this.$ = $$[$0];
                    break;
                case 7:
                    this.$ = $$[$0];
                    break;
                case 8:
                    this.$ = $$[$0];
                    break;
                case 9:
                    this.$ = {
                        type: 'CommentStatement',
                        value: yy.stripComment($$[$0]),
                        strip: yy.stripFlags($$[$0], $$[$0]),
                        loc: yy.locInfo(this._$)
                    };

                    break;
                case 10:
                    this.$ = {
                        type: 'ContentStatement',
                        original: $$[$0],
                        value: $$[$0],
                        loc: yy.locInfo(this._$)
                    };

                    break;
                case 11:
                    this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                    break;
                case 12:
                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
                    break;
                case 13:
                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
                    break;
                case 14:
                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
                    break;
                case 15:
                    this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                    break;
                case 16:
                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                    break;
                case 17:
                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                    break;
                case 18:
                    this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
                    break;
                case 19:
                    var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
                        program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
                    program.chained = true;

                    this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };

                    break;
                case 20:
                    this.$ = $$[$0];
                    break;
                case 21:
                    this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
                    break;
                case 22:
                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                    break;
                case 23:
                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                    break;
                case 24:
                    this.$ = {
                        type: 'PartialStatement',
                        name: $$[$0 - 3],
                        params: $$[$0 - 2],
                        hash: $$[$0 - 1],
                        indent: '',
                        strip: yy.stripFlags($$[$0 - 4], $$[$0]),
                        loc: yy.locInfo(this._$)
                    };

                    break;
                case 25:
                    this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                    break;
                case 26:
                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
                    break;
                case 27:
                    this.$ = $$[$0];
                    break;
                case 28:
                    this.$ = $$[$0];
                    break;
                case 29:
                    this.$ = {
                        type: 'SubExpression',
                        path: $$[$0 - 3],
                        params: $$[$0 - 2],
                        hash: $$[$0 - 1],
                        loc: yy.locInfo(this._$)
                    };

                    break;
                case 30:
                    this.$ = { type: 'Hash', pairs: $$[$0], loc: yy.locInfo(this._$) };
                    break;
                case 31:
                    this.$ = { type: 'HashPair', key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
                    break;
                case 32:
                    this.$ = yy.id($$[$0 - 1]);
                    break;
                case 33:
                    this.$ = $$[$0];
                    break;
                case 34:
                    this.$ = $$[$0];
                    break;
                case 35:
                    this.$ = { type: 'StringLiteral', value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
                    break;
                case 36:
                    this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
                    break;
                case 37:
                    this.$ = { type: 'BooleanLiteral', value: $$[$0] === 'true', original: $$[$0] === 'true', loc: yy.locInfo(this._$) };
                    break;
                case 38:
                    this.$ = { type: 'UndefinedLiteral', original: undefined, value: undefined, loc: yy.locInfo(this._$) };
                    break;
                case 39:
                    this.$ = { type: 'NullLiteral', original: null, value: null, loc: yy.locInfo(this._$) };
                    break;
                case 40:
                    this.$ = $$[$0];
                    break;
                case 41:
                    this.$ = $$[$0];
                    break;
                case 42:
                    this.$ = yy.preparePath(true, $$[$0], this._$);
                    break;
                case 43:
                    this.$ = yy.preparePath(false, $$[$0], this._$);
                    break;
                case 44:
                    $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];
                    break;
                case 45:
                    this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
                    break;
                case 46:
                    this.$ = [];
                    break;
                case 47:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 48:
                    this.$ = [$$[$0]];
                    break;
                case 49:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 50:
                    this.$ = [];
                    break;
                case 51:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 58:
                    this.$ = [];
                    break;
                case 59:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 64:
                    this.$ = [];
                    break;
                case 65:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 70:
                    this.$ = [];
                    break;
                case 71:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 78:
                    this.$ = [];
                    break;
                case 79:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 82:
                    this.$ = [];
                    break;
                case 83:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 86:
                    this.$ = [];
                    break;
                case 87:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 90:
                    this.$ = [];
                    break;
                case 91:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 94:
                    this.$ = [];
                    break;
                case 95:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 98:
                    this.$ = [$$[$0]];
                    break;
                case 99:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 100:
                    this.$ = [$$[$0]];
                    break;
                case 101:
                    $$[$0 - 1].push($$[$0]);
                    break;
            }
        },
        table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 13: 40, 15: [1, 20], 17: 39 }, { 20: 42, 56: 41, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 45, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 48, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 42, 56: 49, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 50, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 51] }, { 72: [1, 35], 86: 52 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 53, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 54, 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 55, 47: [2, 54] }, { 28: 60, 43: 61, 44: [1, 59], 47: [2, 56] }, { 13: 63, 15: [1, 20], 18: [1, 62] }, { 15: [2, 48], 18: [2, 48] }, { 33: [2, 86], 57: 64, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 65, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 66, 47: [1, 67] }, { 30: 68, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 69, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 70, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 71, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 75, 33: [2, 80], 50: 72, 63: 73, 64: 76, 65: [1, 44], 69: 74, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 80] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 51] }, { 20: 75, 53: 81, 54: [2, 84], 63: 82, 64: 76, 65: [1, 44], 69: 83, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 84, 47: [1, 67] }, { 47: [2, 55] }, { 4: 85, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 86, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 87, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 88, 47: [1, 67] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 75, 33: [2, 88], 58: 89, 63: 90, 64: 76, 65: [1, 44], 69: 91, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 92, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 93, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 31: 94, 33: [2, 60], 63: 95, 64: 76, 65: [1, 44], 69: 96, 70: 77, 71: 78, 72: [1, 79], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 66], 36: 97, 63: 98, 64: 76, 65: [1, 44], 69: 99, 70: 77, 71: 78, 72: [1, 79], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 22: 100, 23: [2, 52], 63: 101, 64: 76, 65: [1, 44], 69: 102, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 92], 62: 103, 63: 104, 64: 76, 65: [1, 44], 69: 105, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 106] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 107, 72: [1, 108], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 109], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 110] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 112, 46: 111, 47: [2, 76] }, { 33: [2, 70], 40: 113, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 114] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 75, 63: 116, 64: 76, 65: [1, 44], 67: 115, 68: [2, 96], 69: 117, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 118] }, { 32: 119, 33: [2, 62], 74: 120, 75: [1, 121] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 122, 74: 123, 75: [1, 121] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 124] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 125] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 109] }, { 20: 75, 63: 126, 64: 76, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 75, 33: [2, 72], 41: 127, 63: 128, 64: 76, 65: [1, 44], 69: 129, 70: 77, 71: 78, 72: [1, 79], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 130] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 131] }, { 33: [2, 63] }, { 72: [1, 133], 76: 132 }, { 33: [1, 134] }, { 33: [2, 69] }, { 15: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 135, 74: 136, 75: [1, 121] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 138], 77: [1, 137] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 139] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
        defaultActions: { 4: [2, 1], 55: [2, 55], 57: [2, 20], 61: [2, 57], 74: [2, 81], 83: [2, 85], 87: [2, 18], 91: [2, 89], 102: [2, 53], 105: [2, 93], 111: [2, 19], 112: [2, 77], 117: [2, 97], 120: [2, 63], 123: [2, 69], 124: [2, 12], 136: [2, 75], 137: [2, 32] },
        parseError: function parseError(str, hash) {
            throw new Error(str);
        },
        parse: function parse(input) {
            var self = this,
                stack = [0],
                vstack = [null],
                lstack = [],
                table = this.table,
                yytext = "",
                yylineno = 0,
                yyleng = 0,
                recovering = 0,
                TERROR = 2,
                EOF = 1;
            this.lexer.setInput(input);
            this.lexer.yy = this.yy;
            this.yy.lexer = this.lexer;
            this.yy.parser = this;
            if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
            var yyloc = this.lexer.yylloc;
            lstack.push(yyloc);
            var ranges = this.lexer.options && this.lexer.options.ranges;
            if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
            function popStack(n) {
                stack.length = stack.length - 2 * n;
                vstack.length = vstack.length - n;
                lstack.length = lstack.length - n;
            }
            function lex() {
                var token;
                token = self.lexer.lex() || 1;
                if (typeof token !== "number") {
                    token = self.symbols_[token] || token;
                }
                return token;
            }
            var symbol,
                preErrorSymbol,
                state,
                action,
                a,
                r,
                yyval = {},
                p,
                len,
                newState,
                expected;
            while (true) {
                state = stack[stack.length - 1];
                if (this.defaultActions[state]) {
                    action = this.defaultActions[state];
                } else {
                    if (symbol === null || typeof symbol == "undefined") {
                        symbol = lex();
                    }
                    action = table[state] && table[state][symbol];
                }
                if (typeof action === "undefined" || !action.length || !action[0]) {
                    var errStr = "";
                    if (!recovering) {
                        expected = [];
                        for (p in table[state]) if (this.terminals_[p] && p > 2) {
                            expected.push("'" + this.terminals_[p] + "'");
                        }
                        if (this.lexer.showPosition) {
                            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                        } else {
                            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                        }
                        this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
                    }
                }
                if (action[0] instanceof Array && action.length > 1) {
                    throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                }
                switch (action[0]) {
                    case 1:
                        stack.push(symbol);
                        vstack.push(this.lexer.yytext);
                        lstack.push(this.lexer.yylloc);
                        stack.push(action[1]);
                        symbol = null;
                        if (!preErrorSymbol) {
                            yyleng = this.lexer.yyleng;
                            yytext = this.lexer.yytext;
                            yylineno = this.lexer.yylineno;
                            yyloc = this.lexer.yylloc;
                            if (recovering > 0) recovering--;
                        } else {
                            symbol = preErrorSymbol;
                            preErrorSymbol = null;
                        }
                        break;
                    case 2:
                        len = this.productions_[action[1]][1];
                        yyval.$ = vstack[vstack.length - len];
                        yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                        if (ranges) {
                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                        }
                        r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                        if (typeof r !== "undefined") {
                            return r;
                        }
                        if (len) {
                            stack = stack.slice(0, -1 * len * 2);
                            vstack = vstack.slice(0, -1 * len);
                            lstack = lstack.slice(0, -1 * len);
                        }
                        stack.push(this.productions_[action[1]][0]);
                        vstack.push(yyval.$);
                        lstack.push(yyval._$);
                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                        stack.push(newState);
                        break;
                    case 3:
                        return true;
                }
            }
            return true;
        }
    };
    /* Jison generated lexer */
    var lexer = (function () {
        var lexer = { EOF: 1,
            parseError: function parseError(str, hash) {
                if (this.yy.parser) {
                    this.yy.parser.parseError(str, hash);
                } else {
                    throw new Error(str);
                }
            },
            setInput: function setInput(input) {
                this._input = input;
                this._more = this._less = this.done = false;
                this.yylineno = this.yyleng = 0;
                this.yytext = this.matched = this.match = '';
                this.conditionStack = ['INITIAL'];
                this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
                if (this.options.ranges) this.yylloc.range = [0, 0];
                this.offset = 0;
                return this;
            },
            input: function input() {
                var ch = this._input[0];
                this.yytext += ch;
                this.yyleng++;
                this.offset++;
                this.match += ch;
                this.matched += ch;
                var lines = ch.match(/(?:\r\n?|\n).*/g);
                if (lines) {
                    this.yylineno++;
                    this.yylloc.last_line++;
                } else {
                    this.yylloc.last_column++;
                }
                if (this.options.ranges) this.yylloc.range[1]++;

                this._input = this._input.slice(1);
                return ch;
            },
            unput: function unput(ch) {
                var len = ch.length;
                var lines = ch.split(/(?:\r\n?|\n)/g);

                this._input = ch + this._input;
                this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
                //this.yyleng -= len;
                this.offset -= len;
                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                this.match = this.match.substr(0, this.match.length - 1);
                this.matched = this.matched.substr(0, this.matched.length - 1);

                if (lines.length - 1) this.yylineno -= lines.length - 1;
                var r = this.yylloc.range;

                this.yylloc = { first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                };

                if (this.options.ranges) {
                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                }
                return this;
            },
            more: function more() {
                this._more = true;
                return this;
            },
            less: function less(n) {
                this.unput(this.match.slice(n));
            },
            pastInput: function pastInput() {
                var past = this.matched.substr(0, this.matched.length - this.match.length);
                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
            },
            upcomingInput: function upcomingInput() {
                var next = this.match;
                if (next.length < 20) {
                    next += this._input.substr(0, 20 - next.length);
                }
                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
            },
            showPosition: function showPosition() {
                var pre = this.pastInput();
                var c = new Array(pre.length + 1).join("-");
                return pre + this.upcomingInput() + "\n" + c + "^";
            },
            next: function next() {
                if (this.done) {
                    return this.EOF;
                }
                if (!this._input) this.done = true;

                var token, match, tempMatch, index, col, lines;
                if (!this._more) {
                    this.yytext = '';
                    this.match = '';
                }
                var rules = this._currentRules();
                for (var i = 0; i < rules.length; i++) {
                    tempMatch = this._input.match(this.rules[rules[i]]);
                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                        match = tempMatch;
                        index = i;
                        if (!this.options.flex) break;
                    }
                }
                if (match) {
                    lines = match[0].match(/(?:\r\n?|\n).*/g);
                    if (lines) this.yylineno += lines.length;
                    this.yylloc = { first_line: this.yylloc.last_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.last_column,
                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length };
                    this.yytext += match[0];
                    this.match += match[0];
                    this.matches = match;
                    this.yyleng = this.yytext.length;
                    if (this.options.ranges) {
                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
                    }
                    this._more = false;
                    this._input = this._input.slice(match[0].length);
                    this.matched += match[0];
                    token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                    if (this.done && this._input) this.done = false;
                    if (token) return token;else return;
                }
                if (this._input === "") {
                    return this.EOF;
                } else {
                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), { text: "", token: null, line: this.yylineno });
                }
            },
            lex: function lex() {
                var r = this.next();
                if (typeof r !== 'undefined') {
                    return r;
                } else {
                    return this.lex();
                }
            },
            begin: function begin(condition) {
                this.conditionStack.push(condition);
            },
            popState: function popState() {
                return this.conditionStack.pop();
            },
            _currentRules: function _currentRules() {
                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            },
            topState: function topState() {
                return this.conditionStack[this.conditionStack.length - 2];
            },
            pushState: function begin(condition) {
                this.begin(condition);
            } };
        lexer.options = {};
        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START
        /**/) {

            function strip(start, end) {
                return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
            }

            var YYSTATE = YY_START;
            switch ($avoiding_name_collisions) {
                case 0:
                    if (yy_.yytext.slice(-2) === "\\\\") {
                        strip(0, 1);
                        this.begin("mu");
                    } else if (yy_.yytext.slice(-1) === "\\") {
                        strip(0, 1);
                        this.begin("emu");
                    } else {
                        this.begin("mu");
                    }
                    if (yy_.yytext) return 15;

                    break;
                case 1:
                    return 15;
                    break;
                case 2:
                    this.popState();
                    return 15;

                    break;
                case 3:
                    this.begin('raw');return 15;
                    break;
                case 4:
                    this.popState();
                    // Should be using `this.topState()` below, but it currently
                    // returns the second top instead of the first top. Opened an
                    // issue about it at https://github.com/zaach/jison/issues/291
                    if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
                        return 15;
                    } else {
                        yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
                        return 'END_RAW_BLOCK';
                    }

                    break;
                case 5:
                    return 15;
                    break;
                case 6:
                    this.popState();
                    return 14;

                    break;
                case 7:
                    return 65;
                    break;
                case 8:
                    return 68;
                    break;
                case 9:
                    return 19;
                    break;
                case 10:
                    this.popState();
                    this.begin('raw');
                    return 23;

                    break;
                case 11:
                    return 55;
                    break;
                case 12:
                    return 60;
                    break;
                case 13:
                    return 29;
                    break;
                case 14:
                    return 47;
                    break;
                case 15:
                    this.popState();return 44;
                    break;
                case 16:
                    this.popState();return 44;
                    break;
                case 17:
                    return 34;
                    break;
                case 18:
                    return 39;
                    break;
                case 19:
                    return 51;
                    break;
                case 20:
                    return 48;
                    break;
                case 21:
                    this.unput(yy_.yytext);
                    this.popState();
                    this.begin('com');

                    break;
                case 22:
                    this.popState();
                    return 14;

                    break;
                case 23:
                    return 48;
                    break;
                case 24:
                    return 73;
                    break;
                case 25:
                    return 72;
                    break;
                case 26:
                    return 72;
                    break;
                case 27:
                    return 87;
                    break;
                case 28:
                    // ignore whitespace
                    break;
                case 29:
                    this.popState();return 54;
                    break;
                case 30:
                    this.popState();return 33;
                    break;
                case 31:
                    yy_.yytext = strip(1, 2).replace(/\\"/g, '"');return 80;
                    break;
                case 32:
                    yy_.yytext = strip(1, 2).replace(/\\'/g, "'");return 80;
                    break;
                case 33:
                    return 85;
                    break;
                case 34:
                    return 82;
                    break;
                case 35:
                    return 82;
                    break;
                case 36:
                    return 83;
                    break;
                case 37:
                    return 84;
                    break;
                case 38:
                    return 81;
                    break;
                case 39:
                    return 75;
                    break;
                case 40:
                    return 77;
                    break;
                case 41:
                    return 72;
                    break;
                case 42:
                    yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');return 72;
                    break;
                case 43:
                    return 'INVALID';
                    break;
                case 44:
                    return 5;
                    break;
            }
        };
        lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
        lexer.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
        return lexer;
    })();
    parser.lexer = lexer;
    function Parser() {
        this.yy = {};
    }Parser.prototype = parser;parser.Parser = Parser;
    return new Parser();
})();exports["default"] = handlebars;
module.exports = exports["default"];


},{}],134:[function(require,module,exports){
/* eslint-disable new-cap */
'use strict';

exports.__esModule = true;
exports.print = print;
exports.PrintVisitor = PrintVisitor;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _visitor = require('./visitor');

var _visitor2 = _interopRequireDefault(_visitor);

function print(ast) {
  return new PrintVisitor().accept(ast);
}

function PrintVisitor() {
  this.padding = 0;
}

PrintVisitor.prototype = new _visitor2['default']();

PrintVisitor.prototype.pad = function (string) {
  var out = '';

  for (var i = 0, l = this.padding; i < l; i++) {
    out += '  ';
  }

  out += string + '\n';
  return out;
};

PrintVisitor.prototype.Program = function (program) {
  var out = '',
      body = program.body,
      i = undefined,
      l = undefined;

  if (program.blockParams) {
    var blockParams = 'BLOCK PARAMS: [';
    for (i = 0, l = program.blockParams.length; i < l; i++) {
      blockParams += ' ' + program.blockParams[i];
    }
    blockParams += ' ]';
    out += this.pad(blockParams);
  }

  for (i = 0, l = body.length; i < l; i++) {
    out += this.accept(body[i]);
  }

  this.padding--;

  return out;
};

PrintVisitor.prototype.MustacheStatement = function (mustache) {
  return this.pad('{{ ' + this.SubExpression(mustache) + ' }}');
};
PrintVisitor.prototype.Decorator = function (mustache) {
  return this.pad('{{ DIRECTIVE ' + this.SubExpression(mustache) + ' }}');
};

PrintVisitor.prototype.BlockStatement = PrintVisitor.prototype.DecoratorBlock = function (block) {
  var out = '';

  out += this.pad((block.type === 'DecoratorBlock' ? 'DIRECTIVE ' : '') + 'BLOCK:');
  this.padding++;
  out += this.pad(this.SubExpression(block));
  if (block.program) {
    out += this.pad('PROGRAM:');
    this.padding++;
    out += this.accept(block.program);
    this.padding--;
  }
  if (block.inverse) {
    if (block.program) {
      this.padding++;
    }
    out += this.pad('{{^}}');
    this.padding++;
    out += this.accept(block.inverse);
    this.padding--;
    if (block.program) {
      this.padding--;
    }
  }
  this.padding--;

  return out;
};

PrintVisitor.prototype.PartialStatement = function (partial) {
  var content = 'PARTIAL:' + partial.name.original;
  if (partial.params[0]) {
    content += ' ' + this.accept(partial.params[0]);
  }
  if (partial.hash) {
    content += ' ' + this.accept(partial.hash);
  }
  return this.pad('{{> ' + content + ' }}');
};
PrintVisitor.prototype.PartialBlockStatement = function (partial) {
  var content = 'PARTIAL BLOCK:' + partial.name.original;
  if (partial.params[0]) {
    content += ' ' + this.accept(partial.params[0]);
  }
  if (partial.hash) {
    content += ' ' + this.accept(partial.hash);
  }

  content += ' ' + this.pad('PROGRAM:');
  this.padding++;
  content += this.accept(partial.program);
  this.padding--;

  return this.pad('{{> ' + content + ' }}');
};

PrintVisitor.prototype.ContentStatement = function (content) {
  return this.pad("CONTENT[ '" + content.value + "' ]");
};

PrintVisitor.prototype.CommentStatement = function (comment) {
  return this.pad("{{! '" + comment.value + "' }}");
};

PrintVisitor.prototype.SubExpression = function (sexpr) {
  var params = sexpr.params,
      paramStrings = [],
      hash = undefined;

  for (var i = 0, l = params.length; i < l; i++) {
    paramStrings.push(this.accept(params[i]));
  }

  params = '[' + paramStrings.join(', ') + ']';

  hash = sexpr.hash ? ' ' + this.accept(sexpr.hash) : '';

  return this.accept(sexpr.path) + ' ' + params + hash;
};

PrintVisitor.prototype.PathExpression = function (id) {
  var path = id.parts.join('/');
  return (id.data ? '@' : '') + 'PATH:' + path;
};

PrintVisitor.prototype.StringLiteral = function (string) {
  return '"' + string.value + '"';
};

PrintVisitor.prototype.NumberLiteral = function (number) {
  return 'NUMBER{' + number.value + '}';
};

PrintVisitor.prototype.BooleanLiteral = function (bool) {
  return 'BOOLEAN{' + bool.value + '}';
};

PrintVisitor.prototype.UndefinedLiteral = function () {
  return 'UNDEFINED';
};

PrintVisitor.prototype.NullLiteral = function () {
  return 'NULL';
};

PrintVisitor.prototype.Hash = function (hash) {
  var pairs = hash.pairs,
      joinedPairs = [];

  for (var i = 0, l = pairs.length; i < l; i++) {
    joinedPairs.push(this.accept(pairs[i]));
  }

  return 'HASH{' + joinedPairs.join(', ') + '}';
};
PrintVisitor.prototype.HashPair = function (pair) {
  return pair.key + '=' + this.accept(pair.value);
};
/* eslint-enable new-cap */


},{"./visitor":135}],135:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

function Visitor() {
  this.parents = [];
}

Visitor.prototype = {
  constructor: Visitor,
  mutating: false,

  // Visits a given value. If mutating, will replace the value if necessary.
  acceptKey: function acceptKey(node, name) {
    var value = this.accept(node[name]);
    if (this.mutating) {
      // Hacky sanity check: This may have a few false positives for type for the helper
      // methods but will generally do the right thing without a lot of overhead.
      if (value && !Visitor.prototype[value.type]) {
        throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
      }
      node[name] = value;
    }
  },

  // Performs an accept operation with added sanity check to ensure
  // required keys are not removed.
  acceptRequired: function acceptRequired(node, name) {
    this.acceptKey(node, name);

    if (!node[name]) {
      throw new _exception2['default'](node.type + ' requires ' + name);
    }
  },

  // Traverses a given array. If mutating, empty respnses will be removed
  // for child elements.
  acceptArray: function acceptArray(array) {
    for (var i = 0, l = array.length; i < l; i++) {
      this.acceptKey(array, i);

      if (!array[i]) {
        array.splice(i, 1);
        i--;
        l--;
      }
    }
  },

  accept: function accept(object) {
    if (!object) {
      return;
    }

    /* istanbul ignore next: Sanity code */
    if (!this[object.type]) {
      throw new _exception2['default']('Unknown type: ' + object.type, object);
    }

    if (this.current) {
      this.parents.unshift(this.current);
    }
    this.current = object;

    var ret = this[object.type](object);

    this.current = this.parents.shift();

    if (!this.mutating || ret) {
      return ret;
    } else if (ret !== false) {
      return object;
    }
  },

  Program: function Program(program) {
    this.acceptArray(program.body);
  },

  MustacheStatement: visitSubExpression,
  Decorator: visitSubExpression,

  BlockStatement: visitBlock,
  DecoratorBlock: visitBlock,

  PartialStatement: visitPartial,
  PartialBlockStatement: function PartialBlockStatement(partial) {
    visitPartial.call(this, partial);

    this.acceptKey(partial, 'program');
  },

  ContentStatement: function ContentStatement() /* content */{},
  CommentStatement: function CommentStatement() /* comment */{},

  SubExpression: visitSubExpression,

  PathExpression: function PathExpression() /* path */{},

  StringLiteral: function StringLiteral() /* string */{},
  NumberLiteral: function NumberLiteral() /* number */{},
  BooleanLiteral: function BooleanLiteral() /* bool */{},
  UndefinedLiteral: function UndefinedLiteral() /* literal */{},
  NullLiteral: function NullLiteral() /* literal */{},

  Hash: function Hash(hash) {
    this.acceptArray(hash.pairs);
  },
  HashPair: function HashPair(pair) {
    this.acceptRequired(pair, 'value');
  }
};

function visitSubExpression(mustache) {
  this.acceptRequired(mustache, 'path');
  this.acceptArray(mustache.params);
  this.acceptKey(mustache, 'hash');
}
function visitBlock(block) {
  visitSubExpression.call(this, block);

  this.acceptKey(block, 'program');
  this.acceptKey(block, 'inverse');
}
function visitPartial(partial) {
  this.acceptRequired(partial, 'name');
  this.acceptArray(partial.params);
  this.acceptKey(partial, 'hash');
}

exports['default'] = Visitor;
module.exports = exports['default'];


},{"../exception":139}],136:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _visitor = require('./visitor');

var _visitor2 = _interopRequireDefault(_visitor);

function WhitespaceControl() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  this.options = options;
}
WhitespaceControl.prototype = new _visitor2['default']();

WhitespaceControl.prototype.Program = function (program) {
  var doStandalone = !this.options.ignoreStandalone;

  var isRoot = !this.isRootSeen;
  this.isRootSeen = true;

  var body = program.body;
  for (var i = 0, l = body.length; i < l; i++) {
    var current = body[i],
        strip = this.accept(current);

    if (!strip) {
      continue;
    }

    var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
        _isNextWhitespace = isNextWhitespace(body, i, isRoot),
        openStandalone = strip.openStandalone && _isPrevWhitespace,
        closeStandalone = strip.closeStandalone && _isNextWhitespace,
        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

    if (strip.close) {
      omitRight(body, i, true);
    }
    if (strip.open) {
      omitLeft(body, i, true);
    }

    if (doStandalone && inlineStandalone) {
      omitRight(body, i);

      if (omitLeft(body, i)) {
        // If we are on a standalone node, save the indent info for partials
        if (current.type === 'PartialStatement') {
          // Pull out the whitespace from the final line
          current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
        }
      }
    }
    if (doStandalone && openStandalone) {
      omitRight((current.program || current.inverse).body);

      // Strip out the previous content node if it's whitespace only
      omitLeft(body, i);
    }
    if (doStandalone && closeStandalone) {
      // Always strip the next node
      omitRight(body, i);

      omitLeft((current.inverse || current.program).body);
    }
  }

  return program;
};

WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {
  this.accept(block.program);
  this.accept(block.inverse);

  // Find the inverse program that is involed with whitespace stripping.
  var program = block.program || block.inverse,
      inverse = block.program && block.inverse,
      firstInverse = inverse,
      lastInverse = inverse;

  if (inverse && inverse.chained) {
    firstInverse = inverse.body[0].program;

    // Walk the inverse chain to find the last inverse that is actually in the chain.
    while (lastInverse.chained) {
      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
    }
  }

  var strip = {
    open: block.openStrip.open,
    close: block.closeStrip.close,

    // Determine the standalone candiacy. Basically flag our content as being possibly standalone
    // so our parent can determine if we actually are standalone
    openStandalone: isNextWhitespace(program.body),
    closeStandalone: isPrevWhitespace((firstInverse || program).body)
  };

  if (block.openStrip.close) {
    omitRight(program.body, null, true);
  }

  if (inverse) {
    var inverseStrip = block.inverseStrip;

    if (inverseStrip.open) {
      omitLeft(program.body, null, true);
    }

    if (inverseStrip.close) {
      omitRight(firstInverse.body, null, true);
    }
    if (block.closeStrip.open) {
      omitLeft(lastInverse.body, null, true);
    }

    // Find standalone else statments
    if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
      omitLeft(program.body);
      omitRight(firstInverse.body);
    }
  } else if (block.closeStrip.open) {
    omitLeft(program.body, null, true);
  }

  return strip;
};

WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {
  return mustache.strip;
};

WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
  /* istanbul ignore next */
  var strip = node.strip || {};
  return {
    inlineStandalone: true,
    open: strip.open,
    close: strip.close
  };
};

function isPrevWhitespace(body, i, isRoot) {
  if (i === undefined) {
    i = body.length;
  }

  // Nodes that end with newlines are considered whitespace (but are special
  // cased for strip operations)
  var prev = body[i - 1],
      sibling = body[i - 2];
  if (!prev) {
    return isRoot;
  }

  if (prev.type === 'ContentStatement') {
    return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
  }
}
function isNextWhitespace(body, i, isRoot) {
  if (i === undefined) {
    i = -1;
  }

  var next = body[i + 1],
      sibling = body[i + 2];
  if (!next) {
    return isRoot;
  }

  if (next.type === 'ContentStatement') {
    return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
  }
}

// Marks the node to the right of the position as omitted.
// I.e. {{foo}}' ' will mark the ' ' node as omitted.
//
// If i is undefined, then the first child will be marked as such.
//
// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
// content is met.
function omitRight(body, i, multiple) {
  var current = body[i == null ? 0 : i + 1];
  if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
    return;
  }

  var original = current.value;
  current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
  current.rightStripped = current.value !== original;
}

// Marks the node to the left of the position as omitted.
// I.e. ' '{{foo}} will mark the ' ' node as omitted.
//
// If i is undefined then the last child will be marked as such.
//
// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
// content is met.
function omitLeft(body, i, multiple) {
  var current = body[i == null ? body.length - 1 : i - 1];
  if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
    return;
  }

  // We omit the last node if it's whitespace only and not preceeded by a non-content node.
  var original = current.value;
  current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
  current.leftStripped = current.value !== original;
  return current.leftStripped;
}

exports['default'] = WhitespaceControl;
module.exports = exports['default'];


},{"./visitor":135}],137:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultDecorators = registerDefaultDecorators;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _decoratorsInline = require('./decorators/inline');

var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

function registerDefaultDecorators(instance) {
  _decoratorsInline2['default'](instance);
}


},{"./decorators/inline":138}],138:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerDecorator('inline', function (fn, props, container, options) {
    var ret = fn;
    if (!props.partials) {
      props.partials = {};
      ret = function (context, options) {
        // Create a new partials stack frame prior to exec.
        var original = container.partials;
        container.partials = _utils.extend({}, original, props.partials);
        var ret = fn(context, options);
        container.partials = original;
        return ret;
      };
    }

    props.partials[options.args[0]] = options.fn;

    return ret;
  });
};

module.exports = exports['default'];


},{"../utils":152}],139:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var loc = node && node.loc,
      line = undefined,
      column = undefined;
  if (loc) {
    line = loc.start.line;
    column = loc.start.column;

    message += ' - ' + line + ':' + column;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  /* istanbul ignore else */
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, Exception);
  }

  try {
    if (loc) {
      this.lineNumber = line;

      // Work around issue under safari where we can't directly set the column value
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(this, 'column', {
          value: column,
          enumerable: true
        });
      } else {
        this.column = column;
      }
    }
  } catch (nop) {
    /* Ignore if the browser is very particular */
  }
}

Exception.prototype = new Error();

exports['default'] = Exception;
module.exports = exports['default'];


},{}],140:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultHelpers = registerDefaultHelpers;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _helpersBlockHelperMissing = require('./helpers/block-helper-missing');

var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

var _helpersEach = require('./helpers/each');

var _helpersEach2 = _interopRequireDefault(_helpersEach);

var _helpersHelperMissing = require('./helpers/helper-missing');

var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

var _helpersIf = require('./helpers/if');

var _helpersIf2 = _interopRequireDefault(_helpersIf);

var _helpersLog = require('./helpers/log');

var _helpersLog2 = _interopRequireDefault(_helpersLog);

var _helpersLookup = require('./helpers/lookup');

var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

var _helpersWith = require('./helpers/with');

var _helpersWith2 = _interopRequireDefault(_helpersWith);

function registerDefaultHelpers(instance) {
  _helpersBlockHelperMissing2['default'](instance);
  _helpersEach2['default'](instance);
  _helpersHelperMissing2['default'](instance);
  _helpersIf2['default'](instance);
  _helpersLog2['default'](instance);
  _helpersLookup2['default'](instance);
  _helpersWith2['default'](instance);
}


},{"./helpers/block-helper-missing":141,"./helpers/each":142,"./helpers/helper-missing":143,"./helpers/if":144,"./helpers/log":145,"./helpers/lookup":146,"./helpers/with":147}],141:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('blockHelperMissing', function (context, options) {
    var inverse = options.inverse,
        fn = options.fn;

    if (context === true) {
      return fn(this);
    } else if (context === false || context == null) {
      return inverse(this);
    } else if (_utils.isArray(context)) {
      if (context.length > 0) {
        if (options.ids) {
          options.ids = [options.name];
        }

        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      if (options.data && options.ids) {
        var data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
        options = { data: data };
      }

      return fn(context, options);
    }
  });
};

module.exports = exports['default'];


},{"../utils":152}],142:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('../utils');

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('each', function (context, options) {
    if (!options) {
      throw new _exception2['default']('Must pass iterator to #each');
    }

    var fn = options.fn,
        inverse = options.inverse,
        i = 0,
        ret = '',
        data = undefined,
        contextPath = undefined;

    if (options.data && options.ids) {
      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
    }

    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    if (options.data) {
      data = _utils.createFrame(options.data);
    }

    function execIteration(field, index, last) {
      if (data) {
        data.key = field;
        data.index = index;
        data.first = index === 0;
        data.last = !!last;

        if (contextPath) {
          data.contextPath = contextPath + field;
        }
      }

      ret = ret + fn(context[field], {
        data: data,
        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
      });
    }

    if (context && typeof context === 'object') {
      if (_utils.isArray(context)) {
        for (var j = context.length; i < j; i++) {
          if (i in context) {
            execIteration(i, i, i === context.length - 1);
          }
        }
      } else {
        var priorKey = undefined;

        for (var key in context) {
          if (context.hasOwnProperty(key)) {
            // We're running the iterations one step out of sync so we can detect
            // the last iteration without have to scan the object twice and create
            // an itermediate keys array.
            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1);
            }
            priorKey = key;
            i++;
          }
        }
        if (priorKey !== undefined) {
          execIteration(priorKey, i - 1, true);
        }
      }
    }

    if (i === 0) {
      ret = inverse(this);
    }

    return ret;
  });
};

module.exports = exports['default'];


},{"../exception":139,"../utils":152}],143:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('helperMissing', function () /* [args, ]options */{
    if (arguments.length === 1) {
      // A missing field in a {{foo}} construct.
      return undefined;
    } else {
      // Someone is actually trying to call something, blow up.
      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    }
  });
};

module.exports = exports['default'];


},{"../exception":139}],144:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('if', function (conditional, options) {
    if (_utils.isFunction(conditional)) {
      conditional = conditional.call(this);
    }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function (conditional, options) {
    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
  });
};

module.exports = exports['default'];


},{"../utils":152}],145:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('log', function () /* message, options */{
    var args = [undefined],
        options = arguments[arguments.length - 1];
    for (var i = 0; i < arguments.length - 1; i++) {
      args.push(arguments[i]);
    }

    var level = 1;
    if (options.hash.level != null) {
      level = options.hash.level;
    } else if (options.data && options.data.level != null) {
      level = options.data.level;
    }
    args[0] = level;

    instance.log.apply(instance, args);
  });
};

module.exports = exports['default'];


},{}],146:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('lookup', function (obj, field) {
    return obj && obj[field];
  });
};

module.exports = exports['default'];


},{}],147:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('with', function (context, options) {
    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    var fn = options.fn;

    if (!_utils.isEmpty(context)) {
      var data = options.data;
      if (options.data && options.ids) {
        data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
      }

      return fn(context, {
        data: data,
        blockParams: _utils.blockParams([context], [data && data.contextPath])
      });
    } else {
      return options.inverse(this);
    }
  });
};

module.exports = exports['default'];


},{"../utils":152}],148:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('./utils');

var logger = {
  methodMap: ['debug', 'info', 'warn', 'error'],
  level: 'info',

  // Maps a given level value to the `methodMap` indexes above.
  lookupLevel: function lookupLevel(level) {
    if (typeof level === 'string') {
      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
      if (levelMap >= 0) {
        level = levelMap;
      } else {
        level = parseInt(level, 10);
      }
    }

    return level;
  },

  // Can be overridden in the host environment
  log: function log(level) {
    level = logger.lookupLevel(level);

    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
      var method = logger.methodMap[level];
      if (!console[method]) {
        // eslint-disable-line no-console
        method = 'log';
      }

      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        message[_key - 1] = arguments[_key];
      }

      console[method].apply(console, message); // eslint-disable-line no-console
    }
  }
};

exports['default'] = logger;
module.exports = exports['default'];


},{"./utils":152}],149:[function(require,module,exports){
(function (global){
/* global window */
'use strict';

exports.__esModule = true;

exports['default'] = function (Handlebars) {
  /* istanbul ignore next */
  var root = typeof global !== 'undefined' ? global : window,
      $Handlebars = root.Handlebars;
  /* istanbul ignore next */
  Handlebars.noConflict = function () {
    if (root.Handlebars === Handlebars) {
      root.Handlebars = $Handlebars;
    }
    return Handlebars;
  };
};

module.exports = exports['default'];


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],150:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.checkRevision = checkRevision;
exports.template = template;
exports.wrapProgram = wrapProgram;
exports.resolvePartial = resolvePartial;
exports.invokePartial = invokePartial;
exports.noop = noop;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _utils = require('./utils');

var Utils = _interopRequireWildcard(_utils);

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _base = require('./base');

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = _base.COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
    }
  }
}

function template(templateSpec, env) {
  /* istanbul ignore next */
  if (!env) {
    throw new _exception2['default']('No environment passed to template');
  }
  if (!templateSpec || !templateSpec.main) {
    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
  }

  templateSpec.main.decorator = templateSpec.main_d;

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  env.VM.checkRevision(templateSpec.compiler);

  function invokePartialWrapper(partial, context, options) {
    if (options.hash) {
      context = Utils.extend({}, context, options.hash);
      if (options.ids) {
        options.ids[0] = true;
      }
    }

    partial = env.VM.resolvePartial.call(this, partial, context, options);
    var result = env.VM.invokePartial.call(this, partial, context, options);

    if (result == null && env.compile) {
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, options);
    }
    if (result != null) {
      if (options.indent) {
        var lines = result.split('\n');
        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }

          lines[i] = options.indent + lines[i];
        }
        result = lines.join('\n');
      }
      return result;
    } else {
      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    }
  }

  // Just add water
  var container = {
    strict: function strict(obj, name) {
      if (!(name in obj)) {
        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
      }
      return obj[name];
    },
    lookup: function lookup(depths, name) {
      var len = depths.length;
      for (var i = 0; i < len; i++) {
        if (depths[i] && depths[i][name] != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === 'function' ? current.call(context) : current;
    },

    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,

    fn: function fn(i) {
      var ret = templateSpec[i];
      ret.decorator = templateSpec[i + '_d'];
      return ret;
    },

    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams, depths) {
      var programWrapper = this.programs[i],
          fn = this.fn(i);
      if (data || depths || blockParams || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      }
      return programWrapper;
    },

    data: function data(value, depth) {
      while (value && depth--) {
        value = value._parent;
      }
      return value;
    },
    merge: function merge(param, common) {
      var obj = param || common;

      if (param && common && param !== common) {
        obj = Utils.extend({}, common, param);
      }

      return obj;
    },
    // An empty object to use as replacement for null-contexts
    nullContext: Object.seal({}),

    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };

  function ret(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var data = options.data;

    ret._setup(options);
    if (!options.partial && templateSpec.useData) {
      data = initData(context, data);
    }
    var depths = undefined,
        blockParams = templateSpec.useBlockParams ? [] : undefined;
    if (templateSpec.useDepths) {
      if (options.depths) {
        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
      } else {
        depths = [context];
      }
    }

    function main(context /*, options*/) {
      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    }
    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    return main(context, options);
  }
  ret.isTop = true;

  ret._setup = function (options) {
    if (!options.partial) {
      container.helpers = container.merge(options.helpers, env.helpers);

      if (templateSpec.usePartial) {
        container.partials = container.merge(options.partials, env.partials);
      }
      if (templateSpec.usePartial || templateSpec.useDecorators) {
        container.decorators = container.merge(options.decorators, env.decorators);
      }
    } else {
      container.helpers = options.helpers;
      container.partials = options.partials;
      container.decorators = options.decorators;
    }
  };

  ret._child = function (i, data, blockParams, depths) {
    if (templateSpec.useBlockParams && !blockParams) {
      throw new _exception2['default']('must pass block params');
    }
    if (templateSpec.useDepths && !depths) {
      throw new _exception2['default']('must pass parent depths');
    }

    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
  };
  return ret;
}

function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
  function prog(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var currentDepths = depths;
    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
      currentDepths = [context].concat(depths);
    }

    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
  }

  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}

function resolvePartial(partial, context, options) {
  if (!partial) {
    if (options.name === '@partial-block') {
      partial = options.data['partial-block'];
    } else {
      partial = options.partials[options.name];
    }
  } else if (!partial.call && !options.name) {
    // This is a dynamic partial that returned a string
    options.name = partial;
    partial = options.partials[partial];
  }
  return partial;
}

function invokePartial(partial, context, options) {
  // Use the current closure context to save the partial-block if this partial
  var currentPartialBlock = options.data && options.data['partial-block'];
  options.partial = true;
  if (options.ids) {
    options.data.contextPath = options.ids[0] || options.data.contextPath;
  }

  var partialBlock = undefined;
  if (options.fn && options.fn !== noop) {
    (function () {
      options.data = _base.createFrame(options.data);
      // Wrapper function to get access to currentPartialBlock from the closure
      var fn = options.fn;
      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        // Restore the partial-block from the closure for the execution of the block
        // i.e. the part inside the block of the partial call.
        options.data = _base.createFrame(options.data);
        options.data['partial-block'] = currentPartialBlock;
        return fn(context, options);
      };
      if (fn.partials) {
        options.partials = Utils.extend({}, options.partials, fn.partials);
      }
    })();
  }

  if (partial === undefined && partialBlock) {
    partial = partialBlock;
  }

  if (partial === undefined) {
    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
  } else if (partial instanceof Function) {
    return partial(context, options);
  }
}

function noop() {
  return '';
}

function initData(context, data) {
  if (!data || !('root' in data)) {
    data = data ? _base.createFrame(data) : {};
    data.root = context;
  }
  return data;
}

function executeDecorators(fn, prog, container, depths, data, blockParams) {
  if (fn.decorator) {
    var props = {};
    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
    Utils.extend(prog, props);
  }
  return prog;
}


},{"./base":126,"./exception":139,"./utils":152}],151:[function(require,module,exports){
// Build out our basic SafeString type
'use strict';

exports.__esModule = true;
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
  return '' + this.string;
};

exports['default'] = SafeString;
module.exports = exports['default'];


},{}],152:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.extend = extend;
exports.indexOf = indexOf;
exports.escapeExpression = escapeExpression;
exports.isEmpty = isEmpty;
exports.createFrame = createFrame;
exports.blockParams = blockParams;
exports.appendContextPath = appendContextPath;
var escape = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;',
  '=': '&#x3D;'
};

var badChars = /[&<>"'`=]/g,
    possible = /[&<>"'`=]/;

function escapeChar(chr) {
  return escape[chr];
}

function extend(obj /* , ...source */) {
  for (var i = 1; i < arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }

  return obj;
}

var toString = Object.prototype.toString;

exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
/* eslint-disable func-style */
var isFunction = function isFunction(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
/* istanbul ignore next */
if (isFunction(/x/)) {
  exports.isFunction = isFunction = function (value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
exports.isFunction = isFunction;

/* eslint-enable func-style */

/* istanbul ignore next */
var isArray = Array.isArray || function (value) {
  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
};

exports.isArray = isArray;
// Older IE versions do not directly support indexOf so we must implement our own, sadly.

function indexOf(array, value) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
}

function escapeExpression(string) {
  if (typeof string !== 'string') {
    // don't escape SafeStrings, since they're already safe
    if (string && string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return '';
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = '' + string;
  }

  if (!possible.test(string)) {
    return string;
  }
  return string.replace(badChars, escapeChar);
}

function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

function createFrame(object) {
  var frame = extend({}, object);
  frame._parent = object;
  return frame;
}

function blockParams(params, ids) {
  params.path = ids;
  return params;
}

function appendContextPath(contextPath, id) {
  return (contextPath ? contextPath + '.' : '') + id;
}


},{}],153:[function(require,module,exports){
// USAGE:
// var handlebars = require('handlebars');
/* eslint-disable no-var */

// var local = handlebars.create();

var handlebars = require('../dist/cjs/handlebars')['default'];

var printer = require('../dist/cjs/handlebars/compiler/printer');
handlebars.PrintVisitor = printer.PrintVisitor;
handlebars.print = printer.print;

module.exports = handlebars;

// Publish a Node.js require() handler for .handlebars and .hbs files
function extension(module, filename) {
  var fs = require('fs');
  var templateString = fs.readFileSync(filename, 'utf8');
  module.exports = handlebars.compile(templateString);
}
/* istanbul ignore else */
if (typeof require !== 'undefined' && require.extensions) {
  require.extensions['.handlebars'] = extension;
  require.extensions['.hbs'] = extension;
}

},{"../dist/cjs/handlebars":124,"../dist/cjs/handlebars/compiler/printer":134,"fs":117}],154:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./source-map/source-node').SourceNode;

},{"./source-map/source-map-consumer":161,"./source-map/source-map-generator":162,"./source-map/source-node":163}],155:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = {};
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Return how many unique items are in this ArraySet. If duplicates have been
   * added, than those do not count towards the size.
   *
   * @returns Number
   */
  ArraySet.prototype.size = function ArraySet_size() {
    return Object.getOwnPropertyNames(this._set).length;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var isDuplicate = this.has(aStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set[util.toSetString(aStr)] = idx;
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    return Object.prototype.hasOwnProperty.call(this._set,
                                                util.toSetString(aStr));
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (this.has(aStr)) {
      return this._set[util.toSetString(aStr)];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;

});

},{"./util":164,"amdefine":116}],156:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64 = require('./base64');

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */
  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }

      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }

      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };

});

},{"./base64":157,"amdefine":116}],157:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function (number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + aNumber);
  };

  /**
   * Decode a single base 64 character code digit to an integer. Returns -1 on
   * failure.
   */
  exports.decode = function (charCode) {
    var bigA = 65;     // 'A'
    var bigZ = 90;     // 'Z'

    var littleA = 97;  // 'a'
    var littleZ = 122; // 'z'

    var zero = 48;     // '0'
    var nine = 57;     // '9'

    var plus = 43;     // '+'
    var slash = 47;    // '/'

    var littleOffset = 26;
    var numberOffset = 52;

    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    if (bigA <= charCode && charCode <= bigZ) {
      return (charCode - bigA);
    }

    // 26 - 51: abcdefghijklmnopqrstuvwxyz
    if (littleA <= charCode && charCode <= littleZ) {
      return (charCode - littleA + littleOffset);
    }

    // 52 - 61: 0123456789
    if (zero <= charCode && charCode <= nine) {
      return (charCode - zero + numberOffset);
    }

    // 62: +
    if (charCode == plus) {
      return 62;
    }

    // 63: /
    if (charCode == slash) {
      return 63;
    }

    // Invalid base64 digit.
    return -1;
  };

});

},{"amdefine":116}],158:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next-closest element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element than the one we are searching for, so we return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    }
    else if (cmp > 0) {
      // Our needle is greater than aHaystack[mid].
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }

      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    }
    else {
      // Our needle is less than aHaystack[mid].
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }

      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the index of the closest element if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }

    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                                aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }

    // We have found either the exact element, or the next-closest element than
    // the one we are searching for. However, there may be more than one such
    // element. Make sure we always return the smallest of these.
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }

    return index;
  };

});

},{"amdefine":116}],159:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */
  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA ||
           util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }

  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */
  function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {generatedLine: -1, generatedColumn: 0};
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  MappingList.prototype.unsortedForEach =
    function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  MappingList.prototype.add = function MappingList_add(aMapping) {
    var mapping;
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };

  exports.MappingList = MappingList;

});

},{"./util":164,"amdefine":116}],160:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  // It turns out that some (most?) JavaScript engines don't self-host
  // `Array.prototype.sort`. This makes sense because C++ will likely remain
  // faster than JS when doing raw CPU-intensive sorting. However, when using a
  // custom comparator function, calling back and forth between the VM's C++ and
  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
  // worse generated code for the comparator function than would be optimal. In
  // fact, when sorting with a comparator, these costs outweigh the benefits of
  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
  // a ~3500ms mean speed-up in `bench/bench.html`.

  /**
   * Swap the elements indexed by `x` and `y` in the array `ary`.
   *
   * @param {Array} ary
   *        The array.
   * @param {Number} x
   *        The index of the first item.
   * @param {Number} y
   *        The index of the second item.
   */
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }

  /**
   * Returns a random integer within the range `low .. high` inclusive.
   *
   * @param {Number} low
   *        The lower bound on the range.
   * @param {Number} high
   *        The upper bound on the range.
   */
  function randomIntInRange(low, high) {
    return Math.round(low + (Math.random() * (high - low)));
  }

  /**
   * The Quick Sort algorithm.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   * @param {Number} p
   *        Start index of the array
   * @param {Number} r
   *        End index of the array
   */
  function doQuickSort(ary, comparator, p, r) {
    // If our lower bound is less than our upper bound, we (1) partition the
    // array into two pieces and (2) recurse on each half. If it is not, this is
    // the empty array and our base case.

    if (p < r) {
      // (1) Partitioning.
      //
      // The partitioning chooses a pivot between `p` and `r` and moves all
      // elements that are less than or equal to the pivot to the before it, and
      // all the elements that are greater than it after it. The effect is that
      // once partition is done, the pivot is in the exact place it will be when
      // the array is put in sorted order, and it will not need to be moved
      // again. This runs in O(n) time.

      // Always choose a random pivot so that an input array which is reverse
      // sorted does not cause O(n^2) running time.
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;

      swap(ary, pivotIndex, r);
      var pivot = ary[r];

      // Immediately after `j` is incremented in this loop, the following hold
      // true:
      //
      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
      //
      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }

      swap(ary, i + 1, j);
      var q = i + 1;

      // (2) Recurse on each half.

      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }

  /**
   * Sort the given array in-place with the given comparator function.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   */
  exports.quickSort = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };

});

},{"amdefine":116}],161:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');
  var quickSort = require('./quick-sort').quickSort;

  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    return sourceMap.sections != null
      ? new IndexedSourceMapConsumer(sourceMap)
      : new BasicSourceMapConsumer(sourceMap);
  }

  SourceMapConsumer.fromSourceMap = function(aSourceMap) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
  }

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer.prototype._charIsMappingSeparator =
    function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        if (source != null && sourceRoot != null) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };

  /**
   * Returns all generated line and column information for the original source,
   * line, and column provided. If no column is provided, returns all mappings
   * corresponding to a either the line we are searching for or the next
   * closest line that has any mappings. Otherwise, returns all mappings
   * corresponding to the given line and either the column we are searching for
   * or the next closest column that has any offsets.
   *
   * The only argument is an object with the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: Optional. the column number in the original source.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.allGeneratedPositionsFor =
    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, 'line');

      // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
      // returns the index of the closest mapping less than the needle. By
      // setting needle.originalColumn to 0, we thus find the last mapping for
      // the given line, provided such a mapping exists.
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: line,
        originalColumn: util.getArg(aArgs, 'column', 0)
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }
      if (!this._sources.has(needle.source)) {
        return [];
      }
      needle.source = this._sources.indexOf(needle.source);

      var mappings = [];

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions,
                                    binarySearch.LEAST_UPPER_BOUND);
      if (index >= 0) {
        var mapping = this._originalMappings[index];

        if (aArgs.column === undefined) {
          var originalLine = mapping.originalLine;

          // Iterate until either we run out of mappings, or we run into
          // a mapping for a different line than the one we found. Since
          // mappings are sorted, this is guaranteed to find all mappings for
          // the line we found.
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null),
              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            });

            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;

          // Iterate until either we run out of mappings, or we run into
          // a mapping for a different line than the one we were searching for.
          // Since mappings are sorted, this is guaranteed to find all mappings for
          // the line we are searching for.
          while (mapping &&
                 mapping.originalLine === line &&
                 mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null),
              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            });

            mapping = this._originalMappings[++index];
          }
        }
      }

      return mappings;
    };

  exports.SourceMapConsumer = SourceMapConsumer;

  /**
   * A BasicSourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function BasicSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    sources = sources.map(util.normalize);

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

  /**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns BasicSourceMapConsumer
   */
  BasicSourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);

      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      // Because we are modifying the entries (by converting string sources and
      // names to indices into the sources and names ArraySets), we have to make
      // a copy of the entry or else bad things happen. Shared mutable state
      // strikes again! See github issue #191.

      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];

      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping;
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;

        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;

          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }

          destOriginalMappings.push(destMapping);
        }

        destGeneratedMappings.push(destMapping);
      }

      quickSort(smc.__originalMappings, util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  BasicSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  /**
   * Provide the JIT with a nice shape / hidden class.
   */
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  BasicSourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;

      while (index < length) {
        if (aStr.charAt(index) === ';') {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        }
        else if (aStr.charAt(index) === ',') {
          index++;
        }
        else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;

          // Because each offset is encoded relative to the previous one,
          // many segments often have the same encoding. We can exploit this
          // fact by caching the parsed variable length fields of each segment,
          // allowing us to avoid a second parse if we encounter the same
          // segment again.
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);

          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }

            if (segment.length === 2) {
              throw new Error('Found a source, but no line and column');
            }

            if (segment.length === 3) {
              throw new Error('Found a source and line, but no column');
            }

            cachedSegments[str] = segment;
          }

          // Generated column.
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;

          if (segment.length > 1) {
            // Original source.
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];

            // Original line.
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;

            // Original column.
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;

            if (segment.length > 4) {
              // Original name.
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }

          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            originalMappings.push(mapping);
          }
        }
      }

      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;

      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  BasicSourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator, aBias) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  BasicSourceMapConsumer.prototype.computeColumnSpans =
    function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];

        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];

          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }

        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
      }
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  BasicSourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
      );

      if (index >= 0) {
        var mapping = this._generatedMappings[index];

        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, 'source', null);
          if (source !== null) {
            source = this._sources.at(source);
            if (this.sourceRoot != null) {
              source = util.join(this.sourceRoot, source);
            }
          }
          var name = util.getArg(mapping, 'name', null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source: source,
            line: util.getArg(mapping, 'originalLine', null),
            column: util.getArg(mapping, 'originalColumn', null),
            name: name
          };
        }
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
    function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() &&
        !this.sourcesContent.some(function (sc) { return sc == null; });
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * availible.
   */
  BasicSourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot != null) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot != null
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      // This function is used recursively from
      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
      // don't want to throw if we can't find the source - we just want to
      // return null, so we provide a flag to exit gracefully.
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  BasicSourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, 'source');
      if (this.sourceRoot != null) {
        source = util.relative(this.sourceRoot, source);
      }
      if (!this._sources.has(source)) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      source = this._sources.indexOf(source);

      var needle = {
        source: source,
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
      );

      if (index >= 0) {
        var mapping = this._originalMappings[index];

        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          };
        }
      }

      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };

  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

  /**
   * An IndexedSourceMapConsumer instance represents a parsed source map which
   * we can query for information. It differs from BasicSourceMapConsumer in
   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
   * input.
   *
   * The only parameter is a raw source map (either as a JSON string, or already
   * parsed to an object). According to the spec for indexed source maps, they
   * have the following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - file: Optional. The generated file this source map is associated with.
   *   - sections: A list of section definitions.
   *
   * Each value under the "sections" field has two fields:
   *   - offset: The offset into the original specified at which this section
   *       begins to apply, defined as an object with a "line" and "column"
   *       field.
   *   - map: A source map definition. This source map could also be indexed,
   *       but doesn't have to be.
   *
   * Instead of the "map" field, it's also possible to have a "url" field
   * specifying a URL to retrieve a source map from, but that's currently
   * unsupported.
   *
   * Here's an example source map, taken from the source map spec[0], but
   * modified to omit a section which uses the "url" field.
   *
   *  {
   *    version : 3,
   *    file: "app.js",
   *    sections: [{
   *      offset: {line:100, column:10},
   *      map: {
   *        version : 3,
   *        file: "section.js",
   *        sources: ["foo.js", "bar.js"],
   *        names: ["src", "maps", "are", "fun"],
   *        mappings: "AAAA,E;;ABCDE;"
   *      }
   *    }],
   *  }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
   */
  function IndexedSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    this._sources = new ArraySet();
    this._names = new ArraySet();

    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        // The url field will require support for asynchronicity.
        // See https://github.com/mozilla/source-map/issues/16
        throw new Error('Support for url field in sections not implemented.');
      }
      var offset = util.getArg(s, 'offset');
      var offsetLine = util.getArg(offset, 'line');
      var offsetColumn = util.getArg(offset, 'column');

      if (offsetLine < lastOffset.line ||
          (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }
      lastOffset = offset;

      return {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, 'map'))
      }
    });
  }

  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

  /**
   * The version of the source mapping spec that we are consuming.
   */
  IndexedSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function () {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      };
      return sources;
    }
  });

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  IndexedSourceMapConsumer.prototype.originalPositionFor =
    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      // Find the section containing the generated position we're trying to map
      // to an original position.
      var sectionIndex = binarySearch.search(needle, this._sections,
        function(needle, section) {
          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }

          return (needle.generatedColumn -
                  section.generatedOffset.generatedColumn);
        });
      var section = this._sections[sectionIndex];

      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }

      return section.consumer.originalPositionFor({
        line: needle.generatedLine -
          (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn -
          (section.generatedOffset.generatedLine === needle.generatedLine
           ? section.generatedOffset.generatedColumn - 1
           : 0),
        bias: aArgs.bias
      });
    };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
    function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function (s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  IndexedSourceMapConsumer.prototype.sourceContentFor =
    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  IndexedSourceMapConsumer.prototype.generatedPositionFor =
    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        // Only consider this section if the requested source is in the list of
        // sources of the consumer.
        if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line +
              (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column +
              (section.generatedOffset.generatedLine === generatedPosition.line
               ? section.generatedOffset.generatedColumn - 1
               : 0)
          };
          return ret;
        }
      }

      return {
        line: null,
        column: null
      };
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  IndexedSourceMapConsumer.prototype._parseMappings =
    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[i];

          var source = section.consumer._sources.at(mapping.source);
          if (section.consumer.sourceRoot !== null) {
            source = util.join(section.consumer.sourceRoot, source);
          }
          this._sources.add(source);
          source = this._sources.indexOf(source);

          var name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);

          // The mappings coming from the consumer for the section have
          // generated positions relative to the start of the section, so we
          // need to offset them to be relative to the start of the concatenated
          // generated file.
          var adjustedMapping = {
            source: source,
            generatedLine: mapping.generatedLine +
              (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.column +
              (section.generatedOffset.generatedLine === mapping.generatedLine)
              ? section.generatedOffset.generatedColumn - 1
              : 0,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: name
          };

          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === 'number') {
            this.__originalMappings.push(adjustedMapping);
          }
        };
      };

      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };

  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

});

},{"./array-set":155,"./base64-vlq":156,"./binary-search":158,"./quick-sort":160,"./util":164,"amdefine":116}],162:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64VLQ = require('./base64-vlq');
  var util = require('./util');
  var ArraySet = require('./array-set').ArraySet;
  var MappingList = require('./mapping-list').MappingList;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }

      if (source != null && !this._sources.has(source)) {
        this._sources.add(source);
      }

      if (name != null && !this._names.has(name)) {
        this._names.add(name);
      }

      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.'
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "sourceFile" relative if an absolute Url is passed.
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "sourceFile"
      this._mappings.unsortedForEach(function (mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            // Copy mapping
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source)
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile = util.join(aSourceMapPath, sourceFile);
          }
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            result += ',';
          }
        }

        result += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source != null) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                     - previousSource);
          previousSource = this._sources.indexOf(mapping.source);

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          result += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name != null) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                       - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                    key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };

  exports.SourceMapGenerator = SourceMapGenerator;

});

},{"./array-set":155,"./base64-vlq":156,"./mapping-list":159,"./util":164,"amdefine":116}],163:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
  var util = require('./util');

  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).
  var REGEX_NEWLINE = /(\r?\n)/;

  // Newline character code for charCodeAt() comparisons
  var NEWLINE_CODE = 10;

  // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!
  var isSourceNode = "$$$isSourceNode$$$";

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // All even indices of this array are one line of the generated code,
      // while all odd indices are the newlines between two adjacent lines
      // (since `REGEX_NEWLINE` captures its match).
      // Processed fragments are removed from this array, by calling `shiftNextLine`.
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var shiftNextLine = function() {
        var lineContents = remainingLines.shift();
        // The last line of a file might not have a newline.
        var newLine = remainingLines.shift() || "";
        return lineContents + newLine;
      };

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping !== null) {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            var code = "";
            // Associate first line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
            // The remaining code is added without mapping
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            // No more remaining code, continue
            lastMapping = mapping;
            return;
          }
        }
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[0];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      if (remainingLines.length > 0) {
        if (lastMapping) {
          // Associate the remaining code in the current line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        // and add the remaining lines without any mapping
        node.add(remainingLines.join(""));
      }

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          var source = aRelativePath
            ? util.join(aRelativePath, mapping.source)
            : mapping.source;
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;

});

},{"./source-map-generator":162,"./util":164,"amdefine":116}],164:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consequtive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = (path.charAt(0) === '/');

    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/'
      ? aPath
      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;

  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, '');

    // It is possible for the path to be above the root. In this case, simply
    // checking whether the root is a prefix of the path won't work. Instead, we
    // need to remove components from the root one by one, until either we find
    // a prefix that fits, or we run out of components to remove.
    var level = 0;
    while (aPath.indexOf(aRoot + '/') !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }

      // If the only part of the root that is left is the scheme (i.e. http://,
      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
      // have exhausted all components, so the path is not relative to the root.
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }

      ++level;
    }

    // Make sure we add a "../" for each component we removed from the root.
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports.relative = relative;

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    return '$' + aStr;
  }
  exports.toSetString = toSetString;

  function fromSetString(aStr) {
    return aStr.substr(1);
  }
  exports.fromSetString = fromSetString;

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = mappingA.source - mappingB.source;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    return mappingA.name - mappingB.name;
  };
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings with deflated source and name indices where
   * the generated positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }

    cmp = mappingA.source - mappingB.source;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return mappingA.name - mappingB.name;
  };
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }

    if (aStr1 > aStr2) {
      return 1;
    }

    return -1;
  }

  /**
   * Comparator between two mappings with inflated source and name strings where
   * the generated positions are compared.
   */
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  };
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

});

},{"amdefine":116}],165:[function(require,module,exports){
/*!!
 * Hasher <http://github.com/millermedeiros/hasher>
 * @author Miller Medeiros
 * @version 1.2.0 (2013/11/11 03:18 PM)
 * Released under the MIT License
 */

;(function () {
var factory = function(signals){

/*jshint white:false*/
/*global signals:false, window:false*/

/**
 * Hasher
 * @namespace History Manager for rich-media applications.
 * @name hasher
 */
var hasher = (function(window){

    //--------------------------------------------------------------------------------------
    // Private Vars
    //--------------------------------------------------------------------------------------

    var

        // frequency that it will check hash value on IE 6-7 since it doesn't
        // support the hashchange event
        POOL_INTERVAL = 25,

        // local storage for brevity and better compression --------------------------------

        document = window.document,
        history = window.history,
        Signal = signals.Signal,

        // local vars ----------------------------------------------------------------------

        hasher,
        _hash,
        _checkInterval,
        _isActive,
        _frame, //iframe used for legacy IE (6-7)
        _checkHistory,
        _hashValRegexp = /#(.*)$/,
        _baseUrlRegexp = /(\?.*)|(\#.*)/,
        _hashRegexp = /^\#/,

        // sniffing/feature detection -------------------------------------------------------

        //hack based on this: http://webreflection.blogspot.com/2009/01/32-bytes-to-know-if-your-browser-is-ie.html
        _isIE = (!+"\v1"),
        // hashchange is supported by FF3.6+, IE8+, Chrome 5+, Safari 5+ but
        // feature detection fails on IE compatibility mode, so we need to
        // check documentMode
        _isHashChangeSupported = ('onhashchange' in window) && document.documentMode !== 7,
        //check if is IE6-7 since hash change is only supported on IE8+ and
        //changing hash value on IE6-7 doesn't generate history record.
        _isLegacyIE = _isIE && !_isHashChangeSupported,
        _isLocal = (location.protocol === 'file:');


    //--------------------------------------------------------------------------------------
    // Private Methods
    //--------------------------------------------------------------------------------------

    function _escapeRegExp(str){
        return String(str || '').replace(/\W/g, "\\$&");
    }

    function _trimHash(hash){
        if (!hash) return '';
        var regexp = new RegExp('^' + _escapeRegExp(hasher.prependHash) + '|' + _escapeRegExp(hasher.appendHash) + '$', 'g');
        return hash.replace(regexp, '');
    }

    function _getWindowHash(){
        //parsed full URL instead of getting window.location.hash because Firefox decode hash value (and all the other browsers don't)
        //also because of IE8 bug with hash query in local file [issue #6]
        var result = _hashValRegexp.exec( hasher.getURL() );
        var path = (result && result[1]) || '';
        try {
          return hasher.raw? path : decodeURIComponent(path);
        } catch (e) {
          // in case user did not set `hasher.raw` and decodeURIComponent
          // throws an error (see #57)
          return path;
        }
    }

    function _getFrameHash(){
        return (_frame)? _frame.contentWindow.frameHash : null;
    }

    function _createFrame(){
        _frame = document.createElement('iframe');
        _frame.src = 'about:blank';
        _frame.style.display = 'none';
        document.body.appendChild(_frame);
    }

    function _updateFrame(){
        if(_frame && _hash !== _getFrameHash()){
            var frameDoc = _frame.contentWindow.document;
            frameDoc.open();
            //update iframe content to force new history record.
            //based on Really Simple History, SWFAddress and YUI.history.
            frameDoc.write('<html><head><title>' + document.title + '</title><script type="text/javascript">var frameHash="' + _hash + '";</script></head><body>&nbsp;</body></html>');
            frameDoc.close();
        }
    }

    function _registerChange(newHash, isReplace){
        if(_hash !== newHash){
            var oldHash = _hash;
            _hash = newHash; //should come before event dispatch to make sure user can get proper value inside event handler
            if(_isLegacyIE){
                if(!isReplace){
                    _updateFrame();
                } else {
                    _frame.contentWindow.frameHash = newHash;
                }
            }
            hasher.changed.dispatch(_trimHash(newHash), _trimHash(oldHash));
        }
    }

    if (_isLegacyIE) {
        /**
         * @private
         */
        _checkHistory = function(){
            var windowHash = _getWindowHash(),
                frameHash = _getFrameHash();
            if(frameHash !== _hash && frameHash !== windowHash){
                //detect changes made pressing browser history buttons.
                //Workaround since history.back() and history.forward() doesn't
                //update hash value on IE6/7 but updates content of the iframe.
                //needs to trim hash since value stored already have
                //prependHash + appendHash for fast check.
                hasher.setHash(_trimHash(frameHash));
            } else if (windowHash !== _hash){
                //detect if hash changed (manually or using setHash)
                _registerChange(windowHash);
            }
        };
    } else {
        /**
         * @private
         */
        _checkHistory = function(){
            var windowHash = _getWindowHash();
            if(windowHash !== _hash){
                _registerChange(windowHash);
            }
        };
    }

    function _addListener(elm, eType, fn){
        if(elm.addEventListener){
            elm.addEventListener(eType, fn, false);
        } else if (elm.attachEvent){
            elm.attachEvent('on' + eType, fn);
        }
    }

    function _removeListener(elm, eType, fn){
        if(elm.removeEventListener){
            elm.removeEventListener(eType, fn, false);
        } else if (elm.detachEvent){
            elm.detachEvent('on' + eType, fn);
        }
    }

    function _makePath(paths){
        paths = Array.prototype.slice.call(arguments);

        var path = paths.join(hasher.separator);
        path = path? hasher.prependHash + path.replace(_hashRegexp, '') + hasher.appendHash : path;
        return path;
    }

    function _encodePath(path){
        //used encodeURI instead of encodeURIComponent to preserve '?', '/',
        //'#'. Fixes Safari bug [issue #8]
        path = encodeURI(path);
        if(_isIE && _isLocal){
            //fix IE8 local file bug [issue #6]
            path = path.replace(/\?/, '%3F');
        }
        return path;
    }

    //--------------------------------------------------------------------------------------
    // Public (API)
    //--------------------------------------------------------------------------------------

    hasher = /** @lends hasher */ {

        /**
         * hasher Version Number
         * @type string
         * @constant
         */
        VERSION : '1.2.0',

        /**
         * Boolean deciding if hasher encodes/decodes the hash or not.
         * <ul>
         * <li>default value: false;</li>
         * </ul>
         * @type boolean
         */
        raw : false,

        /**
         * String that should always be added to the end of Hash value.
         * <ul>
         * <li>default value: '';</li>
         * <li>will be automatically removed from `hasher.getHash()`</li>
         * <li>avoid conflicts with elements that contain ID equal to hash value;</li>
         * </ul>
         * @type string
         */
        appendHash : '',

        /**
         * String that should always be added to the beginning of Hash value.
         * <ul>
         * <li>default value: '/';</li>
         * <li>will be automatically removed from `hasher.getHash()`</li>
         * <li>avoid conflicts with elements that contain ID equal to hash value;</li>
         * </ul>
         * @type string
         */
        prependHash : '/',

        /**
         * String used to split hash paths; used by `hasher.getHashAsArray()` to split paths.
         * <ul>
         * <li>default value: '/';</li>
         * </ul>
         * @type string
         */
        separator : '/',

        /**
         * Signal dispatched when hash value changes.
         * - pass current hash as 1st parameter to listeners and previous hash value as 2nd parameter.
         * @type signals.Signal
         */
        changed : new Signal(),

        /**
         * Signal dispatched when hasher is stopped.
         * -  pass current hash as first parameter to listeners
         * @type signals.Signal
         */
        stopped : new Signal(),

        /**
         * Signal dispatched when hasher is initialized.
         * - pass current hash as first parameter to listeners.
         * @type signals.Signal
         */
        initialized : new Signal(),

        /**
         * Start listening/dispatching changes in the hash/history.
         * <ul>
         *   <li>hasher won't dispatch CHANGE events by manually typing a new value or pressing the back/forward buttons before calling this method.</li>
         * </ul>
         */
        init : function(){
            if(_isActive) return;

            _hash = _getWindowHash();

            //thought about branching/overloading hasher.init() to avoid checking multiple times but
            //don't think worth doing it since it probably won't be called multiple times.
            if(_isHashChangeSupported){
                _addListener(window, 'hashchange', _checkHistory);
            }else {
                if(_isLegacyIE){
                    if(! _frame){
                        _createFrame();
                    }
                    _updateFrame();
                }
                _checkInterval = setInterval(_checkHistory, POOL_INTERVAL);
            }

            _isActive = true;
            hasher.initialized.dispatch(_trimHash(_hash));
        },

        /**
         * Stop listening/dispatching changes in the hash/history.
         * <ul>
         *   <li>hasher won't dispatch CHANGE events by manually typing a new value or pressing the back/forward buttons after calling this method, unless you call hasher.init() again.</li>
         *   <li>hasher will still dispatch changes made programatically by calling hasher.setHash();</li>
         * </ul>
         */
        stop : function(){
            if(! _isActive) return;

            if(_isHashChangeSupported){
                _removeListener(window, 'hashchange', _checkHistory);
            }else{
                clearInterval(_checkInterval);
                _checkInterval = null;
            }

            _isActive = false;
            hasher.stopped.dispatch(_trimHash(_hash));
        },

        /**
         * @return {boolean}    If hasher is listening to changes on the browser history and/or hash value.
         */
        isActive : function(){
            return _isActive;
        },

        /**
         * @return {string} Full URL.
         */
        getURL : function(){
            return window.location.href;
        },

        /**
         * @return {string} Retrieve URL without query string and hash.
         */
        getBaseURL : function(){
            return hasher.getURL().replace(_baseUrlRegexp, ''); //removes everything after '?' and/or '#'
        },

        /**
         * Set Hash value, generating a new history record.
         * @param {...string} path    Hash value without '#'. Hasher will join
         * path segments using `hasher.separator` and prepend/append hash value
         * with `hasher.appendHash` and `hasher.prependHash`
         * @example hasher.setHash('lorem', 'ipsum', 'dolor') -> '#/lorem/ipsum/dolor'
         */
        setHash : function(path){
            path = _makePath.apply(null, arguments);
            if(path !== _hash){
                // we should store raw value
                _registerChange(path);
                if (path === _hash) {
                    // we check if path is still === _hash to avoid error in
                    // case of multiple consecutive redirects [issue #39]
                    if (! hasher.raw) {
                        path = _encodePath(path);
                    }
                    window.location.hash = '#' + path;
                }
            }
        },

        /**
         * Set Hash value without keeping previous hash on the history record.
         * Similar to calling `window.location.replace("#/hash")` but will also work on IE6-7.
         * @param {...string} path    Hash value without '#'. Hasher will join
         * path segments using `hasher.separator` and prepend/append hash value
         * with `hasher.appendHash` and `hasher.prependHash`
         * @example hasher.replaceHash('lorem', 'ipsum', 'dolor') -> '#/lorem/ipsum/dolor'
         */
        replaceHash : function(path){
            path = _makePath.apply(null, arguments);
            if(path !== _hash){
                // we should store raw value
                _registerChange(path, true);
                if (path === _hash) {
                    // we check if path is still === _hash to avoid error in
                    // case of multiple consecutive redirects [issue #39]
                    if (! hasher.raw) {
                        path = _encodePath(path);
                    }
                    window.location.replace('#' + path);
                }
            }
        },

        /**
         * @return {string} Hash value without '#', `hasher.appendHash` and `hasher.prependHash`.
         */
        getHash : function(){
            //didn't used actual value of the `window.location.hash` to avoid breaking the application in case `window.location.hash` isn't available and also because value should always be synched.
            return _trimHash(_hash);
        },

        /**
         * @return {Array.<string>} Hash value split into an Array.
         */
        getHashAsArray : function(){
            return hasher.getHash().split(hasher.separator);
        },

        /**
         * Removes all event listeners, stops hasher and destroy hasher object.
         * - IMPORTANT: hasher won't work after calling this method, hasher Object will be deleted.
         */
        dispose : function(){
            hasher.stop();
            hasher.initialized.dispose();
            hasher.stopped.dispose();
            hasher.changed.dispose();
            _frame = hasher = window.hasher = null;
        },

        /**
         * @return {string} A string representation of the object.
         */
        toString : function(){
            return '[hasher version="'+ hasher.VERSION +'" hash="'+ hasher.getHash() +'"]';
        }

    };

    hasher.initialized.memorize = true; //see #33

    return hasher;

}(window));


    return hasher;
};

if (typeof define === 'function' && define.amd) {
    define(['signals'], factory);
} else if (typeof exports === 'object') {
    module.exports = factory(require('signals'));
} else {
    /*jshint sub:true */
    window['hasher'] = factory(window['signals']);
}

}());

},{"signals":191}],166:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":173}],167:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":166,"./_getRawTag":170,"./_objectToString":171}],168:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],169:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":172}],170:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":166}],171:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],172:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],173:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":168}],174:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],175:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":167,"./_getPrototype":169,"./isObjectLike":174}],176:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],177:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":178}],178:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],179:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

if ("production" !== 'production') {
  var invariant = require('fbjs/lib/invariant');
  var warning = require('fbjs/lib/warning');
  var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if ("production" !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;

},{"./lib/ReactPropTypesSecret":183,"fbjs/lib/invariant":122,"fbjs/lib/warning":123}],180:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var emptyFunction = require('fbjs/lib/emptyFunction');
var invariant = require('fbjs/lib/invariant');
var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

},{"./lib/ReactPropTypesSecret":183,"fbjs/lib/emptyFunction":121,"fbjs/lib/invariant":122}],181:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var emptyFunction = require('fbjs/lib/emptyFunction');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');
var assign = require('object-assign');

var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
var checkPropTypes = require('./checkPropTypes');

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if ("production" !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(
            false,
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
        } else if ("production" !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            warning(
              false,
              'You are manually calling a React.PropTypes validation ' +
              'function for the `%s` prop on `%s`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
              propFullName,
              componentName
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      "production" !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      "production" !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(
          false,
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received %s at index %s.',
          getPostfixForTypeWarning(checker),
          i
        );
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

},{"./checkPropTypes":179,"./lib/ReactPropTypesSecret":183,"fbjs/lib/emptyFunction":121,"fbjs/lib/invariant":122,"fbjs/lib/warning":123,"object-assign":176}],182:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if ("production" !== 'production') {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = require('./factoryWithThrowingShims')();
}

},{"./factoryWithThrowingShims":180,"./factoryWithTypeCheckers":181}],183:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

},{}],184:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports['default'] = applyMiddleware;

var _compose = require('./compose');

var _compose2 = _interopRequireDefault(_compose);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function (reducer, preloadedState, enhancer) {
      var store = createStore(reducer, preloadedState, enhancer);
      var _dispatch = store.dispatch;
      var chain = [];

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch(action) {
          return _dispatch(action);
        }
      };
      chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = _compose2['default'].apply(undefined, chain)(store.dispatch);

      return _extends({}, store, {
        dispatch: _dispatch
      });
    };
  };
}
},{"./compose":187}],185:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = bindActionCreators;
function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(undefined, arguments));
  };
}

/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass a single function as the first argument,
 * and get a function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
  }

  var keys = Object.keys(actionCreators);
  var boundActionCreators = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}
},{}],186:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = combineReducers;

var _createStore = require('./createStore');

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _warning = require('./utils/warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!(0, _isPlainObject2['default'])(inputState)) {
    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });

  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });

  if (unexpectedKeys.length > 0) {
    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });

    if (typeof initialState === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');
    }

    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
    if (typeof reducer(undefined, { type: type }) === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');
    }
  });
}

/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if ("production" !== 'production') {
      if (typeof reducers[key] === 'undefined') {
        (0, _warning2['default'])('No reducer provided for key "' + key + '"');
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);

  var unexpectedKeyCache = void 0;
  if ("production" !== 'production') {
    unexpectedKeyCache = {};
  }

  var shapeAssertionError = void 0;
  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var action = arguments[1];

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if ("production" !== 'production') {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        (0, _warning2['default'])(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};
    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(_key, action);
        throw new Error(errorMessage);
      }
      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    return hasChanged ? nextState : state;
  };
}
},{"./createStore":188,"./utils/warning":190,"lodash/isPlainObject":175}],187:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = compose;
/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(undefined, arguments));
    };
  });
}
},{}],188:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.ActionTypes = undefined;
exports['default'] = createStore;

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _symbolObservable = require('symbol-observable');

var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = exports.ActionTypes = {
  INIT: '@@redux/INIT'

  /**
   * Creates a Redux store that holds the state tree.
   * The only way to change the data in the store is to call `dispatch()` on it.
   *
   * There should only be a single store in your app. To specify how different
   * parts of the state tree respond to actions, you may combine several reducers
   * into a single reducer function by using `combineReducers`.
   *
   * @param {Function} reducer A function that returns the next state tree, given
   * the current state tree and the action to handle.
   *
   * @param {any} [preloadedState] The initial state. You may optionally specify it
   * to hydrate the state from the server in universal apps, or to restore a
   * previously serialized user session.
   * If you use `combineReducers` to produce the root reducer function, this must be
   * an object with the same shape as `combineReducers` keys.
   *
   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
   * to enhance the store with third-party capabilities such as middleware,
   * time travel, persistence, etc. The only store enhancer that ships with Redux
   * is `applyMiddleware()`.
   *
   * @returns {Store} A Redux store that lets you read the state, dispatch actions
   * and subscribe to changes.
   */
};function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    return currentState;
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.');
    }

    var isSubscribed = true;

    ensureCanMutateNextListeners();
    nextListeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing what changed. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!(0, _isPlainObject2['default'])(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.INIT });
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */
  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return { unsubscribe: unsubscribe };
      }
    }, _ref[_symbolObservable2['default']] = function () {
      return this;
    }, _ref;
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[_symbolObservable2['default']] = observable, _ref2;
}
},{"lodash/isPlainObject":175,"symbol-observable":196}],189:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;

var _createStore = require('./createStore');

var _createStore2 = _interopRequireDefault(_createStore);

var _combineReducers = require('./combineReducers');

var _combineReducers2 = _interopRequireDefault(_combineReducers);

var _bindActionCreators = require('./bindActionCreators');

var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);

var _applyMiddleware = require('./applyMiddleware');

var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);

var _compose = require('./compose');

var _compose2 = _interopRequireDefault(_compose);

var _warning = require('./utils/warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/*
* This is a dummy function to check if the function name has been altered by minification.
* If the function has been minified and NODE_ENV !== 'production', warn the user.
*/
function isCrushed() {}

if ("production" !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  (0, _warning2['default'])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
}

exports.createStore = _createStore2['default'];
exports.combineReducers = _combineReducers2['default'];
exports.bindActionCreators = _bindActionCreators2['default'];
exports.applyMiddleware = _applyMiddleware2['default'];
exports.compose = _compose2['default'];
},{"./applyMiddleware":184,"./bindActionCreators":185,"./combineReducers":186,"./compose":187,"./createStore":188,"./utils/warning":190}],190:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}
},{}],191:[function(require,module,exports){
/*jslint onevar:true, undef:true, newcap:true, regexp:true, bitwise:true, maxerr:50, indent:4, white:false, nomen:false, plusplus:false */
/*global define:false, require:false, exports:false, module:false, signals:false */

/** @license
 * JS Signals <http://millermedeiros.github.com/js-signals/>
 * Released under the MIT license
 * Author: Miller Medeiros
 * Version: 1.0.0 - Build: 268 (2012/11/29 05:48 PM)
 */

(function(global){

    // SignalBinding -------------------------------------------------
    //================================================================

    /**
     * Object that represents a binding between a Signal and a listener function.
     * <br />- <strong>This is an internal constructor and shouldn't be called by regular users.</strong>
     * <br />- inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.
     * @author Miller Medeiros
     * @constructor
     * @internal
     * @name SignalBinding
     * @param {Signal} signal Reference to Signal object that listener is currently bound to.
     * @param {Function} listener Handler function bound to the signal.
     * @param {boolean} isOnce If binding should be executed just once.
     * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
     * @param {Number} [priority] The priority level of the event listener. (default = 0).
     */
    function SignalBinding(signal, listener, isOnce, listenerContext, priority) {

        /**
         * Handler function bound to the signal.
         * @type Function
         * @private
         */
        this._listener = listener;

        /**
         * If binding should be executed just once.
         * @type boolean
         * @private
         */
        this._isOnce = isOnce;

        /**
         * Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @memberOf SignalBinding.prototype
         * @name context
         * @type Object|undefined|null
         */
        this.context = listenerContext;

        /**
         * Reference to Signal object that listener is currently bound to.
         * @type Signal
         * @private
         */
        this._signal = signal;

        /**
         * Listener priority
         * @type Number
         * @private
         */
        this._priority = priority || 0;
    }

    SignalBinding.prototype = {

        /**
         * If binding is active and should be executed.
         * @type boolean
         */
        active : true,

        /**
         * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute`. (curried parameters)
         * @type Array|null
         */
        params : null,

        /**
         * Call listener passing arbitrary parameters.
         * <p>If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.</p>
         * @param {Array} [paramsArr] Array of parameters that should be passed to the listener
         * @return {*} Value returned by the listener.
         */
        execute : function (paramsArr) {
            var handlerReturn, params;
            if (this.active && !!this._listener) {
                params = this.params? this.params.concat(paramsArr) : paramsArr;
                handlerReturn = this._listener.apply(this.context, params);
                if (this._isOnce) {
                    this.detach();
                }
            }
            return handlerReturn;
        },

        /**
         * Detach binding from signal.
         * - alias to: mySignal.remove(myBinding.getListener());
         * @return {Function|null} Handler function bound to the signal or `null` if binding was previously detached.
         */
        detach : function () {
            return this.isBound()? this._signal.remove(this._listener, this.context) : null;
        },

        /**
         * @return {Boolean} `true` if binding is still bound to the signal and have a listener.
         */
        isBound : function () {
            return (!!this._signal && !!this._listener);
        },

        /**
         * @return {boolean} If SignalBinding will only be executed once.
         */
        isOnce : function () {
            return this._isOnce;
        },

        /**
         * @return {Function} Handler function bound to the signal.
         */
        getListener : function () {
            return this._listener;
        },

        /**
         * @return {Signal} Signal that listener is currently bound to.
         */
        getSignal : function () {
            return this._signal;
        },

        /**
         * Delete instance properties
         * @private
         */
        _destroy : function () {
            delete this._signal;
            delete this._listener;
            delete this.context;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[SignalBinding isOnce:' + this._isOnce +', isBound:'+ this.isBound() +', active:' + this.active + ']';
        }

    };


/*global SignalBinding:false*/

    // Signal --------------------------------------------------------
    //================================================================

    function validateListener(listener, fnName) {
        if (typeof listener !== 'function') {
            throw new Error( 'listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName) );
        }
    }

    /**
     * Custom event broadcaster
     * <br />- inspired by Robert Penner's AS3 Signals.
     * @name Signal
     * @author Miller Medeiros
     * @constructor
     */
    function Signal() {
        /**
         * @type Array.<SignalBinding>
         * @private
         */
        this._bindings = [];
        this._prevParams = null;

        // enforce dispatch to aways work on same context (#47)
        var self = this;
        this.dispatch = function(){
            Signal.prototype.dispatch.apply(self, arguments);
        };
    }

    Signal.prototype = {

        /**
         * Signals Version Number
         * @type String
         * @const
         */
        VERSION : '1.0.0',

        /**
         * If Signal should keep record of previously dispatched parameters and
         * automatically execute listener during `add()`/`addOnce()` if Signal was
         * already dispatched before.
         * @type boolean
         */
        memorize : false,

        /**
         * @type boolean
         * @private
         */
        _shouldPropagate : true,

        /**
         * If Signal is active and should broadcast events.
         * <p><strong>IMPORTANT:</strong> Setting this property during a dispatch will only affect the next dispatch, if you want to stop the propagation of a signal use `halt()` instead.</p>
         * @type boolean
         */
        active : true,

        /**
         * @param {Function} listener
         * @param {boolean} isOnce
         * @param {Object} [listenerContext]
         * @param {Number} [priority]
         * @return {SignalBinding}
         * @private
         */
        _registerListener : function (listener, isOnce, listenerContext, priority) {

            var prevIndex = this._indexOfListener(listener, listenerContext),
                binding;

            if (prevIndex !== -1) {
                binding = this._bindings[prevIndex];
                if (binding.isOnce() !== isOnce) {
                    throw new Error('You cannot add'+ (isOnce? '' : 'Once') +'() then add'+ (!isOnce? '' : 'Once') +'() the same listener without removing the relationship first.');
                }
            } else {
                binding = new SignalBinding(this, listener, isOnce, listenerContext, priority);
                this._addBinding(binding);
            }

            if(this.memorize && this._prevParams){
                binding.execute(this._prevParams);
            }

            return binding;
        },

        /**
         * @param {SignalBinding} binding
         * @private
         */
        _addBinding : function (binding) {
            //simplified insertion sort
            var n = this._bindings.length;
            do { --n; } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
            this._bindings.splice(n + 1, 0, binding);
        },

        /**
         * @param {Function} listener
         * @return {number}
         * @private
         */
        _indexOfListener : function (listener, context) {
            var n = this._bindings.length,
                cur;
            while (n--) {
                cur = this._bindings[n];
                if (cur._listener === listener && cur.context === context) {
                    return n;
                }
            }
            return -1;
        },

        /**
         * Check if listener was attached to Signal.
         * @param {Function} listener
         * @param {Object} [context]
         * @return {boolean} if Signal has the specified listener.
         */
        has : function (listener, context) {
            return this._indexOfListener(listener, context) !== -1;
        },

        /**
         * Add a listener to the signal.
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        add : function (listener, listenerContext, priority) {
            validateListener(listener, 'add');
            return this._registerListener(listener, false, listenerContext, priority);
        },

        /**
         * Add listener to the signal that should be removed after first execution (will be executed only once).
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        addOnce : function (listener, listenerContext, priority) {
            validateListener(listener, 'addOnce');
            return this._registerListener(listener, true, listenerContext, priority);
        },

        /**
         * Remove a single listener from the dispatch queue.
         * @param {Function} listener Handler function that should be removed.
         * @param {Object} [context] Execution context (since you can add the same handler multiple times if executing in a different context).
         * @return {Function} Listener handler function.
         */
        remove : function (listener, context) {
            validateListener(listener, 'remove');

            var i = this._indexOfListener(listener, context);
            if (i !== -1) {
                this._bindings[i]._destroy(); //no reason to a SignalBinding exist if it isn't attached to a signal
                this._bindings.splice(i, 1);
            }
            return listener;
        },

        /**
         * Remove all listeners from the Signal.
         */
        removeAll : function () {
            var n = this._bindings.length;
            while (n--) {
                this._bindings[n]._destroy();
            }
            this._bindings.length = 0;
        },

        /**
         * @return {number} Number of listeners attached to the Signal.
         */
        getNumListeners : function () {
            return this._bindings.length;
        },

        /**
         * Stop propagation of the event, blocking the dispatch to next listeners on the queue.
         * <p><strong>IMPORTANT:</strong> should be called only during signal dispatch, calling it before/after dispatch won't affect signal broadcast.</p>
         * @see Signal.prototype.disable
         */
        halt : function () {
            this._shouldPropagate = false;
        },

        /**
         * Dispatch/Broadcast Signal to all listeners added to the queue.
         * @param {...*} [params] Parameters that should be passed to each handler.
         */
        dispatch : function (params) {
            if (! this.active) {
                return;
            }

            var paramsArr = Array.prototype.slice.call(arguments),
                n = this._bindings.length,
                bindings;

            if (this.memorize) {
                this._prevParams = paramsArr;
            }

            if (! n) {
                //should come after memorize
                return;
            }

            bindings = this._bindings.slice(); //clone array in case add/remove items during dispatch
            this._shouldPropagate = true; //in case `halt` was called before dispatch or during the previous dispatch.

            //execute all callbacks until end of the list or until a callback returns `false` or stops propagation
            //reverse loop since listeners with higher priority will be added at the end of the list
            do { n--; } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
        },

        /**
         * Forget memorized arguments.
         * @see Signal.memorize
         */
        forget : function(){
            this._prevParams = null;
        },

        /**
         * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).
         * <p><strong>IMPORTANT:</strong> calling any method on the signal instance after calling dispose will throw errors.</p>
         */
        dispose : function () {
            this.removeAll();
            delete this._bindings;
            delete this._prevParams;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[Signal active:'+ this.active +' numListeners:'+ this.getNumListeners() +']';
        }

    };


    // Namespace -----------------------------------------------------
    //================================================================

    /**
     * Signals namespace
     * @namespace
     * @name signals
     */
    var signals = Signal;

    /**
     * Custom event broadcaster
     * @see Signal
     */
    // alias for backwards compatibility (see #gh-44)
    signals.Signal = Signal;



    //exports to multiple environments
    if(typeof define === 'function' && define.amd){ //AMD
        define(function () { return signals; });
    } else if (typeof module !== 'undefined' && module.exports){ //node
        module.exports = signals;
    } else { //browser
        //use string because of Google closure compiler ADVANCED_MODE
        /*jslint sub:true */
        global['signals'] = signals;
    }

}(this));

},{}],192:[function(require,module,exports){
/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

var Emitter = require('emitter');
var requestBase = require('./request-base');
var isObject = require('./is-object');

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

var request = module.exports = require('./request').bind(null, Request);

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only verison of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(function(v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for(var subkey in val) {
        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

 request.serializeObject = serialize;

 /**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'application/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

 request.serialize = {
   'application/x-www-form-urlencoded': serialize,
   'application/json': JSON.stringify
 };

 /**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  lines.pop(); // trailing CRLF

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  return /[\/+]json\b/.test(mime);
}

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function type(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function params(str){
  return str.split(/ *; */).reduce(function(obj, str){
    var parts = str.split(/ *= */),
        key = parts.shift(),
        val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req, options) {
  options = options || {};
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  this._setStatusProperties(this.xhr.status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);
  this.body = this.req.method != 'HEAD'
    ? this._parseBody(this.text ? this.text : this.xhr.response)
    : null;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

Response.prototype.get = function(field){
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

Response.prototype._setHeaderProperties = function(header){
  // content-type
  var ct = this.header['content-type'] || '';
  this.type = type(ct);

  // params
  var obj = params(ct);
  for (var key in obj) this[key] = obj[key];
};

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str){
  var parse = request.parse[this.type];
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

Response.prototype._setStatusProperties = function(status){
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }

  var type = status / 100 | 0;

  // status / class
  this.status = this.statusCode = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = (4 == type || 5 == type)
    ? this.toError()
    : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.notFound = 404 == status;
  this.forbidden = 403 == status;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;
      // issue #876: return the http status code if the response parsing fails
      err.statusCode = self.xhr && self.xhr.status ? self.xhr.status : null;
      return self.callback(err);
    }

    self.emit('response', res);

    var new_err;
    try {
      if (res.status < 200 || res.status >= 300) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
        new_err.original = err;
        new_err.response = res;
        new_err.status = res.status;
      }
    } catch(e) {
      new_err = e; // #985 touching res may cause INVALID_STATE_ERR on old Android
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `requestBase`.
 */

Emitter(Request.prototype);
for (var key in requestBase) {
  Request.prototype[key] = requestBase[key];
}

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set responseType to `val`. Presently valid responseTypes are 'blob' and
 * 'arraybuffer'.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} pass
 * @param {Object} options with 'type' property 'auto' or 'basic' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (!options) {
    options = {
      type: 'basic'
    }
  }

  switch (options.type) {
    case 'basic':
      var str = btoa(user + ':' + pass);
      this.set('Authorization', 'Basic ' + str);
    break;

    case 'auto':
      this.username = user;
      this.password = pass;
    break;
  }
  return this;
};

/**
* Add query-string `val`.
*
* Examples:
*
*   request.get('/shoes')
*     .query('size=10')
*     .query({ color: 'blue' })
*
* @param {Object|String} val
* @return {Request} for chaining
* @api public
*/

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `filename`.
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String} filename
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, filename){
  this._getFormData().append(field, file, filename || file.name);
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  var fn = this._callback;
  this.clearTimeout();
  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

Request.prototype._timeoutError = function(){
  var timeout = this._timeout;
  var err = new Error('timeout of ' + timeout + 'ms exceeded');
  err.timeout = timeout;
  this.callback(err);
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */

Request.prototype._appendQueryString = function(){
  var query = this._query.join('&');
  if (query) {
    this.url += ~this.url.indexOf('?')
      ? '&' + query
      : '?' + query;
  }
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  var self = this;
  var xhr = this.xhr = request.getXHR();
  var timeout = this._timeout;
  var data = this._formData || this._data;

  // store callback
  this._callback = fn || noop;

  // state change
  xhr.onreadystatechange = function(){
    if (4 != xhr.readyState) return;

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (0 == status) {
      if (self.timedout) return self._timeoutError();
      if (self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = direction;
    self.emit('progress', e);
  }
  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');
      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch(e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  // timeout
  if (timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self.timedout = true;
      self.abort();
    }, timeout);
  }

  // querystring
  this._appendQueryString();

  // initiate request
  if (this.username && this.password) {
    xhr.open(this.method, this.url, true, this.username, this.password);
  } else {
    xhr.open(this.method, this.url, true);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;
    xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};


/**
 * Expose `Request`.
 */

request.Request = Request;

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn){
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn){
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = function(url, data, fn){
  var req = request('OPTIONS', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, fn){
  var req = request('DELETE', url);
  if (fn) req.end(fn);
  return req;
};

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn){
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn){
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn){
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./is-object":193,"./request":195,"./request-base":194,"emitter":119}],193:[function(require,module,exports){
/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;

},{}],194:[function(require,module,exports){
/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = require('./is-object');

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

exports.clearTimeout = function _clearTimeout(){
  this._timeout = 0;
  clearTimeout(this._timer);
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

exports.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

exports.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeout to `ms`.
 *
 * @param {Number} ms
 * @return {Request} for chaining
 * @api public
 */

exports.timeout = function timeout(ms){
  this._timeout = ms;
  return this;
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} reject
 * @return {Request}
 */

exports.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;
    this._fullfilledPromise = new Promise(function(innerResolve, innerReject){
      self.end(function(err, res){
        if (err) innerReject(err); else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
}

exports.catch = function(cb) {
  return this.then(undefined, cb);
};

/**
 * Allow for extension
 */

exports.use = function use(fn) {
  fn(this);
  return this;
}


/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

exports.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

exports.getHeader = exports.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

exports.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
exports.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
exports.field = function(name, val) {

  // name should be either a string or an object.
  if (null === name ||  undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (isObject(name)) {
    for (var key in name) {
      this.field(key, name[key]);
    }
    return this;
  }

  // val should be defined now
  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
exports.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

exports.withCredentials = function(){
  // This is browser-only functionality. Node side is no-op.
  this._withCredentials = true;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

exports.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

exports.toJSON = function(){
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * TODO: future proof, move to compoent land
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

exports._isHost = function _isHost(obj) {
  var str = {}.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
}

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

exports.send = function(data){
  var obj = isObject(data);
  var type = this._header['content-type'];

  // merge
  if (obj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!obj || this._isHost(data)) return this;

  // default to json
  if (!type) this.type('json');
  return this;
};

},{"./is-object":193}],195:[function(require,module,exports){
// The node and browser modules expose versions of this with the
// appropriate constructor function bound as first argument
/**
 * Issue a request:
 *
 * Examples:
 *
 *    request('GET', '/users').end(callback)
 *    request('/users').end(callback)
 *    request('/users', callback)
 *
 * @param {String} method
 * @param {String|Function} url or callback
 * @return {Request}
 * @api public
 */

function request(RequestConstructor, method, url) {
  // callback
  if ('function' == typeof url) {
    return new RequestConstructor('GET', method).end(url);
  }

  // url first
  if (2 == arguments.length) {
    return new RequestConstructor('GET', method);
  }

  return new RequestConstructor(method, url);
}

module.exports = request;

},{}],196:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = require('./ponyfill.js');

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root; /* global window */


if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (typeof module !== 'undefined') {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./ponyfill.js":197}],197:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};
},{}],198:[function(require,module,exports){
(function (global){
//     Underscore.js 1.9.0
//     http://underscorejs.org
//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` (`self`) in the browser, `global`
  // on the server, or `this` in some virtual machines. We use `self`
  // instead of `window` for `WebWorker` support.
  var root = typeof self == 'object' && self.self === self && self ||
            typeof global == 'object' && global.global === global && global ||
            this ||
            {};

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push,
      slice = ArrayProto.slice,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var nativeIsArray = Array.isArray,
      nativeKeys = Object.keys,
      nativeCreate = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for their old module API. If we're in
  // the browser, add `_` as a global object.
  // (`nodeType` is checked to ensure that `module`
  // and `exports` are not HTML elements.)
  if (typeof exports != 'undefined' && !exports.nodeType) {
    if (typeof module != 'undefined' && !module.nodeType && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.9.0';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      // The 2-argument case is omitted because were not using it.
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  var builtinIteratee;

  // An internal function to generate callbacks that can be applied to each
  // element in a collection, returning the desired result  either `identity`,
  // an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
    return _.property(value);
  };

  // External wrapper for our callback generator. Users may customize
  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
  // This abstraction hides the internal-only argCount argument.
  _.iteratee = builtinIteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // Some functions take a variable number of arguments, or a few expected
  // arguments at the beginning and then a variable number of values to operate
  // on. This helper accumulates all remaining arguments past the functions
  // argument length (or an explicit `startIndex`), into an array that becomes
  // the last argument. Similar to ES6s "rest parameter".
  var restArguments = function(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function() {
      var length = Math.max(arguments.length - startIndex, 0),
          rest = Array(length),
          index = 0;
      for (; index < length; index++) {
        rest[index] = arguments[index + startIndex];
      }
      switch (startIndex) {
        case 0: return func.call(this, rest);
        case 1: return func.call(this, arguments[0], rest);
        case 2: return func.call(this, arguments[0], arguments[1], rest);
      }
      var args = Array(startIndex + 1);
      for (index = 0; index < startIndex; index++) {
        args[index] = arguments[index];
      }
      args[startIndex] = rest;
      return func.apply(this, args);
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var shallowProperty = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  var deepGet = function(obj, path) {
    var length = path.length;
    for (var i = 0; i < length; i++) {
      if (obj == null) return void 0;
      obj = obj[path[i]];
    }
    return length ? obj : void 0;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object.
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = shallowProperty('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  var createReduce = function(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function(obj, iteratee, memo, initial) {
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      if (!initial) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    return function(obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = restArguments(function(obj, path, args) {
    var contextPath, func;
    if (_.isFunction(path)) {
      func = path;
    } else if (_.isArray(path)) {
      contextPath = path.slice(0, -1);
      path = path[path.length - 1];
    }
    return _.map(obj, function(context) {
      var method = func;
      if (!method) {
        if (contextPath && contextPath.length) {
          context = deepGet(context, contextPath);
        }
        if (context == null) return void 0;
        method = context[path];
      }
      return method == null ? method : method.apply(context, args);
    });
  });

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection.
  _.shuffle = function(obj) {
    return _.sample(obj, Infinity);
  };

  // Sample **n** random values from a collection using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
    var length = getLength(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for (var index = 0; index < n; index++) {
      var rand = _.random(index, last);
      var temp = sample[index];
      sample[index] = sample[rand];
      sample[rand] = temp;
    }
    return sample.slice(0, n);
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    var index = 0;
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, key, list) {
      return {
        value: value,
        index: index++,
        criteria: iteratee(value, key, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior, partition) {
    return function(obj, iteratee, context) {
      var result = partition ? [[], []] : {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (_.isString(obj)) {
      // Keep surrogate pair characters together
      return obj.match(reStrSymbol);
    }
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = group(function(result, value, pass) {
    result[pass ? 0 : 1].push(value);
  }, true);

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null || array.length < 1) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null || array.length < 1) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, Boolean);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, output) {
    output = output || [];
    var idx = output.length;
    for (var i = 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        // Flatten current level of array or arguments object.
        if (shallow) {
          var j = 0, len = value.length;
          while (j < len) output[idx++] = value[j++];
        } else {
          flatten(value, shallow, strict, output);
          idx = output.length;
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = restArguments(function(array, otherArrays) {
    return _.difference(array, otherArrays);
  });

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // The faster algorithm will not work with an iteratee if the iteratee
  // is not a one-to-one function, so providing an iteratee will disable
  // the faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted && !iteratee) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = restArguments(function(arrays) {
    return _.uniq(flatten(arrays, true, true));
  });

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      var j;
      for (j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = restArguments(function(array, rest) {
    rest = flatten(rest, true, true);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  });

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices.
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = restArguments(_.unzip);

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values. Passing by pairs is the reverse of _.pairs.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions.
  var createPredicateIndexFinder = function(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  };

  // Returns the first index on an array-like that passes a predicate test.
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions.
  var createIndexFinder = function(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    if (!step) {
      step = stop < start ? -1 : 1;
    }

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Chunk a single array into multiple arrays, each containing `count` or fewer
  // items.
  _.chunk = function(array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0, length = array.length;
    while (i < length) {
      result.push(slice.call(array, i, i += count));
    }
    return result;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments.
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = restArguments(function(func, context, args) {
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var bound = restArguments(function(callArgs) {
      return executeBound(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
  });

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder by default, allowing any combination of arguments to be
  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
  _.partial = restArguments(function(func, boundArgs) {
    var placeholder = _.partial.placeholder;
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  });

  _.partial.placeholder = _;

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = restArguments(function(obj, keys) {
    keys = flatten(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');
    while (index--) {
      var key = keys[index];
      obj[key] = _.bind(obj[key], obj);
    }
  });

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = restArguments(function(func, wait, args) {
    return setTimeout(function() {
      return func.apply(null, args);
    }, wait);
  });

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    var throttled = function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };

    throttled.cancel = function() {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;

    var later = function(context, args) {
      timeout = null;
      if (args) result = func.apply(context, args);
    };

    var debounced = restArguments(function(args) {
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        var callNow = !timeout;
        timeout = setTimeout(later, wait);
        if (callNow) result = func.apply(this, args);
      } else {
        timeout = _.delay(later, wait, this, args);
      }

      return result;
    });

    debounced.cancel = function() {
      clearTimeout(timeout);
      timeout = null;
    };

    return debounced;
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  _.restArguments = restArguments;

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  var collectNonEnumProps = function(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  };

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`.
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object.
  // In contrast to _.map it returns an object.
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = _.keys(obj),
        length = keys.length,
        results = {};
    for (var index = 0; index < length; index++) {
      var currentKey = keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  // The opposite of _.object.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`.
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, defaults) {
    return function(obj) {
      var length = arguments.length;
      if (defaults) obj = Object(obj);
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!defaults || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s).
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test.
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Internal pick helper function to determine if `obj` has key `key`.
  var keyInObj = function(value, key, obj) {
    return key in obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = restArguments(function(obj, keys) {
    var result = {}, iteratee = keys[0];
    if (obj == null) return result;
    if (_.isFunction(iteratee)) {
      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
      keys = _.allKeys(obj);
    } else {
      iteratee = keyInObj;
      keys = flatten(keys, false, false);
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  });

  // Return a copy of the object without the blacklisted properties.
  _.omit = restArguments(function(obj, keys) {
    var iteratee = keys[0], context;
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
      if (keys.length > 1) context = keys[1];
    } else {
      keys = _.map(flatten(keys, false, false), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  });

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq, deepEq;
  eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
    return deepEq(a, b, aStack, bStack);
  };

  // Internal recursive comparison function for `isEqual`.
  deepEq = function(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN.
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
      case '[object Symbol]':
        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
  var nodelist = root.document && root.document.childNodes;
  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    return _.isNumber(obj) && isNaN(obj);
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, path) {
    if (!_.isArray(path)) {
      return obj != null && hasOwnProperty.call(obj, path);
    }
    var length = path.length;
    for (var i = 0; i < length; i++) {
      var key = path[i];
      if (obj == null || !hasOwnProperty.call(obj, key)) {
        return false;
      }
      obj = obj[key];
    }
    return !!length;
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  // Creates a function that, when passed an object, will traverse that objects
  // properties down the given `path`, specified as an array of keys or indexes.
  _.property = function(path) {
    if (!_.isArray(path)) {
      return shallowProperty(path);
    }
    return function(obj) {
      return deepGet(obj, path);
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    if (obj == null) {
      return function(){};
    }
    return function(path) {
      return !_.isArray(path) ? obj[path] : deepGet(obj, path);
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

  // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // Traverses the children of `obj` along `path`. If a child is a function, it
  // is invoked with its parent as context. Returns the value of the final
  // child, or `fallback` if any child is undefined.
  _.result = function(obj, path, fallback) {
    if (!_.isArray(path)) path = [path];
    var length = path.length;
    if (!length) {
      return _.isFunction(fallback) ? fallback.call(obj) : fallback;
    }
    for (var i = 0; i < length; i++) {
      var prop = obj == null ? void 0 : obj[path[i]];
      if (prop === void 0) {
        prop = fallback;
        i = length; // Ensure we don't continue iterating.
      }
      obj = _.isFunction(prop) ? prop.call(obj) : prop;
    }
    return obj;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offset.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    var render;
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var chainResult = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return chainResult(this, func.apply(_, args));
      };
    });
    return _;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return chainResult(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return chainResult(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return String(this._wrapped);
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define == 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[87])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL2NvbXBvbmVudHMvbGlua2VkLXZhbHVlLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9maWVsZC1pbnB1dC5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL2ZpZWxkLWxpc3QuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9maWVsZC1yb3cuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9iYWNrZW5kLWNhbGxiYWNrLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9jaGVja2JveC1ib29sZWFuLmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLWNydWQtZm9ybXMvaW5wdXQvY29sb3IuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9kYXRlLmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLWNydWQtZm9ybXMvaW5wdXQvZGF0ZXRpbWUuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9kcm9wZG93bi1zZWFyY2hhYmxlLmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLWNydWQtZm9ybXMvaW5wdXQvZHJvcGRvd24uanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9lbWFpbC5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL2lucHV0L2VudW0tc2VhcmNoYWJsZS5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL2lucHV0L2VudW0uanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9oaWRkZW4uanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9tdWx0aXNlbGVjdC1zZWFyY2hhYmxlLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9tdWx0aXNlbGVjdC5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLWNydWQtZm9ybXMvaW5wdXQvbnVtZXJpYy5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL2lucHV0L3Bhc3N3b3JkLmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLWNydWQtZm9ybXMvaW5wdXQvcmVhZC1vbmx5LmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLWNydWQtZm9ybXMvaW5wdXQvcmVsYXRpb24tbi1uLmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLWNydWQtZm9ybXMvaW5wdXQvcmVsYXRpb25hbC1uYXRpdmUuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9yZWxhdGlvbmFsLXNlYXJjaGFibGUuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9yaWNoLXRleHRlZGl0b3ItcmVhZC1vbmx5LmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLWNydWQtZm9ybXMvaW5wdXQvcmljaC10ZXh0ZWRpdG9yLXdpdGgtcGx1Z2luLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9yaWNoLXRleHRlZGl0b3IuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9zZWFyY2hhYmxlLXJlbGF0aW9uLW4tbi5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL2lucHV0L3RleHQuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC90ZXh0YXJlYS5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL2lucHV0L3RoaXJkLXBhcnR5L3JlYWN0LWRyb3B6b25lLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC91cGxvYWQuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC91cmwuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9tb2RhbC90aXRsZS5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1kYXRhZ3JpZC1zZXR0aW5ncy9nY2UtZGF0YWdyaWQtc2V0dGluZ3Mvc2V0dGluZ3MuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtZGF0YWdyaWQtc2V0dGluZ3MvZ2NlLWRhdGFncmlkLXNldHRpbmdzL3Zpc2libGUtY29sdW1ucy5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC1maWx0ZXJpbmcvYmFzaWMtb3BlcmF0b3IuanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC1maWx0ZXJpbmcvZmllbGQtaW5wdXQvZGF0ZS5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkLWZpbHRlcmluZy9maWVsZC1pbnB1dC9zZWxlY3QtZHJvcGRvd24uanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC1maWx0ZXJpbmcvZmllbGQtaW5wdXQvc2VsZWN0LXJlbGF0aW9uYWwuanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC1maWx0ZXJpbmcvZmllbGQtaW5wdXQvc2VsZWN0LmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQtZmlsdGVyaW5nL2ZpZWxkLXR5cGVzL2NoZWNrYm94X2Jvb2xlYW4uanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC1maWx0ZXJpbmcvZmllbGQtdHlwZXMvZGF0ZS5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkLWZpbHRlcmluZy9maWVsZC10eXBlcy9kcm9wZG93bi5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkLWZpbHRlcmluZy9maWVsZC10eXBlcy9lbnVtLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQtZmlsdGVyaW5nL2ZpZWxkLXR5cGVzL251bWVyaWMuanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC1maWx0ZXJpbmcvZmllbGQtdHlwZXMvcmVsYXRpb25hbC1uLW4uanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC1maWx0ZXJpbmcvZmllbGQtdHlwZXMvcmVsYXRpb25hbC5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkLWZpbHRlcmluZy9maWVsZC10eXBlcy90ZXh0LmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQtZmlsdGVyaW5nL2ZpbHRlci1zZWxlY3QuanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC1maWx0ZXJpbmcvZmlsdGVyaW5nLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQtZmlsdGVyaW5nL211bHRpcGxlLXNlYXJjaC5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkLWZpbHRlcmluZy9zZWxlY3Qtb3B0aW9ucy9jb21wYXJpc29uLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQtZmlsdGVyaW5nL3NlbGVjdC1vcHRpb25zL2VxdWFsX25vdF9lcXVhbC5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkLWZpbHRlcmluZy9zZWxlY3Qtb3B0aW9ucy9oYXNfb3Jfbm90LmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQtZmlsdGVyaW5nL3NlbGVjdC1vcHRpb25zL3RleHQuanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC1maWx0ZXJpbmcvc2VsZWN0LW9wdGlvbnMvdHJhbnNsYXRpb25zL2kxOG4tY29tcGFyaXNvbi5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkLWZpbHRlcmluZy9zZWxlY3Qtb3B0aW9ucy90cmFuc2xhdGlvbnMvaTE4bi1lcXVhbC1ub3QtZXF1YWwuanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC1maWx0ZXJpbmcvc2VsZWN0LW9wdGlvbnMvdHJhbnNsYXRpb25zL2kxOG4taGFzLW9yLW5vdC5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkLWZpbHRlcmluZy9zZWxlY3Qtb3B0aW9ucy90cmFuc2xhdGlvbnMvaTE4bi10ZXh0LmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvYnV0dG9ucy9kZWZhdWx0LWdyb3VwLWJ1dHRvbi5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC9idXR0b25zL2RlZmF1bHQtbGluay1idXR0b24uanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvZGF0YWdyaWQtYWN0aW9ucy1jb2x1bW4uanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvZGF0YWdyaWQtY2hlY2tib3guanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvZGF0YWdyaWQtcm93LmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkL2RhdGFncmlkLXRib2R5LmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkL3dyYXBwZXJzL2Jvb3RzdHJhcC12My9maWVsZC1yb3ctd3JhcHBlci5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkL3dyYXBwZXJzL2Jvb3RzdHJhcC12My9ncm91cC1idXR0b25zLWxpc3QuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvd3JhcHBlcnMvYm9vdHN0cmFwLXYzL2dyb3VwLWJ1dHRvbnMuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvd3JhcHBlcnMvYm9vdHN0cmFwLXYzL2dyb3VwLXByaW1hcnktYnV0dG9uLmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkL3dyYXBwZXJzL2Jvb3RzdHJhcC12My9saW5rLWJ1dHRvbi13cmFwcGVyLmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkL3dyYXBwZXJzL2Jvb3RzdHJhcC12My9tb2RhbC10aXRsZS13cmFwcGVyLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvd3JhcHBlcnMvYm9vdHN0cmFwLXY0L2ZpZWxkLXJvdy13cmFwcGVyLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvd3JhcHBlcnMvYm9vdHN0cmFwLXY0L2dyb3VwLWJ1dHRvbnMtbGlzdC5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC93cmFwcGVycy9ib290c3RyYXAtdjQvZ3JvdXAtcHJpbWFyeS1idXR0b24uanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvd3JhcHBlcnMvYm9vdHN0cmFwLXY0L2xpbmstYnV0dG9uLXdyYXBwZXIuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvd3JhcHBlcnMvYm9vdHN0cmFwLXY0L21vZGFsLXRpdGxlLXdyYXBwZXIuanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL2RhdGFncmlkL2dyb2NlcnktY3J1ZC5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvZGF0YWdyaWQvanF1ZXJ5LmdjcnVkLmRhdGFncmlkLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9oZWxwZXJzL2FqYXgtaGVscGVyLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9oZWxwZXJzL2xvY2FsLXN0b3JhZ2UtaGVscGVyLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9qcXVlcnktcGx1Z2lucy9jaG9zZW4uanF1ZXJ5LmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9qcXVlcnktcGx1Z2lucy9tb2RhbC5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvanF1ZXJ5LXBsdWdpbnMvcHJpbnRUaGlzLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9qcXVlcnktcGx1Z2lucy90cmFuc2l0aW9uLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9saWJyYXJpZXMvSGFuZGxlYmFyc0V4dGVuZGVkLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9saWJyYXJpZXMvanF1ZXJ5LXVpLXRpbWVwaWNrZXIuanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL21haW4vbWFpbi5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvbW9kdWxlcy9qcXVlcnkvanF1ZXJ5LXBsdWdpbnMuanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL21vZHVsZXMvcmVhY3QvanN4L2RhdGFncmlkL2Zvb3Rlci9wZXItcGFnZS1kcm9wZG93bi5qc3giLCJSZXNvdXJjZXMvcHVibGljL2pzL3NlY3Rpb25zL2NvbnN0YW50cy5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvZGF0YWdyaWQvY29sdW1uLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy9kYXRhZ3JpZC9kYXRhZ3JpZC5jb2x1bW5zLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy9kYXRhZ3JpZC9kYXRhZ3JpZC5ncmlkLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy9kYXRhZ3JpZC9kYXRhZ3JpZC5oZWFkZXItYWN0aW9ucy5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvZGF0YWdyaWQvZGF0YWdyaWQucGFnaW5nLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy9kYXRhZ3JpZC9kYXRhZ3JpZC5zZWFyY2guanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL3NlY3Rpb25zL2kxOG4uanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL3NlY3Rpb25zL29wZXJhdGlvbnMvYWRkLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy9vcGVyYXRpb25zL2Nsb25lLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy9vcGVyYXRpb25zL2NvbW1vbi5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvb3BlcmF0aW9ucy9kZWxldGUuanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL3NlY3Rpb25zL29wZXJhdGlvbnMvZWRpdC5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvb3BlcmF0aW9ucy9yZWFkLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy9vcGVyYXRpb25zL3JlZHVjZXIuanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL3NlY3Rpb25zL3JvdXRlcy9yb3V0ZXIuanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL3NlY3Rpb25zL3R5cGVzL2NhbGxiYWNrLWNvbHVtbi5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvdHlwZXMvY2hlY2tib3gtYm9vbGVhbi5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvdHlwZXMvZGF0ZS1hbmQtdGltZS5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvdHlwZXMvZHJvcGRvd24uanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL3NlY3Rpb25zL3R5cGVzL2VudW0uanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL3NlY3Rpb25zL3R5cGVzL211bHRpcGxlLXNlbGVjdC5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvdHlwZXMvcmVsYXRpb24tbi1uLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy90eXBlcy9yZWxhdGlvbi5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvdHlwZXMvdGV4dGVkaXRvci5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvdHlwZXMvdXBsb2FkLmpzIiwibm9kZV9tb2R1bGVzL2FtZGVmaW5lL2FtZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbGliL19lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Nyb3Nzcm9hZHMvZGlzdC9jcm9zc3JvYWRzLmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL3dhcm5pbmcuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzLnJ1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9iYXNlLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvY29tcGlsZXIvYXN0LmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvY29tcGlsZXIvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2NvbXBpbGVyL2NvZGUtZ2VuLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvY29tcGlsZXIvY29tcGlsZXIuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9jb21waWxlci9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvY29tcGlsZXIvamF2YXNjcmlwdC1jb21waWxlci5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2NvbXBpbGVyL3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2NvbXBpbGVyL3ByaW50ZXIuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9jb21waWxlci92aXNpdG9yLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvY29tcGlsZXIvd2hpdGVzcGFjZS1jb250cm9sLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvZGVjb3JhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2RlY29yYXRvcnMvaW5saW5lLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvZXhjZXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvYmxvY2staGVscGVyLW1pc3NpbmcuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2VhY2guanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2hlbHBlci1taXNzaW5nLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy9pZi5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvbG9nLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy9sb29rdXAuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL3dpdGguanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9sb2dnZXIuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL25vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL25vLWNvbmZsaWN0LmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL3NhZmUtc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL2FycmF5LXNldC5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL2Jhc2U2NC12bHEuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9iYXNlNjQuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9iaW5hcnktc2VhcmNoLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvbWFwcGluZy1saXN0LmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvcXVpY2stc29ydC5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtY29uc3VtZXIuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL3NvdXJjZS1ub2RlLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9oYXNoZXIvZGlzdC9qcy9oYXNoZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwibm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJub2RlX21vZHVsZXMvcmVkdXgvbGliL2FwcGx5TWlkZGxld2FyZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWR1eC9saWIvYmluZEFjdGlvbkNyZWF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL3JlZHV4L2xpYi9jb21iaW5lUmVkdWNlcnMuanMiLCJub2RlX21vZHVsZXMvcmVkdXgvbGliL2NvbXBvc2UuanMiLCJub2RlX21vZHVsZXMvcmVkdXgvbGliL2NyZWF0ZVN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL3JlZHV4L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWR1eC9saWIvdXRpbHMvd2FybmluZy5qcyIsIm5vZGVfbW9kdWxlcy9zaWduYWxzL2Rpc3Qvc2lnbmFscy5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9jbGllbnQuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvaXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3JlcXVlc3QtYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9yZXF1ZXN0LmpzIiwibm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvcG9ueWZpbGwuanMiLCJub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7SUNBTSxXOzs7QUFDRix5QkFBWSxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsWUFDVCxVQURTLEdBQ00sTUFBTSxJQURaLENBQ1QsVUFEUzs7QUFBQSw4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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3U0E7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNydEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDLGVBQWUsRUFBQyxFQUFFLEVBQUMsZ0JBQWdCLEVBQUMsRUFBRSxFQUFDLGlCQUFpQixFQUFDLEVBQUUsRUFBQyxZQUFZLEVBQUMsRUFBRSxFQUFDLE9BQU8sRUFBQyxFQUFFLEVBQUMsY0FBYyxFQUFDLEVBQUUsRUFBQyxvQkFBb0IsRUFBQyxFQUFFLEVBQUMsU0FBUyxFQUFDLEVBQUUsRUFBQyxlQUFlLEVBQUMsRUFBRSxFQUFDLE1BQU0sRUFBQyxFQUFFLEVBQUMsZ0JBQWdCLEVBQUMsRUFBRSxFQUFDLGlCQUFpQixFQUFDLEVBQUUsRUFBQyxjQUFjLEVBQUMsRUFBRSxFQUFDLG9CQUFvQixFQUFDLEVBQUUsRUFBQyxZQUFZLEVBQUMsRUFBRSxFQUFDLGFBQWEsRUFBQyxFQUFFLEVBQUMsSUFBSSxFQUFDLEVBQUUsRUFBQyxRQUFRLEVBQUMsRUFBRSxFQUFDLG1CQUFtQixFQUFDLEVBQUUsRUFBQyxvQkFBb0IsRUFBQyxFQUFFLEVBQUMsUUFBUSxFQUFDLEVBQUUsRUFBQyxRQUFRLEVBQUMsRUFBRSxFQUFDLFNBQVMsRUFBQyxFQUFFLEVBQUMsV0FBVyxFQUFDLEVBQUUsRUFBQyxNQUFNLEVBQUMsRUFBRSxFQUFDLE1BQU0sRUFBQyxFQUFFLEVBQUMsS0FBSyxFQUFDO0FBQzVlLG9CQUFZLEVBQUUsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FB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QUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDdkYsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyx3QkFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3RGLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxXQUFXLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUM7QUFDckosMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyx3QkFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLFdBQVcsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUNySSwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsV0FBVyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDO0FBQ3JJLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7QUFDL0UsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFDSCx3QkFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQzt3QkFDN0UsT0FBTyxHQUFHLEVBQUUsQ0FBQyxjQUFjLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3pELDJCQUFPLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQzs7QUFFdkIsd0JBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUM7O0FBRXRFLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3hCLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsRUFBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFDLENBQUM7QUFDMUUsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyx3QkFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUN0SCwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3RILDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQ0gsd0JBQUksQ0FBQyxDQUFDLEdBQUc7QUFDUCw0QkFBSSxFQUFFLGtCQUFrQjtBQUN4Qiw0QkFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDO0FBQ2QsOEJBQU0sRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQztBQUNoQiw0QkFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDO0FBQ2QsOEJBQU0sRUFBRSxFQUFFO0FBQ1YsNkJBQUssRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3RDLDJCQUFHLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO3FCQUN6QixDQUFDOztBQUVOLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLG1CQUFtQixDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQzdFLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUM7QUFDOUcsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyx3QkFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDeEIsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyx3QkFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDeEIsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFDSCx3QkFBSSxDQUFDLENBQUMsR0FBRztBQUNQLDRCQUFJLEVBQUUsZUFBZTtBQUNyQiw0QkFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDO0FBQ2QsOEJBQU0sRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQztBQUNoQiw0QkFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMs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RyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFDLENBQUM7QUFDOUYsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyx3QkFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDeEIsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyx3QkFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDeEIsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyx3QkFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3ZELDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUN4RCwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFFLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFDLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsU0FBUyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEFBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3hHLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFDLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUMsQ0FBQyxDQUFDO0FBQzNELDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO0FBQ3BCLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsc0JBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzlCLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUMxQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDMUIsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyxzQkFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDOUIsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEdBQUc7QUFBQyx3QkFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzNCLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxHQUFHO0FBQUMsc0JBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQy9CLDBCQUFNO0FBQUEsYUFDTDtTQUNBO0FBQ0QsYUFBSyxFQUFFLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEdBQUcsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxHQUFHLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxHQUFHLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEdBQUcsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxHQUFHLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxHQUFHLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxHQUFHLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEdBQUcsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEdBQUcsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxHQUFHLENBQUMsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxHQUFHLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEdBQUcsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEdBQUcsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEdBQUcsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxDQUFDO0FBQ3hnVyxzQkFBYyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUM7QUFDN00sa0JBQVUsRUFBRSxTQUFTLFVBQVUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQ3ZDLGtCQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3hCO0FBQ0QsYUFBSyxFQUFFLFNBQVMsS0FBSyxDQUFDLEtBQUssRUFBRTtBQUN6QixnQkFBSSxJQUFJLEdBQUcsSUFBSTtnQkFBRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQUUsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDO2dCQUFFLE1BQU0sR0FBRyxFQUFFO2dCQUFFLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSztnQkFBRSxNQUFNLEdBQUcsRUFBRTtnQkFBRSxRQUFRLEdBQUcsQ0FBQztnQkFBRSxN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QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQUFBQyxPQUFPLEVBQUUsQ0FBQztBQUNuQywwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQUFBQyxPQUFPLEVBQUUsQ0FBQztBQUNuQywwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUNMLHdCQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN2Qix3QkFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO0FBQ2hCLHdCQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDOztBQUVwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUNMLHdCQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7QUFDaEIsMkJBQU8sRUFBRSxDQUFDOztBQUVaLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsMkJBQU8sRUFBRSxDQUFDO0FBQ2xCLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsMkJBQU8sRUFBRSxDQUFDO0FBQ2xCLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsMkJBQU8sRUFBRSxDQUFDO0FBQ2xCLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsMkJBQU8sRUFBRSxDQUFDO0FBQ2xCLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsMkJBQU8sRUFBRSxDQUFDO0FBQ2xCLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFOztBQUNQLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxBQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ25DLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxBQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ25DLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsdUJBQUcsQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFDLEdBQUcsQ0FBQyxDQUFDLEFBQUMsT0FBTyxFQUFFLENBQUM7QUFDL0QsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyx1QkFBRyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUMsR0FBRyxDQUFDLENBQUMsQUFBQyxPQUFPLEVBQUUsQ0FBQztBQUMvRCwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUss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QUFDLElBQUksR0FBRyxHQUFHLENBQUM7QUFDbEIsU0FBTyxNQUFNLENBQUM7Q0FDZjs7QUFFTSxTQUFTLGlCQUFpQixDQUFDLFdBQVcsRUFBRSxFQUFFLEVBQUU7QUFDakQsU0FBTyxDQUFDLFdBQVcsR0FBRyxXQUFXLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQSxHQUFJLEVBQUUsQ0FBQztDQUNwRDs7OztBQzNHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzloQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsImNsYXNzIExpbmtlZFZhbHVlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICB2YXIgeyBmaWVsZFZhbHVlIH0gPSBwcm9wcy5kYXRhO1xuXG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZmllbGRWYWx1ZTogZmllbGRWYWx1ZSA/IGZpZWxkVmFsdWUgOiAnJ1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICB2YXIgeyBmaWVsZFZhbHVlIH0gPSBuZXh0UHJvcHMuZGF0YTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IGZpZWxkVmFsdWUgPyBmaWVsZFZhbHVlIDogJydcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpbmtlZENoYW5nZShldmVudCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExpbmtlZFZhbHVlOyIsIlxuaW1wb3J0IElucHV0VGV4dCBmcm9tICcuL2lucHV0L3RleHQuanN4JztcbmltcG9ydCBJbnB1dFRleHRhcmVhIGZyb20gJy4vaW5wdXQvdGV4dGFyZWEuanN4JztcbmltcG9ydCBJbnB1dFRleHRlZGl0b3IgZnJvbSAnLi9pbnB1dC9yaWNoLXRleHRlZGl0b3IuanN4JztcbmltcG9ydCBJbnB1dERhdGUgZnJvbSAnLi9pbnB1dC9kYXRlLmpzeCc7XG5pbXBvcnQgSW5wdXREYXRldGltZSBmcm9tICcuL2lucHV0L2RhdGV0aW1lLmpzeCc7XG5pbXBvcnQgSW5wdXRFbnVtIGZyb20gJy4vaW5wdXQvZW51bS5qc3gnO1xuaW1wb3J0IElucHV0RW51bVNlYXJjaGFibGUgZnJvbSAnLi9pbnB1dC9lbnVtLXNlYXJjaGFibGUuanN4JztcbmltcG9ydCBJbnB1dERyb3Bkb3duIGZyb20gJy4vaW5wdXQvZHJvcGRvd24uanN4JztcbmltcG9ydCBJbnB1dERyb3Bkb3duU2VhcmNoYWJsZSBmcm9tICcuL2lucHV0L2Ryb3Bkb3duLXNlYXJjaGFibGUuanN4JztcbmltcG9ydCBJbnB1dFJlbGF0aW9uYWxTZWFyY2hhYmxlIGZyb20gJy4vaW5wdXQvcmVsYXRpb25hbC1zZWFyY2hhYmxlLmpzeCc7XG5pbXBvcnQgSW5wdXRSZWxhdGlvbmFsTmF0aXZlIGZyb20gJy4vaW5wdXQvcmVsYXRpb25hbC1uYXRpdmUuanN4JztcbmltcG9ydCBJbnB1dFVwbG9hZCBmcm9tICcuL2lucHV0L3VwbG9hZC5qc3gnO1xuaW1wb3J0IElucHV0UmVsYXRpb25OdG9OIGZyb20gJy4vaW5wdXQvcmVsYXRpb24tbi1uLmpzeCc7XG5pbXBvcnQgSW5wdXRTZWFyY2hhYmxlUmVsYXRpb25OdG9OIGZyb20gJy4vaW5wdXQvc2VhcmNoYWJsZS1yZWxhdGlvbi1uLW4uanN4JztcbmltcG9ydCBJbnB1dE51bWVyaWMgZnJvbSAnLi9pbnB1dC9udW1lcmljLmpzeCc7XG5pbXBvcnQgSW5wdXRDaGVja2JveEJvb2xlYW4gZnJvbSAnLi9pbnB1dC9jaGVja2JveC1ib29sZWFuLmpzeCc7XG5pbXBvcnQgSW5wdXRFbWFpbCBmcm9tICcuL2lucHV0L2VtYWlsLmpzeCc7XG5pbXBvcnQgSW5wdXRDb2xvciBmcm9tICcuL2lucHV0L2NvbG9yLmpzeCc7XG5pbXBvcnQgSW5wdXRQYXNzd29yZCBmcm9tICcuL2lucHV0L3Bhc3N3b3JkLmpzeCc7XG5pbXBvcnQgSW5wdXRVcmwgZnJvbSAnLi9pbnB1dC91cmwuanN4JztcbmltcG9ydCBJbnB1dEJhY2tlbmRDYWxsYmFjayBmcm9tIFwiLi9pbnB1dC9iYWNrZW5kLWNhbGxiYWNrLmpzXCI7XG5pbXBvcnQgSW5wdXRNdWx0aXNlbGVjdFNlYXJjaGFibGUgZnJvbSBcIi4vaW5wdXQvbXVsdGlzZWxlY3Qtc2VhcmNoYWJsZS5qc1wiO1xuaW1wb3J0IElucHV0TXVsdGlzZWxlY3QgZnJvbSBcIi4vaW5wdXQvbXVsdGlzZWxlY3RcIjtcblxuY2xhc3MgRmllbGRJbnB1dCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgICBfX3R5cGVfZW1haWwoZmllbGROYW1lLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiA8SW5wdXRFbWFpbCBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0gLz47XG4gICAgfVxuXG4gICAgX190eXBlX3VybChmaWVsZE5hbWUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIDxJbnB1dFVybCBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0gLz47XG4gICAgfVxuXG4gICAgX190eXBlX2NvbG9yKGZpZWxkTmFtZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gPElucHV0Q29sb3Iga2V5PXtmaWVsZE5hbWV9IGRhdGE9e2RhdGF9IC8+O1xuICAgIH1cblxuICAgIF9fdHlwZV9wYXNzd29yZChmaWVsZE5hbWUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIDxJbnB1dFBhc3N3b3JkIGtleT17ZmllbGROYW1lfSBkYXRhPXtkYXRhfSAvPjtcbiAgICB9XG5cbiAgICBfX3R5cGVfY2hlY2tib3hfYm9vbGVhbihmaWVsZE5hbWUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIDxJbnB1dENoZWNrYm94Qm9vbGVhbiBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0gLz47XG4gICAgfVxuXG4gICAgX190eXBlX2Ryb3Bkb3duKGZpZWxkTmFtZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gPElucHV0RHJvcGRvd24ga2V5PXtmaWVsZE5hbWV9IGRhdGE9e2RhdGF9IC8+O1xuICAgIH1cblxuICAgIF9fdHlwZV9kcm9wZG93bl9zZWFyY2goZmllbGROYW1lLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiA8SW5wdXREcm9wZG93blNlYXJjaGFibGUga2V5PXtmaWVsZE5hbWV9IGRhdGE9e2RhdGF9IC8+O1xuICAgIH1cblxuICAgIF9fdHlwZV9lbnVtKGZpZWxkTmFtZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gPElucHV0RW51bSBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0gLz47XG4gICAgfVxuXG4gICAgX190eXBlX211bHRpc2VsZWN0X3NlYXJjaGFibGUoZmllbGROYW1lLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiA8SW5wdXRNdWx0aXNlbGVjdFNlYXJjaGFibGUga2V5PXtmaWVsZE5hbWV9IGRhdGE9e2RhdGF9IC8+O1xuICAgIH1cblxuICAgIF9fdHlwZV9tdWx0aXNlbGVjdF9uYXRpdmUoZmllbGROYW1lLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiA8SW5wdXRNdWx0aXNlbGVjdCBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0gLz47XG4gICAgfVxuXG4gICAgX190eXBlX2VudW1fc2VhcmNoYWJsZShmaWVsZE5hbWUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIDxJbnB1dEVudW1TZWFyY2hhYmxlIGtleT17ZmllbGROYW1lfSBkYXRhPXtkYXRhfSAvPjtcbiAgICB9XG5cbiAgICBfX3R5cGVfaW50KGZpZWxkTmFtZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gPElucHV0TnVtZXJpYyBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0gLz47XG4gICAgfVxuXG4gICAgX190eXBlX3JlbGF0aW9uYWwoZmllbGROYW1lLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiA8SW5wdXRSZWxhdGlvbmFsU2VhcmNoYWJsZSBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0gLz47XG4gICAgfVxuXG4gICAgX190eXBlX3JlbGF0aW9uYWxfbmF0aXZlKGZpZWxkTmFtZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gPElucHV0UmVsYXRpb25hbE5hdGl2ZSBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0gLz47XG4gICAgfVxuXG4gICAgX190eXBlX3JlbGF0aW9uYWxfbl9uKGZpZWxkTmFtZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gPElucHV0U2VhcmNoYWJsZVJlbGF0aW9uTnRvTiBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0gLz47XG4gICAgfVxuXG4gICAgX190eXBlX25hdGl2ZV9yZWxhdGlvbmFsX25fbihmaWVsZE5hbWUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIDxJbnB1dFJlbGF0aW9uTnRvTiBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0gLz47XG4gICAgfVxuXG4gICAgX190eXBlX251bWVyaWMoZmllbGROYW1lLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fdHlwZV9pbnQoZmllbGROYW1lLCBkYXRhKTtcbiAgICB9XG5cbiAgICBfX3R5cGVfYmFja2VuZF9jYWxsYmFjayhmaWVsZE5hbWUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIDxJbnB1dEJhY2tlbmRDYWxsYmFjayBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0vPlxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcblxuICAgICAgICB2YXIgeyBmaWVsZE5hbWUsIGZpZWxkVHlwZSB9ID0gdGhpcy5wcm9wcy5kYXRhLFxuICAgICAgICAgICAgZGF0YSA9IHRoaXMucHJvcHMuZGF0YSxcbiAgICAgICAgICAgIHsgZ2NydWRJbnN0YW5jZSB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuXG4gICAgICAgIGlmICh0aGlzWydfX3R5cGVfJyArIGZpZWxkVHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbJ19fdHlwZV8nICsgZmllbGRUeXBlXShmaWVsZE5hbWUsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC9edGV4dGVkaXRvciQvaS50ZXN0KGZpZWxkVHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiA8SW5wdXRUZXh0ZWRpdG9yIGRhdGE9e2RhdGF9IC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC9edGV4dCQvaS50ZXN0KGZpZWxkVHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiA8SW5wdXRUZXh0YXJlYSBrZXk9e3RpbWVzdGFtcH0gZGF0YT17ZGF0YX0gLz47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL15kYXRlJC9pLnRlc3QoZmllbGRUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIDxJbnB1dERhdGUga2V5PXt0aW1lc3RhbXB9IGRhdGE9e2RhdGF9IGdjcnVkSW5zdGFuY2U9e2djcnVkSW5zdGFuY2V9IC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC9eKGRhdGV0aW1lfHRpbWVzdGFtcCkkL2kudGVzdChmaWVsZFR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gPElucHV0RGF0ZXRpbWUga2V5PXt0aW1lc3RhbXB9IGRhdGE9e2RhdGF9IGdjcnVkSW5zdGFuY2U9e2djcnVkSW5zdGFuY2V9IC8+XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL151cGxvYWQkL2kudGVzdChmaWVsZFR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gPElucHV0VXBsb2FkIGtleT17dGltZXN0YW1wfSBkYXRhPXtkYXRhfSBnY3J1ZEluc3RhbmNlPXtnY3J1ZEluc3RhbmNlfSAvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiA8SW5wdXRUZXh0IGtleT17ZmllbGROYW1lfSBkYXRhPXtkYXRhfSAvPjtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZpZWxkSW5wdXQ7XG4iLCJcbmltcG9ydCBGaWVsZFJvdyBmcm9tICcuL2ZpZWxkLXJvdy5qc3gnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY2xhc3MgRmllbGRMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciB7IGdjcnVkSW5zdGFuY2UsIEZpZWxkSW5wdXRDb21wb25lbnQsIEZpZWxkUm93V3JhcHBlciwgZmllbGRzIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLm1hcChmdW5jdGlvbiBGaWVsZHNGb3JFYWNoKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeyBmaWVsZE5hbWUgfSA9IGZpZWxkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPEZpZWxkUm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtmaWVsZE5hbWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YT17ZmllbGR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2NydWRJbnN0YW5jZT17Z2NydWRJbnN0YW5jZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaWVsZElucHV0Q29tcG9uZW50PXtGaWVsZElucHV0Q29tcG9uZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpZWxkUm93V3JhcHBlcj17RmllbGRSb3dXcmFwcGVyfVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcblxuICAgIH1cbn1cblxuRmllbGRMaXN0LnByb3BUeXBlcyA9IHtcbiAgICBnY3J1ZEluc3RhbmNlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIEZpZWxkSW5wdXRDb21wb25lbnQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIEZpZWxkUm93V3JhcHBlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgZmllbGRzOiBQcm9wVHlwZXMuYXJyYXlcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZpZWxkTGlzdDtcbiIsImltcG9ydCBJbnB1dEhpZGRlbiBmcm9tICcuL2lucHV0L2hpZGRlbi5qc3gnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY2xhc3MgRmllbGRSb3cgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHsgZGF0YSwgZGF0YTogeyBmaWVsZFR5cGUsIGlzUmVxdWlyZWQsIGRpc3BsYXlBcyB9LCBnY3J1ZEluc3RhbmNlLCBGaWVsZElucHV0Q29tcG9uZW50LCBGaWVsZFJvd1dyYXBwZXIgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKC9eaGlkZGVuJC9pLnRlc3QoZmllbGRUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8SW5wdXRIaWRkZW4gZGF0YT17ZGF0YX0gLz5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gPEZpZWxkUm93V3JhcHBlclxuICAgICAgICAgICAgaXNSZXF1aXJlZD17aXNSZXF1aXJlZH1cbiAgICAgICAgICAgIGRpc3BsYXlBcz17ZGlzcGxheUFzfVxuICAgICAgICAgICAgZGF0YT17ZGF0YX1cbiAgICAgICAgICAgIGdjcnVkSW5zdGFuY2U9e2djcnVkSW5zdGFuY2V9XG4gICAgICAgICAgICBGaWVsZElucHV0PXtGaWVsZElucHV0Q29tcG9uZW50fVxuICAgICAgICAvPjtcbiAgICB9XG59XG5cbkZpZWxkUm93LnByb3BUeXBlcyA9IHtcbiAgICBkYXRhOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgICBkaXNwbGF5QXM6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGZpZWxkVHlwZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgaXNSZXF1aXJlZDogUHJvcFR5cGVzLmJvb2xcbiAgICB9KSxcbiAgICBnY3J1ZEluc3RhbmNlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIEZpZWxkSW5wdXRDb21wb25lbnQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIEZpZWxkUm93V3JhcHBlcjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbkZpZWxkUm93LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBGaWVsZElucHV0Q29tcG9uZW50OiBwcm9wcyA9PiA8aW5wdXQgbmFtZT17cHJvcHMuZGF0YS5maWVsZE5hbWV9IC8+LFxuICAgIEZpZWxkUm93V3JhcHBlcjogcHJvcHMgPT4ge1xuICAgICAgICBjb25zdCB7IGlzUmVxdWlyZWQsIGRpc3BsYXlBcywgRmllbGRJbnB1dCwgZGF0YSwgZ2NydWRJbnN0YW5jZSB9ID0gcHJvcHM7XG5cbiAgICAgICAgcmV0dXJuICg8ZGl2PlxuICAgICAgICAgICAgPGxhYmVsPlxuICAgICAgICAgICAgICAgIHtpc1JlcXVpcmVkID8gJyonIDogJyd9XG4gICAgICAgICAgICAgICAge2Rpc3BsYXlBc31cbiAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxGaWVsZElucHV0IGRhdGE9e2RhdGF9IGdjcnVkSW5zdGFuY2U9e2djcnVkSW5zdGFuY2V9Lz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj4pO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRmllbGRSb3c7XG4iLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5jbGFzcyBJbnB1dEJhY2tlbmRDYWxsYmFjayBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgbGV0IHsgZmllbGRWYWx1ZSB9ID0gcHJvcHMuZGF0YTtcblxuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IGZpZWxkVmFsdWUgPyBmaWVsZFZhbHVlIDogJydcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBsZXQgeyBmaWVsZFZhbHVlIH0gPSBuZXh0UHJvcHMuZGF0YTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IGZpZWxkVmFsdWUgPyBmaWVsZFZhbHVlIDogJydcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBkZWZhdWx0VmFsdWUgfSA9IHRoaXMucHJvcHMuZGF0YSxcbiAgICAgICAgICAgIHsgZmllbGRWYWx1ZSB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIGRhbmdlcm91c2x5SW5uZXJIVE1MID0ge1xuICAgICAgICAgICAgICAgIF9faHRtbDogZGVmYXVsdFZhbHVlID8gZGVmYXVsdFZhbHVlIDogZmllbGRWYWx1ZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gPGRpdiBkYW5nZXJvdXNseVNldElubmVySFRNTD17ZGFuZ2Vyb3VzbHlJbm5lckhUTUx9Lz47XG4gICAgfVxufVxuXG5JbnB1dEJhY2tlbmRDYWxsYmFjay5wcm9wVHlwZXMgPSB7XG4gICAgZGF0YTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgICAgZmllbGRWYWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nXG4gICAgfSlcbn07XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0QmFja2VuZENhbGxiYWNrOyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIElucHV0Q2hlY2tib3hCb29sZWFuIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICB2YXIgeyBmaWVsZFZhbHVlLCBkZWZhdWx0VmFsdWUsIHNob3dEZWZhdWx0VmFsdWUgfSA9IHByb3BzLmRhdGEsXG4gICAgICAgICAgICB2YWx1ZSA9IHNob3dEZWZhdWx0VmFsdWUgJiYgZGVmYXVsdFZhbHVlID8gZGVmYXVsdFZhbHVlIDogZmllbGRWYWx1ZTtcblxuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IHRoaXMuZ2V0Q2hlY2tib3hWYWx1ZSh2YWx1ZSksXG4gICAgICAgICAgICBpc0NoZWNrZWQ6IHRoaXMuY2hlY2tib3hJc0NoZWNrZWQodmFsdWUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIHZhciB7IGZpZWxkVmFsdWUsIGRlZmF1bHRWYWx1ZSwgc2hvd0RlZmF1bHRWYWx1ZSB9ID0gbmV4dFByb3BzLmRhdGEsXG4gICAgICAgICAgICB2YWx1ZSA9IHNob3dEZWZhdWx0VmFsdWUgJiYgZGVmYXVsdFZhbHVlID8gZGVmYXVsdFZhbHVlIDogZmllbGRWYWx1ZTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IHRoaXMuZ2V0Q2hlY2tib3hWYWx1ZSh2YWx1ZSksXG4gICAgICAgICAgICBpc0NoZWNrZWQ6IHRoaXMuY2hlY2tib3hJc0NoZWNrZWQodmFsdWUpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsaW5rZWRDaGFuZ2UoKSB7XG4gICAgICAgIHZhciB7IGlzQ2hlY2tlZCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IGlzQ2hlY2tlZCA/ICcwJyA6ICcxJyxcbiAgICAgICAgICAgIGlzQ2hlY2tlZDogIWlzQ2hlY2tlZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q2hlY2tib3hWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09ICcxJyA/ICcxJyA6ICcwJztcbiAgICB9XG4gICAgY2hlY2tib3hJc0NoZWNrZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAnMSc7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHsgZmllbGROYW1lLCBpc1JlYWRPbmx5IH0gPSB0aGlzLnByb3BzLmRhdGEsXG4gICAgICAgICAgICB7IGZpZWxkVmFsdWUsIGlzQ2hlY2tlZCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBpZiAoaXNSZWFkT25seSkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvcm0tY29udHJvbCBnYy1yZWFkLW9ubHktaW5wdXRcIj5cbiAgICAgICAgICAgICAgICAgICAge2lzQ2hlY2tlZCA/IDxpIGNsYXNzTmFtZT1cImZhIGZhLWNoZWNrXCI+PC9pPiA6ICcnfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxpbnB1dCB2YWx1ZT17ZmllbGRWYWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzUmVhZE9ubHl9XG4gICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2lzQ2hlY2tlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMubGlua2VkQ2hhbmdlLmJpbmQodGhpcyl9IC8+XG4gICAgICAgICAgICAgICAgPGlucHV0IG5hbWU9e2ZpZWxkTmFtZX1cbiAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2ZpZWxkVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJoaWRkZW5cIiAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5JbnB1dENoZWNrYm94Qm9vbGVhbi5wcm9wVHlwZXMgPSB7XG4gICAgZGF0YTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgICAgZmllbGROYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBpc1JlYWRPbmx5OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgZmllbGRWYWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBzaG93RGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMuYm9vbFxuICAgIH0pXG59O1xuXG5leHBvcnQgZGVmYXVsdCBJbnB1dENoZWNrYm94Qm9vbGVhbjtcbiIsIlxuaW1wb3J0IElucHV0VGV4dCBmcm9tICcuL3RleHQuanN4JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIElucHV0Q29sb3IgZXh0ZW5kcyBJbnB1dFRleHQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHsgZGF0YSB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIHsgZmllbGROYW1lIH0gPSB0aGlzLnByb3BzLmRhdGE7XG5cbiAgICAgICAgcmV0dXJuIDxJbnB1dFRleHQga2V5PXtmaWVsZE5hbWV9IGRhdGE9e2RhdGF9IC8+XG4gICAgfVxufVxuXG5JbnB1dENvbG9yLnByb3BUeXBlcyA9IHtcbiAgICBkYXRhOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgICBmaWVsZE5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGlzUmVhZE9ubHk6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBmaWVsZFR5cGU6IFByb3BUeXBlcy5zdHJpbmdcbiAgICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dENvbG9yO1xuIiwiaW1wb3J0IElucHV0UmVhZE9ubHkgZnJvbSAnLi9yZWFkLW9ubHkuanN4JztcblxudmFyIGpRdWVyeVBsdWdpbnMgPSByZXF1aXJlKCcuLi8uLi8uLi9SZXNvdXJjZXMvcHVibGljL2pzL21vZHVsZXMvanF1ZXJ5L2pxdWVyeS1wbHVnaW5zJykualF1ZXJ5UGx1Z2lucyxcbiAgICAkID0galF1ZXJ5O1xuXG5jbGFzcyBJbnB1dERhdGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBqUXVlcnlQbHVnaW5zLmRhdGVwaWNrZXIoJChSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSkuZmluZCgnLmdjLWlucHV0LWRhdGUnKSwgdGhpcy5wcm9wcy5nY3J1ZEluc3RhbmNlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBmaWVsZE5hbWUsIGZpZWxkVmFsdWUsIGlzUmVhZE9ubHkgfSA9IHRoaXMucHJvcHMuZGF0YSxcbiAgICAgICAgICAgIGV4dHJhSW5wdXQgPSAnJyxcbiAgICAgICAgICAgIGlucHV0Q2xhc3NlcyA9ICdmb3JtLWNvbnRyb2wgZ2MtaW5wdXQtZGF0ZSc7XG5cbiAgICAgICAgaWYgKGlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgIGV4dHJhSW5wdXQgPSA8SW5wdXRSZWFkT25seSBmaWVsZFZhbHVlPXtmaWVsZFZhbHVlfSAvPjtcbiAgICAgICAgICAgIGlucHV0Q2xhc3NlcyArPSAnIGhpZGRlbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDxkaXY+XG4gICAgICAgICAgICB7ZXh0cmFJbnB1dH1cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17aW5wdXRDbGFzc2VzfVxuICAgICAgICAgICAgICAgIG5hbWU9e2ZpZWxkTmFtZX1cbiAgICAgICAgICAgICAgICByZWFkT25seT17aXNSZWFkT25seX1cbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9e2ZpZWxkVmFsdWV9XG4gICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgIHN0ZXA9XCIxXCJcbiAgICAgICAgICAgIC8+PC9kaXY+O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5wdXREYXRlO1xuIiwiaW1wb3J0IElucHV0UmVhZE9ubHkgZnJvbSAnLi9yZWFkLW9ubHkuanN4JztcblxudmFyIGpRdWVyeVBsdWdpbnMgPSByZXF1aXJlKCcuLi8uLi8uLi9SZXNvdXJjZXMvcHVibGljL2pzL21vZHVsZXMvanF1ZXJ5L2pxdWVyeS1wbHVnaW5zJykualF1ZXJ5UGx1Z2lucyxcbiAgICAkID0galF1ZXJ5O1xuXG5jbGFzcyBJbnB1dERhdGV0aW1lIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgalF1ZXJ5UGx1Z2lucy5kYXRldGltZXBpY2tlcigkKFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKS5maW5kKCcuZ2MtaW5wdXQtZGF0ZXRpbWUnKSwgdGhpcy5wcm9wcy5nY3J1ZEluc3RhbmNlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBmaWVsZE5hbWUsIGZpZWxkVmFsdWUsIGlzUmVhZE9ubHkgfSA9IHRoaXMucHJvcHMuZGF0YSxcbiAgICAgICAgICAgIGV4dHJhSW5wdXQgPSAnJyxcbiAgICAgICAgICAgIGlucHV0Q2xhc3NlcyA9ICdmb3JtLWNvbnRyb2wgZ2MtaW5wdXQtZGF0ZXRpbWUnO1xuXG4gICAgICAgIGlmIChpc1JlYWRPbmx5KSB7XG4gICAgICAgICAgICBleHRyYUlucHV0ID0gPElucHV0UmVhZE9ubHkgZmllbGRWYWx1ZT17ZmllbGRWYWx1ZX0gLz47XG4gICAgICAgICAgICBpbnB1dENsYXNzZXMgKz0gJyBoaWRkZW4nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDxkaXY+XG4gICAgICAgICAgICAgICAge2V4dHJhSW5wdXR9XG4gICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17aW5wdXRDbGFzc2VzfVxuICAgICAgICAgICAgICAgICAgICBuYW1lPXtmaWVsZE5hbWV9XG4gICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5PXtpc1JlYWRPbmx5fVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9e2ZpZWxkVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgc3RlcD1cIjFcIlxuICAgICAgICAgICAgICAgIC8+PC9kaXY+O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5wdXREYXRldGltZTtcbiIsIlxuaW1wb3J0IExpbmtlZFZhbHVlIGZyb20gJy4uL2NvbXBvbmVudHMvbGlua2VkLXZhbHVlLmpzJztcblxuaW1wb3J0IElucHV0UmVhZE9ubHkgZnJvbSAnLi9yZWFkLW9ubHkuanN4JztcbmltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG52YXIgalF1ZXJ5UGx1Z2lucyA9IHJlcXVpcmUoJy4uLy4uLy4uL1Jlc291cmNlcy9wdWJsaWMvanMvbW9kdWxlcy9qcXVlcnkvanF1ZXJ5LXBsdWdpbnMnKS5qUXVlcnlQbHVnaW5zLFxuICAgICQgPSBqUXVlcnksXG4gICAgaTE4biA9IHJlcXVpcmUoJy4uLy4uLy4uL1Jlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvaTE4bicpLmkxOG47XG5cbmNsYXNzIElucHV0RHJvcGRvd25TZWFyY2hhYmxlIGV4dGVuZHMgTGlua2VkVmFsdWUge1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBqUXVlcnlQbHVnaW5zLnNlYXJjaGFibGVTZWxlY3QoJChSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSkuZmluZCgnc2VsZWN0JyksIHRoaXMucHJvcHMuZGF0YS5pc1JlYWRPbmx5KTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICBqUXVlcnlQbHVnaW5zLnNlYXJjaGFibGVTZWxlY3RVcGRhdGUoJChSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSkuZmluZCgnc2VsZWN0JyksIHRoaXMucHJvcHMuZGF0YS5pc1JlYWRPbmx5KTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgeyBmaWVsZE5hbWUsIGZpZWxkVmFsdWVzLCBpc051bGxhYmxlLCBpc1JlYWRPbmx5IH0gPSB0aGlzLnByb3BzLmRhdGEsXG4gICAgICAgICAgICB7IGZpZWxkVmFsdWUgfSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICBmaWVsZFZhbHVlRGVzY3JpcHRpb24gPSAnJyxcbiAgICAgICAgICAgIGV4dHJhSW5wdXQgPSAnJyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBbXTtcblxuICAgICAgICBpZiAoaXNOdWxsYWJsZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wdXNoKHsgaWQ6ICcnLCB0aXRsZTogJycgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXy5lYWNoKGZpZWxkVmFsdWVzLCBmdW5jdGlvbiBmb3JFYWNoRmllbGRWYWx1ZShvcHRpb25EaXNwbGF5LCBvcHRpb25WYWx1ZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogb3B0aW9uVmFsdWUsXG4gICAgICAgICAgICAgICAgdGl0bGU6IG9wdGlvbkRpc3BsYXlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG9wdGlvblZhbHVlID09PSBmaWVsZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZURlc2NyaXB0aW9uID0gb3B0aW9uRGlzcGxheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgIGV4dHJhSW5wdXQgPSA8SW5wdXRSZWFkT25seSBmaWVsZFZhbHVlPXtmaWVsZFZhbHVlRGVzY3JpcHRpb259IC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAge2V4dHJhSW5wdXR9XG4gICAgICAgICAgICAgICAgPHNlbGVjdFxuICAgICAgICAgICAgICAgICAgICBuYW1lPXtmaWVsZE5hbWV9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtmaWVsZFZhbHVlfVxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5saW5rZWRDaGFuZ2UuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzUmVhZE9ubHl9XG4gICAgICAgICAgICAgICAgICAgIGRhdGEtcGxhY2Vob2xkZXI9e2kxOG4udCgnc2VsZWN0X2FuX29wdGlvbicpfT5cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tYXAoZnVuY3Rpb24gRHJvcERvd25Gb3JFYWNoKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHsgaWQsIHRpdGxlIH0gPSBmaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPG9wdGlvbiB2YWx1ZT17aWR9IGtleT17aWR9ID57dGl0bGV9PC9vcHRpb24+O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dERyb3Bkb3duU2VhcmNoYWJsZTtcbiIsIlxuaW1wb3J0IExpbmtlZFZhbHVlIGZyb20gJy4uL2NvbXBvbmVudHMvbGlua2VkLXZhbHVlLmpzJztcbmltcG9ydCBJbnB1dFJlYWRPbmx5IGZyb20gJy4vcmVhZC1vbmx5LmpzeCc7XG5pbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcblxuY2xhc3MgSW5wdXREcm9wZG93biBleHRlbmRzIExpbmtlZFZhbHVlIHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciB7IGZpZWxkTmFtZSwgZmllbGRWYWx1ZXMsIGlzTnVsbGFibGUsIGlzUmVhZE9ubHkgfSA9IHRoaXMucHJvcHMuZGF0YSxcbiAgICAgICAgICAgIHsgZmllbGRWYWx1ZSB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIGZpZWxkVmFsdWVEZXNjcmlwdGlvbiA9ICcnLFxuICAgICAgICAgICAgb3B0aW9ucyA9IFtdO1xuXG4gICAgICAgIGlmIChpc051bGxhYmxlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2goeyBpZDogJycsIHRpdGxlOiAnJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBfLmVhY2goZmllbGRWYWx1ZXMsIGZ1bmN0aW9uIGZvckVhY2hGaWVsZFZhbHVlKG9wdGlvbkRpc3BsYXksIG9wdGlvblZhbHVlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBvcHRpb25WYWx1ZSxcbiAgICAgICAgICAgICAgICB0aXRsZTogb3B0aW9uRGlzcGxheVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEZvciB0aGUgc2VsZWN0IGlkIHNob3cgdGhlIG9wdGlvbiBkaXNwbGF5IGluc3RlYWQgb2YgdGhlIGlkXG4gICAgICAgICAgICBpZiAob3B0aW9uVmFsdWUgPT09IGZpZWxkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlRGVzY3JpcHRpb24gPSBvcHRpb25EaXNwbGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaXNSZWFkT25seSkge1xuICAgICAgICAgICAgcmV0dXJuIDxJbnB1dFJlYWRPbmx5IGZpZWxkVmFsdWU9e2ZpZWxkVmFsdWVEZXNjcmlwdGlvbn0gLz47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPHNlbGVjdFxuICAgICAgICAgICAgICAgIG5hbWU9e2ZpZWxkTmFtZX1cbiAgICAgICAgICAgICAgICB2YWx1ZT17ZmllbGRWYWx1ZX1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5saW5rZWRDaGFuZ2UuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2xcIlxuICAgICAgICAgICAgICAgIGRpc2FibGVkPXtpc1JlYWRPbmx5fT5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWFwKGZ1bmN0aW9uIERyb3BEb3duRm9yRWFjaChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHsgaWQsIHRpdGxlIH0gPSBmaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8b3B0aW9uIHZhbHVlPXtpZH0ga2V5PXtpZH0gPnt0aXRsZX08L29wdGlvbj47XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dERyb3Bkb3duO1xuIiwiXG5pbXBvcnQgSW5wdXRUZXh0IGZyb20gJy4vdGV4dC5qc3gnO1xuXG5jbGFzcyBJbnB1dEVtYWlsIGV4dGVuZHMgSW5wdXRUZXh0IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciB7IGRhdGEgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICB7IGZpZWxkTmFtZSB9ID0gdGhpcy5wcm9wcy5kYXRhO1xuXG4gICAgICAgIHJldHVybiA8SW5wdXRUZXh0IGtleT17ZmllbGROYW1lfSBkYXRhPXtkYXRhfSAvPlxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5wdXRFbWFpbDtcbiIsIlxuXG5pbXBvcnQgTGlua2VkVmFsdWUgZnJvbSAnLi4vY29tcG9uZW50cy9saW5rZWQtdmFsdWUuanMnO1xuaW1wb3J0IElucHV0UmVhZE9ubHkgZnJvbSAnLi9yZWFkLW9ubHkuanN4JztcbmltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG52YXIgalF1ZXJ5UGx1Z2lucyA9IHJlcXVpcmUoJy4uLy4uLy4uL1Jlc291cmNlcy9wdWJsaWMvanMvbW9kdWxlcy9qcXVlcnkvanF1ZXJ5LXBsdWdpbnMnKS5qUXVlcnlQbHVnaW5zLFxuICAgICQgPSBqUXVlcnksXG4gICAgaTE4biA9IHJlcXVpcmUoJy4uLy4uLy4uL1Jlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvaTE4bicpLmkxOG47XG5cbmNsYXNzIElucHV0RW51bVNlYXJjaGFibGUgZXh0ZW5kcyBMaW5rZWRWYWx1ZSB7XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGpRdWVyeVBsdWdpbnMuc2VhcmNoYWJsZVNlbGVjdCgkKFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKS5maW5kKCdzZWxlY3QnKSwgdGhpcy5wcm9wcy5kYXRhLmlzUmVhZE9ubHkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIGpRdWVyeVBsdWdpbnMuc2VhcmNoYWJsZVNlbGVjdFVwZGF0ZSgkKFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKS5maW5kKCdzZWxlY3QnKSwgdGhpcy5wcm9wcy5kYXRhLmlzUmVhZE9ubHkpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciB7IGZpZWxkTmFtZSwgZmllbGRWYWx1ZXMsIGlzTnVsbGFibGUsIGlzUmVhZE9ubHkgfSA9IHRoaXMucHJvcHMuZGF0YSxcbiAgICAgICAgICAgIHsgZmllbGRWYWx1ZSB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIGV4dHJhSW5wdXQgPSAnJyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBbXTtcblxuICAgICAgICBpZiAoaXNSZWFkT25seSkge1xuICAgICAgICAgICAgZXh0cmFJbnB1dCA9IDxJbnB1dFJlYWRPbmx5IGZpZWxkVmFsdWU9e2ZpZWxkVmFsdWV9IC8+O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bGxhYmxlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2goJycpO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkVmFsdWVzLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaEZpZWxkVmFsdWUob3B0aW9uVmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaChvcHRpb25WYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zID0gXy51bmlxKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICB7ZXh0cmFJbnB1dH1cbiAgICAgICAgICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgICAgICAgICAgIG5hbWU9e2ZpZWxkTmFtZX1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2ZpZWxkVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtpc1JlYWRPbmx5fVxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5saW5rZWRDaGFuZ2UuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICAgICAgZGF0YS1wbGFjZWhvbGRlcj17aTE4bi50KCdzZWxlY3RfYW5fb3B0aW9uJyl9PlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1hcChmdW5jdGlvbiBvcHRpb25zRm9yRWFjaChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8b3B0aW9uIGRlZmF1bHRWYWx1ZT17ZmllbGR9IGtleT17ZmllbGR9ID57ZmllbGR9PC9vcHRpb24+O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dEVudW1TZWFyY2hhYmxlO1xuIiwiXG5pbXBvcnQgTGlua2VkVmFsdWUgZnJvbSAnLi4vY29tcG9uZW50cy9saW5rZWQtdmFsdWUuanMnO1xuaW1wb3J0IElucHV0UmVhZE9ubHkgZnJvbSAnLi9yZWFkLW9ubHkuanN4JztcbmltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG5jbGFzcyBJbnB1dEVudW0gZXh0ZW5kcyBMaW5rZWRWYWx1ZSB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgeyBmaWVsZE5hbWUsIGZpZWxkVmFsdWVzLCBpc051bGxhYmxlLCBpc1JlYWRPbmx5IH0gPSB0aGlzLnByb3BzLmRhdGEsXG4gICAgICAgICAgICB7IGZpZWxkVmFsdWUgfSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICBvcHRpb25zID0gW107XG5cbiAgICAgICAgaWYgKGlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybiA8SW5wdXRSZWFkT25seSBmaWVsZFZhbHVlPXtmaWVsZFZhbHVlfSAvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bGxhYmxlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2goJycpO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkVmFsdWVzLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaEZpZWxkVmFsdWUob3B0aW9uVmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaChvcHRpb25WYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zID0gXy51bmlxKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPHNlbGVjdCBuYW1lPXtmaWVsZE5hbWV9IHZhbHVlPXtmaWVsZFZhbHVlfSBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2xcIiBkaXNhYmxlZD17aXNSZWFkT25seX0gb25DaGFuZ2U9e3RoaXMubGlua2VkQ2hhbmdlLmJpbmQodGhpcyl9ID5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWFwKGZ1bmN0aW9uIG9wdGlvbnNGb3JFYWNoKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPG9wdGlvbiBkZWZhdWx0VmFsdWU9e2ZpZWxkfSBrZXk9e2ZpZWxkfSA+e2ZpZWxkfTwvb3B0aW9uPjtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0RW51bTtcbiIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIElucHV0SGlkZGVuIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBjb25zdCB7IGZpZWxkVmFsdWUgfSA9IHByb3BzLmRhdGE7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZmllbGRWYWx1ZTogZmllbGRWYWx1ZSA/IGZpZWxkVmFsdWUgOiAnJ1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICB2YXIgeyBmaWVsZFZhbHVlIH0gPSBuZXh0UHJvcHMuZGF0YTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IGZpZWxkVmFsdWUgPyBmaWVsZFZhbHVlIDogJydcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHsgZmllbGROYW1lIH0gPSB0aGlzLnByb3BzLmRhdGEsXG4gICAgICAgICAgICB7IGZpZWxkVmFsdWUgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgcmV0dXJuIDxpbnB1dFxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgIG5hbWU9e2ZpZWxkTmFtZX1cbiAgICAgICAgICAgIHZhbHVlPXtmaWVsZFZhbHVlfVxuICAgICAgICAgICAgcmVhZE9ubHk9XCJyZWFkT25seVwiXG4gICAgICAgICAgICB0eXBlPVwiaGlkZGVuXCJcbiAgICAgICAgLz47XG4gICAgfVxufVxuXG5JbnB1dEhpZGRlbi5wcm9wVHlwZXMgPSB7XG4gICAgZGF0YTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgICAgZmllbGROYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBmaWVsZFZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nXG4gICAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5wdXRIaWRkZW47XG4iLCJpbXBvcnQgSW5wdXRNdWx0aXNlbGVjdCBmcm9tICcuL211bHRpc2VsZWN0LmpzJztcblxudmFyIGpRdWVyeVBsdWdpbnMgPSByZXF1aXJlKCcuLi8uLi8uLi9SZXNvdXJjZXMvcHVibGljL2pzL21vZHVsZXMvanF1ZXJ5L2pxdWVyeS1wbHVnaW5zJykualF1ZXJ5UGx1Z2lucyxcbiAgICAkID0galF1ZXJ5O1xuXG5jbGFzcyBJbnB1dE11bHRpc2VsZWN0U2VhcmNoYWJsZSBleHRlbmRzIElucHV0TXVsdGlzZWxlY3Qge1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCAkc2VsZWN0ID0gJChSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSkuZmluZCgnc2VsZWN0JyksXG4gICAgICAgICAgICB7IGlzUmVhZE9ubHkgfSA9IHRoaXMucHJvcHMuZGF0YTtcbiAgICAgICAgalF1ZXJ5UGx1Z2lucy5zZWFyY2hhYmxlU2VsZWN0KCRzZWxlY3QsIGlzUmVhZE9ubHkpO1xuICAgICAgICAkc2VsZWN0Lm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiBTZWFyY2hhYmxlU2VsZWN0VXBkYXRlKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtlZENoYW5nZS5hcHBseSh0aGlzLCBbZXZlbnRdKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICBqUXVlcnlQbHVnaW5zLnNlYXJjaGFibGVTZWxlY3RVcGRhdGUoJChSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSkuZmluZCgnc2VsZWN0JyksIHRoaXMucHJvcHMuZGF0YS5pc1JlYWRPbmx5KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0TXVsdGlzZWxlY3RTZWFyY2hhYmxlOyIsImltcG9ydCBJbnB1dFJlYWRPbmx5IGZyb20gJy4vcmVhZC1vbmx5LmpzeCc7XG5pbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcblxudmFyIGkxOG4gPSByZXF1aXJlKCcuLi8uLi8uLi9SZXNvdXJjZXMvcHVibGljL2pzL3NlY3Rpb25zL2kxOG4nKS5pMThuO1xuXG5jbGFzcyBJbnB1dE11bHRpc2VsZWN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBjb25zdCB7IGZpZWxkVmFsdWUgfSA9IHByb3BzLmRhdGE7XG5cbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBmaWVsZFZhbHVlOiBmaWVsZFZhbHVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgZmllbGRWYWx1ZSB9ID0gbmV4dFByb3BzLmRhdGE7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBmaWVsZFZhbHVlOiBmaWVsZFZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsaW5rZWRDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRWYWx1ZXMgPSBbLi4uZXZlbnQudGFyZ2V0Lm9wdGlvbnNdXG4gICAgICAgICAgICAuZmlsdGVyKG9wdGlvbiA9PiBvcHRpb24uc2VsZWN0ZWQpXG4gICAgICAgICAgICAubWFwKG9wdGlvbiA9PiBvcHRpb24udmFsdWUpO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZmllbGRWYWx1ZTogc2VsZWN0ZWRWYWx1ZXNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgZmllbGROYW1lLCBmaWVsZFZhbHVlcywgaXNOdWxsYWJsZSwgaXNSZWFkT25seSB9ID0gdGhpcy5wcm9wcy5kYXRhLFxuICAgICAgICAgICAgeyBmaWVsZFZhbHVlIH0gPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgc2VsZWN0ZWRJdGVtcyxcbiAgICAgICAgICAgIHNlbGVjdGVkSXRlbXNBc1N0cmluZyxcbiAgICAgICAgICAgIGZpZWxkVmFsdWVEZXNjcmlwdGlvbiA9IFtdLFxuICAgICAgICAgICAgZXh0cmFJbnB1dCA9IG51bGwsXG4gICAgICAgICAgICBvcHRpb25zID0gW10sXG4gICAgICAgICAgICBzZWxlY3RDbGFzc05hbWUgPSAnZm9ybS1jb250cm9sJztcblxuICAgICAgICBzZWxlY3RlZEl0ZW1zID0gZmllbGRWYWx1ZSAhPT0gbnVsbCA/IGZpZWxkVmFsdWUgOiBbXTtcbiAgICAgICAgc2VsZWN0ZWRJdGVtc0FzU3RyaW5nID0gc2VsZWN0ZWRJdGVtcy5qb2luKCk7XG5cbiAgICAgICAgaWYgKGlzTnVsbGFibGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaCh7IGlkOiAnJywgdGl0bGU6ICcnIH0pO1xuICAgICAgICB9XG4gICAgICAgIF8uZWFjaChmaWVsZFZhbHVlcywgZnVuY3Rpb24gZm9yRWFjaEZpZWxkVmFsdWUob3B0aW9uRGlzcGxheSwgb3B0aW9uVmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IG9wdGlvblZhbHVlLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBvcHRpb25EaXNwbGF5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEl0ZW1zLmluZGV4T2Yob3B0aW9uVmFsdWUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlRGVzY3JpcHRpb24ucHVzaChvcHRpb25EaXNwbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgIGV4dHJhSW5wdXQgPSA8SW5wdXRSZWFkT25seSBmaWVsZFZhbHVlPXtmaWVsZFZhbHVlRGVzY3JpcHRpb24uam9pbignLCAnKX0gLz47XG4gICAgICAgICAgICBzZWxlY3RDbGFzc05hbWUgKz0gJyBoaWRkZW4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXh0cmFJbnB1dCA9IDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT17ZmllbGROYW1lfSB2YWx1ZT17c2VsZWN0ZWRJdGVtc0FzU3RyaW5nfSAvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIHtleHRyYUlucHV0fVxuICAgICAgICAgICAgICAgIDxzZWxlY3RcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGU9e3RydWV9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtzZWxlY3RlZEl0ZW1zfVxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5saW5rZWRDaGFuZ2UuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzZWxlY3RDbGFzc05hbWV9XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtpc1JlYWRPbmx5fVxuICAgICAgICAgICAgICAgICAgICBkYXRhLXBsYWNlaG9sZGVyPXtpMThuLnQoJ3NlbGVjdF9hbl9vcHRpb24nKX0+XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWFwKGZ1bmN0aW9uIERyb3BEb3duRm9yRWFjaChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB7IGlkLCB0aXRsZSB9ID0gZmllbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxvcHRpb24gdmFsdWU9e2lkfSBrZXk9e2lkfSA+e3RpdGxlfTwvb3B0aW9uPjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5wdXRNdWx0aXNlbGVjdDsiLCJcbmltcG9ydCBJbnB1dFRleHQgZnJvbSAnLi90ZXh0LmpzeCc7XG5cbmNsYXNzIElucHV0TnVtZXJpYyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgeyBkYXRhIH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgeyBmaWVsZE5hbWUgfSA9IHRoaXMucHJvcHMuZGF0YTtcblxuICAgICAgICByZXR1cm4gPElucHV0VGV4dCBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0gLz5cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0TnVtZXJpYztcbiIsIlxuaW1wb3J0IElucHV0VGV4dCBmcm9tICcuL3RleHQuanN4JztcblxuY2xhc3MgSW5wdXRQYXNzd29yZCBleHRlbmRzIElucHV0VGV4dCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgeyBkYXRhIH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgeyBmaWVsZE5hbWUgfSA9IHRoaXMucHJvcHMuZGF0YTtcblxuICAgICAgICByZXR1cm4gPElucHV0VGV4dCBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0gLz5cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0UGFzc3dvcmQ7XG4iLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5jbGFzcyBJbnB1dFJlYWRPbmx5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciB7IGZpZWxkVmFsdWUgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKCFmaWVsZFZhbHVlKSB7XG4gICAgICAgICAgICBmaWVsZFZhbHVlID0gJy0nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICg8ZGl2IGNsYXNzTmFtZT1cImZvcm0tY29udHJvbCBnYy1yZWFkLW9ubHktaW5wdXRcIj57ZmllbGRWYWx1ZX08L2Rpdj4pO1xuICAgIH1cbn1cblxuSW5wdXRSZWFkT25seS5wcm9wVHlwZXMgPSB7XG4gICAgZmllbGRWYWx1ZTogUHJvcFR5cGVzLnN0cmluZ1xufVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dFJlYWRPbmx5O1xuIiwiXG5pbXBvcnQgTGlua2VkVmFsdWUgZnJvbSAnLi4vY29tcG9uZW50cy9saW5rZWQtdmFsdWUuanMnO1xuXG5jbGFzcyBJbnB1dFJlbGF0aW9uTnRvTiBleHRlbmRzIExpbmtlZFZhbHVlIHtcbiAgICBsaW5rZWRDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkVmFsdWVzID0gWy4uLmV2ZW50LnRhcmdldC5vcHRpb25zXVxuICAgICAgICAgICAgLmZpbHRlcihvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKVxuICAgICAgICAgICAgLm1hcChvcHRpb24gPT4gb3B0aW9uLnZhbHVlKTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IHNlbGVjdGVkVmFsdWVzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciB7IGZpZWxkTmFtZSwgZmllbGRWYWx1ZXMsIGlzUmVhZE9ubHkgfSA9IHRoaXMucHJvcHMuZGF0YSxcbiAgICAgICAgICAgIHsgZmllbGRWYWx1ZSB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBbXTtcblxuICAgICAgICBmaWVsZFZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIGZvckVhY2hGaWVsZFZhbHVlKG9wdGlvblZhbHVlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2gob3B0aW9uVmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxzZWxlY3QgbmFtZT17ZmllbGROYW1lfSBtdWx0aXBsZT1cIm11bHRpcGxlXCIgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzUmVhZE9ubHl9IHZhbHVlPXtmaWVsZFZhbHVlfSBvbkNoYW5nZT17dGhpcy5saW5rZWRDaGFuZ2UuYmluZCh0aGlzKX0+XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1hcChmdW5jdGlvbiBEcm9wRG93bkZvckVhY2goZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB7IGlkLCB0aXRsZSB9ID0gZmllbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPG9wdGlvbiB2YWx1ZT17aWR9IGtleT17aWR9Pnt0aXRsZX08L29wdGlvbj47XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dFJlbGF0aW9uTnRvTjtcbiIsIlxuXG5pbXBvcnQgTGlua2VkVmFsdWUgZnJvbSAnLi4vY29tcG9uZW50cy9saW5rZWQtdmFsdWUuanMnO1xuaW1wb3J0IElucHV0UmVhZE9ubHkgZnJvbSAnLi9yZWFkLW9ubHkuanN4JztcblxuY2xhc3MgSW5wdXRSZWxhdGlvbmFsTmF0aXZlIGV4dGVuZHMgTGlua2VkVmFsdWUge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHsgZmllbGROYW1lLCBmaWVsZFZhbHVlcywgaXNOdWxsYWJsZSwgaXNSZWFkT25seSB9ID0gdGhpcy5wcm9wcy5kYXRhLFxuICAgICAgICAgICAgeyBmaWVsZFZhbHVlIH0gPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgZmllbGRWYWx1ZURlc2NyaXB0aW9uID0gJycsXG4gICAgICAgICAgICBvcHRpb25zID0gW107XG5cbiAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdWxsYWJsZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wdXNoKHsgaWQ6ICcnLCB0aXRsZTogJycgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmllbGRWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiBmb3JFYWNoRmllbGRWYWx1ZShvcHRpb25WYWx1ZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wdXNoKG9wdGlvblZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvblZhbHVlLmlkID09PSBmaWVsZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZURlc2NyaXB0aW9uID0gb3B0aW9uVmFsdWUudGl0bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpc1JlYWRPbmx5KSB7XG4gICAgICAgICAgICByZXR1cm4gPElucHV0UmVhZE9ubHkgZmllbGRWYWx1ZT17ZmllbGRWYWx1ZURlc2NyaXB0aW9ufSAvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8c2VsZWN0IG5hbWU9e2ZpZWxkTmFtZX1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2ZpZWxkVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtpc1JlYWRPbmx5fVxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5saW5rZWRDaGFuZ2UuYmluZCh0aGlzKX0+XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1hcChmdW5jdGlvbiBEcm9wRG93bkZvckVhY2goZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB7IGlkLCB0aXRsZSB9ID0gZmllbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPG9wdGlvbiB2YWx1ZT17aWR9IGtleT17aWR9ID57dGl0bGV9PC9vcHRpb24+O1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5wdXRSZWxhdGlvbmFsTmF0aXZlO1xuIiwiXG5cbmltcG9ydCBMaW5rZWRWYWx1ZSBmcm9tICcuLi9jb21wb25lbnRzL2xpbmtlZC12YWx1ZS5qcyc7XG5pbXBvcnQgSW5wdXRSZWFkT25seSBmcm9tICcuL3JlYWQtb25seS5qc3gnO1xuXG52YXIgalF1ZXJ5UGx1Z2lucyA9IHJlcXVpcmUoJy4uLy4uLy4uL1Jlc291cmNlcy9wdWJsaWMvanMvbW9kdWxlcy9qcXVlcnkvanF1ZXJ5LXBsdWdpbnMnKS5qUXVlcnlQbHVnaW5zLFxuICAgICQgPSBqUXVlcnksXG4gICAgaTE4biA9IHJlcXVpcmUoJy4uLy4uLy4uL1Jlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvaTE4bicpLmkxOG47XG5cbmNsYXNzIElucHV0UmVsYXRpb25hbFNlYXJjaGFibGUgZXh0ZW5kcyBMaW5rZWRWYWx1ZSB7XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGpRdWVyeVBsdWdpbnMuc2VhcmNoYWJsZVNlbGVjdCgkKFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKS5maW5kKCdzZWxlY3QnKSwgdGhpcy5wcm9wcy5kYXRhLmlzUmVhZE9ubHkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIGpRdWVyeVBsdWdpbnMuc2VhcmNoYWJsZVNlbGVjdFVwZGF0ZSgkKFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKS5maW5kKCdzZWxlY3QnKSwgdGhpcy5wcm9wcy5kYXRhLmlzUmVhZE9ubHkpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciB7IGZpZWxkTmFtZSwgZmllbGRWYWx1ZSwgZmllbGRWYWx1ZXMsIGlzTnVsbGFibGUsIGlzUmVhZE9ubHkgfSA9IHRoaXMucHJvcHMuZGF0YSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBbXSxcbiAgICAgICAgICAgIGZpZWxkVmFsdWVEZXNjcmlwdGlvbiA9ICcnLFxuICAgICAgICAgICAgZXh0cmFJbnB1dCA9ICcnO1xuXG4gICAgICAgIGlmIChmaWVsZFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICBmaWVsZFZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVsbGFibGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaCh7IGlkOiAnJywgdGl0bGU6ICcnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkVmFsdWVzLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaEZpZWxkVmFsdWUob3B0aW9uVmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaChvcHRpb25WYWx1ZSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25WYWx1ZS5pZCA9PT0gZmllbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWVEZXNjcmlwdGlvbiA9IG9wdGlvblZhbHVlLnRpdGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgIGV4dHJhSW5wdXQgPSA8SW5wdXRSZWFkT25seSBmaWVsZFZhbHVlPXtmaWVsZFZhbHVlRGVzY3JpcHRpb259IC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAge2V4dHJhSW5wdXR9XG4gICAgICAgICAgICAgICAgPHNlbGVjdCBuYW1lPXtmaWVsZE5hbWV9IHZhbHVlPXtmaWVsZFZhbHVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCIgZGlzYWJsZWQ9e2lzUmVhZE9ubHl9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5saW5rZWRDaGFuZ2UuYmluZCh0aGlzKX0gZGF0YS1wbGFjZWhvbGRlcj17aTE4bi50KCdzZWxlY3RfYW5fb3B0aW9uJyl9PlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1hcChmdW5jdGlvbiBEcm9wRG93bkZvckVhY2goZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeyBpZCwgdGl0bGUgfSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8b3B0aW9uIHZhbHVlPXtpZH0ga2V5PXtpZH0gPnt0aXRsZX08L29wdGlvbj47XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0UmVsYXRpb25hbFNlYXJjaGFibGU7XG4iLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IElucHV0UmVhZE9ubHkgZnJvbSAnLi9yZWFkLW9ubHkuanN4JztcblxuY2xhc3MgUmljaFRleHRlZGl0b3JSZWFkT25seSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcHJldmlld0FzSHRtbDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b2dnbGVQcmV2aWV3QXNIdG1sKCkge1xuICAgICAgICBjb25zdCB7IHByZXZpZXdBc0h0bWwgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgcHJldmlld0FzSHRtbDogIXByZXZpZXdBc0h0bWxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGZpZWxkVmFsdWUsIGkxOG4gfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICB7IHByZXZpZXdBc0h0bWwgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgaWYgKCFmaWVsZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gPElucHV0UmVhZE9ubHkgLz5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8UmVhY3QuRnJhZ21lbnQ+XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aWV3QXNIdG1sID9cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnYy1odG1sLXByZXZpZXdcIiBkYW5nZXJvdXNseVNldElubmVySFRNTD17e19faHRtbDogZmllbGRWYWx1ZX19PjwvZGl2PiA6XG4gICAgICAgICAgICAgICAgICAgIDxwcmUgY2xhc3NOYW1lPVwiZ2MtcmljaC10ZXh0ZWRpdG9yLXJlYWQtb25seVwiPntmaWVsZFZhbHVlfTwvcHJlPlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMudG9nZ2xlUHJldmlld0FzSHRtbC5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1vdXRsaW5lLWRhcmtcIlxuICAgICAgICAgICAgICAgID57cHJldmlld0FzSHRtbCA/IGkxOG4ucHJldmlld19hc19wbGFpbl90ZXh0IDogaTE4bi5wcmV2aWV3X2FzX2h0bWx9PC9idXR0b24+XG4gICAgICAgICAgICA8L1JlYWN0LkZyYWdtZW50PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuUmljaFRleHRlZGl0b3JSZWFkT25seS5wcm9wVHlwZXMgPSB7XG4gICAgZmllbGRWYWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBpMThuOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgICBwcmV2aWV3X2FzX3BsYWluX3RleHQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHByZXZpZXdfYXNfaHRtbDogUHJvcFR5cGVzLnN0cmluZ1xuICAgIH0pXG59O1xuXG5SaWNoVGV4dGVkaXRvclJlYWRPbmx5LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBpMThuOiB7XG4gICAgICAgIHByZXZpZXdfYXNfcGxhaW5fdGV4dDogJ1ByZXZpZXcgYXMgcGxhaW4gdGV4dCcsXG4gICAgICAgIHByZXZpZXdfYXNfaHRtbDogJ1ByZXZpZXcgYXMgSFRNTCdcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJpY2hUZXh0ZWRpdG9yUmVhZE9ubHk7XG4iLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5jb25zdCBqUXVlcnlQbHVnaW5zID0gcmVxdWlyZSgnLi4vLi4vLi4vUmVzb3VyY2VzL3B1YmxpYy9qcy9tb2R1bGVzL2pxdWVyeS9qcXVlcnktcGx1Z2lucycpLmpRdWVyeVBsdWdpbnMsXG4gICAgJCA9IGpRdWVyeTtcblxuY2xhc3MgUmljaFRleHRlZGl0b3JXaXRoUGx1Z2luIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IHByb3BzLmZpZWxkVmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBmaWVsZE5hbWUsIGZpZWxkVmFsdWUgfSA9IG5leHRQcm9wcztcbiAgICAgICAgalF1ZXJ5UGx1Z2lucy51cGRhdGVUZXh0ZWRpdG9yKGZpZWxkTmFtZSwgZmllbGRWYWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZmllbGRWYWx1ZTogZmllbGRWYWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGlua2VkQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZmllbGRWYWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyBmaWVsZE5hbWUsIGZpZWxkVmFsdWUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGpRdWVyeVBsdWdpbnMudGV4dGVkaXRvcigkKFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKSwgZmllbGROYW1lLCBmaWVsZFZhbHVlKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHsgZmllbGROYW1lIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBqUXVlcnlQbHVnaW5zLmRlc3Ryb3lUZXh0ZWRpdG9yKGZpZWxkTmFtZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBmaWVsZE5hbWUgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICB7IGZpZWxkVmFsdWUgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgcmV0dXJuIDx0ZXh0YXJlYVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgIG5hbWU9e2ZpZWxkTmFtZX1cbiAgICAgICAgICAgIHZhbHVlPXtmaWVsZFZhbHVlfVxuICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMubGlua2VkQ2hhbmdlLmJpbmQodGhpcyl9XG4gICAgICAgIC8+O1xuICAgIH1cbn1cblxuUmljaFRleHRlZGl0b3JXaXRoUGx1Z2luLnByb3BUeXBlcyA9IHtcbiAgICBmaWVsZE5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgZmllbGRWYWx1ZTogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgUmljaFRleHRlZGl0b3JXaXRoUGx1Z2luOyIsImltcG9ydCBSaWNoVGV4dGVkaXRvcldpdGhQbHVnaW4gZnJvbSAnLi9yaWNoLXRleHRlZGl0b3Itd2l0aC1wbHVnaW4nO1xuaW1wb3J0IFJpY2hUZXh0ZWRpdG9yUmVhZE9ubHkgZnJvbSAnLi9yaWNoLXRleHRlZGl0b3ItcmVhZC1vbmx5LmpzeCc7XG5cbmNvbnN0IGkxOG4gPSByZXF1aXJlKCcuLi8uLi8uLi9SZXNvdXJjZXMvcHVibGljL2pzL3NlY3Rpb25zL2kxOG4nKS5pMThuO1xuXG5jbGFzcyBJbnB1dFJpY2hUZXh0ZWRpdG9yIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgZmllbGROYW1lLCBmaWVsZFZhbHVlLCBpc1JlYWRPbmx5IH0gPSB0aGlzLnByb3BzLmRhdGE7XG5cbiAgICAgICAgaWYgKGlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybiA8UmljaFRleHRlZGl0b3JSZWFkT25seVxuICAgICAgICAgICAgICAgIGkxOG49e2kxOG4udHJhbnNsYXRpb25zfVxuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWU9e2ZpZWxkVmFsdWV9XG4gICAgICAgICAgICAvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiA8UmljaFRleHRlZGl0b3JXaXRoUGx1Z2luXG4gICAgICAgICAgICBmaWVsZE5hbWU9e2ZpZWxkTmFtZX1cbiAgICAgICAgICAgIGZpZWxkVmFsdWU9e2ZpZWxkVmFsdWV9XG4gICAgICAgIC8+O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5wdXRSaWNoVGV4dGVkaXRvcjtcbiIsIlxuXG5pbXBvcnQgTGlua2VkVmFsdWUgZnJvbSAnLi4vY29tcG9uZW50cy9saW5rZWQtdmFsdWUuanMnO1xuXG52YXIgalF1ZXJ5UGx1Z2lucyA9IHJlcXVpcmUoJy4uLy4uLy4uL1Jlc291cmNlcy9wdWJsaWMvanMvbW9kdWxlcy9qcXVlcnkvanF1ZXJ5LXBsdWdpbnMnKS5qUXVlcnlQbHVnaW5zLFxuICAgICQgPSBqUXVlcnksXG4gICAgaTE4biA9IHJlcXVpcmUoJy4uLy4uLy4uL1Jlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvaTE4bicpLmkxOG47XG5cbmNsYXNzIElucHV0U2VhcmNoYWJsZVJlbGF0aW9uTnRvTiBleHRlbmRzIExpbmtlZFZhbHVlIHtcbiAgICBsaW5rZWRDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkVmFsdWVzID0gWy4uLmV2ZW50LnRhcmdldC5vcHRpb25zXVxuICAgICAgICAgICAgLmZpbHRlcihvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKVxuICAgICAgICAgICAgLm1hcChvcHRpb24gPT4gb3B0aW9uLnZhbHVlKTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IHNlbGVjdGVkVmFsdWVzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgalF1ZXJ5UGx1Z2lucy5zZWFyY2hhYmxlU2VsZWN0KCQoUmVhY3RET00uZmluZERPTU5vZGUodGhpcykpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICBqUXVlcnlQbHVnaW5zLnNlYXJjaGFibGVTZWxlY3RVcGRhdGUoJChSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSkpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgZmllbGROYW1lLCBmaWVsZFZhbHVlcywgaXNSZWFkT25seSB9ID0gdGhpcy5wcm9wcy5kYXRhO1xuICAgICAgICBsZXQgeyBmaWVsZFZhbHVlIH0gPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgb3B0aW9ucyA9IFtdO1xuXG4gICAgICAgIGZpZWxkVmFsdWVzLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaEZpZWxkVmFsdWUob3B0aW9uVmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaChvcHRpb25WYWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghZmllbGRWYWx1ZSkge1xuICAgICAgICAgICAgZmllbGRWYWx1ZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxzZWxlY3QgbmFtZT17ZmllbGROYW1lfSBtdWx0aXBsZT1cIm11bHRpcGxlXCIgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzUmVhZE9ubHl9IHZhbHVlPXtmaWVsZFZhbHVlfSBvbkNoYW5nZT17dGhpcy5saW5rZWRDaGFuZ2UuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICAgICAgZGF0YS1wbGFjZWhvbGRlcj17aTE4bi50KCdzZWxlY3Rfc29tZV9vcHRpb25zJyl9PlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tYXAoZnVuY3Rpb24gRHJvcERvd25Gb3JFYWNoKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeyBpZCwgdGl0bGUgfSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxvcHRpb24gdmFsdWU9e2lkfSBrZXk9e2lkfT57dGl0bGV9PC9vcHRpb24+O1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5wdXRTZWFyY2hhYmxlUmVsYXRpb25OdG9OO1xuIiwiaW1wb3J0IElucHV0UmVhZE9ubHkgZnJvbSAnLi9yZWFkLW9ubHkuanN4JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIElucHV0VGV4dCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgdmFyIHsgZmllbGRWYWx1ZSB9ID0gcHJvcHMuZGF0YTtcblxuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IGZpZWxkVmFsdWUgPyBmaWVsZFZhbHVlIDogJydcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgdmFyIHsgZmllbGRWYWx1ZSB9ID0gbmV4dFByb3BzLmRhdGE7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBmaWVsZFZhbHVlOiBmaWVsZFZhbHVlID8gZmllbGRWYWx1ZSA6ICcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsaW5rZWRDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBmaWVsZFZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldElucHV0VHlwZShmaWVsZFR5cGUpIHtcbiAgICAgICAgaWYgKC9eKGVtYWlsfHVybHxjb2xvcnxwYXNzd29yZCkkLy50ZXN0KGZpZWxkVHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZFR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL14oaW50fG51bWVyaWMpJC8udGVzdChmaWVsZFR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ3RleHQnO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciB7IGZpZWxkTmFtZSwgaXNSZWFkT25seSwgZmllbGRUeXBlIH0gPSB0aGlzLnByb3BzLmRhdGEsXG4gICAgICAgICAgICB7IGZpZWxkVmFsdWUgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgaWYgKGlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybiA8SW5wdXRSZWFkT25seSBmaWVsZFZhbHVlPXtmaWVsZFZhbHVlfSAvPlxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDxpbnB1dFxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgIG5hbWU9e2ZpZWxkTmFtZX1cbiAgICAgICAgICAgIHR5cGU9e3RoaXMuZ2V0SW5wdXRUeXBlKGZpZWxkVHlwZSl9XG4gICAgICAgICAgICByZWFkT25seT17aXNSZWFkT25seX1cbiAgICAgICAgICAgIHZhbHVlPXtmaWVsZFZhbHVlfVxuICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMubGlua2VkQ2hhbmdlLmJpbmQodGhpcyl9IC8+O1xuICAgIH1cbn1cblxuSW5wdXRUZXh0LnByb3BUeXBlcyA9IHtcbiAgICBkYXRhOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgICBmaWVsZE5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGlzUmVhZE9ubHk6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBmaWVsZFR5cGU6IFByb3BUeXBlcy5zdHJpbmdcbiAgICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dFRleHQ7XG4iLCJcbmltcG9ydCBJbnB1dFJlYWRPbmx5IGZyb20gJy4vcmVhZC1vbmx5LmpzeCc7XG5cbmNsYXNzIElucHV0VGV4dGFyZWEgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHZhciB7IGZpZWxkVmFsdWUgfSA9IHByb3BzLmRhdGE7XG5cbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBmaWVsZFZhbHVlOiBmaWVsZFZhbHVlID8gZmllbGRWYWx1ZSA6ICcnXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIHZhciB7IGZpZWxkVmFsdWUgfSA9IG5leHRQcm9wcy5kYXRhO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZmllbGRWYWx1ZTogZmllbGRWYWx1ZSA/IGZpZWxkVmFsdWUgOiAnJ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGlua2VkQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZmllbGRWYWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciB7IGZpZWxkTmFtZSwgaXNSZWFkT25seSB9ID0gdGhpcy5wcm9wcy5kYXRhLFxuICAgICAgICAgICAgeyBmaWVsZFZhbHVlIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIGlmIChpc1JlYWRPbmx5KSB7XG4gICAgICAgICAgICByZXR1cm4gPElucHV0UmVhZE9ubHkgZmllbGRWYWx1ZT17ZmllbGRWYWx1ZX0gLz47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gPHRleHRhcmVhXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2xcIlxuICAgICAgICAgICAgbmFtZT17ZmllbGROYW1lfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e2lzUmVhZE9ubHl9XG4gICAgICAgICAgICB2YWx1ZT17ZmllbGRWYWx1ZX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmxpbmtlZENoYW5nZS5iaW5kKHRoaXMpfSAvPjtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0VGV4dGFyZWE7XG4iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInByb3AtdHlwZXNcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiRHJvcHpvbmVcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJEcm9wem9uZVwiXSA9IGZhY3Rvcnkocm9vdFtcInByb3AtdHlwZXNcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yX18pIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKHByb2Nlc3MpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9wcm9wVHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9zdHlsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX3N0eWxlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHlsZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8qIGVzbGludCBwcmVmZXItdGVtcGxhdGU6IDAgKi9cblxuLy9pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cblxudmFyIERyb3B6b25lID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKERyb3B6b25lLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBEcm9wem9uZShwcm9wcywgY29udGV4dCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcm9wem9uZSk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRHJvcHpvbmUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEcm9wem9uZSkpLmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpKTtcblxuICAgIF90aGlzLnJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBpc0RyYWdBY3RpdmUsIGlzRHJhZ0FjY2VwdCwgaXNEcmFnUmVqZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbihfZXh0ZW5kcyh7fSwgX3RoaXMuc3RhdGUsIHtcbiAgICAgICAgICBpc0RyYWdBY3RpdmU6IGlzRHJhZ0FjdGl2ZSxcbiAgICAgICAgICBpc0RyYWdBY2NlcHQ6IGlzRHJhZ0FjY2VwdCxcbiAgICAgICAgICBpc0RyYWdSZWplY3Q6IGlzRHJhZ1JlamVjdFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfTtcblxuICAgIF90aGlzLmNvbXBvc2VIYW5kbGVycyA9IF90aGlzLmNvbXBvc2VIYW5kbGVycy5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5vbkNsaWNrID0gX3RoaXMub25DbGljay5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5vbkRvY3VtZW50RHJvcCA9IF90aGlzLm9uRG9jdW1lbnREcm9wLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLm9uRHJhZ0VudGVyID0gX3RoaXMub25EcmFnRW50ZXIuYmluZChfdGhpcyk7XG4gICAgX3RoaXMub25EcmFnTGVhdmUgPSBfdGhpcy5vbkRyYWdMZWF2ZS5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5vbkRyYWdPdmVyID0gX3RoaXMub25EcmFnT3Zlci5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5vbkRyYWdTdGFydCA9IF90aGlzLm9uRHJhZ1N0YXJ0LmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLm9uRHJvcCA9IF90aGlzLm9uRHJvcC5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5vbkZpbGVEaWFsb2dDYW5jZWwgPSBfdGhpcy5vbkZpbGVEaWFsb2dDYW5jZWwuYmluZChfdGhpcyk7XG4gICAgX3RoaXMub25JbnB1dEVsZW1lbnRDbGljayA9IF90aGlzLm9uSW5wdXRFbGVtZW50Q2xpY2suYmluZChfdGhpcyk7XG5cbiAgICBfdGhpcy5zZXRSZWYgPSBfdGhpcy5zZXRSZWYuYmluZChfdGhpcyk7XG4gICAgX3RoaXMuc2V0UmVmcyA9IF90aGlzLnNldFJlZnMuYmluZChfdGhpcyk7XG5cbiAgICBfdGhpcy5pc0ZpbGVEaWFsb2dBY3RpdmUgPSBmYWxzZTtcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgZHJhZ2dlZEZpbGVzOiBbXSxcbiAgICAgIGFjY2VwdGVkRmlsZXM6IFtdLFxuICAgICAgcmVqZWN0ZWRGaWxlczogW11cbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEcm9wem9uZSwgW3tcbiAgICBrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdmFyIHByZXZlbnREcm9wT25Eb2N1bWVudCA9IHRoaXMucHJvcHMucHJldmVudERyb3BPbkRvY3VtZW50O1xuXG4gICAgICB0aGlzLmRyYWdUYXJnZXRzID0gW107XG5cbiAgICAgIGlmIChwcmV2ZW50RHJvcE9uRG9jdW1lbnQpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCBfdXRpbHMub25Eb2N1bWVudERyYWdPdmVyLCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzLm9uRG9jdW1lbnREcm9wLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmZpbGVJbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbklucHV0RWxlbWVudENsaWNrLCBmYWxzZSk7XG4gICAgICAvLyBUcmllZCBpbXBsZW1lbnRpbmcgYWRkRXZlbnRMaXN0ZW5lciwgYnV0IGRpZG4ndCB3b3JrIG91dFxuICAgICAgZG9jdW1lbnQuYm9keS5vbmZvY3VzID0gdGhpcy5vbkZpbGVEaWFsb2dDYW5jZWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50V2lsbFVubW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHZhciBwcmV2ZW50RHJvcE9uRG9jdW1lbnQgPSB0aGlzLnByb3BzLnByZXZlbnREcm9wT25Eb2N1bWVudDtcblxuICAgICAgaWYgKHByZXZlbnREcm9wT25Eb2N1bWVudCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIF91dGlscy5vbkRvY3VtZW50RHJhZ092ZXIpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgdGhpcy5vbkRvY3VtZW50RHJvcCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZpbGVJbnB1dEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbklucHV0RWxlbWVudENsaWNrLCBmYWxzZSk7XG4gICAgICAvLyBDYW4gYmUgcmVwbGFjZWQgd2l0aCByZW1vdmVFdmVudExpc3RlbmVyLCBpZiBhZGRFdmVudExpc3RlbmVyIHdvcmtzXG4gICAgICBkb2N1bWVudC5ib2R5Lm9uZm9jdXMgPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvc2VIYW5kbGVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvc2VIYW5kbGVycyhoYW5kbGVyKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25Eb2N1bWVudERyb3AnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRvY3VtZW50RHJvcChldnQpIHtcbiAgICAgIGlmICh0aGlzLm5vZGUuY29udGFpbnMoZXZ0LnRhcmdldCkpIHtcbiAgICAgICAgLy8gaWYgd2UgaW50ZXJjZXB0ZWQgYW4gZXZlbnQgZm9yIG91ciBpbnN0YW5jZSwgbGV0IGl0IHByb3BhZ2F0ZSBkb3duIHRvIHRoZSBpbnN0YW5jZSdzIG9uRHJvcCBoYW5kbGVyXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5kcmFnVGFyZ2V0cyA9IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRHJhZ1N0YXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnU3RhcnQoZXZ0KSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5vbkRyYWdTdGFydCkge1xuICAgICAgICB0aGlzLnByb3BzLm9uRHJhZ1N0YXJ0LmNhbGwodGhpcywgZXZ0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkRyYWdFbnRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhZ0VudGVyKGV2dCkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIC8vIENvdW50IHRoZSBkcm9wem9uZSBhbmQgYW55IGNoaWxkcmVuIHRoYXQgYXJlIGVudGVyZWQuXG4gICAgICBpZiAodGhpcy5kcmFnVGFyZ2V0cy5pbmRleE9mKGV2dC50YXJnZXQpID09PSAtMSkge1xuICAgICAgICB0aGlzLmRyYWdUYXJnZXRzLnB1c2goZXZ0LnRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc0RyYWdBY3RpdmU6IHRydWUsIC8vIERvIG5vdCByZWx5IG9uIGZpbGVzIGZvciB0aGUgZHJhZyBzdGF0ZS4gSXQgZG9lc24ndCB3b3JrIGluIFNhZmFyaS5cbiAgICAgICAgZHJhZ2dlZEZpbGVzOiAoMCwgX3V0aWxzLmdldERhdGFUcmFuc2Zlckl0ZW1zKShldnQpXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMucHJvcHMub25EcmFnRW50ZXIpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkRyYWdFbnRlci5jYWxsKHRoaXMsIGV2dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25EcmFnT3ZlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhZ092ZXIoZXZ0KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXZ0LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ2NvcHknOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wcm9wcy5vbkRyYWdPdmVyKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25EcmFnT3Zlci5jYWxsKHRoaXMsIGV2dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25EcmFnTGVhdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYWdMZWF2ZShldnQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgLy8gT25seSBkZWFjdGl2YXRlIG9uY2UgdGhlIGRyb3B6b25lIGFuZCBhbGwgY2hpbGRyZW4gaGF2ZSBiZWVuIGxlZnQuXG4gICAgICB0aGlzLmRyYWdUYXJnZXRzID0gdGhpcy5kcmFnVGFyZ2V0cy5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBlbCAhPT0gZXZ0LnRhcmdldCAmJiBfdGhpczIubm9kZS5jb250YWlucyhlbCk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLmRyYWdUYXJnZXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciBkcmFnZ2luZyBmaWxlcyBzdGF0ZVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzRHJhZ0FjdGl2ZTogZmFsc2UsXG4gICAgICAgIGRyYWdnZWRGaWxlczogW11cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5wcm9wcy5vbkRyYWdMZWF2ZSkge1xuICAgICAgICB0aGlzLnByb3BzLm9uRHJhZ0xlYXZlLmNhbGwodGhpcywgZXZ0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkRyb3AnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyb3AoZXZ0KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgb25Ecm9wID0gX3Byb3BzLm9uRHJvcCxcbiAgICAgICAgICBvbkRyb3BBY2NlcHRlZCA9IF9wcm9wcy5vbkRyb3BBY2NlcHRlZCxcbiAgICAgICAgICBvbkRyb3BSZWplY3RlZCA9IF9wcm9wcy5vbkRyb3BSZWplY3RlZCxcbiAgICAgICAgICBtdWx0aXBsZSA9IF9wcm9wcy5tdWx0aXBsZSxcbiAgICAgICAgICBkaXNhYmxlUHJldmlldyA9IF9wcm9wcy5kaXNhYmxlUHJldmlldyxcbiAgICAgICAgICBhY2NlcHQgPSBfcHJvcHMuYWNjZXB0O1xuXG4gICAgICB2YXIgZmlsZUxpc3QgPSAoMCwgX3V0aWxzLmdldERhdGFUcmFuc2Zlckl0ZW1zKShldnQpO1xuICAgICAgdmFyIGFjY2VwdGVkRmlsZXMgPSBbXTtcbiAgICAgIHZhciByZWplY3RlZEZpbGVzID0gW107XG5cbiAgICAgIC8vIFN0b3AgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yXG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgLy8gUmVzZXQgdGhlIGNvdW50ZXIgYWxvbmcgd2l0aCB0aGUgZHJhZyBvbiBhIGRyb3AuXG4gICAgICB0aGlzLmRyYWdUYXJnZXRzID0gW107XG4gICAgICB0aGlzLmlzRmlsZURpYWxvZ0FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICBmaWxlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgIGlmICghZGlzYWJsZVByZXZpZXcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmlsZS5wcmV2aWV3ID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZW5lcmF0ZSBwcmV2aWV3IGZvciBmaWxlJywgZmlsZSwgZXJyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCgwLCBfdXRpbHMuZmlsZUFjY2VwdGVkKShmaWxlLCBhY2NlcHQpICYmICgwLCBfdXRpbHMuZmlsZU1hdGNoU2l6ZSkoZmlsZSwgX3RoaXMzLnByb3BzLm1heFNpemUsIF90aGlzMy5wcm9wcy5taW5TaXplKSkge1xuICAgICAgICAgIGFjY2VwdGVkRmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3RlZEZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIW11bHRpcGxlKSB7XG4gICAgICAgIC8vIGlmIG5vdCBpbiBtdWx0aSBtb2RlIGFkZCBhbnkgZXh0cmEgYWNjZXB0ZWQgZmlsZXMgdG8gcmVqZWN0ZWQuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBhbGxvdyBlbmQgdXNlcnMgdG8gZWFzaWx5IGlnbm9yZSBhIG11bHRpIGZpbGUgZHJvcCBpbiBcInNpbmdsZVwiIG1vZGUuXG4gICAgICAgIHJlamVjdGVkRmlsZXMucHVzaC5hcHBseShyZWplY3RlZEZpbGVzLCBfdG9Db25zdW1hYmxlQXJyYXkoYWNjZXB0ZWRGaWxlcy5zcGxpY2UoMSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9uRHJvcCkge1xuICAgICAgICBvbkRyb3AuY2FsbCh0aGlzLCBhY2NlcHRlZEZpbGVzLCByZWplY3RlZEZpbGVzLCBldnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVqZWN0ZWRGaWxlcy5sZW5ndGggPiAwICYmIG9uRHJvcFJlamVjdGVkKSB7XG4gICAgICAgIG9uRHJvcFJlamVjdGVkLmNhbGwodGhpcywgcmVqZWN0ZWRGaWxlcywgZXZ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFjY2VwdGVkRmlsZXMubGVuZ3RoID4gMCAmJiBvbkRyb3BBY2NlcHRlZCkge1xuICAgICAgICBvbkRyb3BBY2NlcHRlZC5jYWxsKHRoaXMsIGFjY2VwdGVkRmlsZXMsIGV2dCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIGZpbGVzIHZhbHVlXG4gICAgICB0aGlzLmRyYWdnZWRGaWxlcyA9IG51bGw7XG5cbiAgICAgIC8vIFJlc2V0IGRyYWcgc3RhdGVcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc0RyYWdBY3RpdmU6IGZhbHNlLFxuICAgICAgICBkcmFnZ2VkRmlsZXM6IFtdLFxuICAgICAgICBhY2NlcHRlZEZpbGVzOiBhY2NlcHRlZEZpbGVzLFxuICAgICAgICByZWplY3RlZEZpbGVzOiByZWplY3RlZEZpbGVzXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkNsaWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25DbGljayhldnQpIHtcbiAgICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBvbkNsaWNrID0gX3Byb3BzMi5vbkNsaWNrLFxuICAgICAgICAgIGRpc2FibGVDbGljayA9IF9wcm9wczIuZGlzYWJsZUNsaWNrO1xuXG4gICAgICBpZiAoIWRpc2FibGVDbGljaykge1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICBvbkNsaWNrLmNhbGwodGhpcywgZXZ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluIElFMTEvRWRnZSB0aGUgZmlsZS1icm93c2VyIGRpYWxvZyBpcyBibG9ja2luZywgZW5zdXJlIHRoaXMgaXMgYmVoaW5kIHNldFRpbWVvdXRcbiAgICAgICAgLy8gdGhpcyBpcyBzbyByZWFjdCBjYW4gaGFuZGxlIHN0YXRlIGNoYW5nZXMgaW4gdGhlIG9uQ2xpY2sgcHJvcCBhYm92ZSBhYm92ZVxuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1kcm9wem9uZS9yZWFjdC1kcm9wem9uZS9pc3N1ZXMvNDUwXG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5vcGVuLmJpbmQodGhpcyksIDApO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uSW5wdXRFbGVtZW50Q2xpY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbklucHV0RWxlbWVudENsaWNrKGV2dCkge1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgaWYgKHRoaXMucHJvcHMuaW5wdXRQcm9wcyAmJiB0aGlzLnByb3BzLmlucHV0UHJvcHMub25DbGljaykge1xuICAgICAgICB0aGlzLnByb3BzLmlucHV0UHJvcHMub25DbGljaygpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRmlsZURpYWxvZ0NhbmNlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRmlsZURpYWxvZ0NhbmNlbCgpIHtcbiAgICAgIC8vIHRpbWVvdXQgd2lsbCBub3QgcmVjb2duaXplIGNvbnRleHQgb2YgdGhpcyBtZXRob2RcbiAgICAgIHZhciBvbkZpbGVEaWFsb2dDYW5jZWwgPSB0aGlzLnByb3BzLm9uRmlsZURpYWxvZ0NhbmNlbDtcbiAgICAgIHZhciBmaWxlSW5wdXRFbCA9IHRoaXMuZmlsZUlucHV0RWw7XG4gICAgICB2YXIgaXNGaWxlRGlhbG9nQWN0aXZlID0gdGhpcy5pc0ZpbGVEaWFsb2dBY3RpdmU7XG4gICAgICAvLyBleGVjdXRlIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIG9uRmlsZURpYWxvZ0NhbmNlbCBpcyBkZWZpbmVkIGFuZCBGaWxlRGlhbG9nXG4gICAgICAvLyBpcyBvcGVuZWQgaW4gdGhlIGJyb3dzZXJcblxuICAgICAgaWYgKG9uRmlsZURpYWxvZ0NhbmNlbCAmJiBpc0ZpbGVEaWFsb2dBY3RpdmUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gUmV0dXJucyBhbiBvYmplY3QgYXMgRmlsZUxpc3RcbiAgICAgICAgICB2YXIgRmlsZUxpc3QgPSBmaWxlSW5wdXRFbC5maWxlcztcbiAgICAgICAgICBpZiAoIUZpbGVMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgaXNGaWxlRGlhbG9nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBvbkZpbGVEaWFsb2dDYW5jZWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0UmVmJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UmVmKHJlZikge1xuICAgICAgdGhpcy5ub2RlID0gcmVmO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFJlZnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRSZWZzKHJlZikge1xuICAgICAgdGhpcy5maWxlSW5wdXRFbCA9IHJlZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbiBzeXN0ZW0gZmlsZSB1cGxvYWQgZGlhbG9nLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvcGVuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgIHRoaXMuaXNGaWxlRGlhbG9nQWN0aXZlID0gdHJ1ZTtcbiAgICAgIHRoaXMuZmlsZUlucHV0RWwudmFsdWUgPSBudWxsO1xuICAgICAgdGhpcy5maWxlSW5wdXRFbC5jbGljaygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfcHJvcHMzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBhY2NlcHQgPSBfcHJvcHMzLmFjY2VwdCxcbiAgICAgICAgICBhY2NlcHRDbGFzc05hbWUgPSBfcHJvcHMzLmFjY2VwdENsYXNzTmFtZSxcbiAgICAgICAgICBhY3RpdmVDbGFzc05hbWUgPSBfcHJvcHMzLmFjdGl2ZUNsYXNzTmFtZSxcbiAgICAgICAgICBjaGlsZHJlbiA9IF9wcm9wczMuY2hpbGRyZW4sXG4gICAgICAgICAgZGlzYWJsZWQgPSBfcHJvcHMzLmRpc2FibGVkLFxuICAgICAgICAgIGRpc2FibGVkQ2xhc3NOYW1lID0gX3Byb3BzMy5kaXNhYmxlZENsYXNzTmFtZSxcbiAgICAgICAgICBpbnB1dFByb3BzID0gX3Byb3BzMy5pbnB1dFByb3BzLFxuICAgICAgICAgIG11bHRpcGxlID0gX3Byb3BzMy5tdWx0aXBsZSxcbiAgICAgICAgICBuYW1lID0gX3Byb3BzMy5uYW1lLFxuICAgICAgICAgIHJlamVjdENsYXNzTmFtZSA9IF9wcm9wczMucmVqZWN0Q2xhc3NOYW1lLFxuICAgICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzMywgWydhY2NlcHQnLCAnYWNjZXB0Q2xhc3NOYW1lJywgJ2FjdGl2ZUNsYXNzTmFtZScsICdjaGlsZHJlbicsICdkaXNhYmxlZCcsICdkaXNhYmxlZENsYXNzTmFtZScsICdpbnB1dFByb3BzJywgJ211bHRpcGxlJywgJ25hbWUnLCAncmVqZWN0Q2xhc3NOYW1lJ10pO1xuXG4gICAgICB2YXIgYWNjZXB0U3R5bGUgPSByZXN0LmFjY2VwdFN0eWxlLFxuICAgICAgICAgIGFjdGl2ZVN0eWxlID0gcmVzdC5hY3RpdmVTdHlsZSxcbiAgICAgICAgICBjbGFzc05hbWUgPSByZXN0LmNsYXNzTmFtZSxcbiAgICAgICAgICBkaXNhYmxlZFN0eWxlID0gcmVzdC5kaXNhYmxlZFN0eWxlLFxuICAgICAgICAgIHJlamVjdFN0eWxlID0gcmVzdC5yZWplY3RTdHlsZSxcbiAgICAgICAgICBzdHlsZSA9IHJlc3Quc3R5bGUsXG4gICAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocmVzdCwgWydhY2NlcHRTdHlsZScsICdhY3RpdmVTdHlsZScsICdjbGFzc05hbWUnLCAnZGlzYWJsZWRTdHlsZScsICdyZWplY3RTdHlsZScsICdzdHlsZSddKTtcblxuICAgICAgdmFyIF9zdGF0ZSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgaXNEcmFnQWN0aXZlID0gX3N0YXRlLmlzRHJhZ0FjdGl2ZSxcbiAgICAgICAgICBkcmFnZ2VkRmlsZXMgPSBfc3RhdGUuZHJhZ2dlZEZpbGVzO1xuXG4gICAgICB2YXIgZmlsZXNDb3VudCA9IGRyYWdnZWRGaWxlcy5sZW5ndGg7XG4gICAgICB2YXIgaXNNdWx0aXBsZUFsbG93ZWQgPSBtdWx0aXBsZSB8fCBmaWxlc0NvdW50IDw9IDE7XG4gICAgICB2YXIgaXNEcmFnQWNjZXB0ID0gZmlsZXNDb3VudCA+IDAgJiYgKDAsIF91dGlscy5hbGxGaWxlc0FjY2VwdGVkKShkcmFnZ2VkRmlsZXMsIHRoaXMucHJvcHMuYWNjZXB0KTtcbiAgICAgIHZhciBpc0RyYWdSZWplY3QgPSBmaWxlc0NvdW50ID4gMCAmJiAoIWlzRHJhZ0FjY2VwdCB8fCAhaXNNdWx0aXBsZUFsbG93ZWQpO1xuICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8ICcnO1xuICAgICAgdmFyIG5vU3R5bGVzID0gIWNsYXNzTmFtZSAmJiAhc3R5bGUgJiYgIWFjdGl2ZVN0eWxlICYmICFhY2NlcHRTdHlsZSAmJiAhcmVqZWN0U3R5bGUgJiYgIWRpc2FibGVkU3R5bGU7XG5cbiAgICAgIGlmIChpc0RyYWdBY3RpdmUgJiYgYWN0aXZlQ2xhc3NOYW1lKSB7XG4gICAgICAgIGNsYXNzTmFtZSArPSAnICcgKyBhY3RpdmVDbGFzc05hbWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNEcmFnQWNjZXB0ICYmIGFjY2VwdENsYXNzTmFtZSkge1xuICAgICAgICBjbGFzc05hbWUgKz0gJyAnICsgYWNjZXB0Q2xhc3NOYW1lO1xuICAgICAgfVxuICAgICAgaWYgKGlzRHJhZ1JlamVjdCAmJiByZWplY3RDbGFzc05hbWUpIHtcbiAgICAgICAgY2xhc3NOYW1lICs9ICcgJyArIHJlamVjdENsYXNzTmFtZTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXNhYmxlZCAmJiBkaXNhYmxlZENsYXNzTmFtZSkge1xuICAgICAgICBjbGFzc05hbWUgKz0gJyAnICsgZGlzYWJsZWRDbGFzc05hbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub1N0eWxlcykge1xuICAgICAgICBzdHlsZSA9IF9zdHlsZXMyLmRlZmF1bHQuZGVmYXVsdDtcbiAgICAgICAgYWN0aXZlU3R5bGUgPSBfc3R5bGVzMi5kZWZhdWx0LmFjdGl2ZTtcbiAgICAgICAgYWNjZXB0U3R5bGUgPSBzdHlsZS5hY3RpdmU7XG4gICAgICAgIHJlamVjdFN0eWxlID0gX3N0eWxlczIuZGVmYXVsdC5yZWplY3RlZDtcbiAgICAgICAgZGlzYWJsZWRTdHlsZSA9IF9zdHlsZXMyLmRlZmF1bHQuZGlzYWJsZWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBhcHBsaWVkU3R5bGUgPSBfZXh0ZW5kcyh7fSwgc3R5bGUpO1xuICAgICAgaWYgKGFjdGl2ZVN0eWxlICYmIGlzRHJhZ0FjdGl2ZSkge1xuICAgICAgICBhcHBsaWVkU3R5bGUgPSBfZXh0ZW5kcyh7fSwgc3R5bGUsIGFjdGl2ZVN0eWxlKTtcbiAgICAgIH1cbiAgICAgIGlmIChhY2NlcHRTdHlsZSAmJiBpc0RyYWdBY2NlcHQpIHtcbiAgICAgICAgYXBwbGllZFN0eWxlID0gX2V4dGVuZHMoe30sIGFwcGxpZWRTdHlsZSwgYWNjZXB0U3R5bGUpO1xuICAgICAgfVxuICAgICAgaWYgKHJlamVjdFN0eWxlICYmIGlzRHJhZ1JlamVjdCkge1xuICAgICAgICBhcHBsaWVkU3R5bGUgPSBfZXh0ZW5kcyh7fSwgYXBwbGllZFN0eWxlLCByZWplY3RTdHlsZSk7XG4gICAgICB9XG4gICAgICBpZiAoZGlzYWJsZWRTdHlsZSAmJiBkaXNhYmxlZCkge1xuICAgICAgICBhcHBsaWVkU3R5bGUgPSBfZXh0ZW5kcyh7fSwgc3R5bGUsIGRpc2FibGVkU3R5bGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5wdXRBdHRyaWJ1dGVzID0ge1xuICAgICAgICBhY2NlcHQ6IGFjY2VwdCxcbiAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgICAgICB0eXBlOiAnZmlsZScsXG4gICAgICAgIHN0eWxlOiB7IGRpc3BsYXk6ICdub25lJyB9LFxuICAgICAgICBtdWx0aXBsZTogX3V0aWxzLnN1cHBvcnRNdWx0aXBsZSAmJiBtdWx0aXBsZSxcbiAgICAgICAgcmVmOiB0aGlzLnNldFJlZnMsXG4gICAgICAgIG9uQ2hhbmdlOiB0aGlzLm9uRHJvcCxcbiAgICAgICAgYXV0b0NvbXBsZXRlOiAnb2ZmJ1xuICAgICAgfTtcblxuICAgICAgaWYgKG5hbWUgJiYgbmFtZS5sZW5ndGgpIHtcbiAgICAgICAgaW5wdXRBdHRyaWJ1dGVzLm5hbWUgPSBuYW1lO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgY3VzdG9tIHByb3BlcnRpZXMgYmVmb3JlIHBhc3NpbmcgdGhlbSB0byB0aGUgd3JhcHBlciBkaXYgZWxlbWVudFxuICAgICAgdmFyIGN1c3RvbVByb3BzID0gWydhY2NlcHRlZEZpbGVzJywgJ3ByZXZlbnREcm9wT25Eb2N1bWVudCcsICdkaXNhYmxlUHJldmlldycsICdkaXNhYmxlQ2xpY2snLCAnYWN0aXZlQ2xhc3NOYW1lJywgJ2FjY2VwdENsYXNzTmFtZScsICdyZWplY3RDbGFzc05hbWUnLCAnZGlzYWJsZWRDbGFzc05hbWUnLCAnb25Ecm9wQWNjZXB0ZWQnLCAnb25Ecm9wUmVqZWN0ZWQnLCAnb25GaWxlRGlhbG9nQ2FuY2VsJywgJ21heFNpemUnLCAnbWluU2l6ZSddO1xuICAgICAgdmFyIGRpdlByb3BzID0gX2V4dGVuZHMoe30sIHByb3BzKTtcbiAgICAgIGN1c3RvbVByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZSBkaXZQcm9wc1twcm9wXTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIF9leHRlbmRzKHtcbiAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgICBzdHlsZTogYXBwbGllZFN0eWxlXG4gICAgICAgIH0sIGRpdlByb3BzIC8qIGV4cGFuZCB1c2VyIHByb3ZpZGVkIHByb3BzIGZpcnN0IHNvIGV2ZW50IGhhbmRsZXJzIGFyZSBuZXZlciBvdmVycmlkZGVuICovLCB7XG4gICAgICAgICAgb25DbGljazogdGhpcy5jb21wb3NlSGFuZGxlcnModGhpcy5vbkNsaWNrKSxcbiAgICAgICAgICBvbkRyYWdTdGFydDogdGhpcy5jb21wb3NlSGFuZGxlcnModGhpcy5vbkRyYWdTdGFydCksXG4gICAgICAgICAgb25EcmFnRW50ZXI6IHRoaXMuY29tcG9zZUhhbmRsZXJzKHRoaXMub25EcmFnRW50ZXIpLFxuICAgICAgICAgIG9uRHJhZ092ZXI6IHRoaXMuY29tcG9zZUhhbmRsZXJzKHRoaXMub25EcmFnT3ZlciksXG4gICAgICAgICAgb25EcmFnTGVhdmU6IHRoaXMuY29tcG9zZUhhbmRsZXJzKHRoaXMub25EcmFnTGVhdmUpLFxuICAgICAgICAgIG9uRHJvcDogdGhpcy5jb21wb3NlSGFuZGxlcnModGhpcy5vbkRyb3ApLFxuICAgICAgICAgIHJlZjogdGhpcy5zZXRSZWYsXG4gICAgICAgICAgJ2FyaWEtZGlzYWJsZWQnOiBkaXNhYmxlZFxuICAgICAgICB9KSxcbiAgICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbihjaGlsZHJlbiwgaXNEcmFnQWN0aXZlLCBpc0RyYWdBY2NlcHQsIGlzRHJhZ1JlamVjdCksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgX2V4dGVuZHMoe30sIGlucHV0UHJvcHMgLyogZXhwYW5kIHVzZXIgcHJvdmlkZWQgaW5wdXRQcm9wcyBmaXJzdCBzbyBpbnB1dEF0dHJpYnV0ZXMgb3ZlcnJpZGUgdGhlbSAqLywgaW5wdXRBdHRyaWJ1dGVzKSlcbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERyb3B6b25lO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEcm9wem9uZTtcblxuXG5Ecm9wem9uZS5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBBbGxvdyBzcGVjaWZpYyB0eXBlcyBvZiBmaWxlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9va29uZXQvYXR0ci1hY2NlcHQgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqIEtlZXAgaW4gbWluZCB0aGF0IG1pbWUgdHlwZSBkZXRlcm1pbmF0aW9uIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgcGxhdGZvcm1zLiBDU1YgZmlsZXMsXG4gICAqIGZvciBleGFtcGxlLCBhcmUgcmVwb3J0ZWQgYXMgdGV4dC9wbGFpbiB1bmRlciBtYWNPUyBidXQgYXMgYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsIHVuZGVyXG4gICAqIFdpbmRvd3MuIEluIHNvbWUgY2FzZXMgdGhlcmUgbWlnaHQgbm90IGJlIGEgbWltZSB0eXBlIHNldCBhdCBhbGwuXG4gICAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0LWRyb3B6b25lL3JlYWN0LWRyb3B6b25lL2lzc3Vlcy8yNzZcbiAgICovXG4gIGFjY2VwdDogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIENvbnRlbnRzIG9mIHRoZSBkcm9wem9uZVxuICAgKi9cbiAgY2hpbGRyZW46IF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzMi5kZWZhdWx0Lm5vZGUsIF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuY10pLFxuXG4gIC8qKlxuICAgKiBEaXNhbGxvdyBjbGlja2luZyBvbiB0aGUgZHJvcHpvbmUgY29udGFpbmVyIHRvIG9wZW4gZmlsZSBkaWFsb2dcbiAgICovXG4gIGRpc2FibGVDbGljazogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAqIEVuYWJsZS9kaXNhYmxlIHRoZSBkcm9wem9uZSBlbnRpcmVseVxuICAqL1xuICBkaXNhYmxlZDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBFbmFibGUvZGlzYWJsZSBwcmV2aWV3IGdlbmVyYXRpb25cbiAgICovXG4gIGRpc2FibGVQcmV2aWV3OiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGZhbHNlLCBhbGxvdyBkcm9wcGVkIGl0ZW1zIHRvIHRha2Ugb3ZlciB0aGUgY3VycmVudCBicm93c2VyIHdpbmRvd1xuICAgKi9cbiAgcHJldmVudERyb3BPbkRvY3VtZW50OiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIFBhc3MgYWRkaXRpb25hbCBhdHRyaWJ1dGVzIHRvIHRoZSBgPGlucHV0IHR5cGU9XCJmaWxlXCIvPmAgdGFnXG4gICAqL1xuICBpbnB1dFByb3BzOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCxcblxuICAvKipcbiAgICogQWxsb3cgZHJvcHBpbmcgbXVsdGlwbGUgZmlsZXNcbiAgICovXG4gIG11bHRpcGxlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIGBuYW1lYCBhdHRyaWJ1dGUgZm9yIHRoZSBpbnB1dCB0YWdcbiAgICovXG4gIG5hbWU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBNYXhpbXVtIGZpbGUgc2l6ZVxuICAgKi9cbiAgbWF4U2l6ZTogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXG5cbiAgLyoqXG4gICAqIE1pbmltdW0gZmlsZSBzaXplXG4gICAqL1xuICBtaW5TaXplOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlcixcblxuICAvKipcbiAgICogY2xhc3NOYW1lXG4gICAqL1xuICBjbGFzc05hbWU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBjbGFzc05hbWUgZm9yIGFjdGl2ZSBzdGF0ZVxuICAgKi9cbiAgYWN0aXZlQ2xhc3NOYW1lOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcblxuICAvKipcbiAgICogY2xhc3NOYW1lIGZvciBhY2NlcHRlZCBzdGF0ZVxuICAgKi9cbiAgYWNjZXB0Q2xhc3NOYW1lOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcblxuICAvKipcbiAgICogY2xhc3NOYW1lIGZvciByZWplY3RlZCBzdGF0ZVxuICAgKi9cbiAgcmVqZWN0Q2xhc3NOYW1lOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcblxuICAvKipcbiAgICogY2xhc3NOYW1lIGZvciBkaXNhYmxlZCBzdGF0ZVxuICAgKi9cbiAgZGlzYWJsZWRDbGFzc05hbWU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBDU1Mgc3R5bGVzIHRvIGFwcGx5XG4gICAqL1xuICBzdHlsZTogX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QsXG5cbiAgLyoqXG4gICAqIENTUyBzdHlsZXMgdG8gYXBwbHkgd2hlbiBkcmFnIGlzIGFjdGl2ZVxuICAgKi9cbiAgYWN0aXZlU3R5bGU6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBDU1Mgc3R5bGVzIHRvIGFwcGx5IHdoZW4gZHJvcCB3aWxsIGJlIGFjY2VwdGVkXG4gICAqL1xuICBhY2NlcHRTdHlsZTogX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QsXG5cbiAgLyoqXG4gICAqIENTUyBzdHlsZXMgdG8gYXBwbHkgd2hlbiBkcm9wIHdpbGwgYmUgcmVqZWN0ZWRcbiAgICovXG4gIHJlamVjdFN0eWxlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCxcblxuICAvKipcbiAgICogQ1NTIHN0eWxlcyB0byBhcHBseSB3aGVuIGRyb3B6b25lIGlzIGRpc2FibGVkXG4gICAqL1xuICBkaXNhYmxlZFN0eWxlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCxcblxuICAvKipcbiAgICogb25DbGljayBjYWxsYmFja1xuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgb25DbGljazogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuXG4gIC8qKlxuICAgKiBvbkRyb3AgY2FsbGJhY2tcbiAgICovXG4gIG9uRHJvcDogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuXG4gIC8qKlxuICAgKiBvbkRyb3BBY2NlcHRlZCBjYWxsYmFja1xuICAgKi9cbiAgb25Ecm9wQWNjZXB0ZWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcblxuICAvKipcbiAgICogb25Ecm9wUmVqZWN0ZWQgY2FsbGJhY2tcbiAgICovXG4gIG9uRHJvcFJlamVjdGVkOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG5cbiAgLyoqXG4gICAqIG9uRHJhZ1N0YXJ0IGNhbGxiYWNrXG4gICAqL1xuICBvbkRyYWdTdGFydDogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuXG4gIC8qKlxuICAgKiBvbkRyYWdFbnRlciBjYWxsYmFja1xuICAgKi9cbiAgb25EcmFnRW50ZXI6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcblxuICAvKipcbiAgICogb25EcmFnT3ZlciBjYWxsYmFja1xuICAgKi9cbiAgb25EcmFnT3ZlcjogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuXG4gIC8qKlxuICAgKiBvbkRyYWdMZWF2ZSBjYWxsYmFja1xuICAgKi9cbiAgb25EcmFnTGVhdmU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcblxuICAvKipcbiAgICogUHJvdmlkZSBhIGNhbGxiYWNrIG9uIGNsaWNraW5nIHRoZSBjYW5jZWwgYnV0dG9uIG9mIHRoZSBmaWxlIGRpYWxvZ1xuICAgKi9cbiAgb25GaWxlRGlhbG9nQ2FuY2VsOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmNcbn07XG5cbkRyb3B6b25lLmRlZmF1bHRQcm9wcyA9IHtcbiAgcHJldmVudERyb3BPbkRvY3VtZW50OiB0cnVlLFxuICBkaXNhYmxlZDogZmFsc2UsXG4gIGRpc2FibGVQcmV2aWV3OiBmYWxzZSxcbiAgZGlzYWJsZUNsaWNrOiBmYWxzZSxcbiAgbXVsdGlwbGU6IHRydWUsXG4gIG1heFNpemU6IEluZmluaXR5LFxuICBtaW5TaXplOiAwXG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygxKSkpXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMl9fO1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3VwcG9ydE11bHRpcGxlID0gdW5kZWZpbmVkO1xuZXhwb3J0cy5nZXREYXRhVHJhbnNmZXJJdGVtcyA9IGdldERhdGFUcmFuc2Zlckl0ZW1zO1xuZXhwb3J0cy5maWxlQWNjZXB0ZWQgPSBmaWxlQWNjZXB0ZWQ7XG5leHBvcnRzLmZpbGVNYXRjaFNpemUgPSBmaWxlTWF0Y2hTaXplO1xuZXhwb3J0cy5hbGxGaWxlc0FjY2VwdGVkID0gYWxsRmlsZXNBY2NlcHRlZDtcbmV4cG9ydHMub25Eb2N1bWVudERyYWdPdmVyID0gb25Eb2N1bWVudERyYWdPdmVyO1xuXG52YXIgX2F0dHJBY2NlcHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2F0dHJBY2NlcHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXR0ckFjY2VwdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBzdXBwb3J0TXVsdGlwbGUgPSBleHBvcnRzLnN1cHBvcnRNdWx0aXBsZSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCA/ICdtdWx0aXBsZScgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKSA6IHRydWU7XG5cbmZ1bmN0aW9uIGdldERhdGFUcmFuc2Zlckl0ZW1zKGV2ZW50KSB7XG4gIHZhciBkYXRhVHJhbnNmZXJJdGVtc0xpc3QgPSBbXTtcbiAgaWYgKGV2ZW50LmRhdGFUcmFuc2Zlcikge1xuICAgIHZhciBkdCA9IGV2ZW50LmRhdGFUcmFuc2ZlcjtcbiAgICBpZiAoZHQuZmlsZXMgJiYgZHQuZmlsZXMubGVuZ3RoKSB7XG4gICAgICBkYXRhVHJhbnNmZXJJdGVtc0xpc3QgPSBkdC5maWxlcztcbiAgICB9IGVsc2UgaWYgKGR0Lml0ZW1zICYmIGR0Lml0ZW1zLmxlbmd0aCkge1xuICAgICAgLy8gRHVyaW5nIHRoZSBkcmFnIGV2ZW4gdGhlIGRhdGFUcmFuc2Zlci5maWxlcyBpcyBudWxsXG4gICAgICAvLyBidXQgQ2hyb21lIGltcGxlbWVudHMgc29tZSBkcmFnIHN0b3JlLCB3aGljaCBpcyBhY2Nlc2libGUgdmlhIGRhdGFUcmFuc2Zlci5pdGVtc1xuICAgICAgZGF0YVRyYW5zZmVySXRlbXNMaXN0ID0gZHQuaXRlbXM7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQuZmlsZXMpIHtcbiAgICBkYXRhVHJhbnNmZXJJdGVtc0xpc3QgPSBldmVudC50YXJnZXQuZmlsZXM7XG4gIH1cbiAgLy8gQ29udmVydCBmcm9tIERhdGFUcmFuc2Zlckl0ZW1zTGlzdCB0byB0aGUgbmF0aXZlIEFycmF5XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhVHJhbnNmZXJJdGVtc0xpc3QpO1xufVxuXG4vLyBGaXJlZm94IHZlcnNpb25zIHByaW9yIHRvIDUzIHJldHVybiBhIGJvZ3VzIE1JTUUgdHlwZSBmb3IgZXZlcnkgZmlsZSBkcmFnLCBzbyBkcmFnb3ZlcnMgd2l0aFxuLy8gdGhhdCBNSU1FIHR5cGUgd2lsbCBhbHdheXMgYmUgYWNjZXB0ZWRcbmZ1bmN0aW9uIGZpbGVBY2NlcHRlZChmaWxlLCBhY2NlcHQpIHtcbiAgcmV0dXJuIGZpbGUudHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3gtbW96LWZpbGUnIHx8ICgwLCBfYXR0ckFjY2VwdDIuZGVmYXVsdCkoZmlsZSwgYWNjZXB0KTtcbn1cblxuZnVuY3Rpb24gZmlsZU1hdGNoU2l6ZShmaWxlLCBtYXhTaXplLCBtaW5TaXplKSB7XG4gIHJldHVybiBmaWxlLnNpemUgPD0gbWF4U2l6ZSAmJiBmaWxlLnNpemUgPj0gbWluU2l6ZTtcbn1cblxuZnVuY3Rpb24gYWxsRmlsZXNBY2NlcHRlZChmaWxlcywgYWNjZXB0KSB7XG4gIHJldHVybiBmaWxlcy5ldmVyeShmdW5jdGlvbiAoZmlsZSkge1xuICAgIHJldHVybiBmaWxlQWNjZXB0ZWQoZmlsZSwgYWNjZXB0KTtcbiAgfSk7XG59XG5cbi8vIGFsbG93IHRoZSBlbnRpcmUgZG9jdW1lbnQgdG8gYmUgYSBkcmFnIHRhcmdldFxuZnVuY3Rpb24gb25Eb2N1bWVudERyYWdPdmVyKGV2dCkge1xuICBldnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oZSl7aWYocltlXSlyZXR1cm4gcltlXS5leHBvcnRzO3ZhciBvPXJbZV09e2V4cG9ydHM6e30saWQ6ZSxsb2FkZWQ6ITF9O3JldHVybiB0W2VdLmNhbGwoby5leHBvcnRzLG8sby5leHBvcnRzLG4pLG8ubG9hZGVkPSEwLG8uZXhwb3J0c312YXIgcj17fTtyZXR1cm4gbi5tPXQsbi5jPXIsbi5wPVwiXCIsbigwKX0oW2Z1bmN0aW9uKHQsbixyKXtcInVzZSBzdHJpY3RcIjtuLl9fZXNNb2R1bGU9ITAscig4KSxyKDkpLG5bXCJkZWZhdWx0XCJdPWZ1bmN0aW9uKHQsbil7aWYodCYmbil7dmFyIHI9ZnVuY3Rpb24oKXt2YXIgcj1BcnJheS5pc0FycmF5KG4pP246bi5zcGxpdChcIixcIiksZT10Lm5hbWV8fFwiXCIsbz10LnR5cGV8fFwiXCIsaT1vLnJlcGxhY2UoL1xcLy4qJC8sXCJcIik7cmV0dXJue3Y6ci5zb21lKGZ1bmN0aW9uKHQpe3ZhciBuPXQudHJpbSgpO3JldHVyblwiLlwiPT09bi5jaGFyQXQoMCk/ZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKG4udG9Mb3dlckNhc2UoKSk6L1xcL1xcKiQvLnRlc3Qobik/aT09PW4ucmVwbGFjZSgvXFwvLiokLyxcIlwiKTpvPT09bn0pfX0oKTtpZihcIm9iamVjdFwiPT10eXBlb2YgcilyZXR1cm4gci52fXJldHVybiEwfSx0LmV4cG9ydHM9bltcImRlZmF1bHRcIl19LGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5leHBvcnRzPXt2ZXJzaW9uOlwiMS4yLjJcIn07XCJudW1iZXJcIj09dHlwZW9mIF9fZSYmKF9fZT1yKX0sZnVuY3Rpb24odCxuKXt2YXIgcj10LmV4cG9ydHM9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93Lk1hdGg9PU1hdGg/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZzZWxmLk1hdGg9PU1hdGg/c2VsZjpGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XCJudW1iZXJcIj09dHlwZW9mIF9fZyYmKF9fZz1yKX0sZnVuY3Rpb24odCxuLHIpe3ZhciBlPXIoMiksbz1yKDEpLGk9cig0KSx1PXIoMTkpLGM9XCJwcm90b3R5cGVcIixmPWZ1bmN0aW9uKHQsbil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkobixhcmd1bWVudHMpfX0scz1mdW5jdGlvbih0LG4scil7dmFyIGEscCxsLHksZD10JnMuRyxoPXQmcy5QLHY9ZD9lOnQmcy5TP2Vbbl18fChlW25dPXt9KTooZVtuXXx8e30pW2NdLHg9ZD9vOm9bbl18fChvW25dPXt9KTtkJiYocj1uKTtmb3IoYSBpbiByKXA9ISh0JnMuRikmJnYmJmEgaW4gdixsPShwP3Y6cilbYV0seT10JnMuQiYmcD9mKGwsZSk6aCYmXCJmdW5jdGlvblwiPT10eXBlb2YgbD9mKEZ1bmN0aW9uLmNhbGwsbCk6bCx2JiYhcCYmdSh2LGEsbCkseFthXSE9bCYmaSh4LGEseSksaCYmKCh4W2NdfHwoeFtjXT17fSkpW2FdPWwpfTtlLmNvcmU9byxzLkY9MSxzLkc9MixzLlM9NCxzLlA9OCxzLkI9MTYscy5XPTMyLHQuZXhwb3J0cz1zfSxmdW5jdGlvbih0LG4scil7dmFyIGU9cig1KSxvPXIoMTgpO3QuZXhwb3J0cz1yKDIyKT9mdW5jdGlvbih0LG4scil7cmV0dXJuIGUuc2V0RGVzYyh0LG4sbygxLHIpKX06ZnVuY3Rpb24odCxuLHIpe3JldHVybiB0W25dPXIsdH19LGZ1bmN0aW9uKHQsbil7dmFyIHI9T2JqZWN0O3QuZXhwb3J0cz17Y3JlYXRlOnIuY3JlYXRlLGdldFByb3RvOnIuZ2V0UHJvdG90eXBlT2YsaXNFbnVtOnt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLGdldERlc2M6ci5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Isc2V0RGVzYzpyLmRlZmluZVByb3BlcnR5LHNldERlc2NzOnIuZGVmaW5lUHJvcGVydGllcyxnZXRLZXlzOnIua2V5cyxnZXROYW1lczpyLmdldE93blByb3BlcnR5TmFtZXMsZ2V0U3ltYm9sczpyLmdldE93blByb3BlcnR5U3ltYm9scyxlYWNoOltdLmZvckVhY2h9fSxmdW5jdGlvbih0LG4pe3ZhciByPTAsZT1NYXRoLnJhbmRvbSgpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm5cIlN5bWJvbChcIi5jb25jYXQodm9pZCAwPT09dD9cIlwiOnQsXCIpX1wiLCgrK3IrZSkudG9TdHJpbmcoMzYpKX19LGZ1bmN0aW9uKHQsbixyKXt2YXIgZT1yKDIwKShcIndrc1wiKSxvPXIoMikuU3ltYm9sO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gZVt0XXx8KGVbdF09byYmb1t0XXx8KG98fHIoNikpKFwiU3ltYm9sLlwiK3QpKX19LGZ1bmN0aW9uKHQsbixyKXtyKDI2KSx0LmV4cG9ydHM9cigxKS5BcnJheS5zb21lfSxmdW5jdGlvbih0LG4scil7cigyNSksdC5leHBvcnRzPXIoMSkuU3RyaW5nLmVuZHNXaXRofSxmdW5jdGlvbih0LG4pe3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IFR5cGVFcnJvcih0K1wiIGlzIG5vdCBhIGZ1bmN0aW9uIVwiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKHQsbil7dmFyIHI9e30udG9TdHJpbmc7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiByLmNhbGwodCkuc2xpY2UoOCwtMSl9fSxmdW5jdGlvbih0LG4scil7dmFyIGU9cigxMCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsbixyKXtpZihlKHQpLHZvaWQgMD09PW4pcmV0dXJuIHQ7c3dpdGNoKHIpe2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24ocil7cmV0dXJuIHQuY2FsbChuLHIpfTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKHIsZSl7cmV0dXJuIHQuY2FsbChuLHIsZSl9O2Nhc2UgMzpyZXR1cm4gZnVuY3Rpb24ocixlLG8pe3JldHVybiB0LmNhbGwobixyLGUsbyl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KG4sYXJndW1lbnRzKX19fSxmdW5jdGlvbih0LG4pe3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZih2b2lkIDA9PXQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiK3QpO3JldHVybiB0fX0sZnVuY3Rpb24odCxuLHIpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgbj0vLi87dHJ5e1wiLy4vXCJbdF0obil9Y2F0Y2goZSl7dHJ5e3JldHVybiBuW3IoNykoXCJtYXRjaFwiKV09ITEsIVwiLy4vXCJbdF0obil9Y2F0Y2gobyl7fX1yZXR1cm4hMH19LGZ1bmN0aW9uKHQsbil7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4hIXQoKX1jYXRjaChuKXtyZXR1cm4hMH19fSxmdW5jdGlvbih0LG4pe3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgdD9udWxsIT09dDpcImZ1bmN0aW9uXCI9PXR5cGVvZiB0fX0sZnVuY3Rpb24odCxuLHIpe3ZhciBlPXIoMTYpLG89cigxMSksaT1yKDcpKFwibWF0Y2hcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3ZhciBuO3JldHVybiBlKHQpJiYodm9pZCAwIT09KG49dFtpXSk/ISFuOlwiUmVnRXhwXCI9PW8odCkpfX0sZnVuY3Rpb24odCxuKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCxuKXtyZXR1cm57ZW51bWVyYWJsZTohKDEmdCksY29uZmlndXJhYmxlOiEoMiZ0KSx3cml0YWJsZTohKDQmdCksdmFsdWU6bn19fSxmdW5jdGlvbih0LG4scil7dmFyIGU9cigyKSxvPXIoNCksaT1yKDYpKFwic3JjXCIpLHU9XCJ0b1N0cmluZ1wiLGM9RnVuY3Rpb25bdV0sZj0oXCJcIitjKS5zcGxpdCh1KTtyKDEpLmluc3BlY3RTb3VyY2U9ZnVuY3Rpb24odCl7cmV0dXJuIGMuY2FsbCh0KX0sKHQuZXhwb3J0cz1mdW5jdGlvbih0LG4scix1KXtcImZ1bmN0aW9uXCI9PXR5cGVvZiByJiYobyhyLGksdFtuXT9cIlwiK3Rbbl06Zi5qb2luKFN0cmluZyhuKSkpLFwibmFtZVwiaW4gcnx8KHIubmFtZT1uKSksdD09PWU/dFtuXT1yOih1fHxkZWxldGUgdFtuXSxvKHQsbixyKSl9KShGdW5jdGlvbi5wcm90b3R5cGUsdSxmdW5jdGlvbigpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMmJnRoaXNbaV18fGMuY2FsbCh0aGlzKX0pfSxmdW5jdGlvbih0LG4scil7dmFyIGU9cigyKSxvPVwiX19jb3JlLWpzX3NoYXJlZF9fXCIsaT1lW29dfHwoZVtvXT17fSk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBpW3RdfHwoaVt0XT17fSl9fSxmdW5jdGlvbih0LG4scil7dmFyIGU9cigxNyksbz1yKDEzKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxuLHIpe2lmKGUobikpdGhyb3cgVHlwZUVycm9yKFwiU3RyaW5nI1wiK3IrXCIgZG9lc24ndCBhY2NlcHQgcmVnZXghXCIpO3JldHVybiBTdHJpbmcobyh0KSl9fSxmdW5jdGlvbih0LG4scil7dC5leHBvcnRzPSFyKDE1KShmdW5jdGlvbigpe3JldHVybiA3IT1PYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJhXCIse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pLmF9KX0sZnVuY3Rpb24odCxuKXt2YXIgcj1NYXRoLmNlaWwsZT1NYXRoLmZsb29yO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gaXNOYU4odD0rdCk/MDoodD4wP2U6cikodCl9fSxmdW5jdGlvbih0LG4scil7dmFyIGU9cigyMyksbz1NYXRoLm1pbjt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIHQ+MD9vKGUodCksOTAwNzE5OTI1NDc0MDk5MSk6MH19LGZ1bmN0aW9uKHQsbixyKXtcInVzZSBzdHJpY3RcIjt2YXIgZT1yKDMpLG89cigyNCksaT1yKDIxKSx1PVwiZW5kc1dpdGhcIixjPVwiXCJbdV07ZShlLlArZS5GKnIoMTQpKHUpLFwiU3RyaW5nXCIse2VuZHNXaXRoOmZ1bmN0aW9uKHQpe3ZhciBuPWkodGhpcyx0LHUpLHI9YXJndW1lbnRzLGU9ci5sZW5ndGg+MT9yWzFdOnZvaWQgMCxmPW8obi5sZW5ndGgpLHM9dm9pZCAwPT09ZT9mOk1hdGgubWluKG8oZSksZiksYT1TdHJpbmcodCk7cmV0dXJuIGM/Yy5jYWxsKG4sYSxzKTpuLnNsaWNlKHMtYS5sZW5ndGgscyk9PT1hfX0pfSxmdW5jdGlvbih0LG4scil7dmFyIGU9cig1KSxvPXIoMyksaT1yKDEpLkFycmF5fHxBcnJheSx1PXt9LGM9ZnVuY3Rpb24odCxuKXtlLmVhY2guY2FsbCh0LnNwbGl0KFwiLFwiKSxmdW5jdGlvbih0KXt2b2lkIDA9PW4mJnQgaW4gaT91W3RdPWlbdF06dCBpbltdJiYodVt0XT1yKDEyKShGdW5jdGlvbi5jYWxsLFtdW3RdLG4pKX0pfTtjKFwicG9wLHJldmVyc2Usc2hpZnQsa2V5cyx2YWx1ZXMsZW50cmllc1wiLDEpLGMoXCJpbmRleE9mLGV2ZXJ5LHNvbWUsZm9yRWFjaCxtYXAsZmlsdGVyLGZpbmQsZmluZEluZGV4LGluY2x1ZGVzXCIsMyksYyhcImpvaW4sc2xpY2UsY29uY2F0LHB1c2gsc3BsaWNlLHVuc2hpZnQsc29ydCxsYXN0SW5kZXhPZixyZWR1Y2UscmVkdWNlUmlnaHQsY29weVdpdGhpbixmaWxsXCIpLG8oby5TLFwiQXJyYXlcIix1KX1dKTtcblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIHJlamVjdGVkOiB7XG4gICAgYm9yZGVyU3R5bGU6ICdzb2xpZCcsXG4gICAgYm9yZGVyQ29sb3I6ICcjYzY2JyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZWVlJ1xuICB9LFxuICBkaXNhYmxlZDoge1xuICAgIG9wYWNpdHk6IDAuNVxuICB9LFxuICBhY3RpdmU6IHtcbiAgICBib3JkZXJTdHlsZTogJ3NvbGlkJyxcbiAgICBib3JkZXJDb2xvcjogJyM2YzYnLFxuICAgIGJhY2tncm91bmRDb2xvcjogJyNlZWUnXG4gIH0sXG4gIGRlZmF1bHQ6IHtcbiAgICB3aWR0aDogMjAwLFxuICAgIGhlaWdodDogMjAwLFxuICAgIGJvcmRlcldpZHRoOiAyLFxuICAgIGJvcmRlckNvbG9yOiAnIzY2NicsXG4gICAgYm9yZGVyU3R5bGU6ICdkYXNoZWQnLFxuICAgIGJvcmRlclJhZGl1czogNVxuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IERyb3B6b25lIGZyb20gJy4vdGhpcmQtcGFydHkvcmVhY3QtZHJvcHpvbmUnO1xuaW1wb3J0IHJlcXVlc3QgZnJvbSAnc3VwZXJhZ2VudCc7XG5pbXBvcnQgSW5wdXRSZWFkT25seSBmcm9tICcuL3JlYWQtb25seS5qc3gnO1xuaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XG5cbnZhciBhamF4SGVscGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vUmVzb3VyY2VzL3B1YmxpYy9qcy9oZWxwZXJzL2FqYXgtaGVscGVyJykuYWpheEhlbHBlcixcbiAgICBpMThuID0gcmVxdWlyZSgnLi4vLi4vLi4vUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy9pMThuJykuaTE4bixcbiAgICAkID0galF1ZXJ5O1xuXG5jbGFzcyBJbnB1dFVwbG9hZCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgdmFyIHsgb3B0aW9ucywgZmllbGRWYWx1ZSB9ID0gcHJvcHMuZGF0YTtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBmaWxlUGF0aDogZmllbGRWYWx1ZSA/IG9wdGlvbnMucHVibGljUGF0aCArICcvJyArIGZpZWxkVmFsdWUgOiBudWxsLFxuICAgICAgICAgICAgZmlsZW5hbWU6IGZpZWxkVmFsdWUsXG4gICAgICAgICAgICBsb2FkaW5nOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBvbkRyb3AoYWNjZXB0ZWRGaWxlcykge1xuICAgICAgICBsZXQgdXBsb2FkVXJsID0gYWpheEhlbHBlci5nZXRVcmwuYXBwbHkodGhpcy5wcm9wcy5nY3J1ZEluc3RhbmNlLCBbJ3VwbG9hZCddKSxcbiAgICAgICAgICAgIHVwbG9hZFJlcXVlc3QgPSByZXF1ZXN0LnBvc3QodXBsb2FkVXJsKSxcbiAgICAgICAgICAgIHJlcXVlc3RFeHRyYUhlYWRlcnM7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBsb2FkaW5nOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcXVlc3RFeHRyYUhlYWRlcnMgPSAkLmFqYXhTZXR1cCgpLmhlYWRlcnM7XG5cbiAgICAgICAgaWYgKHJlcXVlc3RFeHRyYUhlYWRlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgXy5lYWNoKHJlcXVlc3RFeHRyYUhlYWRlcnMsIGZ1bmN0aW9uIGZvcmVhY2hSZXF1ZXN0SGVhZGVycyhoZWFkZXJWYWx1ZSwgaGVhZGVyTmFtZSkge1xuICAgICAgICAgICAgICAgIHVwbG9hZFJlcXVlc3Quc2V0KGhlYWRlck5hbWUsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBsb2FkUmVxdWVzdC5hdHRhY2godGhpcy5wcm9wcy5kYXRhLmZpZWxkTmFtZSwgYWNjZXB0ZWRGaWxlc1swXSk7XG4gICAgICAgIHVwbG9hZFJlcXVlc3QuZW5kKGZ1bmN0aW9uIHVwbG9hZFJlc3BvbnNlKGVyciwgb3V0cHV0KSB7XG4gICAgICAgICAgICBjb25zdCB7IGdjcnVkSW5zdGFuY2UgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAganNvblJlc3BvbnNlID0gb3V0cHV0LmJvZHk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXJyIHx8IGpzb25SZXNwb25zZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFqYXhIZWxwZXIuYWpheE9uRmFpbC5hcHBseShnY3J1ZEluc3RhbmNlLCBbb3V0cHV0LnRleHQsIChlcnIgPyBlcnIuc3RhdHVzIDogJ05vdCB3ZWxsIEpTT04gZm9ybWF0dGVkIHJlc3BvbnNlJyksICdlcnJvciddKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGVkIGVycm9yXG4gICAgICAgICAgICAgICAgaWYgKGpzb25SZXNwb25zZS5zdGF0dXMgPT09ICdmYWlsdXJlJykge1xuICAgICAgICAgICAgICAgICAgICBhamF4SGVscGVyLmFqYXhPbkZhaWwuYXBwbHkoZ2NydWRJbnN0YW5jZSwgW2pzb25SZXNwb25zZS5tZXNzYWdlLCBqc29uUmVzcG9uc2Uuc3RhdHVzLCAnZXJyb3InXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGpzb25SZXNwb25zZS5jc3JmVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZ2NydWRJbnN0YW5jZS5jYWNoZWRJbml0aWFsRGF0YS5jc3JmVG9rZW4gPSBqc29uUmVzcG9uc2UuY3NyZlRva2VuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBmaWxlUGF0aDoganNvblJlc3BvbnNlLnVwbG9hZFJlc3VsdC5maWxlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IGpzb25SZXNwb25zZS51cGxvYWRSZXN1bHQuZmlsZW5hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgZGVsZXRlT25DbGljayhldmVudCkge1xuICAgICAgICBjb25zdCB7IGdjcnVkSW5zdGFuY2UgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBkZWxldGVGaWxlVXJsID0gYWpheEhlbHBlci5nZXRVcmwuYXBwbHkoZ2NydWRJbnN0YW5jZSwgW10pLFxuICAgICAgICAgICAgZGVsZXRlRmlsZVJlcXVlc3QgPSByZXF1ZXN0LnBvc3QoZGVsZXRlRmlsZVVybCksXG4gICAgICAgICAgICB7IGZpZWxkTmFtZSB9ID0gdGhpcy5wcm9wcy5kYXRhLFxuICAgICAgICAgICAgeyBmaWxlbmFtZSB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIGRhdGFUb1NlbmQgPSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnZGVsZXRlLWZpbGUnLFxuICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGROYW1lLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2NydWRJbnN0YW5jZS5jYWNoZWRJbml0aWFsRGF0YS5jc3JmVG9rZW4pIHtcbiAgICAgICAgICAgIGRhdGFUb1NlbmRbZ2NydWRJbnN0YW5jZS5jYWNoZWRJbml0aWFsRGF0YS5jc3JmVG9rZW4uaW5wdXROYW1lXSA9IGdjcnVkSW5zdGFuY2UuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuLmlucHV0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGVGaWxlUmVxdWVzdC50eXBlKCdmb3JtJyk7XG4gICAgICAgIGRlbGV0ZUZpbGVSZXF1ZXN0LnNlbmQoZGF0YVRvU2VuZCk7XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBsb2FkaW5nOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGVGaWxlUmVxdWVzdC5lbmQoZnVuY3Rpb24gZGVsZXRlRmlsZVJlcXVlc3RFbmQoZXJyLCBvdXRwdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb25SZXNwb25zZSA9IG91dHB1dC5ib2R5O1xuXG4gICAgICAgICAgICBpZiAoZXJyIHx8IGpzb25SZXNwb25zZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFqYXhIZWxwZXIuYWpheE9uRmFpbC5hcHBseShnY3J1ZEluc3RhbmNlLCBbb3V0cHV0LnRleHQsIChlcnIgPyBlcnIuc3RhdHVzIDogJ05vdCB3ZWxsIEpTT04gZm9ybWF0dGVkIHJlc3BvbnNlJyksICdlcnJvciddKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlZCBlcnJvclxuICAgICAgICAgICAgICAgIGlmIChqc29uUmVzcG9uc2Uuc3RhdHVzID09PSAnZmFpbHVyZScpIHtcbiAgICAgICAgICAgICAgICAgICAgYWpheEhlbHBlci5hamF4T25GYWlsLmFwcGx5KGdjcnVkSW5zdGFuY2UsIFtqc29uUmVzcG9uc2UubWVzc2FnZSwganNvblJlc3BvbnNlLnN0YXR1cywgJ2Vycm9yJ10pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChqc29uUmVzcG9uc2UuY3NyZlRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGdjcnVkSW5zdGFuY2UuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuID0ganNvblJlc3BvbnNlLmNzcmZUb2tlbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYXRoOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogJydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0VHJhbnNsYXRpb25GaWxlQXR0YWNoKCkge1xuICAgICAgICBsZXQgc3BsaXR0ZWRTdHJpbmcgPSBpMThuLnQoJ3VwbG9hZF9hdHRhY2hfZmlsZScpLnNwbGl0KCd7YnJvd3NlX2ZpbGV9Jyk7XG5cbiAgICAgICAgaWYgKHNwbGl0dGVkU3RyaW5nLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BsaXR0ZWRTdHJpbmdbMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKDxzcGFuPlxuICAgICAgICAgICAge3NwbGl0dGVkU3RyaW5nWzBdfSB7PGE+e2kxOG4udCgnYnJvd3NlX2ZpbGUnKX08L2E+fSB7c3BsaXR0ZWRTdHJpbmdbMV19XG4gICAgICAgIDwvc3Bhbj4pO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciB7IGZpbGVQYXRoLCBsb2FkaW5nLCBmaWxlbmFtZSB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIHsgZmllbGROYW1lLCBpc1JlYWRPbmx5IH0gPSB0aGlzLnByb3BzLmRhdGE7XG5cbiAgICAgICAgaWYgKGxvYWRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiAoPGRpdj5cbiAgICAgICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJmYSBmYS1yZWZyZXNoIGZhLXNwaW5cIj48L2k+IExvYWRpbmcuLi5cbiAgICAgICAgICAgIDwvZGl2Pik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNSZWFkT25seSAmJiAhZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiA8SW5wdXRSZWFkT25seSBmaWVsZFZhbHVlPVwiXCIvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgPERyb3B6b25lIHN0eWxlPXt7IGRpc3BsYXk6ICdibG9jaycgfX0gb25Ecm9wPXt0aGlzLm9uRHJvcC5iaW5kKHRoaXMpfSBtdWx0aXBsZT17ZmFsc2V9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnYy1kcm9wem9uZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cImZhIGZhLWNsb3VkLXVwbG9hZFwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmbmJzcDsge3RoaXMuZ2V0VHJhbnNsYXRpb25GaWxlQXR0YWNoKCl9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9Ecm9wem9uZT5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJoaWRkZW5cIiBuYW1lPXtmaWVsZE5hbWV9IHZhbHVlPVwiXCIgLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKDxkaXY+XG4gICAgICAgICAgICA8YSBocmVmPXtmaWxlUGF0aH0gdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgL1xcLihqcChlKT9nfGdpZnxwbmd8dGlmZikkLy50ZXN0KGZpbGVQYXRoKSA/XG4gICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPXtmaWxlUGF0aH0gaGVpZ2h0PVwiNTBcIi8+IDpcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e2ZpbGVuYW1lfTwvc3Bhbj5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDwvYT4gJm5ic3A7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaXNSZWFkT25seSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgb25DbGljaz17dGhpcy5kZWxldGVPbkNsaWNrLmJpbmQodGhpcyl9IGNsYXNzTmFtZT1cImJ0biBidG4tZGVmYXVsdFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cImZhIGZhLXRyYXNoLW9cIj48L2k+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaTE4bi50KCdhY3Rpb25fZGVsZXRlJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHtpc1JlYWRPbmx5ID8gJycgOiA8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9e2ZpZWxkTmFtZX0gdmFsdWU9e2ZpbGVuYW1lfS8+fVxuICAgICAgICA8L2Rpdj4pO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5wdXRVcGxvYWQ7XG4iLCJcbmltcG9ydCBJbnB1dFRleHQgZnJvbSAnLi90ZXh0LmpzeCc7XG5cbmNsYXNzIElucHV0VXJsIGV4dGVuZHMgSW5wdXRUZXh0IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciB7IGRhdGEgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICB7IGZpZWxkTmFtZSB9ID0gdGhpcy5wcm9wcy5kYXRhO1xuXG4gICAgICAgIHJldHVybiA8SW5wdXRUZXh0IGtleT17ZmllbGROYW1lfSBkYXRhPXtkYXRhfSAvPlxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5wdXRVcmw7XG4iLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5jbGFzcyBNb2RhbFRpdGxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgdGl0bGUsIE1vZGFsVGl0bGVXcmFwcGVyIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8TW9kYWxUaXRsZVdyYXBwZXIgdGl0bGU9e3RpdGxlfSAvPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuTW9kYWxUaXRsZS5wcm9wVHlwZXMgPSB7XG4gICAgdGl0bGU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgTW9kYWxUaXRsZVdyYXBwZXI6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5Nb2RhbFRpdGxlLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBNb2RhbFRpdGxlV3JhcHBlcjogcHJvcHMgPT4gPFJlYWN0LkZyYWdtZW50PlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImNsb3NlXCJcbiAgICAgICAgICAgIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCJcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJDbG9zZVwiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8aDQgY2xhc3NOYW1lPVwibW9kYWwtdGl0bGVcIj5cbiAgICAgICAgICAgIHtwcm9wcy50aXRsZX1cbiAgICAgICAgPC9oND5cbiAgICA8L1JlYWN0LkZyYWdtZW50PlxufTtcblxuZXhwb3J0IGRlZmF1bHQgTW9kYWxUaXRsZTtcbiIsImltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFZpc2libGVDb2x1bW5zIGZyb20gJy4vdmlzaWJsZS1jb2x1bW5zLmpzeCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5jbGFzcyBTZXR0aW5ncyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5zZXRDb250YWluZXIgPSB0aGlzLnNldENvbnRhaW5lci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2V0dGluZ3NPcGVuOiBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9nZ2xlU2V0dGluZ3MoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgc2V0dGluZ3NPcGVuOiAhdGhpcy5zdGF0ZS5zZXR0aW5nc09wZW5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0Q29udGFpbmVyKHJlZikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHJlZjtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHRoaXMuY2xpY2tPdXRzaWRlKGUpLCB0cnVlKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHRoaXMuY2xpY2tPdXRzaWRlKGUpLCB0cnVlKTtcbiAgICB9XG5cbiAgICBjbGlja091dHNpZGUoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyBzZXR0aW5nc09wZW4gfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzT3BlbiAmJiB0aGlzLmNvbnRhaW5lciAmJiAhdGhpcy5jb250YWluZXIuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NPcGVuOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblJlZnJlc2hDYWxsYmFjaygpIHtcbiAgICAgICAgY29uc3QgeyBvblJlZnJlc2hDYWxsYmFjayB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBpZiAob25SZWZyZXNoQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIG9uUmVmcmVzaENhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkNsZWFyRmlsdGVyaW5nQ2FsbGJhY2soKSB7XG4gICAgICAgIGNvbnN0IHsgb25DbGVhckZpbHRlcmluZ0NhbGxiYWNrIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGlmIChvbkNsZWFyRmlsdGVyaW5nQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIG9uQ2xlYXJGaWx0ZXJpbmdDYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25DbGVhckNhY2hlQ2FsbGJhY2soKSB7XG4gICAgICAgIGNvbnN0IHsgb25DbGVhckNhY2hlQ2FsbGJhY2sgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKG9uQ2xlYXJDYWNoZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICBvbkNsZWFyQ2FjaGVDYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHNldHRpbmdzT3BlbiB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpMThuLFxuICAgICAgICAgICAgICAgIHZpc2libGVDb2x1bW5zQ2FsbGJhY2tPbkNoYW5nZSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zLFxuICAgICAgICAgICAgICAgIHZpc2libGVDb2x1bW5zLFxuICAgICAgICAgICAgICAgIGdjcnVkSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgR3JvdXBQcmltYXJ5QnV0dG9uLFxuICAgICAgICAgICAgICAgIEdyb3VwQnV0dG9uc0xpc3QsXG4gICAgICAgICAgICAgICAgc3ViTWVudUxlZnREaXJlY3Rpb25cbiAgICAgICAgICAgIH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgYnV0dG9ucyA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1N1Yk1lbnU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN1Yk1lbnVMZWZ0RGlyZWN0aW9uOiBzdWJNZW51TGVmdERpcmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2ZhIGZhLWxpc3QtYWx0JyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogaTE4bi5jb2x1bW5zLFxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2x1bW5zJyxcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogZSA9PiBlLnByZXZlbnREZWZhdWx0KCksXG4gICAgICAgICAgICAgICAgICAgIHN1YkNvbXBvbmVudDogPFZpc2libGVDb2x1bW5zXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja09uQ2hhbmdlPXt2aXNpYmxlQ29sdW1uc0NhbGxiYWNrT25DaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2NydWRJbnN0YW5jZT17Z2NydWRJbnN0YW5jZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGVDb2x1bW5zPXt2aXNpYmxlQ29sdW1uc31cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2ZhIGZhLXJlZnJlc2gnLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBpMThuLnJlZnJlc2gsXG4gICAgICAgICAgICAgICAgICAgIGtleTogJ3JlZnJlc2gnLFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBlID0+IHRoaXMub25SZWZyZXNoQ2FsbGJhY2soZSlcblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpY29uOiAnZmEgZmEtZmlsdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogaTE4bi5jbGVhcl9maWx0ZXJpbmcsXG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2NsZWFyX2ZpbHRlcmluZycsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGUgPT4gdGhpcy5vbkNsZWFyRmlsdGVyaW5nQ2FsbGJhY2soZSlcblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpY29uOiAnZmEgZmEtZXJhc2VyJyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogaTE4bi5jbGVhcl9jYWNoZSxcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnY2xlYXJfY2FjaGUnLFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBlID0+IHRoaXMub25DbGVhckNhY2hlQ2FsbGJhY2soZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuXG4gICAgICAgIHJldHVybiAoPGRpdiByZWY9e3RoaXMuc2V0Q29udGFpbmVyfSBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ2J0bi1ncm91cCcsIHtcbiAgICAgICAgICAgIG9wZW46IHNldHRpbmdzT3BlblxuICAgICAgICB9KX0gPlxuICAgICAgICAgICAgPEdyb3VwUHJpbWFyeUJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb25DbGljaz17KCkgPT4gdGhpcy50b2dnbGVTZXR0aW5ncygpfT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYSBmYS1nZWFyXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICZuYnNwO3tpMThuLnNldHRpbmdzfSZuYnNwO1xuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImNhcmV0XCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9Hcm91cFByaW1hcnlCdXR0b24+XG4gICAgICAgICAgICA8R3JvdXBCdXR0b25zTGlzdFxuICAgICAgICAgICAgICAgIHN1Yk1lbnVMZWZ0RGlyZWN0aW9uPXtzdWJNZW51TGVmdERpcmVjdGlvbn1cbiAgICAgICAgICAgICAgICBidXR0b25zPXtidXR0b25zLm1hcChidXR0b24gPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Yk1lbnVMZWZ0RGlyZWN0aW9uOiBidXR0b24uc3ViTWVudUxlZnREaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGhhc1N1Yk1lbnU6IGJ1dHRvbi5oYXNTdWJNZW51LFxuICAgICAgICAgICAgICAgICAgICBpY29uOiBidXR0b24uaWNvbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogYnV0dG9uLnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGtleTogYnV0dG9uLmtleSxcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1dHRvbi5vbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24ub25DbGljayhldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN1YkNvbXBvbmVudDogYnV0dG9uLnN1YkNvbXBvbmVudFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pfT5cbiAgICAgICAgICAgIDwvR3JvdXBCdXR0b25zTGlzdD5cbiAgICAgICAgPC9kaXY+KTtcbiAgICB9XG59XG5cblNldHRpbmdzLnByb3BUeXBlcyA9IHtcbiAgICBvblJlZnJlc2hDYWxsYmFjazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DbGVhckZpbHRlcmluZ0NhbGxiYWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNsZWFyQ2FjaGVDYWxsYmFjazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgY29sdW1uczogUHJvcFR5cGVzLmFycmF5LFxuICAgIGdjcnVkSW5zdGFuY2U6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgdmlzaWJsZUNvbHVtbnM6IFByb3BUeXBlcy5hcnJheSxcbiAgICB2aXNpYmxlQ29sdW1uc0NhbGxiYWNrT25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIGkxOG46IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICAgIHNldHRpbmdzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjb2x1bW5zOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICByZWZyZXNoOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjbGVhcl9maWx0ZXJpbmc6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNsZWFyX2NhY2hlOiBQcm9wVHlwZXMuc3RyaW5nXG4gICAgfSksXG4gICAgR3JvdXBQcmltYXJ5QnV0dG9uOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBzdWJNZW51TGVmdERpcmVjdGlvbjogUHJvcFR5cGVzLmJvb2xcbn07XG5cblNldHRpbmdzLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBHcm91cFByaW1hcnlCdXR0b246IChwcm9wcykgPT4gPGJ1dHRvbiB7Li4ucHJvcHN9Pntwcm9wcy5jaGlsZHJlbn08L2J1dHRvbj4sXG4gICAgR3JvdXBCdXR0b25zTGlzdDogKHByb3BzKSA9PiAoPHVsIGNsYXNzTmFtZT1cImRyb3Bkb3duLW1lbnVcIj5cbiAgICAgICAge3Byb3BzLmJ1dHRvbnMubWFwKGJ1dHRvbiA9PlxuICAgICAgICAgICAgPGxpIGtleT17YnV0dG9uLmtleX0gY2xhc3NOYW1lPXtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZHJvcGRvd24tc3VibWVudSc6IGJ1dHRvbi5oYXNTdWJNZW51LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xlZnQtZGlyZWN0aW9uJzogYnV0dG9uLmhhc1N1Yk1lbnUgJiYgYnV0dG9uLnN1Yk1lbnVMZWZ0RGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgICAgICAgIGhyZWY9e2J1dHRvbi5ocmVmID8gYnV0dG9uLmhyZWYgOiAnJ31cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17YnV0dG9uLm9uQ2xpY2t9XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldD17YnV0dG9uLnRhcmdldH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHtidXR0b24uaWNvbiAmJiA8aSBjbGFzc05hbWU9e2NsYXNzTmFtZXMoYnV0dG9uLmljb24sICdnYy1idXR0b24taWNvbicpfSAvPn1cbiAgICAgICAgICAgICAgICAgICAge2J1dHRvbi50ZXh0fVxuICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5zdWJDb21wb25lbnQgJiYgPHVsIGNsYXNzTmFtZT1cImRyb3Bkb3duLW1lbnVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtidXR0b24uc3ViQ29tcG9uZW50fVxuICAgICAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICl9XG4gICAgPC91bD4pXG59O1xuXG5leHBvcnQgZGVmYXVsdCBTZXR0aW5ncztcbiIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIFZpc2libGVDb2x1bW5zIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICBsZXQgY2hlY2tlZENvbHVtbnMgPSB7fSxcbiAgICAgICAgICAgIHsgdmlzaWJsZUNvbHVtbnMgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5jb2x1bW5zLmZvckVhY2goKGNvbHVtbikgPT4ge1xuICAgICAgICAgICAgY2hlY2tlZENvbHVtbnNbY29sdW1uLmNvbHVtbk5hbWVdID0gdmlzaWJsZUNvbHVtbnMuaW5kZXhPZihjb2x1bW4uY29sdW1uTmFtZSkgPiAtMTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGNoZWNrZWRDb2x1bW5zXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkNoZWNrYm94Q2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIGxldCBjaGVja2VkQ29sdW1ucyA9IHRoaXMuc3RhdGUuY2hlY2tlZENvbHVtbnMsXG4gICAgICAgICAgICB2aXNpYmxlQ29sdW1ucyA9IFtdO1xuXG4gICAgICAgIGNoZWNrZWRDb2x1bW5zW2V2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZmllbGQtbmFtZScpXSA9IGV2ZW50LnRhcmdldC5jaGVja2VkO1xuXG4gICAgICAgIGlmICghdGhpcy5oYXNBdExlYXN0T25lQ2hlY2tlZChjaGVja2VkQ29sdW1ucykpIHtcbiAgICAgICAgICAgIGNoZWNrZWRDb2x1bW5zW2V2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZmllbGQtbmFtZScpXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGNoZWNrZWRDb2x1bW5zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKGNoZWNrZWRDb2x1bW5zKS5mb3JFYWNoKChjb2x1bW5OYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hlY2tlZENvbHVtbnNbY29sdW1uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlQ29sdW1ucy5wdXNoKGNvbHVtbk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnByb3BzLmNhbGxiYWNrT25DaGFuZ2UuYXBwbHkodGhpcy5wcm9wcy5nY3J1ZEluc3RhbmNlLCBbdmlzaWJsZUNvbHVtbnNdKTtcbiAgICB9XG5cbiAgICBoYXNBdExlYXN0T25lQ2hlY2tlZChjaGVja2VkQ29sdW1ucykge1xuICAgICAgICBsZXQgYXRMZWFzdE9uZUNoZWNrZWQgPSBmYWxzZTtcblxuICAgICAgICBPYmplY3Qua2V5cyhjaGVja2VkQ29sdW1ucykuZm9yRWFjaCgoY29sdW1uTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoZWNrZWRDb2x1bW5zW2NvbHVtbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgYXRMZWFzdE9uZUNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXRMZWFzdE9uZUNoZWNrZWQ7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGNvbHVtbnMgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICB7IGNoZWNrZWRDb2x1bW5zIH0gPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgY29sdW1uc0NoZWNrYm94ZXMgPSBjb2x1bW5zLm1hcCgoY29sdW1uKSA9PlxuICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJkcm9wZG93bi1pdGVtXCIga2V5PXtjb2x1bW4uY29sdW1uTmFtZX0+XG4gICAgICAgICAgICAgICAgICAgIDxhPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBkYXRhLWZpZWxkLW5hbWU9e2NvbHVtbi5jb2x1bW5OYW1lfSBvbkNoYW5nZT17dGhpcy5vbkNoZWNrYm94Q2hhbmdlLmJpbmQodGhpcyl9IGNoZWNrZWQ9e2NoZWNrZWRDb2x1bW5zW2NvbHVtbi5jb2x1bW5OYW1lXX0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmbmJzcDsge2NvbHVtbi5kaXNwbGF5QXN9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIGNvbHVtbnNDaGVja2JveGVzO1xuICAgIH1cbn1cblxuVmlzaWJsZUNvbHVtbnMucHJvcFR5cGVzID0ge1xuICAgIGNvbHVtbnM6IFByb3BUeXBlcy5hcnJheSxcbiAgICB2aXNpYmxlQ29sdW1uczogUHJvcFR5cGVzLmFycmF5LFxuICAgIGdjcnVkSW5zdGFuY2U6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgY2FsbGJhY2tPbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFZpc2libGVDb2x1bW5zO1xuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzaWNPcGVyYXRvciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgaTE4biA9IHtcbiAgICAgICAgICAgIGJhc2ljX29wZXJhdG9yOiAnQmFzaWMgT3BlcmF0b3InLFxuICAgICAgICAgICAgYW5kX3N0YXRlbWVudDogJ0FORCcsXG4gICAgICAgICAgICBvcl9zdGF0ZW1lbnQ6ICdPUidcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5pMThuKSB7XG4gICAgICAgICAgICBpMThuID0gT2JqZWN0LmFzc2lnbih7fSwgaTE4biwgdGhpcy5wcm9wcy5pMThuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT1cInJvdyBmb3JtLWdyb3VwXCI+XG4gICAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiY29sLW1kLTMgY29udHJvbC1sYWJlbFwiPntpMThuLmJhc2ljX29wZXJhdG9yfSA6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLW1kLTNcIj5cbiAgICAgICAgICAgICAgICA8c2VsZWN0IG5hbWU9XCJiYXNpY19vcGVyYXRvclwiIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiPlxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiQU5EXCI+e2kxOG4uYW5kX3N0YXRlbWVudH08L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIk9SXCI+e2kxOG4ub3Jfc3RhdGVtZW50fTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIH1cbn0iLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dERhdGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyBvbkNvbXBvbmVudE1vdW50IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGlmIChvbkNvbXBvbmVudE1vdW50KSB7XG4gICAgICAgICAgICBvbkNvbXBvbmVudE1vdW50LmFwcGx5KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICBjb25zdCB7IG9uQ29tcG9uZW50VXBkYXRlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGlmIChvbkNvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICAgICAgb25Db21wb25lbnRVcGRhdGUuYXBwbHkodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIgKCkge1xuICAgICAgICBjb25zdCB7IGlucHV0VmFsdWUsIGZpZWxkSW5kZXggfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgcmV0dXJuIDxpbnB1dFxuICAgICAgICAgICAgcmVxdWlyZWQ9e3RydWV9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2xcIlxuICAgICAgICAgICAgbmFtZT17J2V4dGVuZGVkX3NlYXJjaFsnICsgZmllbGRJbmRleCArICddW3ZhbHVlXSd9XG4gICAgICAgICAgICB0eXBlPVwidGV4dFwiIHZhbHVlPXtpbnB1dFZhbHVlfVxuICAgICAgICAvPjtcbiAgICB9XG59XG5cbklucHV0RGF0ZS5wcm9wVHlwZXMgPSB7XG4gICAgZmllbGRJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBpbnB1dFZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGlucHV0VmFsdWVPbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmNcbn07IiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXRTZWxlY3REcm9wZG93biBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCB7IG9uQ29tcG9uZW50TW91bnQgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKG9uQ29tcG9uZW50TW91bnQpIHtcbiAgICAgICAgICAgIG9uQ29tcG9uZW50TW91bnQuYXBwbHkodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIGNvbnN0IHsgb25Db21wb25lbnRVcGRhdGUgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKG9uQ29tcG9uZW50VXBkYXRlKSB7XG4gICAgICAgICAgICBvbkNvbXBvbmVudFVwZGF0ZS5hcHBseSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlciAoKSB7XG4gICAgICAgIGNvbnN0IHsgcGVybWl0dGVkVmFsdWVzLCBmaWVsZEluZGV4IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgb3B0aW9uc0FycmF5ID0gW107XG5cbiAgICAgICAgT2JqZWN0LmtleXMocGVybWl0dGVkVmFsdWVzKS5mb3JFYWNoKChpdGVtSWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1EaXNwbGF5ID0gcGVybWl0dGVkVmFsdWVzW2l0ZW1JZF07XG4gICAgICAgICAgICBvcHRpb25zQXJyYXkucHVzaCg8b3B0aW9uIHZhbHVlPXtpdGVtSWR9IGtleT17aXRlbUlkfT57aXRlbURpc3BsYXl9PC9vcHRpb24+KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIDxzZWxlY3QgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCIgbmFtZT17J2V4dGVuZGVkX3NlYXJjaFsnICsgZmllbGRJbmRleCArICddW3ZhbHVlXSd9PlxuICAgICAgICAgICAge29wdGlvbnNBcnJheX1cbiAgICAgICAgPC9zZWxlY3Q+O1xuICAgIH1cbn0iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dFNlbGVjdFJlbGF0aW9uYWwgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyBvbkNvbXBvbmVudE1vdW50IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGlmIChvbkNvbXBvbmVudE1vdW50KSB7XG4gICAgICAgICAgICBvbkNvbXBvbmVudE1vdW50LmFwcGx5KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICBjb25zdCB7IG9uQ29tcG9uZW50VXBkYXRlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGlmIChvbkNvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICAgICAgb25Db21wb25lbnRVcGRhdGUuYXBwbHkodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIgKCkge1xuICAgICAgICBjb25zdCB7IHBlcm1pdHRlZFZhbHVlcywgZmllbGRJbmRleCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICByZXR1cm4gPHNlbGVjdCBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2xcIiBuYW1lPXsnZXh0ZW5kZWRfc2VhcmNoWycgKyBmaWVsZEluZGV4ICsgJ11bdmFsdWVdJ30+XG4gICAgICAgICAgICB7cGVybWl0dGVkVmFsdWVzLm1hcCgoaXRlbSkgPT4gPG9wdGlvbiB2YWx1ZT17aXRlbS5pZH0ga2V5PXtpdGVtLmlkfT57aXRlbS50aXRsZX08L29wdGlvbj4pfVxuICAgICAgICA8L3NlbGVjdD47XG4gICAgfVxufSIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0U2VsZWN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHsgb25Db21wb25lbnRNb3VudCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBpZiAob25Db21wb25lbnRNb3VudCkge1xuICAgICAgICAgICAgb25Db21wb25lbnRNb3VudC5hcHBseSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgeyBvbkNvbXBvbmVudFVwZGF0ZSB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBpZiAob25Db21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgICAgIG9uQ29tcG9uZW50VXBkYXRlLmFwcGx5KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyICgpIHtcbiAgICAgICAgY29uc3QgeyBwZXJtaXR0ZWRWYWx1ZXMsIGZpZWxkSW5kZXggfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgcmV0dXJuIDxzZWxlY3QgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCIgbmFtZT17J2V4dGVuZGVkX3NlYXJjaFsnICsgZmllbGRJbmRleCArICddW3ZhbHVlXSd9PlxuICAgICAgICAgICAge3Blcm1pdHRlZFZhbHVlcy5tYXAoKGl0ZW0pID0+IDxvcHRpb24gdmFsdWU9e2l0ZW19IGtleT17aXRlbX0+e2l0ZW19PC9vcHRpb24+KX1cbiAgICAgICAgPC9zZWxlY3Q+O1xuICAgIH1cbn0iLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFNlbGVjdE9wdGlvbnNFcXVhbE5vdEVxdWFsIGZyb20gJy4uL3NlbGVjdC1vcHRpb25zL2VxdWFsX25vdF9lcXVhbCc7XG5pbXBvcnQgRmlsdGVyU2VsZWN0IGZyb20gXCIuLi9maWx0ZXItc2VsZWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaENoZWNrYm94Qm9vbGVhbiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGNvbXBhcmlzb25WYWx1ZTogJ2VxdWFscycsXG4gICAgICAgICAgICBpc0NoZWNrZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpbnB1dFZhbHVlT25DaGFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IHsgaXNDaGVja2VkIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaXNDaGVja2VkOiAhaXNDaGVja2VkXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbXBhcmlzb25PbkNoYW5nZShjb21wYXJpc29uVmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjb21wYXJpc29uVmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGlzQ2hlY2tlZCwgY29tcGFyaXNvblZhbHVlIH0gPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgeyBmaWVsZEluZGV4LCBpMThuLCBpc01vYmlsZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IEpzeEFycmF5O1xuXG4gICAgICAgIEpzeEFycmF5ID0gW1xuICAgICAgICAgICAgPEZpbHRlclNlbGVjdFxuICAgICAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICAgICAgZmllbGRJbmRleD17ZmllbGRJbmRleH1cbiAgICAgICAgICAgICAgICBTZWxlY3RPcHRpb25zPXtTZWxlY3RPcHRpb25zRXF1YWxOb3RFcXVhbH1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZUNhbGxiYWNrPXt0aGlzLmNvbXBhcmlzb25PbkNoYW5nZS5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgICAgIGtleT1cIjBcIlxuICAgICAgICAgICAgICAgIGlzTW9iaWxlPXtpc01vYmlsZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKGNvbXBhcmlzb25WYWx1ZSAhPT0gJ2lzX2VtcHR5JyAmJiBjb21wYXJpc29uVmFsdWUgIT09ICdpc19ub3RfZW1wdHknKSB7XG4gICAgICAgICAgICBKc3hBcnJheS5wdXNoKDxkaXYga2V5PVwiMlwiIGNsYXNzTmFtZT1cImNvbC1tZC04XCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNoZWNrZWQ9e2lzQ2hlY2tlZH0gb25DaGFuZ2U9e3RoaXMuaW5wdXRWYWx1ZU9uQ2hhbmdlLmJpbmQodGhpcyl9IHN0eWxlPXt7IG1hcmdpblRvcDogMTIgfX0gLz5cbiAgICAgICAgICAgICAgICA8aW5wdXQgbmFtZT17J2V4dGVuZGVkX3NlYXJjaFsnICsgZmllbGRJbmRleCArICddW3ZhbHVlXSd9IHR5cGU9XCJoaWRkZW5cIiB2YWx1ZT17aXNDaGVja2VkID8gJzEnIDogJzAnfS8+XG4gICAgICAgICAgICA8L2Rpdj4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEpzeEFycmF5O1xuICAgIH1cbn1cblxuU2VhcmNoQ2hlY2tib3hCb29sZWFuLnByb3BUeXBlcyA9IHtcbiAgICBmaWVsZEluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGlzTW9iaWxlOiBQcm9wVHlwZXMuYm9vbFxufTtcblxuU2VhcmNoQ2hlY2tib3hCb29sZWFuLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBpc01vYmlsZTogZmFsc2Vcbn07IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBDb21wYXJpc29uU2VsZWN0T3B0aW9ucyBmcm9tICcuLi9zZWxlY3Qtb3B0aW9ucy9jb21wYXJpc29uJztcbmltcG9ydCBGaWx0ZXJTZWxlY3QgZnJvbSBcIi4uL2ZpbHRlci1zZWxlY3RcIjtcbmltcG9ydCBJbnB1dERhdGUgZnJvbSBcIi4uL2ZpZWxkLWlucHV0L2RhdGVcIjtcblxuY2xhc3MgU2VhcmNoRGF0ZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGNvbXBhcmlzb25WYWx1ZTogJ2NvbnRhaW5zJyxcbiAgICAgICAgICAgIGlucHV0VmFsdWU6ICcnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29tcGFyaXNvbk9uQ2hhbmdlKGNvbXBhcmlzb25WYWx1ZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGNvbXBhcmlzb25WYWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY29tcGFyaXNvblZhbHVlIH0gPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgeyBmaWVsZEluZGV4LCBvbkNvbXBvbmVudE1vdW50LCBvbkNvbXBvbmVudFVwZGF0ZSwgaTE4biwgaXNNb2JpbGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBKc3hBcnJheTtcblxuICAgICAgICBKc3hBcnJheSA9IFtcbiAgICAgICAgICAgIDxGaWx0ZXJTZWxlY3RcbiAgICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgICAgIGZpZWxkSW5kZXg9e2ZpZWxkSW5kZXh9XG4gICAgICAgICAgICAgICAgU2VsZWN0T3B0aW9ucz17Q29tcGFyaXNvblNlbGVjdE9wdGlvbnN9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2VDYWxsYmFjaz17dGhpcy5jb21wYXJpc29uT25DaGFuZ2UuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICBrZXk9XCIwXCJcbiAgICAgICAgICAgICAgICBpc01vYmlsZT17aXNNb2JpbGV9XG4gICAgICAgICAgICAvPlxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChjb21wYXJpc29uVmFsdWUgIT09ICdpc19lbXB0eScgJiYgY29tcGFyaXNvblZhbHVlICE9PSAnaXNfbm90X2VtcHR5Jykge1xuICAgICAgICAgICAgSnN4QXJyYXkucHVzaCg8ZGl2IGtleT1cIjJcIiBjbGFzc05hbWU9XCJjb2wtbWQtOFwiPlxuICAgICAgICAgICAgICAgIDxJbnB1dERhdGVcbiAgICAgICAgICAgICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICAgICAgICAgICAgZmllbGRJbmRleD17ZmllbGRJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgb25Db21wb25lbnRNb3VudD17b25Db21wb25lbnRNb3VudH1cbiAgICAgICAgICAgICAgICAgICAgb25Db21wb25lbnRVcGRhdGU9e29uQ29tcG9uZW50VXBkYXRlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEpzeEFycmF5O1xuICAgIH1cbn1cblxuU2VhcmNoRGF0ZS5wcm9wVHlwZXMgPSB7XG4gICAgZmllbGRJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBvbkNvbXBvbmVudE1vdW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNvbXBvbmVudFVwZGF0ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgaXNNb2JpbGU6IFByb3BUeXBlcy5ib29sXG59O1xuXG5TZWFyY2hEYXRlLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBpc01vYmlsZTogZmFsc2Vcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNlYXJjaERhdGU7IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBGaWx0ZXJTZWxlY3QgZnJvbSBcIi4uL2ZpbHRlci1zZWxlY3RcIjtcbmltcG9ydCBJbnB1dFNlbGVjdERyb3Bkb3duIGZyb20gXCIuLi9maWVsZC1pbnB1dC9zZWxlY3QtZHJvcGRvd25cIjtcbmltcG9ydCBTZWxlY3RPcHRpb25zRXF1YWxOb3RFcXVhbCBmcm9tIFwiLi4vc2VsZWN0LW9wdGlvbnMvZXF1YWxfbm90X2VxdWFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaERyb3Bkb3duIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgY29tcGFyaXNvblZhbHVlOiAnY29udGFpbnMnLFxuICAgICAgICAgICAgaW5wdXRWYWx1ZTogJydcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb21wYXJpc29uT25DaGFuZ2UoY29tcGFyaXNvblZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgY29tcGFyaXNvblZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBjb21wYXJpc29uVmFsdWUgfSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICB7IGZpZWxkSW5kZXgsIHBlcm1pdHRlZFZhbHVlcywgb25Db21wb25lbnRNb3VudCwgb25Db21wb25lbnRVcGRhdGUsIGkxOG4sIGlzTW9iaWxlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgSnN4QXJyYXksXG4gICAgICAgICAgICBvcHRpb25zQXJyYXkgPSBbXTtcblxuICAgICAgICBKc3hBcnJheSA9IFtcbiAgICAgICAgICAgIDxGaWx0ZXJTZWxlY3RcbiAgICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgICAgIGZpZWxkSW5kZXg9e2ZpZWxkSW5kZXh9XG4gICAgICAgICAgICAgICAgU2VsZWN0T3B0aW9ucz17U2VsZWN0T3B0aW9uc0VxdWFsTm90RXF1YWx9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2VDYWxsYmFjaz17dGhpcy5jb21wYXJpc29uT25DaGFuZ2UuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICBrZXk9XCIwXCJcbiAgICAgICAgICAgICAgICBpc01vYmlsZT17aXNNb2JpbGV9XG4gICAgICAgICAgICAvPlxuICAgICAgICBdO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKHBlcm1pdHRlZFZhbHVlcykuZm9yRWFjaCgoaXRlbUlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVtRGlzcGxheSA9IHBlcm1pdHRlZFZhbHVlc1tpdGVtSWRdO1xuICAgICAgICAgICAgb3B0aW9uc0FycmF5LnB1c2goPG9wdGlvbiB2YWx1ZT17aXRlbUlkfSBrZXk9e2l0ZW1JZH0+e2l0ZW1EaXNwbGF5fTwvb3B0aW9uPik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjb21wYXJpc29uVmFsdWUgIT09ICdpc19lbXB0eScgJiYgY29tcGFyaXNvblZhbHVlICE9PSAnaXNfbm90X2VtcHR5Jykge1xuICAgICAgICAgICAgSnN4QXJyYXkucHVzaCg8ZGl2IGtleT1cIjJcIiBjbGFzc05hbWU9XCJjb2wtbWQtOFwiPlxuICAgICAgICAgICAgICAgIDxJbnB1dFNlbGVjdERyb3Bkb3duXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkSW5kZXg9e2ZpZWxkSW5kZXh9XG4gICAgICAgICAgICAgICAgICAgIHBlcm1pdHRlZFZhbHVlcz17cGVybWl0dGVkVmFsdWVzfVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBvbmVudE1vdW50PXtvbkNvbXBvbmVudE1vdW50fVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBvbmVudFVwZGF0ZT17b25Db21wb25lbnRVcGRhdGV9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2Pik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gSnN4QXJyYXk7XG4gICAgfVxufVxuXG5TZWFyY2hEcm9wZG93bi5wcm9wVHlwZXMgPSB7XG4gICAgZmllbGRJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBwZXJtaXR0ZWRWYWx1ZXM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgaXNNb2JpbGU6IFByb3BUeXBlcy5pc01vYmlsZVxufTtcblxuU2VhcmNoRHJvcGRvd24uZGVmYXVsdFByb3BzID0ge1xuICAgIGlzTW9iaWxlOiBmYWxzZVxufTsiLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEZpbHRlclNlbGVjdCBmcm9tIFwiLi4vZmlsdGVyLXNlbGVjdFwiO1xuaW1wb3J0IElucHV0U2VsZWN0IGZyb20gXCIuLi9maWVsZC1pbnB1dC9zZWxlY3RcIjtcbmltcG9ydCBTZWxlY3RPcHRpb25zRXF1YWxOb3RFcXVhbCBmcm9tIFwiLi4vc2VsZWN0LW9wdGlvbnMvZXF1YWxfbm90X2VxdWFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaEVudW0gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjb21wYXJpc29uVmFsdWU6ICdjb250YWlucydcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb21wYXJpc29uT25DaGFuZ2UoY29tcGFyaXNvblZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgY29tcGFyaXNvblZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBjb21wYXJpc29uVmFsdWUgfSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZmllbGRJbmRleCxcbiAgICAgICAgICAgICAgICBwZXJtaXR0ZWRWYWx1ZXMsXG4gICAgICAgICAgICAgICAgb25Db21wb25lbnRNb3VudCxcbiAgICAgICAgICAgICAgICBvbkNvbXBvbmVudFVwZGF0ZSxcbiAgICAgICAgICAgICAgICBpMThuLFxuICAgICAgICAgICAgICAgIGlzTW9iaWxlXG4gICAgICAgICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IEpzeEFycmF5O1xuXG4gICAgICAgIEpzeEFycmF5ID0gW1xuICAgICAgICAgICAgPEZpbHRlclNlbGVjdFxuICAgICAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICAgICAgZmllbGRJbmRleD17ZmllbGRJbmRleH1cbiAgICAgICAgICAgICAgICBTZWxlY3RPcHRpb25zPXtTZWxlY3RPcHRpb25zRXF1YWxOb3RFcXVhbH1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZUNhbGxiYWNrPXt0aGlzLmNvbXBhcmlzb25PbkNoYW5nZS5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgICAgIGtleT1cIjBcIlxuICAgICAgICAgICAgICAgIGlzTW9iaWxlPXtpc01vYmlsZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKGNvbXBhcmlzb25WYWx1ZSAhPT0gJ2lzX2VtcHR5JyAmJiBjb21wYXJpc29uVmFsdWUgIT09ICdpc19ub3RfZW1wdHknKSB7XG4gICAgICAgICAgICBKc3hBcnJheS5wdXNoKDxkaXYga2V5PVwiMlwiIGNsYXNzTmFtZT1cImNvbC1tZC04XCI+XG4gICAgICAgICAgICAgICAgPElucHV0U2VsZWN0XG4gICAgICAgICAgICAgICAgICAgIHBlcm1pdHRlZFZhbHVlcz17cGVybWl0dGVkVmFsdWVzfVxuICAgICAgICAgICAgICAgICAgICBmaWVsZEluZGV4PXtmaWVsZEluZGV4fVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBvbmVudE1vdW50PXtvbkNvbXBvbmVudE1vdW50fVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBvbmVudFVwZGF0ZT17b25Db21wb25lbnRVcGRhdGV9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2Pik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gSnN4QXJyYXk7XG4gICAgfVxufVxuXG5TZWFyY2hFbnVtLnByb3BUeXBlcyA9IHtcbiAgICBmaWVsZEluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHBlcm1pdHRlZFZhbHVlczogUHJvcFR5cGVzLmFycmF5LFxuICAgIGlzTW9iaWxlOiBQcm9wVHlwZXMuYm9vbFxufTtcblxuU2VhcmNoRW51bS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgaXNNb2JpbGU6IGZhbHNlXG59OyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQ29tcGFyaXNvblNlbGVjdE9wdGlvbnMgZnJvbSAnLi4vc2VsZWN0LW9wdGlvbnMvY29tcGFyaXNvbic7XG5pbXBvcnQgRmlsdGVyU2VsZWN0IGZyb20gJy4uL2ZpbHRlci1zZWxlY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hOdW1lcmljIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgY29tcGFyaXNvblZhbHVlOiAnZXF1YWxzJyxcbiAgICAgICAgICAgIGlucHV0VmFsdWU6ICcnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaW5wdXRWYWx1ZU9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaW5wdXRWYWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbXBhcmlzb25PbkNoYW5nZShjb21wYXJpc29uVmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjb21wYXJpc29uVmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGNvbXBhcmlzb25WYWx1ZSwgaW5wdXRWYWx1ZSB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIHsgZmllbGRJbmRleCwgaTE4biwgaXNNb2JpbGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBKc3hBcnJheTtcblxuICAgICAgICBKc3hBcnJheSA9IFtcbiAgICAgICAgICAgIDxGaWx0ZXJTZWxlY3RcbiAgICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgICAgIGZpZWxkSW5kZXg9e2ZpZWxkSW5kZXh9XG4gICAgICAgICAgICAgICAgU2VsZWN0T3B0aW9ucz17Q29tcGFyaXNvblNlbGVjdE9wdGlvbnN9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2VDYWxsYmFjaz17dGhpcy5jb21wYXJpc29uT25DaGFuZ2UuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICBrZXk9XCIwXCJcbiAgICAgICAgICAgICAgICBpc01vYmlsZT17aXNNb2JpbGV9XG4gICAgICAgICAgICAvPlxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChjb21wYXJpc29uVmFsdWUgIT09ICdpc19lbXB0eScgJiYgY29tcGFyaXNvblZhbHVlICE9PSAnaXNfbm90X2VtcHR5Jykge1xuICAgICAgICAgICAgSnN4QXJyYXkucHVzaCg8ZGl2IGtleT1cIjJcIiBjbGFzc05hbWU9XCJjb2wtbWQtOFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCByZXF1aXJlZD17dHJ1ZX0gY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCIgbmFtZT17J2V4dGVuZGVkX3NlYXJjaFsnICsgZmllbGRJbmRleCArICddW3ZhbHVlXSd9IHR5cGU9XCJudW1iZXJcIiB2YWx1ZT17aW5wdXRWYWx1ZX0gb25DaGFuZ2U9e3RoaXMuaW5wdXRWYWx1ZU9uQ2hhbmdlLmJpbmQodGhpcyl9IC8+XG4gICAgICAgICAgICA8L2Rpdj4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEpzeEFycmF5O1xuICAgIH1cbn1cblxuU2VhcmNoTnVtZXJpYy5wcm9wVHlwZXMgPSB7XG4gICAgZmllbGRJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBpc01vYmlsZTogUHJvcFR5cGVzLmJvb2xcbn07XG5cblNlYXJjaE51bWVyaWMuZGVmYXVsdFByb3BzID0ge1xuICAgIGlzTW9iaWxlOiBmYWxzZVxufTsiLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFNlbGVjdE9wdGlvbnNIYXNPck5vdCBmcm9tIFwiLi4vc2VsZWN0LW9wdGlvbnMvaGFzX29yX25vdFwiO1xuaW1wb3J0IEZpbHRlclNlbGVjdCBmcm9tIFwiLi4vZmlsdGVyLXNlbGVjdFwiO1xuaW1wb3J0IElucHV0U2VsZWN0UmVsYXRpb25hbCBmcm9tIFwiLi4vZmllbGQtaW5wdXQvc2VsZWN0LXJlbGF0aW9uYWxcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoUmVsYXRpb25hbE50b04gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjb21wYXJpc29uVmFsdWU6ICdoYXMnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29tcGFyaXNvbk9uQ2hhbmdlKGNvbXBhcmlzb25WYWx1ZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGNvbXBhcmlzb25WYWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY29tcGFyaXNvblZhbHVlIH0gPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgeyBmaWVsZEluZGV4LCBwZXJtaXR0ZWRWYWx1ZXMsIG9uQ29tcG9uZW50TW91bnQsIG9uQ29tcG9uZW50VXBkYXRlLCBpMThuLCBpc01vYmlsZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IEpzeEFycmF5O1xuXG4gICAgICAgIEpzeEFycmF5ID0gW1xuICAgICAgICAgICAgPEZpbHRlclNlbGVjdFxuICAgICAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICAgICAgZmllbGRJbmRleD17ZmllbGRJbmRleH1cbiAgICAgICAgICAgICAgICBTZWxlY3RPcHRpb25zPXtTZWxlY3RPcHRpb25zSGFzT3JOb3R9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2VDYWxsYmFjaz17dGhpcy5jb21wYXJpc29uT25DaGFuZ2UuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICBrZXk9XCIwXCJcbiAgICAgICAgICAgICAgICBpc01vYmlsZT17aXNNb2JpbGV9XG4gICAgICAgICAgICAvPlxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChjb21wYXJpc29uVmFsdWUgIT09ICdpc19lbXB0eScgJiYgY29tcGFyaXNvblZhbHVlICE9PSAnaXNfbm90X2VtcHR5Jykge1xuICAgICAgICAgICAgSnN4QXJyYXkucHVzaCg8ZGl2IGtleT1cIjJcIiBjbGFzc05hbWU9XCJjb2wtbWQtOFwiPlxuICAgICAgICAgICAgICAgIDxJbnB1dFNlbGVjdFJlbGF0aW9uYWxcbiAgICAgICAgICAgICAgICAgICAgZmllbGRJbmRleD17ZmllbGRJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgcGVybWl0dGVkVmFsdWVzPXtwZXJtaXR0ZWRWYWx1ZXN9XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcG9uZW50TW91bnQ9e29uQ29tcG9uZW50TW91bnR9XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcG9uZW50VXBkYXRlPXtvbkNvbXBvbmVudFVwZGF0ZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBKc3hBcnJheTtcbiAgICB9XG59XG5cblNlYXJjaFJlbGF0aW9uYWxOdG9OLnByb3BUeXBlcyA9IHtcbiAgICBmaWVsZEluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHBlcm1pdHRlZFZhbHVlczogUHJvcFR5cGVzLmFycmF5LFxuICAgIGlzTW9iaWxlOiBQcm9wVHlwZXMuYm9vbFxufTtcblxuU2VhcmNoUmVsYXRpb25hbE50b04uZGVmYXVsdFByb3BzID0ge1xuICAgIGlzTW9iaWxlOiBmYWxzZVxufTsiLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEZpbHRlclNlbGVjdCBmcm9tIFwiLi4vZmlsdGVyLXNlbGVjdFwiO1xuaW1wb3J0IElucHV0U2VsZWN0UmVsYXRpb25hbCBmcm9tIFwiLi4vZmllbGQtaW5wdXQvc2VsZWN0LXJlbGF0aW9uYWxcIjtcbmltcG9ydCBTZWxlY3RPcHRpb25zRXF1YWxOb3RFcXVhbCBmcm9tIFwiLi4vc2VsZWN0LW9wdGlvbnMvZXF1YWxfbm90X2VxdWFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaFJlbGF0aW9uYWwgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjb21wYXJpc29uVmFsdWU6ICdoYXMnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29tcGFyaXNvbk9uQ2hhbmdlKGNvbXBhcmlzb25WYWx1ZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGNvbXBhcmlzb25WYWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY29tcGFyaXNvblZhbHVlIH0gPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgeyBmaWVsZEluZGV4LCBwZXJtaXR0ZWRWYWx1ZXMsIG9uQ29tcG9uZW50TW91bnQsIG9uQ29tcG9uZW50VXBkYXRlLCBpMThuLCBpc01vYmlsZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IEpzeEFycmF5O1xuXG4gICAgICAgIEpzeEFycmF5ID0gW1xuICAgICAgICAgICAgPEZpbHRlclNlbGVjdFxuICAgICAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICAgICAgZmllbGRJbmRleD17ZmllbGRJbmRleH1cbiAgICAgICAgICAgICAgICBTZWxlY3RPcHRpb25zPXtTZWxlY3RPcHRpb25zRXF1YWxOb3RFcXVhbH1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZUNhbGxiYWNrPXt0aGlzLmNvbXBhcmlzb25PbkNoYW5nZS5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgICAgIGtleT1cIjBcIlxuICAgICAgICAgICAgICAgIGlzTW9iaWxlPXtpc01vYmlsZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKGNvbXBhcmlzb25WYWx1ZSAhPT0gJ2lzX2VtcHR5JyAmJiBjb21wYXJpc29uVmFsdWUgIT09ICdpc19ub3RfZW1wdHknKSB7XG4gICAgICAgICAgICBKc3hBcnJheS5wdXNoKDxkaXYga2V5PVwiMlwiIGNsYXNzTmFtZT1cImNvbC1tZC04XCI+XG4gICAgICAgICAgICAgICAgPElucHV0U2VsZWN0UmVsYXRpb25hbFxuICAgICAgICAgICAgICAgICAgICBmaWVsZEluZGV4PXtmaWVsZEluZGV4fVxuICAgICAgICAgICAgICAgICAgICBwZXJtaXR0ZWRWYWx1ZXM9e3Blcm1pdHRlZFZhbHVlc31cbiAgICAgICAgICAgICAgICAgICAgb25Db21wb25lbnRNb3VudD17b25Db21wb25lbnRNb3VudH1cbiAgICAgICAgICAgICAgICAgICAgb25Db21wb25lbnRVcGRhdGU9e29uQ29tcG9uZW50VXBkYXRlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEpzeEFycmF5O1xuICAgIH1cbn1cblxuU2VhcmNoUmVsYXRpb25hbC5wcm9wVHlwZXMgPSB7XG4gICAgZmllbGRJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBwZXJtaXR0ZWRWYWx1ZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgICBpc01vYmlsZTogUHJvcFR5cGVzLmJvb2xcbn07XG5cblNlYXJjaFJlbGF0aW9uYWwuZGVmYXVsdFByb3BzID0ge1xuICAgIGlzTW9iaWxlOiBmYWxzZVxufSIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgRmlsdGVyU2VsZWN0IGZyb20gJy4uL2ZpbHRlci1zZWxlY3QnO1xuaW1wb3J0IFRleHRTZWxlY3RPcHRpb25zIGZyb20gJy4uL3NlbGVjdC1vcHRpb25zL3RleHQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hUZXh0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgY29tcGFyaXNvblZhbHVlOiAnY29udGFpbnMnLFxuICAgICAgICAgICAgaW5wdXRWYWx1ZTogJydcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpbnB1dFZhbHVlT25DaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBpbnB1dFZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29tcGFyaXNvbk9uQ2hhbmdlKGNvbXBhcmlzb25WYWx1ZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGNvbXBhcmlzb25WYWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY29tcGFyaXNvblZhbHVlLCBpbnB1dFZhbHVlIH0gPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgeyBmaWVsZEluZGV4LCBpMThuLCBpc01vYmlsZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IEpzeEFycmF5O1xuXG4gICAgICAgIEpzeEFycmF5ID0gW1xuICAgICAgICAgICAgPEZpbHRlclNlbGVjdFxuICAgICAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICAgICAgZmllbGRJbmRleD17ZmllbGRJbmRleH1cbiAgICAgICAgICAgICAgICBTZWxlY3RPcHRpb25zPXtUZXh0U2VsZWN0T3B0aW9uc31cbiAgICAgICAgICAgICAgICBvbkNoYW5nZUNhbGxiYWNrPXt0aGlzLmNvbXBhcmlzb25PbkNoYW5nZS5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgICAgIGtleT1cIjFcIlxuICAgICAgICAgICAgICAgIGlzTW9iaWxlPXtpc01vYmlsZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKGNvbXBhcmlzb25WYWx1ZSAhPT0gJ2lzX2VtcHR5JyAmJiBjb21wYXJpc29uVmFsdWUgIT09ICdpc19ub3RfZW1wdHknKSB7XG4gICAgICAgICAgICBKc3hBcnJheS5wdXNoKDxkaXYga2V5PVwiMlwiIGNsYXNzTmFtZT1cImNvbC1tZC04XCI+XG4gICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkPXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2xcIlxuICAgICAgICAgICAgICAgICAgICBuYW1lPXsnZXh0ZW5kZWRfc2VhcmNoWycgKyBmaWVsZEluZGV4ICsgJ11bdmFsdWVdJ31cbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17aW5wdXRWYWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaW5wdXRWYWx1ZU9uQ2hhbmdlLmJpbmQodGhpcyl9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2Pik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gSnN4QXJyYXk7XG4gICAgfVxufVxuXG5TZWFyY2hUZXh0LnByb3BUeXBlcyA9IHtcbiAgICBmaWVsZEluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGlzTW9iaWxlOiBQcm9wVHlwZXMuYm9vbFxufTtcblxuU2VhcmNoVGV4dC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgaXNNb2JpbGU6IGZhbHNlXG59OyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsdGVyU2VsZWN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgY29tcGFyaXNvblZhbHVlOiAnJ1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VsZWN0T25DaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY29tcGFyaXNvblZhbHVlID0gZXZlbnQudGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgeyBvbkNoYW5nZUNhbGxiYWNrIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgY29tcGFyaXNvblZhbHVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9uQ2hhbmdlQ2FsbGJhY2soY29tcGFyaXNvblZhbHVlKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgZmllbGRJbmRleCwgU2VsZWN0T3B0aW9ucywgaTE4biwgaXNNb2JpbGUgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICB7IGNvbXBhcmlzb25WYWx1ZSB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ2NvbC1tZC00Jyx7XG4gICAgICAgICAgICAnYjEwJzogaXNNb2JpbGVcbiAgICAgICAgfSl9PlxuICAgICAgICAgICAgPHNlbGVjdCBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2xcIiBuYW1lPXsnZXh0ZW5kZWRfc2VhcmNoWycgKyBmaWVsZEluZGV4ICsgJ11bZmlsdGVyXSd9IHZhbHVlPXtjb21wYXJpc29uVmFsdWV9IG9uQ2hhbmdlPXt0aGlzLnNlbGVjdE9uQ2hhbmdlLmJpbmQodGhpcyl9PlxuICAgICAgICAgICAgICAgIDxTZWxlY3RPcHRpb25zIGkxOG49e2kxOG59IC8+XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgPC9kaXY+XG4gICAgfVxufVxuXG5GaWx0ZXJTZWxlY3QucHJvcFR5cGVzID0ge1xuICAgIGZpZWxkSW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgU2VsZWN0T3B0aW9uczogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DaGFuZ2VDYWxsYmFjazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgaXNNb2JpbGU6IFByb3BUeXBlcy5ib29sXG59O1xuXG5GaWx0ZXJTZWxlY3QuZGVmYXVsdFByb3BzID0ge1xuICAgIGlzTW9iaWxlOiBmYWxzZVxufVxuIiwiaW1wb3J0IEJhc2ljT3BlcmF0b3IgZnJvbSAnLi9iYXNpYy1vcGVyYXRvci5qcyc7XG5pbXBvcnQgTXVsdGlwbGVTZWFyY2ggZnJvbSAnLi9tdWx0aXBsZS1zZWFyY2guanMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWx0ZXJpbmcgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpbmRleGVzOiBbXG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFkZE1vcmVGaWx0ZXJzKCkge1xuICAgICAgICBsZXQgeyBpbmRleGVzIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIC8vIHRoZSBsYXN0IGluZGV4IGlzIGFsd2F5cyB0aGUgYmlnZ2VyIG9uZSBzbyBhZGQgKzFcbiAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4ZXNbaW5kZXhlcy5sZW5ndGggLSAxXSArIDEpO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaW5kZXhlc1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZW1vdmVGaWx0ZXIoZmllbGRJbmRleCkge1xuICAgICAgICBsZXQgeyBpbmRleGVzIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIGluZGV4ZXMgPSBpbmRleGVzLmZpbHRlcigoaW5kZXgpID0+IGluZGV4ICE9PSBmaWVsZEluZGV4KVxuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaW5kZXhlc1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgaW5kZXhlcyB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgICAgICAgb25TdWJtaXRDYWxsYmFjayxcbiAgICAgICAgICAgICAgICBvbklucHV0TW91bnQsXG4gICAgICAgICAgICAgICAgTW9kYWxUaXRsZSxcbiAgICAgICAgICAgICAgICBzY3JlZW5TaXplXG4gICAgICAgICAgICB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGluZGV4ZXNMZW5ndGggPSBpbmRleGVzLmxlbmd0aDtcbiAgICAgICAgbGV0IEpTWGFycmF5LFxuICAgICAgICAgICAgaTE4biA9IHtcbiAgICAgICAgICAgICAgICBiYXNpY19vcGVyYXRvcjogJ0Jhc2ljIE9wZXJhdG9yJyxcbiAgICAgICAgICAgICAgICBhbmRfc3RhdGVtZW50OiAnQU5EJyxcbiAgICAgICAgICAgICAgICBvcl9zdGF0ZW1lbnQ6ICdPUicsXG4gICAgICAgICAgICAgICAgZmlsdGVyaW5nOiAnRmlsdGVyaW5nJyxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6ICdGaWx0ZXInLFxuICAgICAgICAgICAgICAgIGNhbmNlbF9maWx0ZXJpbmc6ICdDYW5jZWwnLFxuICAgICAgICAgICAgICAgIGFkZF9tb3JlOiAnQWRkIG1vcmUnLFxuICAgICAgICAgICAgICAgIHJlbW92ZV9maWx0ZXI6ICdSZW1vdmUgRmlsdGVyJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5pMThuKSB7XG4gICAgICAgICAgICBpMThuID0gT2JqZWN0LmFzc2lnbih7fSwgaTE4biwgdGhpcy5wcm9wcy5pMThuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEpTWGFycmF5ID0gaW5kZXhlcy5tYXAoXG4gICAgICAgICAgICAoaW5kZXgpID0+XG4gICAgICAgICAgICAgICAgPE11bHRpcGxlU2VhcmNoXG4gICAgICAgICAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcz17ZmllbGRzfVxuICAgICAgICAgICAgICAgICAgICBmaWVsZEluZGV4PXtpbmRleH1cbiAgICAgICAgICAgICAgICAgICAga2V5PXtpbmRleH1cbiAgICAgICAgICAgICAgICAgICAgaGFzUmVtb3ZlQnV0dG9uPXtpbmRleGVzTGVuZ3RoID4gMX1cbiAgICAgICAgICAgICAgICAgICAgb25EZWxldGVDYWxsYmFjaz17dGhpcy5yZW1vdmVGaWx0ZXIuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICAgICAgb25JbnB1dE1vdW50PXtvbklucHV0TW91bnR9XG4gICAgICAgICAgICAgICAgICAgIHNjcmVlblNpemU9e3NjcmVlblNpemV9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJtb2RhbC1kaWFsb2cgZ2MtbW9kYWwtZGlhbG9nXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICA8Zm9ybSBtZXRob2Q9XCJwb3N0XCIgY2xhc3NOYW1lPVwiZm9ybS1ob3Jpem9udGFsXCIgb25TdWJtaXQ9e29uU3VibWl0Q2FsbGJhY2suYmluZCh0aGlzKX0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW9kYWwtaGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8TW9kYWxUaXRsZSB0aXRsZT17aTE4bi5maWx0ZXJpbmd9Lz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW9kYWwtYm9keSBkZWxldGUtbW9kYWxcIj5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxCYXNpY09wZXJhdG9yIGkxOG49e2kxOG59IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge0pTWGFycmF5fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2MtZmlsdGVyaW5nLXJvd1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJ0biBidG4tZGVmYXVsdCBidG4tb3V0bGluZS1kYXJrXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuYWRkTW9yZUZpbHRlcnMuYmluZCh0aGlzKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZW0gY2xhc3NOYW1lPVwiZmEgZmEtcGx1c1wiPjwvZW0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmbmJzcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpMThuLmFkZF9tb3JlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW9kYWwtZm9vdGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzc05hbWU9XCJidG4gYnRuLWRlZmF1bHQgYnRuLW91dGxpbmUtZGFya1wiIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2kxOG4uY2FuY2VsX2ZpbHRlcmluZ31cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwic3VibWl0XCIgY2xhc3NOYW1lPVwiYnRuIGJ0bi1zdWNjZXNzIGRlbGV0ZS1tdWx0aXBsZS1jb25maXJtYXRpb24tYnV0dG9uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2kxOG4uZmlsdGVyfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZm9ybT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj47XG4gICAgfVxufVxuXG5GaWx0ZXJpbmcucHJvcFR5cGVzID0ge1xuICAgIGZpZWxkczogUHJvcFR5cGVzLmFycmF5LFxuICAgIG9uU3VibWl0Q2FsbGJhY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uSW5wdXRNb3VudDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBNb2RhbFRpdGxlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBzY3JlZW5TaXplOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5GaWx0ZXJpbmcuZGVmYXVsdFByb3BzID0ge1xuICAgIE1vZGFsVGl0bGU6IHByb3BzID0+IDxSZWFjdC5GcmFnbWVudD5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJjbG9zZVwiXG4gICAgICAgICAgICBkYXRhLWRpc21pc3M9XCJtb2RhbFwiXG4gICAgICAgICAgICBhcmlhLWxhYmVsPVwiQ2xvc2VcIlxuICAgICAgICA+XG4gICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGg0IGNsYXNzTmFtZT1cIm1vZGFsLXRpdGxlXCI+XG4gICAgICAgICAgICB7cHJvcHMudGl0bGV9XG4gICAgICAgIDwvaDQ+XG4gICAgPC9SZWFjdC5GcmFnbWVudD4sXG4gICAgc2NyZWVuU2l6ZTogJ2wnXG59O1xuIiwiaW1wb3J0IFNlYXJjaFRleHQgZnJvbSBcIi4vZmllbGQtdHlwZXMvdGV4dFwiO1xuaW1wb3J0IFNlYXJjaERhdGUgZnJvbSBcIi4vZmllbGQtdHlwZXMvZGF0ZVwiO1xuaW1wb3J0IFNlYXJjaE51bWVyaWMgZnJvbSBcIi4vZmllbGQtdHlwZXMvbnVtZXJpY1wiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuaW1wb3J0IFNlYXJjaENoZWNrYm94Qm9vbGVhbiBmcm9tIFwiLi9maWVsZC10eXBlcy9jaGVja2JveF9ib29sZWFuXCI7XG5pbXBvcnQgU2VhcmNoRW51bSBmcm9tIFwiLi9maWVsZC10eXBlcy9lbnVtXCI7XG5pbXBvcnQgU2VhcmNoRHJvcGRvd24gZnJvbSBcIi4vZmllbGQtdHlwZXMvZHJvcGRvd25cIjtcbmltcG9ydCBTZWFyY2hSZWxhdGlvbmFsIGZyb20gXCIuL2ZpZWxkLXR5cGVzL3JlbGF0aW9uYWxcIjtcbmltcG9ydCBTZWFyY2hSZWxhdGlvbmFsTnRvTiBmcm9tIFwiLi9maWVsZC10eXBlcy9yZWxhdGlvbmFsLW4tblwiO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmNsYXNzIE11bHRpcGxlU2VhcmNoIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBjb25zdCBmaXJzdEZpZWxkc0tleSA9IHByb3BzLmZpZWxkcy5maW5kKChfX2l0ZW0sIGtleSkgPT4ga2V5ID09PSAwKSxcbiAgICAgICAgICAgIHtmaWVsZE5hbWUsIHR5cGUsIHBlcm1pdHRlZFZhbHVlc30gPSBmaXJzdEZpZWxkc0tleTtcblxuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWU6IGZpZWxkTmFtZSxcbiAgICAgICAgICAgIHNlbGVjdGVkVHlwZTogdHlwZSxcbiAgICAgICAgICAgIHBlcm1pdHRlZFZhbHVlc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25DaGFuZ2VTZWxlY3QoZXZlbnQpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRGaWVsZCA9IHRoaXMucHJvcHMuZmllbGRzLmZpbmQoKGZpZWxkKSA9PiBmaWVsZC5maWVsZE5hbWUgPT09IGV2ZW50LnRhcmdldC52YWx1ZSksXG4gICAgICAgICAgICB7ZmllbGROYW1lLCB0eXBlLCBwZXJtaXR0ZWRWYWx1ZXN9ID0gc2VsZWN0ZWRGaWVsZDtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWU6IGZpZWxkTmFtZSxcbiAgICAgICAgICAgIHNlbGVjdGVkVHlwZTogdHlwZSxcbiAgICAgICAgICAgIHBlcm1pdHRlZFZhbHVlczogcGVybWl0dGVkVmFsdWVzXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uRGVsZXRlQ2xpY2soKSB7XG4gICAgICAgIGNvbnN0IHtmaWVsZEluZGV4LCBvbkRlbGV0ZUNhbGxiYWNrfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgb25EZWxldGVDYWxsYmFjayhmaWVsZEluZGV4KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHtzZWxlY3RlZFZhbHVlLCBzZWxlY3RlZFR5cGUsIHBlcm1pdHRlZFZhbHVlc30gPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZpZWxkSW5kZXgsXG4gICAgICAgICAgICAgICAgZmllbGRzLFxuICAgICAgICAgICAgICAgIGhhc1JlbW92ZUJ1dHRvbixcbiAgICAgICAgICAgICAgICBvbklucHV0TW91bnQsXG4gICAgICAgICAgICAgICAgc2NyZWVuU2l6ZVxuICAgICAgICAgICAgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBldmVuT3JPZGQgPSBmaWVsZEluZGV4ICUgMiA9PT0gMCA/ICdldmVuJyA6ICdvZGQnLFxuICAgICAgICAgICAgaXNNb2JpbGUgPSBzY3JlZW5TaXplID09PSAncycgfHwgc2NyZWVuU2l6ZSA9PT0gJ3hzJztcbiAgICAgICAgbGV0IHNlYXJjaElucHV0LCBvbkNvbXBvbmVudE1vdW50LCBvbkNvbXBvbmVudFVwZGF0ZSxcbiAgICAgICAgICAgIGkxOG4gPSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlX2ZpbHRlcjogJ1JlbW92ZSBGaWx0ZXInXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmkxOG4pIHtcbiAgICAgICAgICAgIGkxOG4gPSBPYmplY3QuYXNzaWduKHt9LCBpMThuLCB0aGlzLnByb3BzLmkxOG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9uSW5wdXRNb3VudCAmJiBvbklucHV0TW91bnRbc2VsZWN0ZWRUeXBlXSkge1xuICAgICAgICAgICAgb25Db21wb25lbnRNb3VudCA9IG9uSW5wdXRNb3VudFtzZWxlY3RlZFR5cGVdLm9uTW91bnQ7XG4gICAgICAgICAgICBvbkNvbXBvbmVudFVwZGF0ZSA9IG9uSW5wdXRNb3VudFtzZWxlY3RlZFR5cGVdLm9uVXBkYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChzZWxlY3RlZFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICAgICAgY2FzZSAndGltZXN0YW1wJzpcbiAgICAgICAgICAgICAgICBzZWFyY2hJbnB1dCA9IDxTZWFyY2hEYXRlXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkSW5kZXg9e2ZpZWxkSW5kZXh9XG4gICAgICAgICAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcG9uZW50TW91bnQ9e29uQ29tcG9uZW50TW91bnR9XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcG9uZW50VXBkYXRlPXtvbkNvbXBvbmVudFVwZGF0ZX1cbiAgICAgICAgICAgICAgICAgICAgaXNNb2JpbGU9e2lzTW9iaWxlfVxuICAgICAgICAgICAgICAgIC8+O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdpbnQnOlxuICAgICAgICAgICAgY2FzZSAnbnVtZXJpYyc6XG4gICAgICAgICAgICAgICAgc2VhcmNoSW5wdXQgPSA8U2VhcmNoTnVtZXJpY1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEluZGV4PXtmaWVsZEluZGV4fVxuICAgICAgICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBvbmVudE1vdW50PXtvbkNvbXBvbmVudE1vdW50fVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBvbmVudFVwZGF0ZT17b25Db21wb25lbnRVcGRhdGV9XG4gICAgICAgICAgICAgICAgICAgIGlzTW9iaWxlPXtpc01vYmlsZX1cbiAgICAgICAgICAgICAgICAvPjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnY2hlY2tib3hfYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgc2VhcmNoSW5wdXQgPSA8U2VhcmNoQ2hlY2tib3hCb29sZWFuXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkSW5kZXg9e2ZpZWxkSW5kZXh9XG4gICAgICAgICAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcG9uZW50TW91bnQ9e29uQ29tcG9uZW50TW91bnR9XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcG9uZW50VXBkYXRlPXtvbkNvbXBvbmVudFVwZGF0ZX1cbiAgICAgICAgICAgICAgICAgICAgaXNNb2JpbGU9e2lzTW9iaWxlfVxuICAgICAgICAgICAgICAgIC8+O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdyZWxhdGlvbmFsX25fbic6XG4gICAgICAgICAgICBjYXNlICduYXRpdmVfcmVsYXRpb25hbF9uX24nOlxuICAgICAgICAgICAgICAgIHNlYXJjaElucHV0ID0gPFNlYXJjaFJlbGF0aW9uYWxOdG9OXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkSW5kZXg9e2ZpZWxkSW5kZXh9XG4gICAgICAgICAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICAgICAgICAgIHBlcm1pdHRlZFZhbHVlcz17cGVybWl0dGVkVmFsdWVzfVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBvbmVudE1vdW50PXtvbkNvbXBvbmVudE1vdW50fVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBvbmVudFVwZGF0ZT17b25Db21wb25lbnRVcGRhdGV9XG4gICAgICAgICAgICAgICAgICAgIGlzTW9iaWxlPXtpc01vYmlsZX1cbiAgICAgICAgICAgICAgICAvPjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAncmVsYXRpb25hbCc6XG4gICAgICAgICAgICBjYXNlICdyZWxhdGlvbmFsX25hdGl2ZSc6XG4gICAgICAgICAgICAgICAgc2VhcmNoSW5wdXQgPSA8U2VhcmNoUmVsYXRpb25hbFxuICAgICAgICAgICAgICAgICAgICBmaWVsZEluZGV4PXtmaWVsZEluZGV4fVxuICAgICAgICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgICAgICAgICBwZXJtaXR0ZWRWYWx1ZXM9e3Blcm1pdHRlZFZhbHVlc31cbiAgICAgICAgICAgICAgICAgICAgb25Db21wb25lbnRNb3VudD17b25Db21wb25lbnRNb3VudH1cbiAgICAgICAgICAgICAgICAgICAgb25Db21wb25lbnRVcGRhdGU9e29uQ29tcG9uZW50VXBkYXRlfVxuICAgICAgICAgICAgICAgICAgICBpc01vYmlsZT17aXNNb2JpbGV9XG4gICAgICAgICAgICAgICAgLz47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ211bHRpc2VsZWN0X25hdGl2ZSc6XG4gICAgICAgICAgICBjYXNlICdtdWx0aXNlbGVjdF9zZWFyY2hhYmxlJzpcbiAgICAgICAgICAgIGNhc2UgJ2Ryb3Bkb3duJzpcbiAgICAgICAgICAgIGNhc2UgJ2Ryb3Bkb3duX3NlYXJjaCc6XG4gICAgICAgICAgICAgICAgc2VhcmNoSW5wdXQgPSA8U2VhcmNoRHJvcGRvd25cbiAgICAgICAgICAgICAgICAgICAgZmllbGRJbmRleD17ZmllbGRJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICAgICAgICAgICAgcGVybWl0dGVkVmFsdWVzPXtwZXJtaXR0ZWRWYWx1ZXN9XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcG9uZW50TW91bnQ9e29uQ29tcG9uZW50TW91bnR9XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcG9uZW50VXBkYXRlPXtvbkNvbXBvbmVudFVwZGF0ZX1cbiAgICAgICAgICAgICAgICAgICAgaXNNb2JpbGU9e2lzTW9iaWxlfVxuICAgICAgICAgICAgICAgIC8+O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdlbnVtX3NlYXJjaGFibGUnOlxuICAgICAgICAgICAgY2FzZSAnZW51bSc6XG4gICAgICAgICAgICAgICAgc2VhcmNoSW5wdXQgPSA8U2VhcmNoRW51bVxuICAgICAgICAgICAgICAgICAgICBmaWVsZEluZGV4PXtmaWVsZEluZGV4fVxuICAgICAgICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgICAgICAgICBwZXJtaXR0ZWRWYWx1ZXM9e3Blcm1pdHRlZFZhbHVlc31cbiAgICAgICAgICAgICAgICAgICAgb25Db21wb25lbnRNb3VudD17b25Db21wb25lbnRNb3VudH1cbiAgICAgICAgICAgICAgICAgICAgb25Db21wb25lbnRVcGRhdGU9e29uQ29tcG9uZW50VXBkYXRlfVxuICAgICAgICAgICAgICAgICAgICBpc01vYmlsZT17aXNNb2JpbGV9XG4gICAgICAgICAgICAgICAgLz47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgc2VhcmNoSW5wdXQgPSA8U2VhcmNoVGV4dFxuICAgICAgICAgICAgICAgICAgICBmaWVsZEluZGV4PXtmaWVsZEluZGV4fVxuICAgICAgICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBvbmVudE1vdW50PXtvbkNvbXBvbmVudE1vdW50fVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBvbmVudFVwZGF0ZT17b25Db21wb25lbnRVcGRhdGV9XG4gICAgICAgICAgICAgICAgICAgIHNjcmVlblNpemU9e3NjcmVlblNpemV9XG4gICAgICAgICAgICAgICAgICAgIGlzTW9iaWxlPXtpc01vYmlsZX1cbiAgICAgICAgICAgICAgICAvPjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT17J3JvdyBnYy1maWx0ZXJpbmctcm93ICcgKyBldmVuT3JPZGR9PlxuICAgICAgICAgICAge2hhc1JlbW92ZUJ1dHRvblxuICAgICAgICAgICAgICAgID8gPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ2NvbC1tZC0xJywge1xuICAgICAgICAgICAgICAgICAgICAnYjEwJzogaXNNb2JpbGVcbiAgICAgICAgICAgICAgICB9KX0+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYnRuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2J0bi1kZWZhdWx0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2J0bi1vdXRsaW5lLWRhcmsnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYnRuLWJsb2NrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25EZWxldGVDbGljay5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e2kxOG4ucmVtb3ZlX2ZpbHRlcn0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGVtIGNsYXNzTmFtZT1cImZhIGZhLXRyYXNoLW9cIj48L2VtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpc01vYmlsZSAmJiA8UmVhY3QuRnJhZ21lbnQ+Jm5ic3A7IHtpMThuLnJlbW92ZV9maWx0ZXJ9PC9SZWFjdC5GcmFnbWVudD59XG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDogJyd9XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lcygnY29sLW1kLTMnLCB7XG4gICAgICAgICAgICAgICAgJ2IxMCc6IGlzTW9iaWxlXG4gICAgICAgICAgICB9KX0+XG4gICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2xcIiBuYW1lPXsnZXh0ZW5kZWRfc2VhcmNoWycgKyBmaWVsZEluZGV4ICsgJ11bbmFtZV0nfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25DaGFuZ2VTZWxlY3QuYmluZCh0aGlzKX0gdmFsdWU9e3NlbGVjdGVkVmFsdWV9PlxuICAgICAgICAgICAgICAgICAgICB7ZmllbGRzLm1hcCgoZmllbGQpID0+IDxvcHRpb24gdmFsdWU9e2ZpZWxkLmZpZWxkTmFtZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17ZmllbGQuZmllbGROYW1lfT57ZmllbGQuZGlzcGxheUFzfTwvb3B0aW9uPil9XG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzKCdyb3cnLCB7XG4gICAgICAgICAgICAgICAgICAgICdjb2wtbWQtOCc6IGhhc1JlbW92ZUJ1dHRvbixcbiAgICAgICAgICAgICAgICAgICAgJ2NvbC1tZC05JzogIWhhc1JlbW92ZUJ1dHRvbixcbiAgICAgICAgICAgICAgICAgICAgJ2IxMCc6IGlzTW9iaWxlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICAgICAge3NlYXJjaElucHV0fVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PjtcbiAgICB9XG59XG5cbk11bHRpcGxlU2VhcmNoLnByb3BUeXBlcyA9IHtcbiAgICBmaWVsZEluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGZpZWxkczogUHJvcFR5cGVzLmFycmF5LFxuICAgIGhhc1JlbW92ZUJ1dHRvbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgb25EZWxldGVDYWxsYmFjazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2NyZWVuU2l6ZTogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuTXVsdGlwbGVTZWFyY2guZGVmYXVsdFByb3BzID0ge1xuICAgIHNjcmVlblNpemU6ICdsJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTXVsdGlwbGVTZWFyY2g7IiwiaW1wb3J0IGkxOG5Db21wYXJpc29uIGZyb20gJy4vdHJhbnNsYXRpb25zL2kxOG4tY29tcGFyaXNvbic7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5jbGFzcyBDb21wYXJpc29uU2VsZWN0T3B0aW9ucyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgaTE4biA9IGkxOG5Db21wYXJpc29uO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGkxOG4pO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmkxOG4pIHtcbiAgICAgICAgICAgIGkxOG4gPSBPYmplY3QuYXNzaWduKHt9LCBpMThuLCB0aGlzLnByb3BzLmkxOG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coaTE4bik7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PVwiZXF1YWxzXCIgdmFsdWU9XCJlcXVhbHNcIj57aTE4bi5jb21wYXJpc29uX2VxdWFsc308L29wdGlvbj4sXG4gICAgICAgICAgICA8b3B0aW9uIGtleT1cIm5vdF9lcXVhbHNcIiB2YWx1ZT1cIm5vdF9lcXVhbHNcIj57aTE4bi5jb21wYXJpc29uX25vdF9lcXVhbHN9PC9vcHRpb24+LFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9XCJncmVhdGVyX3RoYW5cIiB2YWx1ZT1cImdyZWF0ZXJfdGhhblwiPntpMThuLmNvbXBhcmlzb25fZ3JlYXRlcl90aGFufTwvb3B0aW9uPixcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PVwibGVzc190aGFuXCIgdmFsdWU9XCJsZXNzX3RoYW5cIj57aTE4bi5jb21wYXJpc29uX2xlc3NfdGhhbn08L29wdGlvbj4sXG4gICAgICAgICAgICA8b3B0aW9uIGtleT1cImdyZWF0ZXJfdGhhbl9vcl9lcXVhbFwiIHZhbHVlPVwiZ3JlYXRlcl90aGFuX29yX2VxdWFsXCI+e2kxOG4uY29tcGFyaXNvbl9ncmVhdGVyX3RoYW5fb3JfZXF1YWx9PC9vcHRpb24+LFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9XCJsZXNzX3RoYW5fb3JfZXF1YWxcIiB2YWx1ZT1cImxlc3NfdGhhbl9vcl9lcXVhbFwiPntpMThuLmNvbXBhcmlzb25fbGVzc190aGFuX29yX2VxdWFsfTwvb3B0aW9uPixcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PVwiaXNfZW1wdHlcIiB2YWx1ZT1cImlzX2VtcHR5XCI+e2kxOG4uY29tcGFyaXNvbl9pc19lbXB0eX08L29wdGlvbj4sXG4gICAgICAgICAgICA8b3B0aW9uIGtleT1cImlzX25vdF9lbXB0eVwiIHZhbHVlPVwiaXNfbm90X2VtcHR5XCI+e2kxOG4uY29tcGFyaXNvbl9pc19ub3RfZW1wdHl9PC9vcHRpb24+XG4gICAgICAgIF1cbiAgICB9XG59XG5cbkNvbXBhcmlzb25TZWxlY3RPcHRpb25zLnByb3BUeXBlcyA9IHtcbiAgICBpMThuOiBQcm9wVHlwZXMub2JqZWN0XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBhcmlzb25TZWxlY3RPcHRpb25zOyIsImltcG9ydCBpMThuRXF1YWxOb3RFcXVhbCBmcm9tICcuL3RyYW5zbGF0aW9ucy9pMThuLWVxdWFsLW5vdC1lcXVhbCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5jbGFzcyBTZWxlY3RPcHRpb25zRXF1YWxOb3RFcXVhbCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgaTE4biA9IGkxOG5FcXVhbE5vdEVxdWFsO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmkxOG4pIHtcbiAgICAgICAgICAgIGkxOG4gPSBPYmplY3QuYXNzaWduKHt9LCBpMThuLCB0aGlzLnByb3BzLmkxOG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PVwiZXF1YWxzXCIgdmFsdWU9XCJlcXVhbHNcIj57aTE4bi5jb21wYXJpc29uX2VxdWFsc308L29wdGlvbj4sXG4gICAgICAgICAgICA8b3B0aW9uIGtleT1cIm5vdF9lcXVhbHNcIiB2YWx1ZT1cIm5vdF9lcXVhbHNcIj57aTE4bi5jb21wYXJpc29uX25vdF9lcXVhbHN9PC9vcHRpb24+LFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9XCJpc19lbXB0eVwiIHZhbHVlPVwiaXNfZW1wdHlcIj57aTE4bi5jb21wYXJpc29uX2lzX2VtcHR5fTwvb3B0aW9uPixcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PVwiaXNfbm90X2VtcHR5XCIgdmFsdWU9XCJpc19ub3RfZW1wdHlcIj57aTE4bi5jb21wYXJpc29uX2lzX25vdF9lbXB0eX08L29wdGlvbj5cbiAgICAgICAgXVxuICAgIH1cbn1cblxuU2VsZWN0T3B0aW9uc0VxdWFsTm90RXF1YWwucHJvcFR5cGVzID0ge1xuICAgIGkxOG46IFByb3BUeXBlcy5vYmplY3Rcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0T3B0aW9uc0VxdWFsTm90RXF1YWw7IiwiaW1wb3J0IGkxOG5IYXNPck5vdCBmcm9tICcuL3RyYW5zbGF0aW9ucy9pMThuLWhhcy1vci1ub3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY2xhc3MgU2VsZWN0T3B0aW9uc0hhc09yTm90IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBpMThuID0gaTE4bkhhc09yTm90O1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmkxOG4pIHtcbiAgICAgICAgICAgIGkxOG4gPSBPYmplY3QuYXNzaWduKHt9LCBpMThuLCB0aGlzLnByb3BzLmkxOG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PVwiaGFzXCIgdmFsdWU9XCJoYXNcIj57aTE4bi5jb21wYXJpc29uX2hhc308L29wdGlvbj4sXG4gICAgICAgICAgICA8b3B0aW9uIGtleT1cImRvZXNfbm90X2hhdmVcIiB2YWx1ZT1cImRvZXNfbm90X2hhdmVcIj57aTE4bi5jb21wYXJpc29uX2RvZXNfbm90X2hhdmV9PC9vcHRpb24+LFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9XCJpc19lbXB0eVwiIHZhbHVlPVwiaXNfZW1wdHlcIj57aTE4bi5jb21wYXJpc29uX2lzX2VtcHR5fTwvb3B0aW9uPixcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PVwiaXNfbm90X2VtcHR5XCIgdmFsdWU9XCJpc19ub3RfZW1wdHlcIj57aTE4bi5jb21wYXJpc29uX2lzX25vdF9lbXB0eX08L29wdGlvbj5cbiAgICAgICAgXVxuICAgIH1cbn1cblxuU2VsZWN0T3B0aW9uc0hhc09yTm90LnByb3BUeXBlcyA9IHtcbiAgICBpMThuOiBQcm9wVHlwZXMub2JqZWN0XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdE9wdGlvbnNIYXNPck5vdDsiLCJpbXBvcnQgaTE4blRleHQgZnJvbSAnLi90cmFuc2xhdGlvbnMvaTE4bi10ZXh0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIFRleHRTZWxlY3RPcHRpb25zIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBpMThuID0gaTE4blRleHQ7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaTE4bikge1xuICAgICAgICAgICAgaTE4biA9IE9iamVjdC5hc3NpZ24oe30sIGkxOG4sIHRoaXMucHJvcHMuaTE4bik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgPG9wdGlvbiBrZXk9XCJjb250YWluc1wiIHZhbHVlPVwiY29udGFpbnNcIj57aTE4bi5jb21wYXJpc29uX2NvbnRhaW5zfTwvb3B0aW9uPixcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PVwic3RhcnRzX3dpdGhcIiB2YWx1ZT1cInN0YXJ0c193aXRoXCI+e2kxOG4uY29tcGFyaXNvbl9zdGFydHNfd2l0aH08L29wdGlvbj4sXG4gICAgICAgICAgICA8b3B0aW9uIGtleT1cImVuZHNfd2l0aFwiIHZhbHVlPVwiZW5kc193aXRoXCI+e2kxOG4uY29tcGFyaXNvbl9lbmRzX3dpdGh9PC9vcHRpb24+LFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9XCJlcXVhbHNcIiB2YWx1ZT1cImVxdWFsc1wiPntpMThuLmNvbXBhcmlzb25fZXF1YWxzfTwvb3B0aW9uPixcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PVwibm90X2VxdWFsc1wiIHZhbHVlPVwibm90X2VxdWFsc1wiPntpMThuLmNvbXBhcmlzb25fbm90X2VxdWFsc308L29wdGlvbj4sXG4gICAgICAgICAgICA8b3B0aW9uIGtleT1cImlzX2VtcHR5XCIgdmFsdWU9XCJpc19lbXB0eVwiPntpMThuLmNvbXBhcmlzb25faXNfZW1wdHl9PC9vcHRpb24+LFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9XCJpc19ub3RfZW1wdHlcIiB2YWx1ZT1cImlzX25vdF9lbXB0eVwiPntpMThuLmNvbXBhcmlzb25faXNfbm90X2VtcHR5fTwvb3B0aW9uPlxuICAgICAgICBdXG4gICAgfVxufVxuXG5UZXh0U2VsZWN0T3B0aW9ucy5wcm9wVHlwZXMgPSB7XG4gICAgaTE4bjogUHJvcFR5cGVzLm9iamVjdFxufVxuXG5leHBvcnQgZGVmYXVsdCBUZXh0U2VsZWN0T3B0aW9uczsiLCJleHBvcnQgZGVmYXVsdCB7XG4gICAgY29tcGFyaXNvbl9lcXVhbHM6ICdlcXVhbHMnLFxuICAgIGNvbXBhcmlzb25fbm90X2VxdWFsczogJ25vdCBlcXVhbHMnLFxuICAgIGNvbXBhcmlzb25fZ3JlYXRlcl90aGFuOiAnZ3JlYXRlciB0aGFuJyxcbiAgICBjb21wYXJpc29uX2xlc3NfdGhhbjogJ2xlc3MgdGhhbicsXG4gICAgY29tcGFyaXNvbl9ncmVhdGVyX3RoYW5fb3JfZXF1YWw6ICdncmVhdGVyIHRoYW4gb3IgZXF1YWwnLFxuICAgIGNvbXBhcmlzb25fbGVzc190aGFuX29yX2VxdWFsOiAnbGVzcyB0aGFuIG9yIGVxdWFsJyxcbiAgICBjb21wYXJpc29uX2lzX2VtcHR5OiAnaXMgZW1wdHknLFxuICAgIGNvbXBhcmlzb25faXNfbm90X2VtcHR5OiAnaXMgbm90IGVtcHR5J1xufTsiLCJleHBvcnQgZGVmYXVsdCB7XG4gICAgY29tcGFyaXNvbl9lcXVhbHM6ICdlcXVhbHMnLFxuICAgIGNvbXBhcmlzb25fbm90X2VxdWFsczogJ25vdCBlcXVhbHMnLFxuICAgIGNvbXBhcmlzb25faXNfZW1wdHk6ICdpcyBlbXB0eScsXG4gICAgY29tcGFyaXNvbl9pc19ub3RfZW1wdHk6ICdpcyBub3QgZW1wdHknXG59OyIsImV4cG9ydCBkZWZhdWx0IHtcbiAgICBjb21wYXJpc29uX2hhczogJ2hhcycsXG4gICAgY29tcGFyaXNvbl9kb2VzX25vdF9oYXZlOiAnZG9lcyBub3QgaGF2ZScsXG4gICAgY29tcGFyaXNvbl9pc19lbXB0eTogJ2lzIGVtcHR5JyxcbiAgICBjb21wYXJpc29uX2lzX25vdF9lbXB0eTogJ2lzIG5vdCBlbXB0eSdcbn07IiwiZXhwb3J0IGRlZmF1bHQge1xuICAgIGNvbXBhcmlzb25fY29udGFpbnM6ICdjb250YWlucycsXG4gICAgY29tcGFyaXNvbl9zdGFydHNfd2l0aDogJ3N0YXJ0cyB3aXRoJyxcbiAgICBjb21wYXJpc29uX2VuZHNfd2l0aDogJ2VuZHMgd2l0aCcsXG4gICAgY29tcGFyaXNvbl9lcXVhbHM6ICdlcXVhbHMnLFxuICAgIGNvbXBhcmlzb25fbm90X2VxdWFsczogJ25vdCBlcXVhbHMnLFxuICAgIGNvbXBhcmlzb25faXNfZW1wdHk6ICdpcyBlbXB0eScsXG4gICAgY29tcGFyaXNvbl9pc19ub3RfZW1wdHk6ICdpcyBub3QgZW1wdHknXG59OyIsImltcG9ydCBQcm9wVHlwZXMsIHsgc2hhcGUgfSBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gXCJjbGFzc25hbWVzXCI7XG5cbmNsYXNzIERlZmF1bHRHcm91cEJ1dHRvbiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5zZXRDb250YWluZXIgPSB0aGlzLnNldENvbnRhaW5lci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2V0dGluZ3NPcGVuOiBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9nZ2xlU2V0dGluZ3MoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgc2V0dGluZ3NPcGVuOiAhdGhpcy5zdGF0ZS5zZXR0aW5nc09wZW5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0Q29udGFpbmVyKHJlZikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHJlZjtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHRoaXMuY2xpY2tPdXRzaWRlKGUpLCB0cnVlKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHRoaXMuY2xpY2tPdXRzaWRlKGUpLCB0cnVlKTtcbiAgICB9XG5cbiAgICBjbGlja091dHNpZGUoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyBzZXR0aW5nc09wZW4gfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzT3BlbiAmJiB0aGlzLmNvbnRhaW5lciAmJiAhdGhpcy5jb250YWluZXIuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NPcGVuOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgc2V0dGluZ3NPcGVuIH0gPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgICB7IGJ1dHRvbnMsIG1heEJ1dHRvbnMsIGkxOG4sIEdyb3VwUHJpbWFyeUJ1dHRvbiwgR3JvdXBCdXR0b25zTGlzdCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICByZXR1cm4gKDxkaXZcbiAgICAgICAgICAgIHJlZj17dGhpcy5zZXRDb250YWluZXJ9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ2J0bi1ncm91cCcsIHtcbiAgICAgICAgICAgICAgICBvcGVuOiBzZXR0aW5nc09wZW5cbiAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgcm9sZT1cImdyb3VwXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPEdyb3VwUHJpbWFyeUJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb25DbGljaz17ZSA9PiB0aGlzLnRvZ2dsZVNldHRpbmdzKCl9PlxuICAgICAgICAgICAgICAgIHttYXhCdXR0b25zID09PSAxID8gaTE4bi5hY3Rpb25zIDogaTE4bi5tb3JlfSZuYnNwO1xuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImNhcmV0XCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9Hcm91cFByaW1hcnlCdXR0b24+XG4gICAgICAgICAgICA8R3JvdXBCdXR0b25zTGlzdCBidXR0b25zPXtidXR0b25zLm1hcChidXR0b24gPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IGJ1dHRvbi51cmwgPyBidXR0b24udXJsOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBidXR0b24ubmV3VGFiID8gJ19ibGFuaycgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogYnV0dG9uLmljb24sXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGJ1dHRvbi50ZXh0LFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGJ1dHRvbi5rZXksXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1dHRvbi5vbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5vbkNsaWNrKGJ1dHRvbi5wcmltYXJ5S2V5VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSl9PlxuICAgICAgICAgICAgPC9Hcm91cEJ1dHRvbnNMaXN0PlxuICAgICAgICA8L2Rpdj4pO1xuICAgIH1cbn1cblxuRGVmYXVsdEdyb3VwQnV0dG9uLnByb3BUeXBlcyA9IHtcbiAgICBidXR0b25zOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgbWF4QnV0dG9uczogUHJvcFR5cGVzLm51bWJlcixcbiAgICBpMThuOiBzaGFwZSh7XG4gICAgICAgIGFjdGlvbnM6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIG1vcmU6IFByb3BUeXBlcy5zdHJpbmdcbiAgICB9KVxufTtcblxuRGVmYXVsdEdyb3VwQnV0dG9uLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBpMThuOiB7XG4gICAgICAgIGFjdGlvbnM6ICdBY3Rpb25zJyxcbiAgICAgICAgbW9yZTogJ01vcmUnXG4gICAgfSxcbiAgICBHcm91cFByaW1hcnlCdXR0b246IChwcm9wcykgPT4gPGJ1dHRvbiB7Li4ucHJvcHN9Pntwcm9wcy5jaGlsZHJlbn08L2J1dHRvbj4sXG4gICAgR3JvdXBCdXR0b25zTGlzdDogKHByb3BzKSA9PiAoPHVsIGNsYXNzTmFtZT1cImRyb3Bkb3duLW1lbnVcIj5cbiAgICAgICAge3Byb3BzLmJ1dHRvbnMubWFwKGJ1dHRvbiA9PlxuICAgICAgICAgICAgPGxpIGtleT17YnV0dG9uLmtleX0gY2xhc3NOYW1lPXtjbGFzc05hbWVzKHsnZHJvcGRvd24tc3VibWVudSc6IGJ1dHRvbi5oYXNTdWJNZW51fSl9PlxuICAgICAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgICAgICAgIGhyZWY9e2J1dHRvbi5ocmVmfVxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtidXR0b24ub25DbGlja31cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0PXtidXR0b24udGFyZ2V0fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAge2J1dHRvbi5pY29uICYmIDxpIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhidXR0b24uaWNvbiwgJ2djLWJ1dHRvbi1pY29uJyl9IC8+fVxuICAgICAgICAgICAgICAgICAgICB7YnV0dG9uLnRleHR9XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgKX1cbiAgICA8L3VsPilcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERlZmF1bHRHcm91cEJ1dHRvbjsiLCJpbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIERlZmF1bHRMaW5rQnV0dG9uIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG5cbiAgICBvbkNsaWNrQ2FsbGJhY2soZXZlbnQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgb25DbGljayxcbiAgICAgICAgICAgIHByaW1hcnlLZXlWYWx1ZVxuICAgICAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIG9uQ2xpY2socHJpbWFyeUtleVZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGljb24sXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgcmlnaHRNYXJnaW4sXG4gICAgICAgICAgICAgICAgbmV3VGFiLFxuICAgICAgICAgICAgICAgIExpbmtCdXR0b25XcmFwcGVyXG4gICAgICAgICAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICByZXR1cm4gKDxMaW5rQnV0dG9uV3JhcHBlclxuICAgICAgICAgICAgY2xhc3NOYW1lcz17eydyNSc6IHJpZ2h0TWFyZ2lufX1cbiAgICAgICAgICAgIGhyZWY9eyh1cmwgPyB1cmwgOiAnJyl9XG4gICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIG9uQ2xpY2s9e2UgPT4gdGhpcy5vbkNsaWNrQ2FsbGJhY2soZSl9XG4gICAgICAgICAgICB0YXJnZXQ9e25ld1RhYiA/ICdfYmxhbmsnIDogJyd9XG4gICAgICAgID5cbiAgICAgICAgICAgIHtpY29uICYmIDxpIGNsYXNzTmFtZT17aWNvbn0gLz59XG4gICAgICAgICAgICB7dGV4dCAmJiAoPHNwYW4+Jm5ic3A7e3RleHR9PC9zcGFuPil9XG4gICAgICAgIDwvTGlua0J1dHRvbldyYXBwZXI+KTtcbiAgICB9XG59O1xuXG5EZWZhdWx0TGlua0J1dHRvbi5wcm9wVHlwZXMgPSB7XG4gICAgaWNvbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB1cmw6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgdGV4dDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICByaWdodE1hcmdpbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcHJpbWFyeUtleVZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG5ld1RhYjogUHJvcFR5cGVzLmJvb2wsXG4gICAgTGlua0J1dHRvbldyYXBwZXI6IFByb3BUeXBlcy5mdW5jLFxufTtcblxuRGVmYXVsdExpbmtCdXR0b24uZGVmYXVsdFByb3BzID0ge1xuICAgIExpbmtCdXR0b25XcmFwcGVyOiAocHJvcHMpID0+IDxhIHsuLi5wcm9wc30+e3Byb3BzLmNoaWxkcmVufTwvYT5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IERlZmF1bHRMaW5rQnV0dG9uOyIsImltcG9ydCBHcm91cEJ1dHRvbnMgZnJvbSAnLi93cmFwcGVycy9ib290c3RyYXAtdjMvZ3JvdXAtYnV0dG9ucy5qc3gnO1xuaW1wb3J0IFByb3BUeXBlcywgeyBzaGFwZSB9IGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IERhdGFncmlkQ2hlY2tib3ggZnJvbSAnLi9kYXRhZ3JpZC1jaGVja2JveC5qc3gnO1xuXG5jbGFzcyBEYXRhZ3JpZEFjdGlvbnNDb2x1bW4gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBhY3Rpb25CdXR0b25zLFxuICAgICAgICAgICAgYmFja2VuZEFjdGlvbkJ1dHRvbnMsXG4gICAgICAgICAgICBvcHRpb25zOiB7IGhhc0VkaXQsIGhhc1JlYWQgLCBoYXNDbG9uZSwgaGFzRGVsZXRlLCBoYXNBY3Rpb25CdXR0b25zLCBkZWxldGVNdWx0aXBsZSB9LFxuICAgICAgICAgICAgb25FZGl0Q2xpY2ssXG4gICAgICAgICAgICBvblJlYWRDbGljayxcbiAgICAgICAgICAgIG9uQ2xvbmVDbGljayxcbiAgICAgICAgICAgIG9uRGVsZXRlQ2xpY2ssXG4gICAgICAgICAgICBvblJvd0NoZWNrYm94Q2xpY2ssXG4gICAgICAgICAgICB1cmxVbmlxdWVIYXNoLFxuICAgICAgICAgICAgc2NyZWVuU2l6ZSxcbiAgICAgICAgICAgIHJvd1NlbGVjdGVkLFxuICAgICAgICAgICAgdG9nZ2xlU2VsZWN0Um93LFxuICAgICAgICAgICAgcHJpbWFyeUtleVZhbHVlLFxuICAgICAgICAgICAgaTE4bixcbiAgICAgICAgICAgIExpbmtCdXR0b25XcmFwcGVyLFxuICAgICAgICAgICAgR3JvdXBQcmltYXJ5QnV0dG9uLFxuICAgICAgICAgICAgR3JvdXBCdXR0b25zTGlzdFxuICAgICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IGJ1dHRvbnMgPSBbXTtcblxuICAgICAgICBpZiAoaGFzRWRpdCkge1xuICAgICAgICAgICAgYnV0dG9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6ICdnYy1lZGl0JyxcbiAgICAgICAgICAgICAgICB1cmw6ICcjLycgKyB1cmxVbmlxdWVIYXNoICsgJ2VkaXQvJyArIHByaW1hcnlLZXlWYWx1ZSxcbiAgICAgICAgICAgICAgICBpY29uOiAnZmEgZmEtcGVuY2lsJyxcbiAgICAgICAgICAgICAgICB0ZXh0OiBpMThuLmVkaXQsXG4gICAgICAgICAgICAgICAgb25DbGljazogb25FZGl0Q2xpY2ssXG4gICAgICAgICAgICAgICAgbmV3VGFiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcmltYXJ5S2V5VmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1JlYWQpIHtcbiAgICAgICAgICAgIGJ1dHRvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiAnZ2MtcmVhZCcsXG4gICAgICAgICAgICAgICAgdXJsOiAnIy8nICsgdXJsVW5pcXVlSGFzaCArICdyZWFkLycgKyBwcmltYXJ5S2V5VmFsdWUsXG4gICAgICAgICAgICAgICAgaWNvbjogJ2ZhIGZhLWV5ZScsXG4gICAgICAgICAgICAgICAgdGV4dDogaTE4bi52aWV3LFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IG9uUmVhZENsaWNrLFxuICAgICAgICAgICAgICAgIG5ld1RhYjogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJpbWFyeUtleVZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNDbG9uZSkge1xuICAgICAgICAgICAgYnV0dG9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6ICdnYy1jbG9uZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnIy8nICsgdXJsVW5pcXVlSGFzaCArICdjbG9uZS8nICsgcHJpbWFyeUtleVZhbHVlLFxuICAgICAgICAgICAgICAgIGljb246ICdmYSBmYS1jb3B5JyxcbiAgICAgICAgICAgICAgICB0ZXh0OiBpMThuLmNsb25lLFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IG9uQ2xvbmVDbGljayxcbiAgICAgICAgICAgICAgICBuZXdUYWI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHByaW1hcnlLZXlWYWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzQWN0aW9uQnV0dG9ucyAmJiBhY3Rpb25CdXR0b25zKSB7XG4gICAgICAgICAgICBhY3Rpb25CdXR0b25zLmZvckVhY2goKGJ1dHRvbikgPT4ge1xuICAgICAgICAgICAgICAgIGJ1dHRvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogYnV0dG9uLmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBpY29uOiBidXR0b24uaWNvbkNzc0NsYXNzLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBidXR0b24ubGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGJ1dHRvbi5vbkNsaWNrLFxuICAgICAgICAgICAgICAgICAgICBuZXdUYWI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5VmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0FjdGlvbkJ1dHRvbnMgJiYgYmFja2VuZEFjdGlvbkJ1dHRvbnMpIHtcbiAgICAgICAgICAgIGJhY2tlbmRBY3Rpb25CdXR0b25zLmZvckVhY2goKGJ1dHRvbikgPT4ge1xuICAgICAgICAgICAgICAgIGJ1dHRvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogYnV0dG9uLmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBpY29uOiBidXR0b24uaWNvbkNzc0NsYXNzLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBidXR0b24ubGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIG5ld1RhYjogYnV0dG9uLm5ld1RhYixcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBidXR0b24udXJsLFxuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5VmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0RlbGV0ZSkge1xuICAgICAgICAgICAgYnV0dG9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6ICdnYy1kZWxldGUnLFxuICAgICAgICAgICAgICAgIGljb246ICdmYSBmYS10cmFzaC1vJyxcbiAgICAgICAgICAgICAgICB0ZXh0OiBpMThuLmFjdGlvbl9kZWxldGUsXG4gICAgICAgICAgICAgICAgb25DbGljazogb25EZWxldGVDbGljayxcbiAgICAgICAgICAgICAgICBuZXdUYWI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHByaW1hcnlLZXlWYWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPHRkIGNsYXNzTmFtZT1cImdjLWFjdGlvbnNcIj5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZU11bHRpcGxlICYmIHNjcmVlblNpemUgIT09ICd4cycgJiYgc2NyZWVuU2l6ZSAhPT0gJ3MnICYmXG4gICAgICAgICAgICAgICAgICAgIDxEYXRhZ3JpZENoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dTZWxlY3RlZD17cm93U2VsZWN0ZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVTZWxlY3RSb3c9e3RvZ2dsZVNlbGVjdFJvd31cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUm93Q2hlY2tib3hDbGljaz17b25Sb3dDaGVja2JveENsaWNrfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleVZhbHVlPXtwcmltYXJ5S2V5VmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDxHcm91cEJ1dHRvbnNcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9ucz17YnV0dG9uc31cbiAgICAgICAgICAgICAgICAgICAgc2NyZWVuU2l6ZT17c2NyZWVuU2l6ZX1cbiAgICAgICAgICAgICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICAgICAgICAgICAgTGlua0J1dHRvbldyYXBwZXI9e0xpbmtCdXR0b25XcmFwcGVyfVxuICAgICAgICAgICAgICAgICAgICBHcm91cFByaW1hcnlCdXR0b249e0dyb3VwUHJpbWFyeUJ1dHRvbn1cbiAgICAgICAgICAgICAgICAgICAgR3JvdXBCdXR0b25zTGlzdD17R3JvdXBCdXR0b25zTGlzdH1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbkRhdGFncmlkQWN0aW9uc0NvbHVtbi5wcm9wVHlwZXMgPSB7XG4gICAgYWN0aW9uQnV0dG9uczogUHJvcFR5cGVzLmFycmF5LFxuICAgIGJhY2tlbmRBY3Rpb25CdXR0b25zOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgb3B0aW9uczogc2hhcGUoe1xuICAgICAgICBkZWxldGVNdWx0aXBsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGhhc0VkaXQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBoYXNDbG9uZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGhhc0RlbGV0ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGhhc1JlYWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBoYXNBY3Rpb25CdXR0b25zOiBQcm9wVHlwZXMuYm9vbFxuICAgIH0pLFxuICAgIG9uRWRpdENsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNsb25lQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUmVhZENsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkRlbGV0ZUNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblJvd0NoZWNrYm94Q2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIHVybFVuaXF1ZUhhc2g6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgc2NyZWVuU2l6ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICByb3dTZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgdG9nZ2xlU2VsZWN0Um93OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBwcmltYXJ5S2V5VmFsdWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgaTE4bjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgICAgZWRpdDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgdmlldzogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgYWN0aW9uX2RlbGV0ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgYWN0aW9uczogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgbW9yZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY2xvbmU6IFByb3BUeXBlcy5zdHJpbmdcbiAgICB9KSxcbiAgICBMaW5rQnV0dG9uV3JhcHBlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgR3JvdXBCdXR0b25zTGlzdDogUHJvcFR5cGVzLmZ1bmMsXG59O1xuXG5EYXRhZ3JpZEFjdGlvbnNDb2x1bW4uZGVmYXVsdFByb3BzID0ge1xuICAgIHVybFVuaXF1ZUhhc2g6ICcnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBEYXRhZ3JpZEFjdGlvbnNDb2x1bW47IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY2xhc3MgRGF0YWdyaWRDaGVja2JveCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgb25DaGVja2JveENsaWNrKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgdG9nZ2xlU2VsZWN0Um93LCBvblJvd0NoZWNrYm94Q2xpY2ssIHByaW1hcnlLZXlWYWx1ZSB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICB0b2dnbGVTZWxlY3RSb3cocHJpbWFyeUtleVZhbHVlKTtcbiAgICAgICAgb25Sb3dDaGVja2JveENsaWNrKGV2ZW50LCBwcmltYXJ5S2V5VmFsdWUpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyByb3dTZWxlY3RlZCwgcHJpbWFyeUtleVZhbHVlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICBjaGVja2VkPXtyb3dTZWxlY3RlZH1cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtlID0+IHRoaXMub25DaGVja2JveENsaWNrKGUpfVxuICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2Mtc2VsZWN0LXJvd1wiXG4gICAgICAgICAgICAgICAgZGF0YS1pZD17cHJpbWFyeUtleVZhbHVlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbkRhdGFncmlkQ2hlY2tib3gucHJvcFR5cGVzID0ge1xuICAgIHJvd1NlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICB0b2dnbGVTZWxlY3RSb3c6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUm93Q2hlY2tib3hDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcHJpbWFyeUtleVZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5leHBvcnQgZGVmYXVsdCBEYXRhZ3JpZENoZWNrYm94OyIsImltcG9ydCBEYXRhZ3JpZEFjdGlvbnNDb2x1bW4gZnJvbSBcIi4vZGF0YWdyaWQtYWN0aW9ucy1jb2x1bW4uanN4XCI7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBQcm9wVHlwZXMsIHsgc2hhcGUgfSBmcm9tICdwcm9wLXR5cGVzJztcblxuY2xhc3MgRGF0YWdyaWRSb3cgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZGF0YToge2NvbHVtbnNEYXRhfSxcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHsgaGFzQWN0aW9uQnV0dG9ucyB9LFxuICAgICAgICAgICAgICAgIG9uRWRpdENsaWNrLFxuICAgICAgICAgICAgICAgIG9uQ2xvbmVDbGljayxcbiAgICAgICAgICAgICAgICBvblJlYWRDbGljayxcbiAgICAgICAgICAgICAgICBvbkRlbGV0ZUNsaWNrLFxuICAgICAgICAgICAgICAgIG9uUm93Q2hlY2tib3hDbGljayxcbiAgICAgICAgICAgICAgICB1cmxVbmlxdWVIYXNoLFxuICAgICAgICAgICAgICAgIGFjdGlvbkJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgYmFja2VuZEFjdGlvbkJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgc2NyZWVuU2l6ZSxcbiAgICAgICAgICAgICAgICBvcmRlckJ5LFxuICAgICAgICAgICAgICAgIGkxOG4sXG4gICAgICAgICAgICAgICAgcHJpbWFyeUtleVZhbHVlLFxuICAgICAgICAgICAgICAgIHRvZ2dsZVNlbGVjdFJvdyxcbiAgICAgICAgICAgICAgICByb3dTZWxlY3RlZCxcbiAgICAgICAgICAgICAgICBMaW5rQnV0dG9uV3JhcHBlcixcbiAgICAgICAgICAgICAgICBHcm91cFByaW1hcnlCdXR0b24sXG4gICAgICAgICAgICAgICAgR3JvdXBCdXR0b25zTGlzdFxuICAgICAgICAgICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgbGV0IGNvbHVtbkRhdGEgPSBbXTtcblxuICAgICAgICBjb2x1bW5zRGF0YS5mb3JFYWNoKGNvbHVtbiA9PiB7XG5cbiAgICAgICAgICAgIGNvbHVtbkRhdGEucHVzaChcbiAgICAgICAgICAgICAgICA8dGRcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiBvcmRlckJ5ID09PSBjb2x1bW4ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0YWJsZS1hY3RpdmUnOiBvcmRlckJ5ID09PSBjb2x1bW4ubmFtZVxuICAgICAgICAgICAgICAgICAgICB9LCAnZ2MtZGF0YS1jb250YWluZXInKX1cbiAgICAgICAgICAgICAgICAgICAga2V5PXtjb2x1bW4ubmFtZX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICB7IWNvbHVtbi52YWx1ZSAmJiA8c3Bhbj4mbmJzcDs8L3NwYW4+fVxuICAgICAgICAgICAgICAgICAgICAgICAge2NvbHVtbi52YWx1ZSAmJiAhY29sdW1uLmlzSHRtbCAmJiA8ZGl2IGNsYXNzTmFtZT1cImdjLWRhdGEtY29udGFpbmVyLXRleHRcIj57Y29sdW1uLnZhbHVlfTwvZGl2Pn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHtjb2x1bW4udmFsdWUgJiYgY29sdW1uLmlzSHRtbCAmJiA8ZGl2IGNsYXNzTmFtZT1cImdjLWRhdGEtY29udGFpbmVyLXRleHRcIiBkYW5nZXJvdXNseVNldElubmVySFRNTD17e19faHRtbDogY29sdW1uLnZhbHVlfX0+PC9kaXY+fVxuICAgICAgICAgICAgICAgICA8L3RkPlxuXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPHRyIFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgICd3YXJuaW5nJzogcm93U2VsZWN0ZWRcbiAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICBkYXRhLWlkPXtwcmltYXJ5S2V5VmFsdWV9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge2hhc0FjdGlvbkJ1dHRvbnMgJiZcbiAgICAgICAgICAgICAgICA8RGF0YWdyaWRBY3Rpb25zQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM9e29wdGlvbnN9XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkJ1dHRvbnM9e2FjdGlvbkJ1dHRvbnN9XG4gICAgICAgICAgICAgICAgICAgIGJhY2tlbmRBY3Rpb25CdXR0b25zPXtiYWNrZW5kQWN0aW9uQnV0dG9uc31cbiAgICAgICAgICAgICAgICAgICAgb25FZGl0Q2xpY2s9e29uRWRpdENsaWNrfVxuICAgICAgICAgICAgICAgICAgICBvbkNsb25lQ2xpY2s9e29uQ2xvbmVDbGlja31cbiAgICAgICAgICAgICAgICAgICAgb25SZWFkQ2xpY2s9e29uUmVhZENsaWNrfVxuICAgICAgICAgICAgICAgICAgICBvbkRlbGV0ZUNsaWNrPXtvbkRlbGV0ZUNsaWNrfVxuICAgICAgICAgICAgICAgICAgICBvblJvd0NoZWNrYm94Q2xpY2s9e29uUm93Q2hlY2tib3hDbGlja31cbiAgICAgICAgICAgICAgICAgICAgdXJsVW5pcXVlSGFzaD17dXJsVW5pcXVlSGFzaH1cbiAgICAgICAgICAgICAgICAgICAgc2NyZWVuU2l6ZT17c2NyZWVuU2l6ZX1cbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlU2VsZWN0Um93PXt0b2dnbGVTZWxlY3RSb3d9XG4gICAgICAgICAgICAgICAgICAgIHJvd1NlbGVjdGVkPXtyb3dTZWxlY3RlZH1cbiAgICAgICAgICAgICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleVZhbHVlPXtwcmltYXJ5S2V5VmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIExpbmtCdXR0b25XcmFwcGVyPXtMaW5rQnV0dG9uV3JhcHBlcn1cbiAgICAgICAgICAgICAgICAgICAgR3JvdXBQcmltYXJ5QnV0dG9uPXtHcm91cFByaW1hcnlCdXR0b259XG4gICAgICAgICAgICAgICAgICAgIEdyb3VwQnV0dG9uc0xpc3Q9e0dyb3VwQnV0dG9uc0xpc3R9XG4gICAgICAgICAgICAgICAgLz59XG4gICAgICAgICAgICAgICAge2NvbHVtbkRhdGF9XG4gICAgICAgICAgICA8L3RyPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuRGF0YWdyaWRSb3cucHJvcFR5cGVzID0ge1xuICAgIGRhdGE6IHNoYXBlKHtcbiAgICAgICAgY29sdW1uc0RhdGE6IFByb3BUeXBlcy5hcnJheVxuICAgIH0pLFxuICAgIG9wdGlvbnM6IHNoYXBlKHtcbiAgICAgICAgZGVsZXRlTXVsdGlwbGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBoYXNFZGl0OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgaGFzQ2xvbmU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBoYXNEZWxldGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBoYXNSZWFkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgaGFzQWN0aW9uQnV0dG9uczogUHJvcFR5cGVzLmJvb2xcbiAgICB9KSxcbiAgICBvbkVkaXRDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DbG9uZUNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblJlYWRDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25EZWxldGVDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Sb3dDaGVja2JveENsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICB1cmxVbmlxdWVIYXNoOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFjdGlvbkJ1dHRvbnM6IFByb3BUeXBlcy5hcnJheSxcbiAgICBiYWNrZW5kQWN0aW9uQnV0dG9uczogUHJvcFR5cGVzLmFycmF5LFxuICAgIHNjcmVlblNpemU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgaTE4bjogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBwcmltYXJ5S2V5VmFsdWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgdG9nZ2xlU2VsZWN0Um93OiBQcm9wVHlwZXMuZnVuYyxcbiAgICByb3dTZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgTGlua0J1dHRvbldyYXBwZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIExpbmtCdXR0b25XcmFwcGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBHcm91cEJ1dHRvbnNMaXN0OiBQcm9wVHlwZXMuZnVuYyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERhdGFncmlkUm93OyIsImltcG9ydCBEYXRhZ3JpZFJvdyBmcm9tICcuL2RhdGFncmlkLXJvdy5qc3gnO1xuaW1wb3J0IFByb3BUeXBlcywge3NoYXBlfSBmcm9tICdwcm9wLXR5cGVzJztcblxuY2xhc3MgRGF0YWdyaWRUYm9keSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNlbGVjdGVkSWRzOiBbXVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9nZ2xlU2VsZWN0Um93KGlkKSB7XG4gICAgICAgIGxldCB7IHNlbGVjdGVkSWRzIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIGlmIChzZWxlY3RlZElkcy5pbmRleE9mKGlkKSA+IC0xKSB7XG4gICAgICAgICAgICBzZWxlY3RlZElkcyA9IHNlbGVjdGVkSWRzLmZpbHRlcihzZWxlY3RlZElkID0+IHNlbGVjdGVkSWQgIT09IGlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGVkSWRzLnB1c2goaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBzZWxlY3RlZElkc1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHJvd3MsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgb3JkZXJCeSxcbiAgICAgICAgICAgIGNvbHVtbnMsXG4gICAgICAgICAgICBvbkVkaXRDbGljayxcbiAgICAgICAgICAgIG9uQ2xvbmVDbGljayxcbiAgICAgICAgICAgIG9uUmVhZENsaWNrLFxuICAgICAgICAgICAgb25EZWxldGVDbGljayxcbiAgICAgICAgICAgIG9uUm93Q2hlY2tib3hDbGljayxcbiAgICAgICAgICAgIHVybFVuaXF1ZUhhc2gsXG4gICAgICAgICAgICBhY3Rpb25CdXR0b25zLFxuICAgICAgICAgICAgc2NyZWVuU2l6ZSxcbiAgICAgICAgICAgIGkxOG4sXG4gICAgICAgICAgICBMaW5rQnV0dG9uV3JhcHBlcixcbiAgICAgICAgICAgIEdyb3VwUHJpbWFyeUJ1dHRvbixcbiAgICAgICAgICAgIEdyb3VwQnV0dG9uc0xpc3RcbiAgICAgICAgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICB7IHNlbGVjdGVkSWRzIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIHJldHVybiAocm93cy5tYXAoKHJvdywga2V5KSA9PlxuICAgICAgICAgICAgPERhdGFncmlkUm93XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sdW1uc31cbiAgICAgICAgICAgICAgICBvcHRpb25zPXtvcHRpb25zfVxuICAgICAgICAgICAgICAgIGRhdGE9e3Jvd31cbiAgICAgICAgICAgICAgICBvcmRlckJ5PXtvcmRlckJ5fVxuICAgICAgICAgICAgICAgIGtleT17a2V5fVxuICAgICAgICAgICAgICAgIG9uRWRpdENsaWNrPXtvbkVkaXRDbGlja31cbiAgICAgICAgICAgICAgICBvblJlYWRDbGljaz17b25SZWFkQ2xpY2t9XG4gICAgICAgICAgICAgICAgb25DbG9uZUNsaWNrPXtvbkNsb25lQ2xpY2t9XG4gICAgICAgICAgICAgICAgb25EZWxldGVDbGljaz17b25EZWxldGVDbGlja31cbiAgICAgICAgICAgICAgICBvblJvd0NoZWNrYm94Q2xpY2s9e29uUm93Q2hlY2tib3hDbGlja31cbiAgICAgICAgICAgICAgICB1cmxVbmlxdWVIYXNoPXt1cmxVbmlxdWVIYXNofVxuICAgICAgICAgICAgICAgIGFjdGlvbkJ1dHRvbnM9e2FjdGlvbkJ1dHRvbnN9XG4gICAgICAgICAgICAgICAgYmFja2VuZEFjdGlvbkJ1dHRvbnM9e3Jvdy5iYWNrZW5kQWN0aW9uQnV0dG9uc31cbiAgICAgICAgICAgICAgICBzY3JlZW5TaXplPXtzY3JlZW5TaXplfVxuICAgICAgICAgICAgICAgIHRvZ2dsZVNlbGVjdFJvdz17aWQgPT4gdGhpcy50b2dnbGVTZWxlY3RSb3coaWQpfVxuICAgICAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICAgICAgcHJpbWFyeUtleVZhbHVlPXtyb3cucHJpbWFyeUtleVZhbHVlfVxuICAgICAgICAgICAgICAgIHJvd1NlbGVjdGVkPXtzZWxlY3RlZElkcy5pbmRleE9mKHJvdy5wcmltYXJ5S2V5VmFsdWUpID4gLTF9XG4gICAgICAgICAgICAgICAgTGlua0J1dHRvbldyYXBwZXI9e0xpbmtCdXR0b25XcmFwcGVyfVxuICAgICAgICAgICAgICAgIEdyb3VwUHJpbWFyeUJ1dHRvbj17R3JvdXBQcmltYXJ5QnV0dG9ufVxuICAgICAgICAgICAgICAgIEdyb3VwQnV0dG9uc0xpc3Q9e0dyb3VwQnV0dG9uc0xpc3R9XG4gICAgICAgICAgICAvPikpO1xuICAgIH1cbn1cblxuRGF0YWdyaWRUYm9keS5wcm9wVHlwZXM9IHtcbiAgICByb3dzOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgb3B0aW9uczogc2hhcGUoe1xuICAgICAgICBkZWxldGVNdWx0aXBsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGhhc0VkaXQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBoYXNDbG9uZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGhhc0RlbGV0ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGhhc1JlYWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBoYXNBY3Rpb25CdXR0b25zOiBQcm9wVHlwZXMuYm9vbFxuICAgIH0pLFxuICAgIG9yZGVyQnk6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgY29sdW1uczogUHJvcFR5cGVzLmFycmF5LFxuICAgIG9uRWRpdENsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNsb25lQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUmVhZENsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkRlbGV0ZUNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblJvd0NoZWNrYm94Q2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIHVybFVuaXF1ZUhhc2g6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgYWN0aW9uQnV0dG9uczogUHJvcFR5cGVzLmFycmF5LFxuICAgIHNjcmVlblNpemU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgaTE4bjogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBMaW5rQnV0dG9uV3JhcHBlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgR3JvdXBQcmltYXJ5QnV0dG9uOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBHcm91cEJ1dHRvbnNMaXN0OiBQcm9wVHlwZXMuZnVuYyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERhdGFncmlkVGJvZHk7IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY2xhc3MgRmllbGRSb3dXcmFwcGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgaXNSZXF1aXJlZCwgZGlzcGxheUFzLCBGaWVsZElucHV0LCBkYXRhLCBnY3J1ZEluc3RhbmNlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuICg8ZGl2IGNsYXNzTmFtZT1cImZvcm0tZ3JvdXBcIj5cbiAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJjb2wtc20tMyBjb250cm9sLWxhYmVsXCI+XG4gICAgICAgICAge2lzUmVxdWlyZWQgPyAnKicgOiAnJ31cbiAgICAgICAgICB7ZGlzcGxheUFzfVxuICAgICAgPC9sYWJlbD5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXNtLTlcIj5cbiAgICAgICAgICA8RmllbGRJbnB1dCBkYXRhPXtkYXRhfSBnY3J1ZEluc3RhbmNlPXtnY3J1ZEluc3RhbmNlfS8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj4pO1xuICB9XG59XG5cbkZpZWxkUm93V3JhcHBlci5wcm9wVHlwZXMgPSB7XG4gICAgaXNSZXF1aXJlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgZGlzcGxheUFzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIEZpZWxkSW5wdXQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIGRhdGE6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgZ2NydWRJbnN0YW5jZTogUHJvcFR5cGVzLm9iamVjdFxufTtcblxuZXhwb3J0IGRlZmF1bHQgRmllbGRSb3dXcmFwcGVyOyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5jbGFzcyBHcm91cEJ1dHRvbnNMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgICAgY29uc3Qge2J1dHRvbnN9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiAoPHVsIGNsYXNzTmFtZT1cImRyb3Bkb3duLW1lbnVcIj5cbiAgICAgICAge2J1dHRvbnMubWFwKGJ1dHRvbiA9PlxuICAgICAgICAgICAgPGxpXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZHJvcGRvd24taXRlbVwiXG4gICAgICAgICAgICAgICAga2V5PXtidXR0b24ua2V5fVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2Ryb3Bkb3duLXN1Ym1lbnUnOiBidXR0b24uaGFzU3ViTWVudSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZWZ0LWRpcmVjdGlvbic6IGJ1dHRvbi5oYXNTdWJNZW51ICYmIGJ1dHRvbi5zdWJNZW51TGVmdERpcmVjdGlvblxuICAgICAgICAgICAgICAgICAgICB9KX0+XG4gICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgICAgaHJlZj17YnV0dG9uLmhyZWYgPyBidXR0b24uaHJlZiA6ICcnfVxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtidXR0b24ub25DbGlja31cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0PXtidXR0b24udGFyZ2V0fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAge2J1dHRvbi5pY29uICYmIDxpIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhidXR0b24uaWNvbiwgJ2djLWJ1dHRvbi1pY29uJyl9IC8+fVxuICAgICAgICAgICAgICAgICAgICB7YnV0dG9uLnRleHR9XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnN1YkNvbXBvbmVudCAmJiA8dWwgY2xhc3NOYW1lPVwiZHJvcGRvd24tbWVudVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAge2J1dHRvbi5zdWJDb21wb25lbnR9XG4gICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgKX1cbiAgICA8L3VsPik7XG4gIH1cbn1cblxuR3JvdXBCdXR0b25zTGlzdC5wcm9wVHlwZXMgPSB7XG4gICAgYnV0dG9uczogUHJvcFR5cGVzLmFycmF5XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHcm91cEJ1dHRvbnNMaXN0OyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgRGVmYXVsdExpbmtCdXR0b24gZnJvbSBcIi4uLy4uL2J1dHRvbnMvZGVmYXVsdC1saW5rLWJ1dHRvbi5qc3hcIjtcbmltcG9ydCBEZWZhdWx0R3JvdXBCdXR0b24gZnJvbSBcIi4uLy4uL2J1dHRvbnMvZGVmYXVsdC1ncm91cC1idXR0b24uanN4XCI7XG5cbmNsYXNzIEdyb3VwQnV0dG9ucyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHJlbmRlcigpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgICBidXR0b25zLFxuICAgICAgICAgIHNjcmVlblNpemUsXG4gICAgICAgICAgaTE4bixcbiAgICAgICAgICBMaW5rQnV0dG9uV3JhcHBlcixcbiAgICAgICAgICBHcm91cFByaW1hcnlCdXR0b24sXG4gICAgICAgICAgR3JvdXBCdXR0b25zTGlzdFxuICAgICAgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgIG1heEJ1dHRvbnMgPSAoc2NyZWVuU2l6ZSA9PT0gJ3hzJyB8fCBzY3JlZW5TaXplID09PSAncycpID8gMSA6IDIsXG4gICAgICAgIGJ1dHRvbk1hcCA9IGJ1dHRvbiA9PlxuICAgICAgICAgICAgPERlZmF1bHRMaW5rQnV0dG9uXG4gICAgICAgICAgICAgICBrZXk9e2J1dHRvbi5rZXl9XG4gICAgICAgICAgICAgICB1cmw9e2J1dHRvbi51cmx9XG4gICAgICAgICAgICAgICBpY29uPXtidXR0b24uaWNvbn1cbiAgICAgICAgICAgICAgIHRleHQ9e2J1dHRvbi50ZXh0fVxuICAgICAgICAgICAgICAgbmV3VGFiPXtidXR0b24ubmV3VGFifVxuICAgICAgICAgICAgICAgcmlnaHRNYXJnaW49e3RydWV9XG4gICAgICAgICAgICAgICBwcmltYXJ5S2V5VmFsdWU9e2J1dHRvbi5wcmltYXJ5S2V5VmFsdWV9XG4gICAgICAgICAgICAgICBvbkNsaWNrPXtidXR0b24ub25DbGlja31cbiAgICAgICAgICAgICAgIExpbmtCdXR0b25XcmFwcGVyPXtMaW5rQnV0dG9uV3JhcHBlcn1cbiAgICAgICAgICAgIC8+XG5cbiAgICAgIGlmICghYnV0dG9ucyB8fCBidXR0b25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnV0dG9ucy5sZW5ndGggPD0gbWF4QnV0dG9ucykge1xuICAgICAgICAgIHJldHVybiBidXR0b25zLm1hcChidXR0b25NYXApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKDxzcGFuPlxuICAgICAgICAgIHsoYnV0dG9ucy5maWx0ZXIoKF9fYnV0dG9uLCBrZXkpID0+IGtleSA8IChtYXhCdXR0b25zIC0gMSkpLm1hcChidXR0b25NYXApKX1cbiAgICAgICAgICA8RGVmYXVsdEdyb3VwQnV0dG9uXG4gICAgICAgICAgICAgIGJ1dHRvbnM9e2J1dHRvbnMuZmlsdGVyKChfX2J1dHRvbiwga2V5KSA9PiBrZXkgPj0gKG1heEJ1dHRvbnMgLSAxKSl9XG4gICAgICAgICAgICAgIG1heEJ1dHRvbnM9e21heEJ1dHRvbnN9XG4gICAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICAgIEdyb3VwUHJpbWFyeUJ1dHRvbj17R3JvdXBQcmltYXJ5QnV0dG9ufVxuICAgICAgICAgICAgICBHcm91cEJ1dHRvbnNMaXN0PXtHcm91cEJ1dHRvbnNMaXN0fVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvc3Bhbj5cbiAgICApO1xuICB9XG59XG5cbkdyb3VwQnV0dG9ucy5wcm9wVHlwZXMgPSB7XG4gICAgYnV0dG9uczogUHJvcFR5cGVzLmFycmF5LFxuICAgIHNjcmVlblNpemU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgaTE4bjogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBHcm91cEJ1dHRvbnNMaXN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBMaW5rQnV0dG9uV3JhcHBlcjogUHJvcFR5cGVzLmZ1bmMsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBHcm91cEJ1dHRvbnM7IiwiY2xhc3MgR3JvdXBQcmltYXJ5QnV0dG9uIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzc05hbWU9XCJidG4gYnRuLWRlZmF1bHQgZHJvcGRvd24tdG9nZ2xlXCIgey4uLnByb3BzfT57cHJvcHMuY2hpbGRyZW59PC9idXR0b24+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBHcm91cFByaW1hcnlCdXR0b247IiwiaW1wb3J0IGNsYXNzTmFtZXNMaWJyYXJ5IGZyb20gXCJjbGFzc25hbWVzXCI7XG5cbmNsYXNzIExpbmtCdXR0b25XcmFwcGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgICAgY29uc3RcbiAgICAgICAgICB7IGNoaWxkcmVuLCBjbGFzc05hbWVzLCBocmVmLCByb2xlLCBvbkNsaWNrLCB0YXJnZXQgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxhXG4gICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzTGlicmFyeSgnYnRuJywgJ2J0bi1kZWZhdWx0JywgY2xhc3NOYW1lcyl9XG4gICAgICAgICAgaHJlZj17aHJlZn1cbiAgICAgICAgICByb2xlPXtyb2xlfVxuICAgICAgICAgIG9uQ2xpY2s9e29uQ2xpY2t9XG4gICAgICAgICAgdGFyZ2V0PXt0YXJnZXR9XG4gICAgICAgID5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvYT4pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExpbmtCdXR0b25XcmFwcGVyOyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIE1vZGFsVGl0bGVXcmFwcGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgICAgY29uc3QgeyB0aXRsZSB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgcmV0dXJuIDxSZWFjdC5GcmFnbWVudD5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjbG9zZVwiXG4gICAgICAgICAgICAgIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCJcbiAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIkNsb3NlXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPGg0IGNsYXNzTmFtZT1cIm1vZGFsLXRpdGxlXCI+XG4gICAgICAgICAgICAgIHt0aXRsZX1cbiAgICAgICAgICA8L2g0PlxuICAgICAgPC9SZWFjdC5GcmFnbWVudD5cbiAgfVxufVxuXG5Nb2RhbFRpdGxlV3JhcHBlci5wcm9wVHlwZXMgPSB7XG4gICAgdGl0bGU6IFByb3BUeXBlcy5zdHJpbmdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1vZGFsVGl0bGVXcmFwcGVyOyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIEZpZWxkUm93V3JhcHBlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGlzUmVxdWlyZWQsIGRpc3BsYXlBcywgRmllbGRJbnB1dCwgZGF0YSwgZ2NydWRJbnN0YW5jZSB9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiAoPGRpdiBjbGFzc05hbWU9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cImNvbC1zbS0zIGNvbC1mb3JtLWxhYmVsXCI+XG4gICAgICAgICAge2lzUmVxdWlyZWQgPyAnKicgOiAnJ31cbiAgICAgICAgICB7ZGlzcGxheUFzfVxuICAgICAgPC9sYWJlbD5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXNtLTlcIj5cbiAgICAgICAgICA8RmllbGRJbnB1dCBkYXRhPXtkYXRhfSBnY3J1ZEluc3RhbmNlPXtnY3J1ZEluc3RhbmNlfS8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj4pO1xuICB9XG59XG5cbkZpZWxkUm93V3JhcHBlci5wcm9wVHlwZXMgPSB7XG4gICAgaXNSZXF1aXJlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgZGlzcGxheUFzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIEZpZWxkSW5wdXQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIGRhdGE6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgZ2NydWRJbnN0YW5jZTogUHJvcFR5cGVzLm9iamVjdFxufTtcblxuZXhwb3J0IGRlZmF1bHQgRmllbGRSb3dXcmFwcGVyOyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5jbGFzcyBHcm91cEJ1dHRvbnNMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgICAgY29uc3Qge2J1dHRvbnN9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiAoPGRpdiBjbGFzc05hbWU9XCJkcm9wZG93bi1tZW51XCI+XG4gICAgICAgIHtidXR0b25zLm1hcChidXR0b24gPT5cbiAgICAgICAgICAgICFidXR0b24uaGFzU3ViTWVudSA/XG4gICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgICAga2V5PXtidXR0b24ua2V5fVxuICAgICAgICAgICAgICAgICAgICBocmVmPXtidXR0b24uaHJlZn1cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17YnV0dG9uLm9uQ2xpY2t9XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldD17YnV0dG9uLnRhcmdldH1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZHJvcGRvd24taXRlbVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7YnV0dG9uLmljb24gJiYgPGkgY2xhc3NOYW1lPXtjbGFzc05hbWVzKGJ1dHRvbi5pY29uLCAnZ2MtYnV0dG9uLWljb24nKX0gLz59XG4gICAgICAgICAgICAgICAgICAgIHtidXR0b24udGV4dH1cbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgOlxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAga2V5PXtidXR0b24ua2V5fVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ2Ryb3Bkb3duLWl0ZW0nLCAnZHJvcGRvd24tc3VibWVudScsICdkcm9wZG93bi1zdWJtZW51LWl0ZW0nLHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZWZ0LWRpcmVjdGlvbic6IGJ1dHRvbi5zdWJNZW51TGVmdERpcmVjdGlvblxuICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHtidXR0b24uaWNvbiAmJiA8aSBjbGFzc05hbWU9e2NsYXNzTmFtZXMoYnV0dG9uLmljb24sICdnYy1idXR0b24taWNvbicpfSAvPn1cbiAgICAgICAgICAgICAgICAgICAge2J1dHRvbi50ZXh0fVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uc3ViQ29tcG9uZW50ICYmIDx1bCBjbGFzc05hbWU9XCJkcm9wZG93bi1tZW51XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2J1dHRvbi5zdWJDb21wb25lbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgKX1cbiAgICA8L2Rpdj4pO1xuICB9XG59XG5cbkdyb3VwQnV0dG9uc0xpc3QucHJvcFR5cGVzID0ge1xuICAgIGJ1dHRvbnM6IFByb3BUeXBlcy5hcnJheVxufTtcblxuZXhwb3J0IGRlZmF1bHQgR3JvdXBCdXR0b25zTGlzdDsiLCJjbGFzcyBHcm91cFByaW1hcnlCdXR0b24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzTmFtZT1cImJ0biBidG4tb3V0bGluZS1kYXJrIGRyb3Bkb3duLXRvZ2dsZVwiIHsuLi5wcm9wc30+e3Byb3BzLmNoaWxkcmVufTwvYnV0dG9uPlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgR3JvdXBQcmltYXJ5QnV0dG9uOyIsImltcG9ydCBjbGFzc05hbWVzTGlicmFyeSBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5jbGFzcyBMaW5rQnV0dG9uV3JhcHBlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHJlbmRlcigpIHtcbiAgICAgIGNvbnN0XG4gICAgICAgICAgeyBjaGlsZHJlbiwgY2xhc3NOYW1lcywgaHJlZiwgcm9sZSwgb25DbGljaywgdGFyZ2V0IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAgIDxhXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc0xpYnJhcnkoJ2J0bicsICdidG4tb3V0bGluZS1kYXJrJywgY2xhc3NOYW1lcyl9XG4gICAgICAgICAgICAgIGhyZWY9e2hyZWZ9XG4gICAgICAgICAgICAgIHJvbGU9e3JvbGV9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9e29uQ2xpY2t9XG4gICAgICAgICAgICAgIHRhcmdldD17dGFyZ2V0fVxuICAgICAgICAgID5cbiAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgIDwvYT4pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExpbmtCdXR0b25XcmFwcGVyOyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIE1vZGFsVGl0bGVXcmFwcGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgICAgY29uc3QgeyB0aXRsZSB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgcmV0dXJuIDxSZWFjdC5GcmFnbWVudD5cbiAgICAgICAgICA8aDQgY2xhc3NOYW1lPVwibW9kYWwtdGl0bGVcIj5cbiAgICAgICAgICAgICAge3RpdGxlfVxuICAgICAgICAgIDwvaDQ+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2xvc2VcIlxuICAgICAgICAgICAgICBkYXRhLWRpc21pc3M9XCJtb2RhbFwiXG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJDbG9zZVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9SZWFjdC5GcmFnbWVudD5cbiAgfVxufVxuXG5Nb2RhbFRpdGxlV3JhcHBlci5wcm9wVHlwZXMgPSB7XG4gICAgdGl0bGU6IFByb3BUeXBlcy5zdHJpbmdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1vZGFsVGl0bGVXcmFwcGVyOyIsImltcG9ydCBQZXJQYWdlRHJvcGRvd24gZnJvbSAnLi4vbW9kdWxlcy9yZWFjdC9qc3gvZGF0YWdyaWQvZm9vdGVyL3Blci1wYWdlLWRyb3Bkb3duLmpzeCc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBGaWx0ZXJpbmcgZnJvbSAnLi4vLi4vLi4vLi4vUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQtZmlsdGVyaW5nL2ZpbHRlcmluZyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBEYXRhZ3JpZFRib2R5IGZyb20gJy4uLy4uLy4uLy4uL1JlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkL2RhdGFncmlkLXRib2R5LmpzeCc7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vLi4vLi4vLi4vUmVhY3QtQ29tcG9uZW50cy9nY2UtZGF0YWdyaWQtc2V0dGluZ3MvZ2NlLWRhdGFncmlkLXNldHRpbmdzL3NldHRpbmdzLmpzeCc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBHcm91cFByaW1hcnlCdXR0b25Cb290c3RyYXBWMyBmcm9tICcuLi8uLi8uLi8uLi9SZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC93cmFwcGVycy9ib290c3RyYXAtdjMvZ3JvdXAtcHJpbWFyeS1idXR0b24uanN4JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IEdyb3VwQnV0dG9uc0xpc3RCb290c3RyYXBWMyBmcm9tICcuLi8uLi8uLi8uLi9SZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC93cmFwcGVycy9ib290c3RyYXAtdjMvZ3JvdXAtYnV0dG9ucy1saXN0LmpzeCc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBMaW5rQnV0dG9uV3JhcHBlckJvb3RzdHJhcFYzIGZyb20gJy4uLy4uLy4uLy4uL1JlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkL3dyYXBwZXJzL2Jvb3RzdHJhcC12My9saW5rLWJ1dHRvbi13cmFwcGVyLmpzeCc7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQgRmllbGRSb3dXcmFwcGVyQm9vdHN0cmFwVjMgZnJvbSAnLi4vLi4vLi4vLi4vUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvd3JhcHBlcnMvYm9vdHN0cmFwLXYzL2ZpZWxkLXJvdy13cmFwcGVyJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IE1vZGFsVGl0bGVXcmFwcGVyQm9vdHN0cmFwVjMgZnJvbSAnLi4vLi4vLi4vLi4vUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvd3JhcHBlcnMvYm9vdHN0cmFwLXYzL21vZGFsLXRpdGxlLXdyYXBwZXInOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQgR3JvdXBQcmltYXJ5QnV0dG9uQm9vdHN0cmFwVjQgZnJvbSAnLi4vLi4vLi4vLi4vUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvd3JhcHBlcnMvYm9vdHN0cmFwLXY0L2dyb3VwLXByaW1hcnktYnV0dG9uLmpzeCc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBHcm91cEJ1dHRvbnNMaXN0Qm9vdHN0cmFwVjQgZnJvbSAnLi4vLi4vLi4vLi4vUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvd3JhcHBlcnMvYm9vdHN0cmFwLXY0L2dyb3VwLWJ1dHRvbnMtbGlzdC5qc3gnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQgTGlua0J1dHRvbldyYXBwZXJCb290c3RyYXBWNCBmcm9tICcuLi8uLi8uLi8uLi9SZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC93cmFwcGVycy9ib290c3RyYXAtdjQvbGluay1idXR0b24td3JhcHBlci5qc3gnOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IEZpZWxkUm93V3JhcHBlckJvb3RzdHJhcFY0IGZyb20gJy4uLy4uLy4uLy4uL1JlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkL3dyYXBwZXJzL2Jvb3RzdHJhcC12NC9maWVsZC1yb3ctd3JhcHBlcic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBNb2RhbFRpdGxlV3JhcHBlckJvb3RzdHJhcFY0IGZyb20gJy4uLy4uLy4uLy4uL1JlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkL3dyYXBwZXJzL2Jvb3RzdHJhcC12NC9tb2RhbC10aXRsZS13cmFwcGVyJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IE1vZGFsVGl0bGUgZnJvbSAnLi4vLi4vLi4vLi4vUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9tb2RhbC90aXRsZS5qc3gnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cblxubGV0IEhhbmRsZWJhcnMgPSByZXF1aXJlKCcuLi9saWJyYXJpZXMvSGFuZGxlYmFyc0V4dGVuZGVkJykuSGFuZGxlYmFycyxcbiAgICBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpLFxuICAgICQgPSBqUXVlcnksXG4gICAgalF1ZXJ5UGx1Z2lucyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvanF1ZXJ5L2pxdWVyeS1wbHVnaW5zJykualF1ZXJ5UGx1Z2lucyxcbiAgICBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9zZWN0aW9ucy9jb25zdGFudHMnKS5Db25zdGFudHMsXG4gICAgYWpheEhlbHBlciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYWpheC1oZWxwZXInKS5hamF4SGVscGVyLFxuICAgIGkxOG4gPSByZXF1aXJlKCcuLi9zZWN0aW9ucy9pMThuJykuaTE4bixcbiAgICBsb2NhbFN0b3JhZ2VIZWxwZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2xvY2FsLXN0b3JhZ2UtaGVscGVyJykubG9jYWxTdG9yYWdlSGVscGVyLFxuICAgIEdyaWQgPSByZXF1aXJlKCcuLy4uL3NlY3Rpb25zL2RhdGFncmlkL2RhdGFncmlkLmdyaWQuanMnKS5HcmlkLFxuICAgIE9wZXJhdGlvbkFkZCA9IHJlcXVpcmUoJy4vLi4vc2VjdGlvbnMvb3BlcmF0aW9ucy9hZGQuanMnKS5PcGVyYXRpb25BZGQsXG4gICAgT3BlcmF0aW9uRWRpdCA9IHJlcXVpcmUoJy4vLi4vc2VjdGlvbnMvb3BlcmF0aW9ucy9lZGl0LmpzJykuT3BlcmF0aW9uRWRpdCxcbiAgICBPcGVyYXRpb25DbG9uZSA9IHJlcXVpcmUoJy4vLi4vc2VjdGlvbnMvb3BlcmF0aW9ucy9jbG9uZS5qcycpLk9wZXJhdGlvbkNsb25lLFxuICAgIE9wZXJhdGlvblJlYWQgPSByZXF1aXJlKCcuLy4uL3NlY3Rpb25zL29wZXJhdGlvbnMvcmVhZC5qcycpLk9wZXJhdGlvblJlYWQsXG4gICAgT3BlcmF0aW9uRGVsZXRlID0gcmVxdWlyZSgnLi8uLi9zZWN0aW9ucy9vcGVyYXRpb25zL2RlbGV0ZS5qcycpLk9wZXJhdGlvbkRlbGV0ZSxcbiAgICBPcGVyYXRpb25zQ29tbW9uID0gcmVxdWlyZSgnLi8uLi9zZWN0aW9ucy9vcGVyYXRpb25zL2NvbW1vbi5qcycpLk9wZXJhdGlvbnNDb21tb24sXG4gICAgQ29sdW1uID0gcmVxdWlyZSgnLi4vc2VjdGlvbnMvZGF0YWdyaWQvY29sdW1uJykuQ29sdW1uLFxuICAgIERhdGFncmlkQ29sdW1ucyA9IHJlcXVpcmUoJy4uL3NlY3Rpb25zL2RhdGFncmlkL2RhdGFncmlkLmNvbHVtbnMnKS5EYXRhZ3JpZENvbHVtbnMsXG4gICAgRGF0YWdyaWRQYWdpbmcgPSByZXF1aXJlKCcuLi9zZWN0aW9ucy9kYXRhZ3JpZC9kYXRhZ3JpZC5wYWdpbmcnKS5EYXRhZ3JpZFBhZ2luZyxcbiAgICBEYXRhZ3JpZEhlYWRlckFjdGlvbnMgPSByZXF1aXJlKCcuLy4uL3NlY3Rpb25zL2RhdGFncmlkL2RhdGFncmlkLmhlYWRlci1hY3Rpb25zLmpzJykuRGF0YWdyaWRIZWFkZXJBY3Rpb25zLFxuICAgIERhdGFncmlkU2VhcmNoID0gcmVxdWlyZSgnLi8uLi9zZWN0aW9ucy9kYXRhZ3JpZC9kYXRhZ3JpZC5zZWFyY2guanMnKS5EYXRhZ3JpZFNlYXJjaCxcbiAgICBSb3V0ZXIgPSByZXF1aXJlKCcuLi9zZWN0aW9ucy9yb3V0ZXMvcm91dGVyJykuUm91dGVyLFxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGJhc2ljIE9iamVjdCB0aGF0IGRvZXMgYWxsIHRoZSBmdW5jdGlvbmFsaXR5IGZvciBHcm9jZXJ5Q3J1ZFxuICAgICAqXG4gICAgICogQGNsYXNzIEdyb2NlcnlDcnVkXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGdjcnVkX2NvbnRhaW5lclxuICAgICAqIEBwYXJhbSBPYmplY3Qgc2V0dGluZ3NcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBHcm9jZXJ5Q3J1ZCA9IGZ1bmN0aW9uIEdyb2NlcnlDcnVkKGdjcnVkX2NvbnRhaW5lciwgc2V0dGluZ3MpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge2pRdWVyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJGdjID0gZ2NydWRfY29udGFpbmVyO1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgfTtcblxuaWYgKCQuZm4gIT09IHVuZGVmaW5lZCkge1xuICAgIHJlcXVpcmUoJy4uL2pxdWVyeS1wbHVnaW5zL3ByaW50VGhpcycpO1xuICAgIHJlcXVpcmUoJy4uL2pxdWVyeS1wbHVnaW5zL3RyYW5zaXRpb24nKTtcbiAgICByZXF1aXJlKCcuLi9qcXVlcnktcGx1Z2lucy9tb2RhbCcpO1xuICAgIHJlcXVpcmUoJy4uL2pxdWVyeS1wbHVnaW5zL2Nob3Nlbi5qcXVlcnknKTtcbiAgICByZXF1aXJlKCcuLi9saWJyYXJpZXMvanF1ZXJ5LXVpLXRpbWVwaWNrZXInKTtcbn1cblxuLy9Hcm9jZXJ5Q3J1ZCBwdWJsaWMgdmFyaWFibGVzXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuaW5zZXJ0RmllbGRzID0gW107XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUudXJsID0gJyc7XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuaW5kZXhlZENvbHVtbnMgPSB7fTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5oYXNBY3Rpb25zID0gJyc7XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuZW51bUZpZWxkcyA9IFtdO1xuR3JvY2VyeUNydWQucHJvdG90eXBlLmVudW1GaWVsZHNEYXRhID0gW107XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuZHJvcGRvd25GaWVsZHMgPSBbXTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5kcm9wZG93bkZpZWxkc0RhdGEgPSBbXTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5jaGVja2JveEJvb2xlYW5GaWVsZHMgPSBbXTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5jaGVja2JveEJvb2xlYW5GaWVsZHNEYXRhID0gW107XG5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5yZWxhdGlvbk50b05GaWVsZHMgPSB7fTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5yZWxhdGlvbk50b05EYXRhID0ge307XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUubXVsdGlwbGVTZWxlY3RGaWVsZHMgPSB7fTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5tdWx0aXBsZVNlbGVjdERhdGEgPSB7fTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS50ZXh0ZWRpdG9yRmllbGRzID0ge307XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuY2FsbGJhY2tDb2x1bW5GaWVsZHMgPSB7fTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLmNvbXBvbmVudHMgPSB7XG4gICAgR3JvdXBQcmltYXJ5QnV0dG9uOiBudWxsLFxuICAgIEdyb3VwQnV0dG9uc0xpc3Q6IG51bGwsXG4gICAgTGlua0J1dHRvbldyYXBwZXI6IG51bGwsXG4gICAgRmllbGRSb3dXcmFwcGVyOiBudWxsLFxuICAgIE1vZGFsVGl0bGVXcmFwcGVyOiBudWxsXG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUucmVsYXRpb25GaWVsZHMgPSBbXTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5yZWxhdGlvbkRhdGEgPSB7fTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS51cGxvYWRGaWVsZHMgPSBbXTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS51cGxvYWRGaWVsZHNEYXRhID0ge307XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuZGF0ZUZpZWxkcyA9IFtdO1xuR3JvY2VyeUNydWQucHJvdG90eXBlLmRhdGV0aW1lRmllbGRzID0gW107XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuZGF0ZUZvcm1hdHRlciA9IG51bGw7XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUudXBkYXRlRmllbGRzID0gW107XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUucmVhZEZpZWxkcyA9IFtdO1xuR3JvY2VyeUNydWQucHJvdG90eXBlLmNsb25lRmllbGRzID0gW107XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuY29sdW1ucyA9IFtdO1xuR3JvY2VyeUNydWQucHJvdG90eXBlLnZpc2libGVDb2x1bW5zID0gW107XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuc2VhcmNoX3RpbWVyID0gbnVsbDtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5jYWNoZWRJbml0aWFsRGF0YSA9IG51bGw7XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUucHJpbWFyeUtleUZpZWxkID0gbnVsbDtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5qc29uRGF0YSA9IHt9O1xuR3JvY2VyeUNydWQucHJvdG90eXBlLnJvd3NEYXRhID0gbnVsbDtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS51bmlxdWVJZCA9IG51bGw7XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuZGF0ZUZvcm1hdCA9IG51bGw7XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuZGF0YWdyaWRTdG9yZSA9IG51bGw7XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuaGFzaEV2ZW50ID0gbnVsbDtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5zdHJpbmdWYXJpYWJsZXMgPSB7XG4gICAgc3ViamVjdDogJ1JlY29yZCcsXG4gICAgc3ViamVjdFBsdXJhbDogJydcbn07XG5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB0aGlzLmdldEluaXREYXRhKCk7XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuY29tcG9uZW50c0luaXQgPSBmdW5jdGlvbiBjb21wb25lbnRzSW5pdCgpIHtcbiAgICBpZiAodGhpcy5jYWNoZWRJbml0aWFsRGF0YS5jb25maWcuc2tpbiA9PT0gJ2Jvb3RzdHJhcC12NCcpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLkdyb3VwQnV0dG9uc0xpc3QgPSBHcm91cEJ1dHRvbnNMaXN0Qm9vdHN0cmFwVjQ7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5Hcm91cFByaW1hcnlCdXR0b24gPSBHcm91cFByaW1hcnlCdXR0b25Cb290c3RyYXBWNDtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLkxpbmtCdXR0b25XcmFwcGVyID0gTGlua0J1dHRvbldyYXBwZXJCb290c3RyYXBWNDtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLkZpZWxkUm93V3JhcHBlciA9IEZpZWxkUm93V3JhcHBlckJvb3RzdHJhcFY0O1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuTW9kYWxUaXRsZVdyYXBwZXIgPSBNb2RhbFRpdGxlV3JhcHBlckJvb3RzdHJhcFY0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5Hcm91cEJ1dHRvbnNMaXN0ID0gR3JvdXBCdXR0b25zTGlzdEJvb3RzdHJhcFYzO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuR3JvdXBQcmltYXJ5QnV0dG9uID0gR3JvdXBQcmltYXJ5QnV0dG9uQm9vdHN0cmFwVjM7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5MaW5rQnV0dG9uV3JhcHBlciA9IExpbmtCdXR0b25XcmFwcGVyQm9vdHN0cmFwVjM7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5GaWVsZFJvd1dyYXBwZXIgPSBGaWVsZFJvd1dyYXBwZXJCb290c3RyYXBWMztcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLk1vZGFsVGl0bGVXcmFwcGVyID0gTW9kYWxUaXRsZVdyYXBwZXJCb290c3RyYXBWMztcbiAgICB9XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuaW5pdEZhY2FkZSA9IGZ1bmN0aW9uIGluaXRGYWNhZGUoKSB7XG4gICAgUm91dGVyLnNldFJvdXRlcy5hcHBseSh0aGlzKTtcbiAgICB0aGlzLmNvbXBvbmVudHNJbml0KCk7XG4gICAgdGhpcy5kYXRhZ3JpZEluaXQoKTtcblxuICAgIGpRdWVyeVBsdWdpbnMuaW5pdCgpO1xuXG4gICAgT3BlcmF0aW9uQWRkLmxpc3RlbmVyQWRkQnV0dG9uLmFwcGx5KHRoaXMpO1xuICAgIE9wZXJhdGlvbnNDb21tb24ubGlzdGVuZXJTdWJtaXRGb3JtLmFwcGx5KHRoaXMpO1xuICAgIE9wZXJhdGlvbkRlbGV0ZS5saXN0ZW5lckRlbGV0ZVNpbmdsZU1vZGFsLmFwcGx5KHRoaXMpO1xuICAgIE9wZXJhdGlvbkRlbGV0ZS5saXN0ZW5lckRlbGV0ZU11bHRpcGxlLmFwcGx5KHRoaXMpO1xuICAgIE9wZXJhdGlvbkRlbGV0ZS5saXN0ZW5lckRlbGV0ZU11bHRpcGxlTW9kYWwuYXBwbHkodGhpcyk7XG4gICAgT3BlcmF0aW9uc0NvbW1vbi5pbml0UmVkdXhTdG9yZS5hcHBseSh0aGlzKTtcblxuICAgIERhdGFncmlkU2VhcmNoLmxpc3RlbmVyU2VhcmNoQnV0dG9uLmFwcGx5KHRoaXMpO1xuICAgIEdyaWQubGlzdGVuZXJDb2x1bW5XaXRoT3JkZXJpbmcuYXBwbHkodGhpcyk7XG4gICAgR3JpZC5saXN0ZW5lclBhZ2luZ0J1dHRvbnMuYXBwbHkodGhpcyk7XG4gICAgRGF0YWdyaWRIZWFkZXJBY3Rpb25zLmxpc3RlbmVyUHJpbnRCdXR0b24uYXBwbHkodGhpcyk7XG4gICAgdGhpcy5saXN0ZW5lclBlclBhZ2UoKTtcblxuICAgIHRoaXMubGlzdGVuZXJPblNjcmVlblJlc2l6ZSgpO1xuXG4gICAgdGhpcy5pbml0aWFsaXplRmllbGRUeXBlc0RhdGEoKTtcblxuICAgIENvbHVtbi5pbml0Q2FjaGVkRGF0YS5hcHBseSh0aGlzKTtcblxuICAgIC8vIEFsbCB0aGVzZSBNVVNUIGJlIGFmdGVyIHRoZSBpbml0aWFsaXplRmllbGRUeXBlc0RhdGEgYW5kIGluaXRDYWNoZWREYXRhXG4gICAgRGF0YWdyaWRDb2x1bW5zLnNldFZpc2libGVDb2x1bW5zLmFwcGx5KHRoaXMpO1xuICAgIHRoaXMucmVuZGVyU2V0dGluZ3NCdXR0b24uYXBwbHkodGhpcyk7XG4gICAgdGhpcy5lbmFibGVGaWx0ZXJpbmdDb21wb25lbnQuYXBwbHkodGhpcyk7XG5cbiAgICB0aGlzLmluaXRpYWxpemluZ0RhdGEoKTtcblxuICAgIFJvdXRlci5pbml0LmFwcGx5KHRoaXMpO1xufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLmxpc3RlbmVyT25TY3JlZW5SZXNpemUgPSBmdW5jdGlvbiBsaXN0ZW5lck9uU2NyZWVuUmVzaXplKCkge1xuICAgIGxldCByZXNpemVyVGltZW91dCA9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBpZiAod2luZG93KSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiBvbldpbmRvd1Jlc2l6ZSgpIHtcbiAgICAgICAgICAgIGlmIChyZXNpemVyVGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXNpemVyVGltZW91dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc2l6ZXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiB3aW5kb3dSZXNpemVUaW1lb3V0KCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZXJUaW1lb3V0ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvd3NEYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRGF0YWdyaWRCb2R5KHRoaXMucm93c0RhdGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlRmlsdGVyaW5nQ29tcG9uZW50KCk7XG5cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgMjUwKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuX2ZpbHRlcmluZ09uU3VibWl0Q2FsbGJhY2sgPSBmdW5jdGlvbiBfZmlsdGVyaW5nT25TdWJtaXRDYWxsYmFjayhldmVudCkge1xuICAgIGxldCBkYXRhVG9TZW5kID0gYWpheEhlbHBlci5nZXRNdWx0aWxheWVyUG9zdERhdGFGcm9tRm9ybS5hcHBseSh0aGlzLCBbICQoZXZlbnQudGFyZ2V0KSBdKSxcbiAgICAgICAgaGlkZGVuRmllbGRzSHRtbCA9ICcnLFxuICAgICAgICBudW1iZXJPZkZpbHRlcnMgPSAwO1xuICAgIGNvbnN0IHBlcl9wYWdlID0gR3JpZC5nZXRQZXJQYWdlLmFwcGx5KHRoaXMpLFxuICAgICAgICBvcmRlcl9ieSA9IEdyaWQuZ2V0T3JkZXJCeS5hcHBseSh0aGlzKSxcbiAgICAgICAgc29ydGluZyA9IEdyaWQuZ2V0U29ydGluZy5hcHBseSh0aGlzKTtcblxuICAgIF8uZWFjaChkYXRhVG9TZW5kLCBmdW5jdGlvbiBmb3JlYWNoRGF0YVRvU2VuZChmaWVsZFZhbHVlLCBmaWVsZE5hbWUpIHtcbiAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gL15leHRlbmRlZF9zZWFyY2gvLnRlc3QoZmllbGROYW1lKSA/ICdnYy1leHRlbmRlZC1zZWFyY2gtaW5wdXQnIDogJyc7XG5cbiAgICAgICAgaWYgKC9eZXh0ZW5kZWRfc2VhcmNoXFxbXFxkK1xcXVxcW25hbWVcXF0kLy50ZXN0KGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIG51bWJlck9mRmlsdGVycysrO1xuICAgICAgICB9XG5cbiAgICAgICAgaGlkZGVuRmllbGRzSHRtbCArPSAnPGlucHV0IHR5cGU9XCJoaWRkZW5cIiBuYW1lPVwiJyArIGZpZWxkTmFtZSArICdcIiB2YWx1ZT1cIicgKyBmaWVsZFZhbHVlICsgJ1wiIGNsYXNzPVwiJyArIGNsYXNzTmFtZSArICdcIiAvPic7XG4gICAgfSk7XG5cbiAgICAkKCcuZ2MtaGlkZGVuLXNlYXJjaC1pbnB1dHMnKS5odG1sKGhpZGRlbkZpZWxkc0h0bWwpO1xuXG4gICAgaWYgKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuKSB7XG4gICAgICAgIGRhdGFUb1NlbmRbdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5jc3JmVG9rZW4uaW5wdXROYW1lXSA9IHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuLmlucHV0VmFsdWU7XG4gICAgfVxuXG4gICAgZGF0YVRvU2VuZC5hY3Rpb24gPSAnZGF0YWdyaWQnO1xuICAgIGRhdGFUb1NlbmQucGFnZSA9ICcxJztcbiAgICBkYXRhVG9TZW5kLnBlcl9wYWdlID0gcGVyX3BhZ2U7XG4gICAgZGF0YVRvU2VuZC5vcmRlcl9ieSA9IG9yZGVyX2J5O1xuICAgIGRhdGFUb1NlbmQuc29ydGluZyA9IHNvcnRpbmc7XG5cbiAgICB0aGlzLiRnYy5maW5kKCcucGFnZS1udW1iZXItaW5wdXQnKS52YWwoJzEnKTtcbiAgICB0aGlzLiRnYy5maW5kKCcucGFnZS1udW1iZXItaGlkZGVuJykudmFsKCcxJyk7XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuJGdjXG4gICAgICAgIC5maW5kKCcuZ2MtZmlsdGVyaW5nLW1vZGFsJylcbiAgICAgICAgLmdjX21vZGFsKCdoaWRlJyk7XG5cbiAgICB0aGlzLnNlbmRQb3N0UmVxdWVzdCh7XG4gICAgICAgIHVybDogdGhpcy4kZ2MuZGF0YSgndXJsJyksXG4gICAgICAgIGRhdGFUb1NlbmQ6IGRhdGFUb1NlbmQsXG4gICAgICAgIHN1Y2Nlc3NDYWxsYmFjazogZnVuY3Rpb24gc3VjY2Vzc0NhbGxiYWNrKGpzb25SZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKGpzb25SZXNwb25zZS5jc3JmVG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbiA9IGpzb25SZXNwb25zZS5jc3JmVG9rZW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyRGF0YWdyaWQoanNvblJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRGF0YWdyaWQoanNvblJlc3BvbnNlKTtcbiAgICAgICAgICAgIEdyaWQudXBkYXRlR3JpZERldGFpbHMuYXBwbHkodGhpcywgWyBqc29uUmVzcG9uc2UgXSk7XG4gICAgICAgICAgICBEYXRhZ3JpZENvbHVtbnMudHJpZ2dlckNvbHVtbnNSZW5kZXIuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZmlsdGVyLWJ1dHRvbicpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCdidG4tc3VjY2VzcycpXG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdidG4tb3V0bGluZS1kYXJrJyk7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtcmVtb3ZlLWZpbHRlci1jb250YWluZXInKS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZmlsdGVyLXRleHQnKS5hZGRDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZmlsdGVyLWNvdW50ZXInKS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZmlsdGVyLWNvdW50ZXItbnVtYmVyJykuaHRtbChudW1iZXJPZkZpbHRlcnMudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgICAgIGlmIChudW1iZXJPZkZpbHRlcnMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZmlsdGVyLWNvdW50ZXItdGV4dCcpLnJlbW92ZUNsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZmlsdGVyLWNvdW50ZXItdGV4dC1wbHVyYWwnKS5hZGRDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1maWx0ZXItY291bnRlci10ZXh0JykuYWRkQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1maWx0ZXItY291bnRlci10ZXh0LXBsdXJhbCcpLnJlbW92ZUNsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcbn07XG5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5lbmFibGVGaWx0ZXJpbmdDb21wb25lbnQgPSBmdW5jdGlvbiBlbmFibGVGaWx0ZXJpbmdDb21wb25lbnQoKSB7XG4gICAgY29uc3QgZ2NJbnN0YW5jZSA9IHRoaXMsXG4gICAgICAgIHNlYXJjaGFibGVTZWxlY3QgPSB7XG4gICAgICAgICAgICBvbk1vdW50OiBmdW5jdGlvbiBvblNlYXJjaGFibGVNb3VudCgpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIHRpbWVPdXRmb3JTZWFyY2hhYmxlU2VsZWN0KCkge1xuICAgICAgICAgICAgICAgICAgICAkKFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKS5jaG9zZW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dfc2luZ2xlX2Rlc2VsZWN0OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgNTAwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25TZWFyY2hhYmxlVXBkYXRlKCkge1xuICAgICAgICAgICAgICAgICQoUmVhY3RET00uZmluZERPTU5vZGUodGhpcykpLnRyaWdnZXIoJ2Nob3Nlbjp1cGRhdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0RGF0ZXRpbWUgPSB7XG4gICAgICAgICAgICBvbk1vdW50OiBmdW5jdGlvbiBvbkRhdGVNb3VudCgpIHtcbiAgICAgICAgICAgICAgICAkKFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKS5kYXRldGltZXBpY2tlcih7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQ6IChnY0luc3RhbmNlLmRhdGVGb3JtYXQpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0RGF0ZSA9IHtcbiAgICAgICAgICAgIG9uTW91bnQ6IGZ1bmN0aW9uIG9uRGF0ZU1vdW50KCkge1xuICAgICAgICAgICAgICAgICQoUmVhY3RET00uZmluZERPTU5vZGUodGhpcykpLmRhdGVwaWNrZXIoe1xuICAgICAgICAgICAgICAgICAgICBkYXRlRm9ybWF0OiAoZ2NJbnN0YW5jZS5kYXRlRm9ybWF0KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIGlmICghdGhpcy5zZXR0aW5ncy5kYXRhZ3JpZFNlYXJjaEFsbElucHV0KSB7XG4gICAgICAgIFJlYWN0RE9NLnJlbmRlcig8RmlsdGVyaW5nXG4gICAgICAgICAgICBNb2RhbFRpdGxlPXtwcm9wcyA9PiA8TW9kYWxUaXRsZVxuICAgICAgICAgICAgICAgIE1vZGFsVGl0bGVXcmFwcGVyPXt0aGlzLmNvbXBvbmVudHMuTW9kYWxUaXRsZVdyYXBwZXJ9XG4gICAgICAgICAgICAgICAgdGl0bGU9e3Byb3BzLnRpdGxlfVxuICAgICAgICAgICAgLz59XG4gICAgICAgICAgICBpMThuPXt7XG4gICAgICAgICAgICAgICAgYmFzaWNfb3BlcmF0b3I6IGkxOG4udCgnZmlsdGVyaW5nX29wZXJhdG9yJyksXG4gICAgICAgICAgICAgICAgYW5kX3N0YXRlbWVudDogaTE4bi50KCdmaWx0ZXJpbmdfYW5kX3N0YXRlbWVudCcpLFxuICAgICAgICAgICAgICAgIG9yX3N0YXRlbWVudDogaTE4bi50KCdmaWx0ZXJpbmdfb3Jfc3RhdGVtZW50JyksXG4gICAgICAgICAgICAgICAgZmlsdGVyaW5nOiBpMThuLnQoJ2ZpbHRlcmluZ190ZXh0JyksXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBpMThuLnQoJ2ZpbHRlcmluZ19maWx0ZXJfdGV4dCcpLFxuICAgICAgICAgICAgICAgIGNhbmNlbF9maWx0ZXJpbmc6IGkxOG4udCgnZmlsdGVyaW5nX2NhbmNlbCcpLFxuICAgICAgICAgICAgICAgIGFkZF9tb3JlOiBpMThuLnQoJ2ZpbHRlcmluZ19hZGRfbW9yZScpLFxuICAgICAgICAgICAgICAgIHJlbW92ZV9maWx0ZXI6IGkxOG4udCgnZmlsdGVyaW5nX3JlbW92ZV9maWx0ZXInKSxcbiAgICAgICAgICAgICAgICBjb21wYXJpc29uX2NvbnRhaW5zOiBpMThuLnQoJ2ZpbHRlcmluZ19jb250YWlucycpLFxuICAgICAgICAgICAgICAgIGNvbXBhcmlzb25fc3RhcnRzX3dpdGg6IGkxOG4udCgnZmlsdGVyaW5nX3N0YXJ0c193aXRoJyksXG4gICAgICAgICAgICAgICAgY29tcGFyaXNvbl9lbmRzX3dpdGg6IGkxOG4udCgnZmlsdGVyaW5nX2VuZHNfd2l0aCcpLFxuICAgICAgICAgICAgICAgIGNvbXBhcmlzb25fZXF1YWxzOiBpMThuLnQoJ2ZpbHRlcmluZ19lcXVhbHMnKSxcbiAgICAgICAgICAgICAgICBjb21wYXJpc29uX25vdF9lcXVhbHM6IGkxOG4udCgnZmlsdGVyaW5nX25vdF9lcXVhbHMnKSxcbiAgICAgICAgICAgICAgICBjb21wYXJpc29uX2lzX2VtcHR5OiBpMThuLnQoJ2ZpbHRlcmluZ19pc19lbXB0eScpLFxuICAgICAgICAgICAgICAgIGNvbXBhcmlzb25faXNfbm90X2VtcHR5OiBpMThuLnQoJ2ZpbHRlcmluZ19pc19ub3RfZW1wdHknKSxcbiAgICAgICAgICAgICAgICBjb21wYXJpc29uX2dyZWF0ZXJfdGhhbjogaTE4bi50KCdmaWx0ZXJpbmdfZ3JlYXRlcl90aGFuJyksXG4gICAgICAgICAgICAgICAgY29tcGFyaXNvbl9sZXNzX3RoYW46IGkxOG4udCgnZmlsdGVyaW5nX2xlc3NfdGhhbicpLFxuICAgICAgICAgICAgICAgIGNvbXBhcmlzb25fZ3JlYXRlcl90aGFuX29yX2VxdWFsOiBpMThuLnQoJ2ZpbHRlcmluZ19ncmVhdGVyX3RoYW5fb3JfZXF1YWwnKSxcbiAgICAgICAgICAgICAgICBjb21wYXJpc29uX2xlc3NfdGhhbl9vcl9lcXVhbDogaTE4bi50KCdmaWx0ZXJpbmdfbGVzc190aGFuX29yX2VxdWFsJyksXG4gICAgICAgICAgICAgICAgY29tcGFyaXNvbl9oYXM6IGkxOG4udCgnZmlsdGVyaW5nX2hhcycpLFxuICAgICAgICAgICAgICAgIGNvbXBhcmlzb25fZG9lc19ub3RfaGF2ZTogaTE4bi50KCdmaWx0ZXJpbmdfZG9lc19ub3RfaGF2ZScpXG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgc2NyZWVuU2l6ZT17dGhpcy5nZXRTY3JlZW5XaWR0aCgpfVxuICAgICAgICAgICAgZmllbGRzPXt0aGlzLmdldEZpZWxkc0ZvckZpbHRlcmluZy5hcHBseSh0aGlzKX1cbiAgICAgICAgICAgIG9uU3VibWl0Q2FsbGJhY2s9e3RoaXMuX2ZpbHRlcmluZ09uU3VibWl0Q2FsbGJhY2suYmluZCh0aGlzKX1cbiAgICAgICAgICAgIG9uSW5wdXRNb3VudD17e1xuICAgICAgICAgICAgICAgIGRhdGU6IGlucHV0RGF0ZSxcbiAgICAgICAgICAgICAgICBkYXRldGltZTogaW5wdXREYXRldGltZSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGlucHV0RGF0ZXRpbWUsXG4gICAgICAgICAgICAgICAgZW51bV9zZWFyY2hhYmxlOiBzZWFyY2hhYmxlU2VsZWN0LFxuICAgICAgICAgICAgICAgIGRyb3Bkb3duX3NlYXJjaDogc2VhcmNoYWJsZVNlbGVjdCxcbiAgICAgICAgICAgICAgICByZWxhdGlvbmFsOiBzZWFyY2hhYmxlU2VsZWN0LFxuICAgICAgICAgICAgICAgIHJlbGF0aW9uYWxfbl9uOiBzZWFyY2hhYmxlU2VsZWN0XG4gICAgICAgICAgICB9fVxuICAgICAgICAvPiwgdGhpcy4kZ2MuZmluZCgnLmdjLWZpbHRlcmluZy1jb250YWluZXInKVswXSk7XG4gICAgfVxufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLnJlbmRlclNldHRpbmdzQnV0dG9uID0gZnVuY3Rpb24gcmVuZGVyVmlzaWJsZUNvbHVtbnNDaGVja2JveGVzKCkge1xuICAgIGNvbnN0IHJlZnJlc2hDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIEdyaWQuc2VhcmNoQW5kT3JkZXJpbmdUcmlnZ2VyLmFwcGx5KHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBzdWJNZW51TGVmdERpcmVjdGlvbiA9ICF0aGlzLmNhY2hlZEluaXRpYWxEYXRhLm9wZXJhdGlvbnMuZXhwb3J0RGF0YSB8fCAhdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5vcGVyYXRpb25zLnByaW50LFxuICAgICAgICBjbGVhckZpbHRlcmluZ0NhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLXNlYXJjaGFibGUtaW5wdXQnKS52YWwoJycpO1xuICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLXNlYXJjaGFibGUtc2VsZWN0JykudmFsKCcnKTtcbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1zZWFyY2hhYmxlLWNoZWNrYm94JykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1zZWFyY2gtaW5wdXQnKS52YWwoJycpLmJsdXIoKTtcbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1oaWRkZW4tc2VhcmNoLWlucHV0cycpLmh0bWwoJycpO1xuXG4gICAgICAgICAgICBHcmlkLnNlYXJjaEFuZE9yZGVyaW5nVHJpZ2dlci5hcHBseSh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJDYWNoZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlSGVscGVyLnJlbW92ZUxvY2FsU3RvcmFnZUl0ZW0oJ2djcnVkSW5pdGlhbERhdGFfJyArIHRoaXMudW5pcXVlSWQpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlSGVscGVyLnJlbW92ZUxvY2FsU3RvcmFnZUl0ZW0oJ2djcnVkVmlzaWJsZUNvbHVtbnNfJyArIHRoaXMudW5pcXVlSWQpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlSGVscGVyLnJlbW92ZUxvY2FsU3RvcmFnZUl0ZW0oJ2djcnVkUHJlZmVyZW5jZXMnKTtcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaWJsZUNvbHVtbnNDYWxsYmFjayA9ICh2aXNpYmxlQ29sdW1ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRWaXNpYmxlQ29sdW1ucyA9IERhdGFncmlkQ29sdW1ucy5maWx0ZXJWaXNpYmxlQ29sdW1ucy5hcHBseSh0aGlzLCBbdmlzaWJsZUNvbHVtbnNdKTtcbiAgICAgICAgICAgIERhdGFncmlkQ29sdW1ucy50cmlnZ2VyQ29sdW1uc1JlbmRlci5hcHBseSh0aGlzLCBbZmlsdGVyZWRWaXNpYmxlQ29sdW1uc10pO1xuICAgICAgICAgICAgRGF0YWdyaWRDb2x1bW5zLnNldENhY2hlRm9yVmlzaWJsZUNvbHVtbnMuYXBwbHkodGhpcywgW3Zpc2libGVDb2x1bW5zXSk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURhdGFncmlkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHsgR3JvdXBQcmltYXJ5QnV0dG9uLCBHcm91cEJ1dHRvbnNMaXN0IH0gPSB0aGlzLmNvbXBvbmVudHM7XG5cbiAgICBSZWFjdERPTS5yZW5kZXIoPFNldHRpbmdzXG4gICAgICAgIHN1Yk1lbnVMZWZ0RGlyZWN0aW9uPXtzdWJNZW51TGVmdERpcmVjdGlvbn1cbiAgICAgICAgb25SZWZyZXNoQ2FsbGJhY2s9e3JlZnJlc2hDYWxsYmFja31cbiAgICAgICAgb25DbGVhckZpbHRlcmluZ0NhbGxiYWNrPXtjbGVhckZpbHRlcmluZ0NhbGxiYWNrfVxuICAgICAgICBvbkNsZWFyQ2FjaGVDYWxsYmFjaz17Y2xlYXJDYWNoZUNhbGxiYWNrfVxuICAgICAgICBjb2x1bW5zPXt0aGlzLmNvbHVtbnN9XG4gICAgICAgIHZpc2libGVDb2x1bW5zPXt0aGlzLnZpc2libGVDb2x1bW5zfVxuICAgICAgICBnY3J1ZEluc3RhbmNlPXt0aGlzfVxuICAgICAgICB2aXNpYmxlQ29sdW1uc0NhbGxiYWNrT25DaGFuZ2U9e3Zpc2libGVDb2x1bW5zQ2FsbGJhY2t9XG4gICAgICAgIGkxOG49e3RoaXMuY2FjaGVkSW5pdGlhbERhdGEuaTE4bn1cbiAgICAgICAgR3JvdXBQcmltYXJ5QnV0dG9uPXtHcm91cFByaW1hcnlCdXR0b259XG4gICAgICAgIEdyb3VwQnV0dG9uc0xpc3Q9e0dyb3VwQnV0dG9uc0xpc3R9XG4gICAgLz4sIHRoaXMuJGdjLmZpbmQoJy5nYy1zZXR0aW5ncy1idXR0b24tY29udGFpbmVyJylbMF0pO1xufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLnJlbmRlckRhdGFncmlkID0gZnVuY3Rpb24gcmVyZW5kZXJEYXRhZ3JpZChkYXRhKSB7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmpzb25EYXRhID0gZGF0YTtcbiAgICB9XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuZ2V0SW5pdERhdGEgPSBmdW5jdGlvbiBnZXRJbml0RGF0YSgpIHtcblxuICAgIC8qIEBpZiBFTlZJUk9OTUVOVD0nd2Vic2l0ZScgKi9cbiAgICAgICAgLyogUHJvdGVjdGlvbiBpbiBjYXNlIHNvbWVvbmUgd2lsbCBkb3dubG9hZFxuICAgICAgICAqICB0aGUgSlMgY29kZS4gQ3JhenlmeSByZWFkcyB0aGUgaG9zdCBuYW1lIGFuZCBpZiBpdCBkb2Vzbid0IGluY2x1ZGVcbiAgICAgICAgKiAgZ3JvY2VyeWNydWQgaXQgd2lsbCBkbyBzb21lIGNyYXp5IHN0dWZmIGF0IHRoZSBjb2RlLiBJZiB5b3UgdHJ5IHRvIGRlYnVnXG4gICAgICAgICogIGl0LCBpdCBjYW4gZHJpdmUgeW91IGNyYXp5IDotUFxuICAgICAgICAqICAqL1xuICAgICAgICAvKiBAZWNobyBDUkFaWUZZICovXG4gICAgLyogQGVuZGlmICovXG5cbiAgICB0aGlzLnVuaXF1ZUlkID0gdGhpcy4kZ2MuZGF0YSgndW5pcXVlLWlkJyk7XG4gICAgdGhpcy51cmwgPSB0aGlzLiRnYy5kYXRhKCd1cmwnKTtcblxuICAgIHRoaXMuc2VuZEdldFJlcXVlc3Qoe1xuICAgICAgICB1cmw6IHRoaXMuJGdjLmRhdGEoJ3VybCcpLFxuICAgICAgICBkYXRhVG9TZW5kOiB7XG4gICAgICAgICAgICBhY3Rpb246IENvbnN0YW50cy5BQ1RJT05fSU5JVF9EQVRBXG4gICAgICAgIH0sXG4gICAgICAgIHN1Y2Nlc3NDYWxsYmFjazogZnVuY3Rpb24gc3VjY2Vzc0NhbGxiYWNrKGpzb25SZXNwb25zZSkge1xuXG4gICAgICAgICAgICB0aGlzLnNldEluaXRWYXJpYWJsZXMoanNvblJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkSW5pdGlhbERhdGEgPSBqc29uUmVzcG9uc2U7XG5cbiAgICAgICAgICAgIHRoaXMuaW5pdEZhY2FkZSgpO1xuICAgICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcbn07XG5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5keW5hbWljVHJhbnNsYXRpb24gPSBmdW5jdGlvbiBkeW5hbWljVHJhbnNsYXRpb24oaTE4blN0cmluZ3MpIHtcbiAgICB2YXIgcGFnaW5nU3ViU3RyaW5nO1xuXG4gICAgaTE4blN0cmluZ3MuY29uZmlybV9kZWxldGVfbXVsdGlwbGUgPSBpMThuLmZvcm1hdChpMThuU3RyaW5ncy5jb25maXJtX2RlbGV0ZV9tdWx0aXBsZSwge1xuICAgICAgICBpdGVtc19hbW91bnQ6ICc8c3BhbiBjbGFzcz1cImdjLWRlbGV0ZS1jb3VudFwiPjwvc3Bhbj4nXG4gICAgfSk7XG5cbiAgICBpMThuU3RyaW5ncy5wYWdpbmdfZGlzcGxheWluZyA9IGkxOG4uZm9ybWF0KGkxOG5TdHJpbmdzLnBhZ2luZ19kaXNwbGF5aW5nLCB7XG4gICAgICAgIHN0YXJ0OiAnPHNwYW4gY2xhc3M9XCJwYWdpbmctc3RhcnRzXCI+MTwvc3Bhbj4nLFxuICAgICAgICBlbmQ6ICc8c3BhbiBjbGFzcz1cInBhZ2luZy1lbmRzXCI+MTA8L3NwYW4+JyxcbiAgICAgICAgcmVzdWx0czogJzxzcGFuIGNsYXNzPVwiY3VycmVudC10b3RhbC1yZXN1bHRzXCI+PC9zcGFuPidcbiAgICB9KTtcblxuICAgIHBhZ2luZ1N1YlN0cmluZyA9IGkxOG5TdHJpbmdzLnBhZ2luZ19zaG93X2VudHJpZXMubWF0Y2goLyguKikrXFx7cGFnaW5nXFx9KC4qKSsvKTtcbiAgICBpMThuU3RyaW5ncy5wYWdpbmdfc2hvd19lbnRyaWVzID0ge1xuICAgICAgICBmaXJzdDogcGFnaW5nU3ViU3RyaW5nICE9PSBudWxsID8gcGFnaW5nU3ViU3RyaW5nWzFdIDogJycsXG4gICAgICAgIHNlY29uZDogcGFnaW5nU3ViU3RyaW5nICE9PSBudWxsID8gcGFnaW5nU3ViU3RyaW5nWzJdIDogJydcbiAgICB9O1xuXG4gICAgaTE4blN0cmluZ3MucGFnaW5nX2ZpbHRlcmVkX2Zyb20gPSBpMThuLmZvcm1hdChpMThuU3RyaW5ncy5wYWdpbmdfZmlsdGVyZWRfZnJvbSwge1xuICAgICAgICB0b3RhbF9yZXN1bHRzOiAnPHNwYW4gY2xhc3M9XCJmdWxsLXRvdGFsXCI+PC9zcGFuPidcbiAgICB9KTtcbn07XG5cbi8vIEdDLTE5NTogQXV0b21hdGljYWxseSByZW5kZXIgdGhlIHN1Ym1lbnUgdG8gdGhlIGxlZnQgaWYgdGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZS5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5zdWJNZW51T3ZlcmZsb3dDaGVjayA9IGZ1bmN0aW9uIHN1Yk1lbnVPdmVyZmxvd0NoZWNrKCkge1xuICAgIHZhciBzZXR0aW5nc0J1dHRvbk9mZnNldCA9IHRoaXMuJGdjLmZpbmQoJy5nYy1zZXR0aW5ncy1idXR0b24nKS5vZmZzZXQoKTtcbiAgICBpZiAoc2V0dGluZ3NCdXR0b25PZmZzZXQgJiYgKHNldHRpbmdzQnV0dG9uT2Zmc2V0LmxlZnQgKyAxNjAgKyAxODApID4gJCh3aW5kb3cpLndpZHRoKCkpIHtcbiAgICAgICAgdGhpcy4kZ2NcbiAgICAgICAgICAgIC5maW5kKCcuZ2Mtc2V0dGluZ3MtYnV0dG9uJylcbiAgICAgICAgICAgIC5uZXh0KClcbiAgICAgICAgICAgIC5maW5kKCcuZHJvcGRvd24tc3VibWVudScpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2xlZnQtZGlyZWN0aW9uJyk7XG4gICAgfVxufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLmRhdGFncmlkSW5pdCA9IGZ1bmN0aW9uIGRhdGFncmlkSW5pdCgpIHtcbiAgICB2YXIgaTE4blN0cmluZ3MgPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmkxOG4sXG4gICAgICAgIGluaXREYXRhID0gdGhpcy5jYWNoZWRJbml0aWFsRGF0YTtcblxuICAgIHRoaXMuZHluYW1pY1RyYW5zbGF0aW9uKGkxOG5TdHJpbmdzKTtcblxuICAgIHRoaXMuc3RyaW5nVmFyaWFibGVzLmlzQm9vdHN0cmFwVjQgPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNvbmZpZy5za2luID09PSAnYm9vdHN0cmFwLXY0JztcbiAgICB0aGlzLnN0cmluZ1ZhcmlhYmxlcy5hZGRVcmwgPSAnIy8nICsgdGhpcy5oYXNoRXZlbnQuYWRkSXRlbTtcbiAgICB0aGlzLnN0cmluZ1ZhcmlhYmxlcy5vcGVyYXRpb25BZGRFbmFibGVkID0gaW5pdERhdGEub3BlcmF0aW9ucy5hZGQ7XG4gICAgdGhpcy5zdHJpbmdWYXJpYWJsZXMub3BlcmF0aW9uRXhwb3J0RW5hYmxlZCA9IGluaXREYXRhLm9wZXJhdGlvbnMuZXhwb3J0RGF0YTtcbiAgICB0aGlzLnN0cmluZ1ZhcmlhYmxlcy5vcGVyYXRpb25QcmludEVuYWJsZWQgPSBpbml0RGF0YS5vcGVyYXRpb25zLnByaW50O1xuXG4gICAgdGhpcy4kZ2NcbiAgICAgICAgLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX1NFQVJDSF9ST1cpXG4gICAgICAgIC5hcHBlbmQoXG4gICAgICAgICAgdGhpcy5oYW5kbGViYXJzVGVtcGxhdGUoJy5nYy1oZWFkZXItYWN0aW9ucy1vcGVyYXRpb25zJywge1xuICAgICAgICAgICAgICBpc0Jvb3RzdHJhcFY0OiB0aGlzLnN0cmluZ1ZhcmlhYmxlcy5pc0Jvb3RzdHJhcFY0LFxuICAgICAgICAgICAgICBkZWxldGVNdWx0aXBsZTogaW5pdERhdGEub3BlcmF0aW9ucy5kZWxldGVNdWx0aXBsZSxcbiAgICAgICAgICAgICAgaGFzQWN0aW9uQnV0dG9uczogdGhpcy5kYXRhZ3JpZEhhc0FjdGlvbnMuYXBwbHkodGhpcyksXG4gICAgICAgICAgICAgIGkxOG46IGkxOG5TdHJpbmdzXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgIHRoaXMuJGdjXG4gICAgICAgIC5maW5kKCcuZm9vdGVyLXRvb2xzJylcbiAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlYmFyc1RlbXBsYXRlKCcuZ2MtZm9vdGVyLXRlbXBsYXRlJywge1xuICAgICAgICAgICAgICAgIGkxOG46IGkxOG5TdHJpbmdzLFxuICAgICAgICAgICAgICAgIGlzQm9vdHN0cmFwVjQ6IHRoaXMuc3RyaW5nVmFyaWFibGVzLmlzQm9vdHN0cmFwVjRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICB0aGlzLiRnY1xuICAgICAgICAuZmluZChDb25zdGFudHMuU0VMRUNUT1JfREFUQUdSSURfQ09OVEFJTkVSKVxuICAgICAgICAucHJlcGVuZChcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlYmFyc1RlbXBsYXRlKENvbnN0YW50cy5IQU5ETEVCQVJTX1RFTVBMQVRFX0NBUFRJT05fVElUTEUsIHtcbiAgICAgICAgICAgICAgICBzdWJqZWN0OiB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLnN1YmplY3Quc3ViamVjdF9zaW5nbGUsXG4gICAgICAgICAgICAgICAgc3ViamVjdFBsdXJhbDogdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5zdWJqZWN0LnN1YmplY3RfcGx1cmFsXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgdGhpcy4kZ2NcbiAgICAgICAgLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX0hFQURFUl9UT09MUylcbiAgICAgICAgLnByZXBlbmQoXG4gICAgICAgICAgICB0aGlzLmhhbmRsZWJhcnNUZW1wbGF0ZShDb25zdGFudHMuSEFORExFQkFSU19BRERfQlVUVE9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uQWRkRW5hYmxlZDogdGhpcy5zdHJpbmdWYXJpYWJsZXMub3BlcmF0aW9uQWRkRW5hYmxlZCxcbiAgICAgICAgICAgICAgICBhZGRVcmw6IHRoaXMuc3RyaW5nVmFyaWFibGVzLmFkZFVybCxcbiAgICAgICAgICAgICAgICBhZGRJdGVtU3RyaW5nOiBpMThuLmZvcm1hdChpMThuU3RyaW5ncy5hZGRfaXRlbSwge1xuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0OiB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLnN1YmplY3Quc3ViamVjdF9zaW5nbGVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1leHBvcnQtYnV0dG9uLWNvbnRhaW5lcicpLmh0bWwoXG4gICAgICAgIHRoaXMuaGFuZGxlYmFyc1RlbXBsYXRlKENvbnN0YW50cy5IQU5ETEVCQVJTX0VYUE9SVF9CVVRUT04sIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbkV4cG9ydEVuYWJsZWQ6IHRoaXMuc3RyaW5nVmFyaWFibGVzLm9wZXJhdGlvbkV4cG9ydEVuYWJsZWQsXG4gICAgICAgICAgICBpMThuOiBpMThuU3RyaW5nc1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLiRnYy5maW5kKCcuZ2MtcHJpbnQtYnV0dG9uLWNvbnRhaW5lcicpLmh0bWwoXG4gICAgICAgIHRoaXMuaGFuZGxlYmFyc1RlbXBsYXRlKENvbnN0YW50cy5IQU5ETEVCQVJTX1BSSU5UX0JVVFRPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uUHJpbnRFbmFibGVkOiB0aGlzLnN0cmluZ1ZhcmlhYmxlcy5vcGVyYXRpb25QcmludEVuYWJsZWQsXG4gICAgICAgICAgICBpMThuOiBpMThuU3RyaW5nc1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLiRnYy5maW5kKCcuZ2Mtc2VhcmNoLWZpbHRlci1idXR0b24tY29udGFpbmVyJykuaHRtbChcbiAgICAgICAgdGhpcy5oYW5kbGViYXJzVGVtcGxhdGUoJy5zZWFyY2gtYnV0dG9uLXRlbXBsYXRlJywge1xuICAgICAgICAgICAgaTE4bjogaTE4blN0cmluZ3MsXG4gICAgICAgICAgICBzZWFyY2hBbGxCdXR0b246IHRoaXMuc2V0dGluZ3MuZGF0YWdyaWRTZWFyY2hBbGxJbnB1dFxuICAgICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLnN1Yk1lbnVPdmVyZmxvd0NoZWNrLmFwcGx5KHRoaXMpO1xuXG4gICAgdGhpcy4kZ2NcbiAgICAgICAgLnByZXBlbmQoXG4gICAgICAgICAgICB0aGlzLmhhbmRsZWJhcnNUZW1wbGF0ZShDb25zdGFudHMuSEFORExFQkFSU19JTlNFUlRfTU9EQUwsIHtcbiAgICAgICAgICAgICAgICBpMThuOiBpMThuU3RyaW5nc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgIHRoaXMuJGdjLnByZXBlbmQoXG4gICAgICAgIHRoaXMuaGFuZGxlYmFyc1RlbXBsYXRlKENvbnN0YW50cy5IQU5ETEVCQVJTX0RFTEVURV9TSU5HTEVfTU9EQUwsIHtcbiAgICAgICAgICAgIGkxOG46IGkxOG5TdHJpbmdzXG4gICAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuJGdjLnByZXBlbmQoXG4gICAgICAgIHRoaXMuaGFuZGxlYmFyc1RlbXBsYXRlKENvbnN0YW50cy5IQU5ETEVCQVJTX0RFTEVURV9NVVRMSVBMRV9NT0RBTCwge1xuICAgICAgICAgICAgaTE4bjogaTE4blN0cmluZ3NcbiAgICAgICAgfSlcbiAgICApO1xuXG4gICAgdGhpcy4kZ2MuZmluZCgnLnBhZ2luZy1lbnRyaWVzLWNvbnRhaW5lcicpLnByZXBlbmQoXG4gICAgICAgIHRoaXMuaGFuZGxlYmFyc1RlbXBsYXRlKCcucGFnaW5nLWVudHJpZXMtdGVtcGxhdGUnLCB7XG4gICAgICAgICAgICBpMThuOiBpMThuU3RyaW5nc1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgICAvLyBBZnRlciB0aGUgcGFnaW5nIGlzIHJlbmRlcmVkIHdlIHdpbGwgYWxzbyBuZWVkIHRvIGFkZCB0aGUgcGFnaW5nQ29tcG9uZW50XG4gICAgUmVhY3RET00ucmVuZGVyKDxQZXJQYWdlRHJvcGRvd24gZGVmYXVsdFBlclBhZ2U9e2luaXREYXRhLnBhZ2luZy5kZWZhdWx0UGVyUGFnZX0gcGFnaW5nT3B0aW9ucz17aW5pdERhdGEucGFnaW5nLnBhZ2luZ09wdGlvbnN9IC8+LCB0aGlzLiRnYy5maW5kKCcucGVyLXBhZ2UtY29udGFpbmVyJylbMF0pO1xuXG4gICAgdGhpcy4kZ2MuZmluZCgnLmRpc3BsYXlpbmctcGFnaW5nLWNvbnRhaW5lcicpLnByZXBlbmQoXG4gICAgICAgIHRoaXMuaGFuZGxlYmFyc1RlbXBsYXRlKCcuZGlzcGxheWluZy1wYWdpbmctdGVtcGxhdGUnLCB7XG4gICAgICAgICAgICBpMThuOiBpMThuU3RyaW5nc1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgICBSZWFjdERPTS5yZW5kZXIoXG4gICAgICAgIDxNb2RhbFRpdGxlXG4gICAgICAgICAgICBNb2RhbFRpdGxlV3JhcHBlcj17dGhpcy5jb21wb25lbnRzLk1vZGFsVGl0bGVXcmFwcGVyfVxuICAgICAgICAgICAgdGl0bGU9e2kxOG5TdHJpbmdzLmVycm9yX2dlbmVyaWNfdGl0bGV9XG4gICAgICAgIC8+LFxuICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZXJyb3ItbW9kYWwnKVxuICAgICAgICAgICAgLmZpbmQoJy5tb2RhbC1oZWFkZXInKVswXSk7XG5cbiAgICBSZWFjdERPTS5yZW5kZXIoXG4gICAgICAgIDxNb2RhbFRpdGxlXG4gICAgICAgICAgICBNb2RhbFRpdGxlV3JhcHBlcj17dGhpcy5jb21wb25lbnRzLk1vZGFsVGl0bGVXcmFwcGVyfVxuICAgICAgICAgICAgdGl0bGU9e2kxOG5TdHJpbmdzLmFjdGlvbl9kZWxldGV9XG4gICAgICAgIC8+LFxuICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgLmZpbmQoJy5kZWxldGUtc2luZ2xlLWNvbmZpcm1hdGlvbicpXG4gICAgICAgICAgICAuZmluZCgnLm1vZGFsLWhlYWRlcicpWzBdKTtcblxuICAgIFJlYWN0RE9NLnJlbmRlcihcbiAgICAgICAgPE1vZGFsVGl0bGVcbiAgICAgICAgICAgIE1vZGFsVGl0bGVXcmFwcGVyPXt0aGlzLmNvbXBvbmVudHMuTW9kYWxUaXRsZVdyYXBwZXJ9XG4gICAgICAgICAgICB0aXRsZT17aTE4blN0cmluZ3MuYWN0aW9uX2RlbGV0ZX1cbiAgICAgICAgLz4sXG4gICAgICAgIHRoaXMuJGdjXG4gICAgICAgICAgICAuZmluZCgnLmdjLWRlbGV0ZS1tdWx0aXBsZS1jb25maXJtYXRpb24nKVxuICAgICAgICAgICAgLmZpbmQoJy5tb2RhbC1oZWFkZXInKVswXSk7XG5cbiAgICBpMThuLmluaXQoaTE4blN0cmluZ3MpO1xuXG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuZ2V0RmllbGRzRm9yRmlsdGVyaW5nID0gZnVuY3Rpb24gZ2V0RmllbGRzRm9yRmlsdGVyaW5nKCkge1xuICAgIGxldCBmaWVsZHMgPSBbXSxcbiAgICAgICAgaW5kZXhlZENvbHVtbnMgPSB7fTtcbiAgICBjb25zdCB7IGZpZWxkVHlwZXNDb2x1bW5zLCBjb2x1bW5zIH0gPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhO1xuXG4gICAgY29sdW1ucy5mb3JFYWNoKChjb2x1bW4pID0+IHtcbiAgICAgICAgaW5kZXhlZENvbHVtbnNbY29sdW1uLm5hbWVdID0gY29sdW1uLmRpc3BsYXlBcztcbiAgICB9KTtcblxuICAgIE9iamVjdC5rZXlzKGZpZWxkVHlwZXNDb2x1bW5zKS5mb3JFYWNoKGZ1bmN0aW9uIGZvckVhY2hGaWVsZFR5cGVzQ29sdW1ucyhmaWVsZE5hbWUpIHtcbiAgICAgICAgaWYgKGluZGV4ZWRDb2x1bW5zW2ZpZWxkTmFtZV0pIHtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWU6IGZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBmaWVsZFR5cGVzQ29sdW1uc1tmaWVsZE5hbWVdLmRhdGFUeXBlLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlBczogaW5kZXhlZENvbHVtbnNbZmllbGROYW1lXSxcbiAgICAgICAgICAgICAgICBwZXJtaXR0ZWRWYWx1ZXM6IGZpZWxkVHlwZXNDb2x1bW5zW2ZpZWxkTmFtZV0ucGVybWl0dGVkVmFsdWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZpZWxkcztcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybnMge2pRdWVyeX1cbiAqL1xuR3JvY2VyeUNydWQucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiBmaW5kKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuJGdjLmZpbmQoc2VsZWN0b3IpO1xufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLnNldEluaXRWYXJpYWJsZXMgPSBmdW5jdGlvbiBzZXRJbml0VmFyaWFibGVzKGRhdGEpIHtcbiAgICB0aGlzLmNvbHVtbnMgPSBbXTtcblxuICAgIF8uZWFjaChkYXRhLmNvbHVtbnMsIGZ1bmN0aW9uIGZvcmVhY2hDb2x1bW5zKGNvbHVtbikge1xuICAgICAgICB0aGlzLmNvbHVtbnMucHVzaCh7XG4gICAgICAgICAgICBjb2x1bW5OYW1lOiBjb2x1bW4ubmFtZSxcbiAgICAgICAgICAgIGRpc3BsYXlBczogY29sdW1uLmRpc3BsYXlBc1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmluZGV4ZWRDb2x1bW5zW2NvbHVtbi5uYW1lXSA9IGNvbHVtbi5kaXNwbGF5QXM7XG4gICAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5zZW5kR2V0UmVxdWVzdCA9IGZ1bmN0aW9uIHNlbmRHZXRSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnVybCA9ICFfLmlzVW5kZWZpbmVkKG9wdGlvbnMudXJsKSA/IG9wdGlvbnMudXJsIDogdGhpcy4kZ2MuZGF0YSgndXJsJyk7XG5cbiAgICByZXR1cm4gYWpheEhlbHBlci5zZW5kR2V0UmVxdWVzdC5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLnNlbmRQb3N0UmVxdWVzdCA9IGZ1bmN0aW9uIHNlbmRQb3N0UmVxdWVzdChvcHRpb25zKSB7XG4gICAgb3B0aW9ucy51cmwgPSAhXy5pc1VuZGVmaW5lZChvcHRpb25zLnVybCkgPyBvcHRpb25zLnVybCA6IHRoaXMuJGdjLmRhdGEoJ3VybCcpO1xuXG4gICAgcmV0dXJuIGFqYXhIZWxwZXIuc2VuZFBvc3RSZXF1ZXN0LmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuaGFuZGxlYmFyc1RlbXBsYXRlID0gZnVuY3Rpb24gaGFuZGxlYmFyc1RlbXBsYXRlKHN0cmluZ1NlbGVjdG9yLCB0ZW1wbGF0ZU9iamVjdCkge1xuXG4gICAgdmFyIGhhbmRsZWJhcnNUZW1wbGF0ZUNvbXBpbGVkID0gSGFuZGxlYmFycy5jb21waWxlKFxuICAgICAgICB0aGlzLiRnYy5maW5kKHN0cmluZ1NlbGVjdG9yKS5odG1sKClcbiAgICApO1xuXG4gICAgcmV0dXJuIGhhbmRsZWJhcnNUZW1wbGF0ZUNvbXBpbGVkKHRlbXBsYXRlT2JqZWN0KTtcbn07XG5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5kYXRhZ3JpZEhhc0FjdGlvbnMgPSBmdW5jdGlvbiBkYXRhZ3JpZEhhc0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVkSW5pdGlhbERhdGEub3BlcmF0aW9ucy5kZWxldGVTaW5nbGUgfHxcbiAgICAgICAgdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5vcGVyYXRpb25zLmVkaXQgfHxcbiAgICAgICAgdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5vcGVyYXRpb25zLnJlYWQgfHxcbiAgICAgICAgdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5vcGVyYXRpb25zLmFjdGlvbkJ1dHRvbnMgfHxcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5hY3Rpb25CdXR0b25zLmxlbmd0aCA+IDA7XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuaW5pdGlhbGl6ZUZpZWxkVHlwZXNEYXRhID0gZnVuY3Rpb24gaW5pdGlhbGl6ZUZpZWxkVHlwZXNEYXRhKCkge1xuICAgIHZhciBmaWVsZFR5cGVzQWRkRm9ybSA9IHt9LFxuICAgICAgICBmaWVsZFR5cGVzRWRpdEZvcm0gPSB7fSxcbiAgICAgICAgZmllbGRUeXBlc0Nsb25lRm9ybSA9IHt9LFxuICAgICAgICBmaWVsZFR5cGVzUmVhZEZvcm0gPSB7fSxcbiAgICAgICAgZmllbGRUeXBlc0NvbHVtbnMgPSB7fTtcblxuICAgIF8uZWFjaCh0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmZpZWxkVHlwZXMsIGZ1bmN0aW9uIGZpZWxkVHlwZXNGb3JFYXJjaChmaWVsZFR5cGVPYmplY3QsIGZpZWxkTmFtZSkge1xuICAgICAgICBmaWVsZFR5cGVzQWRkRm9ybVtmaWVsZE5hbWVdID0gZmllbGRUeXBlT2JqZWN0O1xuICAgICAgICBmaWVsZFR5cGVzRWRpdEZvcm1bZmllbGROYW1lXSA9IGZpZWxkVHlwZU9iamVjdDtcbiAgICAgICAgZmllbGRUeXBlc0Nsb25lRm9ybVtmaWVsZE5hbWVdID0gZmllbGRUeXBlT2JqZWN0O1xuICAgICAgICBmaWVsZFR5cGVzUmVhZEZvcm1bZmllbGROYW1lXSA9IGZpZWxkVHlwZU9iamVjdDtcbiAgICAgICAgZmllbGRUeXBlc0NvbHVtbnNbZmllbGROYW1lXSA9IGZpZWxkVHlwZU9iamVjdDtcbiAgICB9KTtcblxuICAgIC8vIG92ZXJyaWRpbmcgdGhlIGZpZWxkIHR5cGVzXG4gICAgXy5lYWNoKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuZmllbGRUeXBlc0FkZEZvcm0sIGZ1bmN0aW9uIGZpZWxkVHlwZXNBZGRGb3JtRm9yRWFjaChmaWVsZFR5cGVPYmplY3QsIGZpZWxkTmFtZSkge1xuICAgICAgICBmaWVsZFR5cGVzQWRkRm9ybVtmaWVsZE5hbWVdID0gZmllbGRUeXBlT2JqZWN0O1xuICAgIH0pO1xuXG4gICAgXy5lYWNoKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuZmllbGRUeXBlc0VkaXRGb3JtLCBmdW5jdGlvbiBmaWVsZFR5cGVzRWRpdEZvcm1Gb3JFYWNoKGZpZWxkVHlwZU9iamVjdCwgZmllbGROYW1lKSB7XG4gICAgICAgIGZpZWxkVHlwZXNFZGl0Rm9ybVtmaWVsZE5hbWVdID0gZmllbGRUeXBlT2JqZWN0O1xuICAgIH0pO1xuXG4gICAgXy5lYWNoKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuZmllbGRUeXBlc0Nsb25lRm9ybSwgZnVuY3Rpb24gZmllbGRUeXBlc0Nsb25lRm9ybUZvckVhY2goZmllbGRUeXBlT2JqZWN0LCBmaWVsZE5hbWUpIHtcbiAgICAgICAgZmllbGRUeXBlc0Nsb25lRm9ybVtmaWVsZE5hbWVdID0gZmllbGRUeXBlT2JqZWN0O1xuICAgIH0pO1xuXG4gICAgXy5lYWNoKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuZmllbGRUeXBlc1JlYWRGb3JtLCBmdW5jdGlvbiBmaWVsZFR5cGVzUmVhZEZvcm1Gb3JFYWNoKGZpZWxkVHlwZU9iamVjdCwgZmllbGROYW1lKSB7XG4gICAgICAgIGZpZWxkVHlwZXNSZWFkRm9ybVtmaWVsZE5hbWVdID0gZmllbGRUeXBlT2JqZWN0O1xuICAgIH0pO1xuXG4gICAgXy5lYWNoKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuZmllbGRUeXBlc0NvbHVtbnMsIGZ1bmN0aW9uIGZpZWxkVHlwZXNDb2x1bW5zRm9yRWFjaChmaWVsZFR5cGVPYmplY3QsIGZpZWxkTmFtZSkge1xuICAgICAgICBmaWVsZFR5cGVzQ29sdW1uc1tmaWVsZE5hbWVdID0gZmllbGRUeXBlT2JqZWN0O1xuICAgIH0pO1xuXG4gICAgdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5maWVsZFR5cGVzQWRkRm9ybSA9IGZpZWxkVHlwZXNBZGRGb3JtO1xuICAgIHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuZmllbGRUeXBlc0VkaXRGb3JtID0gZmllbGRUeXBlc0VkaXRGb3JtO1xuICAgIHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuZmllbGRUeXBlc0Nsb25lRm9ybSA9IGZpZWxkVHlwZXNDbG9uZUZvcm07XG4gICAgdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5maWVsZFR5cGVzUmVhZEZvcm0gPSBmaWVsZFR5cGVzUmVhZEZvcm07XG4gICAgdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5maWVsZFR5cGVzQ29sdW1ucyA9IGZpZWxkVHlwZXNDb2x1bW5zO1xuXG4gICAgc3dpdGNoICh0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNvbmZpZy5kYXRlRm9ybWF0KSB7XG4gICAgICAgIGNhc2UgJ3VrLWRhdGUnOlxuICAgICAgICAgICAgdGhpcy5kYXRlRm9ybWF0ID0gJ2RkL21tL3l5JztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3VzLWRhdGUnOlxuICAgICAgICAgICAgdGhpcy5kYXRlRm9ybWF0ID0gJ21tL2RkL3l5JztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NxbC1kYXRlJzpcbiAgICAgICAgICAgIHRoaXMuZGF0ZUZvcm1hdCA9ICd5eS1tbS1kZCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG4vKipcbiAqIEhhdmluZyB0aGUgZmlyc3QgY2FsbCBpbnRvIHRoZSBiYWNrZW5kIGluIG9yZGVyIHRvIGZpbGwgb3VyIGRhdGFncmlkIHdpdGggc29tZSBkYXRhXG4gKi9cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5pbml0aWFsaXppbmdEYXRhID0gZnVuY3Rpb24gaW5pdGlhbGl6aW5nRGF0YSgpIHtcbiAgICB2YXIgZGF0YVRvU2VuZCA9IHt9LFxuICAgICAgICBjYWNoZWREYXRhLFxuICAgICAgICBjYWNoZWRQcmVmZXJlbmNlcyxcbiAgICAgICAgY29sdW1uX3RpdGxlLFxuICAgICAgICAkY29sdW1uVG9PcmRlcixcbiAgICAgICAgcmVhZE9ubHlBZGRGaWVsZHMgPSB7fSxcbiAgICAgICAgcmVhZE9ubHlFZGl0RmllbGRzID0ge30sXG4gICAgICAgIHJlYWRPbmx5Q2xvbmVGaWVsZHMgPSB7fTtcblxuICAgIEdyaWQuc2V0RXhwb3J0VXJsLmFwcGx5KHRoaXMpO1xuICAgIGRhdGFUb1NlbmQuYWN0aW9uID0gQ29uc3RhbnRzLkFDVElPTl9EQVRBR1JJRDtcblxuICAgIGlmICh0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbikge1xuICAgICAgICBkYXRhVG9TZW5kW3RoaXMuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuLmlucHV0TmFtZV0gPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbi5pbnB1dFZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMuaGFzQWN0aW9ucyA9IHRoaXMuZGF0YWdyaWRIYXNBY3Rpb25zLmFwcGx5KHRoaXMpO1xuXG4gICAgXy5lYWNoKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEucmVhZE9ubHlBZGRGaWVsZHMsIGZ1bmN0aW9uIHJlYWRPbmx5QWRkRmllbGRzRm9yRWFyY2goZmllbGQpIHtcbiAgICAgICAgcmVhZE9ubHlBZGRGaWVsZHNbZmllbGRdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLnJlYWRPbmx5QWRkRmllbGRzID0gcmVhZE9ubHlBZGRGaWVsZHM7XG5cbiAgICBfLmVhY2godGhpcy5jYWNoZWRJbml0aWFsRGF0YS5yZWFkT25seUNsb25lRmllbGRzLCBmdW5jdGlvbiByZWFkT25seUNsb25lRmllbGRzRm9yRWFyY2goZmllbGQpIHtcbiAgICAgICAgcmVhZE9ubHlDbG9uZUZpZWxkc1tmaWVsZF0gPSB0cnVlO1xuICAgIH0pO1xuICAgIHRoaXMuY2FjaGVkSW5pdGlhbERhdGEucmVhZE9ubHlDbG9uZUZpZWxkcyA9IHJlYWRPbmx5Q2xvbmVGaWVsZHM7XG5cbiAgICBfLmVhY2godGhpcy5jYWNoZWRJbml0aWFsRGF0YS5yZWFkT25seUVkaXRGaWVsZHMsIGZ1bmN0aW9uIHJlYWRPbmx5RWRpdEZpZWxkc0ZvckVhcmNoKGZpZWxkKSB7XG4gICAgICAgIHJlYWRPbmx5RWRpdEZpZWxkc1tmaWVsZF0gPSB0cnVlO1xuICAgIH0pO1xuICAgIHRoaXMuY2FjaGVkSW5pdGlhbERhdGEucmVhZE9ubHlFZGl0RmllbGRzID0gcmVhZE9ubHlFZGl0RmllbGRzO1xuXG4gICAgY2FjaGVkRGF0YSA9IGxvY2FsU3RvcmFnZUhlbHBlci5nZXRMb2NhbFN0b3JhZ2VJdGVtKCdnY3J1ZEluaXRpYWxEYXRhXycgKyB0aGlzLnVuaXF1ZUlkKTtcbiAgICBjYWNoZWRQcmVmZXJlbmNlcyA9IGxvY2FsU3RvcmFnZUhlbHBlci5nZXRMb2NhbFN0b3JhZ2VJdGVtKCdnY3J1ZFByZWZlcmVuY2VzJyk7XG5cbiAgICBpZiAoY2FjaGVkRGF0YSkge1xuICAgICAgICBjYWNoZWREYXRhID0gSlNPTi5wYXJzZShjYWNoZWREYXRhKTtcbiAgICAgICAgZGF0YVRvU2VuZC5vcmRlcl9ieSA9IGNhY2hlZERhdGEub3JkZXJfYnk7XG4gICAgICAgIGRhdGFUb1NlbmQuc29ydGluZyA9IGNhY2hlZERhdGEuc29ydGluZztcblxuICAgICAgICBpZiAoY2FjaGVkUHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIGNhY2hlZFByZWZlcmVuY2VzID0gSlNPTi5wYXJzZShjYWNoZWRQcmVmZXJlbmNlcyk7XG4gICAgICAgICAgICBkYXRhVG9TZW5kLnBlcl9wYWdlID0gY2FjaGVkUHJlZmVyZW5jZXMucGVyX3BhZ2U7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcucGVyX3BhZ2UnKS52YWwoZGF0YVRvU2VuZC5wZXJfcGFnZSk7XG4gICAgICAgIH1cblxuICAgICAgICAkY29sdW1uVG9PcmRlciA9IHRoaXMuJGdjLmZpbmQoJy5jb2x1bW4td2l0aC1vcmRlcmluZ1tkYXRhLW9yZGVyLWJ5PVwiJyArIGRhdGFUb1NlbmQub3JkZXJfYnkgKyAnXCJdJyk7XG4gICAgICAgIGNvbHVtbl90aXRsZSA9ICRjb2x1bW5Ub09yZGVyLmFkZENsYXNzKCdhY3RpdmUgdGFibGUtYWN0aXZlIG9yZGVyaW5nLScgKyBkYXRhVG9TZW5kLnNvcnRpbmcpLnRleHQoKTtcblxuICAgICAgICBpZiAoZGF0YVRvU2VuZC5vcmRlcl9ieSAmJiBkYXRhVG9TZW5kLnNvcnRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1vcmRlci1ieS1oaWRkZW4nKS52YWwoZGF0YVRvU2VuZC5vcmRlcl9ieSk7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2Mtc29ydGluZy1oaWRkZW4nKS52YWwoZGF0YVRvU2VuZC5zb3J0aW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbHVtbl90aXRsZSA9ICQudHJpbShjb2x1bW5fdGl0bGUpO1xuXG4gICAgICAgICRjb2x1bW5Ub09yZGVyLmh0bWwoJzxkaXY+JyArIGNvbHVtbl90aXRsZSArICc8L2Rpdj4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlbmRQb3N0UmVxdWVzdCh7XG4gICAgICAgIHVybDogdGhpcy4kZ2MuZGF0YSgndXJsJyksXG4gICAgICAgIGRhdGFUb1NlbmQ6IGRhdGFUb1NlbmQsXG4gICAgICAgIHN1Y2Nlc3NDYWxsYmFjazogZnVuY3Rpb24gc3VjY2Vzc0NhbGxiYWNrKGpzb25SZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIGNvbHVtbkluZGV4LFxuICAgICAgICAgICAgICAgIHBhZ2luZ0VuZHM7XG5cbiAgICAgICAgICAgIGlmIChqc29uUmVzcG9uc2UuY3NyZlRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5jc3JmVG9rZW4gPSBqc29uUmVzcG9uc2UuY3NyZlRva2VuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgICAgIC5maW5kKCcuY3VycmVudC10b3RhbC1yZXN1bHRzJylcbiAgICAgICAgICAgICAgICAuaHRtbChqc29uUmVzcG9uc2UuZmlsdGVyZWRfdG90YWwpO1xuICAgICAgICAgICAgdGhpcy4kZ2NcbiAgICAgICAgICAgICAgICAuZmluZCgnLmZ1bGwtdG90YWwnKVxuICAgICAgICAgICAgICAgIC5odG1sKGpzb25SZXNwb25zZS5maWx0ZXJlZF90b3RhbCk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURhdGFncmlkKGpzb25SZXNwb25zZSk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhVG9TZW5kLnNvcnRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4ID0gJGNvbHVtblRvT3JkZXIuaW5kZXgoKSArIDE7XG4gICAgICAgICAgICAgICAgJGNvbHVtblRvT3JkZXIuY2xvc2VzdCgnLmdyb2NlcnktY3J1ZC10YWJsZScpXG4gICAgICAgICAgICAgICAgICAgIC5maW5kKCd0aGVhZCB0ciB0ZDpudGgtY2hpbGQoJyArIGNvbHVtbkluZGV4ICsgJyknKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2FjdGl2ZSB0YWJsZS1hY3RpdmUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGpzb25SZXNwb25zZS5jc3JmVG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbiA9IGpzb25SZXNwb25zZS5jc3JmVG9rZW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhZ2luZ0VuZHMgPSBkYXRhVG9TZW5kLnBlcl9wYWdlID4ganNvblJlc3BvbnNlLmZpbHRlcmVkX3RvdGFsXG4gICAgICAgICAgICAgICAgPyBqc29uUmVzcG9uc2UuZmlsdGVyZWRfdG90YWxcbiAgICAgICAgICAgICAgICA6IGRhdGFUb1NlbmQucGVyX3BhZ2U7XG5cbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5wYWdpbmctZW5kcycpLmh0bWwocGFnaW5nRW5kcyk7XG4gICAgICAgICAgICBEYXRhZ3JpZFBhZ2luZy5wYWdpbmdDYWxjdWxhdGlvbnMuYXBwbHkodGhpcyk7XG4gICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgZXJyb3JDYWxsYmFjazogZnVuY3Rpb24gZGF0YWdyaWRFcnJvckNhbGxiYWNrKCkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlSGVscGVyLnJlbW92ZUxvY2FsU3RvcmFnZUl0ZW0oJ2djcnVkSW5pdGlhbERhdGFfJyArIHRoaXMudW5pcXVlSWQpO1xuICAgICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcbn07XG5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS50cmFuc2Zvcm1Sb3dzRGF0YSA9IGZ1bmN0aW9uIHRyYW5zZm9ybVJvd3NEYXRhKHJlc3VsdCkge1xuICAgIGxldCByb3dzID0gW107XG5cbiAgICBfLmVhY2gocmVzdWx0LmRhdGEsIGZ1bmN0aW9uIGVhY2hEYXRhKGRhdGFPYmplY3QpIHtcbiAgICAgICAgcm93cy5wdXNoKENvbHVtbi5nZXRSb3dzRGF0YS5hcHBseSh0aGlzLCBbZGF0YU9iamVjdF0pKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgcmV0dXJuIHJvd3M7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdGJvZHkgZnJvbSB0aGUgcmVzcG9uc2Ugd2l0aCBIYW5kbGVCYXJzIHRlbXBsYXRlXG4gKiAqL1xuR3JvY2VyeUNydWQucHJvdG90eXBlLmdldFRhYmxlQm9keUZyb21SZXNwb25zZSA9IGZ1bmN0aW9uIGdldFRhYmxlQm9keUZyb21SZXNwb25zZShyZXN1bHQpIHtcbiAgICBjb25zdFxuICAgICAgICByb3dfaHRtbCA9IHRoaXMuJGdjLmZpbmQoQ29uc3RhbnRzLkhBTkRMRUJBUlNfVEVNUExBVEVfUk9XKS5odG1sKCksXG4gICAgICAgIHJvd190ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShyb3dfaHRtbCksXG4gICAgICAgIHJvd3MgPSB0aGlzLnRyYW5zZm9ybVJvd3NEYXRhKHJlc3VsdCk7XG5cbiAgICByZXR1cm4gcm93X3RlbXBsYXRlKHsgcm93cyB9KTtcbn07XG5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5vbkVkaXRDbGljayA9IGZ1bmN0aW9uIG9uRWRpdENsaWNrKHByaW1hcnlLZXlWYWx1ZSkge1xuICAgIE9wZXJhdGlvbkVkaXQub25FZGl0Q2xpY2suYXBwbHkodGhpcywgW3ByaW1hcnlLZXlWYWx1ZV0pO1xufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLm9uQ2xvbmVDbGljayA9IGZ1bmN0aW9uIG9uQ2xvbmVDbGljayhwcmltYXJ5S2V5VmFsdWUpIHtcbiAgICBPcGVyYXRpb25DbG9uZS5vbkNsb25lQ2xpY2suYXBwbHkodGhpcywgW3ByaW1hcnlLZXlWYWx1ZV0pO1xufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLm9uUmVhZENsaWNrID0gZnVuY3Rpb24gb25SZWFkQ2xpY2socHJpbWFyeUtleVZhbHVlKSB7XG4gICAgT3BlcmF0aW9uUmVhZC5vblJlYWRDbGljay5hcHBseSh0aGlzLCBbcHJpbWFyeUtleVZhbHVlXSk7XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUub25EZWxldGVDbGljayA9IGZ1bmN0aW9uIG9uRGVsZXRlQ2xpY2socHJpbWFyeUtleVZhbHVlKSB7XG4gICAgT3BlcmF0aW9uRGVsZXRlLm9uRGVsZXRlQ2xpY2suYXBwbHkodGhpcywgW3ByaW1hcnlLZXlWYWx1ZV0pO1xufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLmNyZWF0ZURhdGFncmlkID0gZnVuY3Rpb24gY3JlYXRlRGF0YWdyaWQoZGF0YSkge1xuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5qc29uRGF0YSA9IGRhdGE7XG4gICAgfVxuXG4gICAgdGhpcy5yb3dzRGF0YSA9IHRoaXMudHJhbnNmb3JtUm93c0RhdGEodGhpcy5qc29uRGF0YSk7XG5cbiAgICB0aGlzLnJlbmRlckRhdGFncmlkQm9keS5hcHBseSh0aGlzLCBbdGhpcy5yb3dzRGF0YV0pO1xuXG4gICAgLyp0aGlzLmxpc3RlbmVyQWN0aW9uS2V5cygpO1xuICAgIE9wZXJhdGlvbkRlbGV0ZS5saXN0ZW5lclNlbGVjdFJvdy5hcHBseSh0aGlzKTtcbiAgICBHcmlkLmFjdGl2YXRlT3JkZXJpbmdSb3dzLmFwcGx5KHRoaXMpOyovXG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuZ2V0U2NyZWVuV2lkdGggPSBmdW5jdGlvbiBnZXRTY3JlZW5XaWR0aCgpIHtcbiAgICBpZiAod2luZG93ICYmIHdpbmRvdy5tYXRjaE1lZGlhKSB7XG5cbiAgICAgICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKCcobWF4LXdpZHRoOiA1NzZweCknKS5tYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3hzJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYSgnKG1heC13aWR0aDogNzY4cHgpJykubWF0Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuICdzJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnbCc7XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUucmVuZGVyRGF0YWdyaWRCb2R5ID0gZnVuY3Rpb24gcmVuZGVyRGF0YWdyaWRCb2R5KHJvd3MpIHtcbiAgICBjb25zdCB7IG9wZXJhdGlvbnM6IHsgZWRpdCwgcmVhZCwgZGVsZXRlU2luZ2xlLCBkZWxldGVNdWx0aXBsZSwgY2xvbmUgfSB9ID0gdGhpcy5jYWNoZWRJbml0aWFsRGF0YSxcbiAgICAgICAgeyBHcm91cFByaW1hcnlCdXR0b24sIEdyb3VwQnV0dG9uc0xpc3QsIExpbmtCdXR0b25XcmFwcGVyIH0gPSB0aGlzLmNvbXBvbmVudHM7XG5cbiAgICBSZWFjdERPTS5yZW5kZXIoXG4gICAgICAgIDxEYXRhZ3JpZFRib2R5XG4gICAgICAgICAgICByb3dzPXtyb3dzfVxuICAgICAgICAgICAgb3B0aW9ucz17e1xuICAgICAgICAgICAgICAgIGRlbGV0ZU11bHRpcGxlOiBkZWxldGVNdWx0aXBsZSxcbiAgICAgICAgICAgICAgICBoYXNFZGl0OiBlZGl0LFxuICAgICAgICAgICAgICAgIGhhc0Nsb25lOiBjbG9uZSxcbiAgICAgICAgICAgICAgICBoYXNEZWxldGU6IGRlbGV0ZVNpbmdsZSxcbiAgICAgICAgICAgICAgICBoYXNSZWFkOiByZWFkLFxuICAgICAgICAgICAgICAgIGhhc0FjdGlvbkJ1dHRvbnM6IHRoaXMuaGFzQWN0aW9uc1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIHVybFVuaXF1ZUhhc2g9e3RoaXMuaGFzaEV2ZW50LnVybFVuaXF1ZUhhc2h9XG4gICAgICAgICAgICBvcmRlckJ5PXtHcmlkLmdldE9yZGVyQnkuYXBwbHkodGhpcyl9XG4gICAgICAgICAgICBjb2x1bW5zPXt0aGlzLmNvbHVtbnN9XG4gICAgICAgICAgICBvbkVkaXRDbGljaz17dGhpcy5vbkVkaXRDbGljay5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgb25DbG9uZUNsaWNrPXt0aGlzLm9uQ2xvbmVDbGljay5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgb25Sb3dDaGVja2JveENsaWNrPXt0aGlzLmhpZGVTaG93RGVsZXRlQnV0dG9uLmJpbmQodGhpcyl9XG4gICAgICAgICAgICBvblJlYWRDbGljaz17dGhpcy5vblJlYWRDbGljay5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgb25EZWxldGVDbGljaz17dGhpcy5vbkRlbGV0ZUNsaWNrLmJpbmQodGhpcyl9XG4gICAgICAgICAgICBhY3Rpb25CdXR0b25zPXt0aGlzLnNldHRpbmdzLmFjdGlvbkJ1dHRvbnN9XG4gICAgICAgICAgICBzY3JlZW5TaXplPXt0aGlzLmdldFNjcmVlbldpZHRoKCl9XG4gICAgICAgICAgICBpMThuPXt0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmkxOG59XG4gICAgICAgICAgICBMaW5rQnV0dG9uV3JhcHBlcj17TGlua0J1dHRvbldyYXBwZXJ9XG4gICAgICAgICAgICBHcm91cFByaW1hcnlCdXR0b249e0dyb3VwUHJpbWFyeUJ1dHRvbn1cbiAgICAgICAgICAgIEdyb3VwQnV0dG9uc0xpc3Q9e0dyb3VwQnV0dG9uc0xpc3R9XG4gICAgICAgIC8+LCB0aGlzLiRnYy5maW5kKCcuZ2MtdGJvZHknKVswXSk7XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUubGlzdGVuZXJBY3Rpb25LZXlzID0gZnVuY3Rpb24gbGlzdGVuZXJBY3Rpb25LZXlzKCkge1xuICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1hY3Rpb24nKS5jbGljayhmdW5jdGlvbiBjbGlja0FjdGlvbkJ1dHRvbihldmVudCkge1xuICAgICAgICB2YXIgJGN1cnJlbnRCdXR0b24gPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLFxuICAgICAgICAgICAgcHJpbWFyeUtleVZhbHVlID0gJGN1cnJlbnRCdXR0b24uZGF0YSgncHJpbWFyeS1rZXktdmFsdWUnKSxcbiAgICAgICAgICAgIGFjdGlvbkJ1dHRvbktleSA9ICRjdXJyZW50QnV0dG9uLmRhdGEoJ2FjdGlvbi1rZXknKTtcblxuICAgICAgICAvKiBhY3Rpb25CdXR0b25zIERhdGEgaXMgbG9va2luZyBsaWtlIHRoaXNcbiAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgaWNvbkNzc0NsYXNzOiAnZmEgZmEtc21pbGUtbycsXG4gICAgICAgICAgICAgbGFiZWw6ICdTbWlsZXknLFxuICAgICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIHNtaWxleUNhbGxiYWNrKCkge31cbiAgICAgICAgICAgICB9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldHRpbmdzLmFjdGlvbkJ1dHRvbnNbYWN0aW9uQnV0dG9uS2V5XVxuICAgICAgICAgIC5hY3Rpb25DYWxsYmFjay5hcHBseSh0aGlzLCBbJGN1cnJlbnRCdXR0b24sIHByaW1hcnlLZXlWYWx1ZSwgdGhpc10pO1xuXG4gICAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5jbGVhckZpbHRlcmluZ0NhY2hlID0gZnVuY3Rpb24gY2xlYXJGaWx0ZXJpbmdDYWNoZSgpIHtcbiAgICB2YXIgJHNlYXJjaEFsbElucHV0ID0gdGhpcy4kZ2MuZmluZCgnLnNlYXJjaC1idXR0b24gPiBpbnB1dC5nYy1zZWFyY2gtaW5wdXQnKTtcblxuICAgIHRoaXMuJGdjLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX0hJRERFTl9QQUdFX05VTUJFUikudmFsKCcxJyk7XG4gICAgdGhpcy4kZ2MuZmluZChDb25zdGFudHMuU0VMRUNUT1JfUEFHRV9OVU1CRVJfSU5QVVQpLnZhbCgnMScpO1xuICAgIHRoaXMuJGdjLmZpbmQoJy5ncm9jZXJ5LWNydWQtdGFibGUgdHI6Zmlyc3QnKS5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9BQ1RJVkUpXG4gICAgICAgIC5yZW1vdmVDbGFzcygnYWN0aXZlIHRhYmxlLWFjdGl2ZSBvcmRlcmluZy1kZXNjIG9yZGVyaW5nLWFzYycpO1xuICAgIHRoaXMuJGdjLmZpbmQoJ3RoZWFkJykuZmluZCgndGQuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZSB0YWJsZS1hY3RpdmUnKTtcbiAgICB0aGlzLiRnYy5maW5kKCd0aGVhZCAudmFsdWUtbm90LWVtcHR5JykucmVtb3ZlQ2xhc3MoJ3ZhbHVlLW5vdC1lbXB0eScpLnZhbCgnJyk7XG5cbiAgICBpZiAoJHNlYXJjaEFsbElucHV0LnZhbCgpICE9PSAnJykge1xuICAgICAgICAkc2VhcmNoQWxsSW5wdXQudmFsKCcnKS50cmlnZ2VyKCdibHVyJyk7XG4gICAgfVxuXG4gICAgR3JpZC5zZWFyY2hBbmRPcmRlcmluZ1RyaWdnZXIuYXBwbHkodGhpcyk7XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuYXBwZW5kU2VhcmNoQ2xlYXJCdXR0b25zID0gZnVuY3Rpb24gYXBwZW5kU2VhcmNoQ2xlYXJCdXR0b25zKCkge1xuICAgIHZhciBkYXRhZ3JpZF9vYmplY3QgPSB0aGlzO1xuXG4gICAgdGhpcy4kZ2MuZmluZCgnLmNsZWFyLXNlYXJjaCcpLnJlbW92ZSgpO1xuXG4gICAgdGhpcy4kZ2MuZmluZChDb25zdGFudHMuU0VMRUNUT1JfU0VBUkNIX0ZJRUxEX0lOUFVUKS5lYWNoKGZ1bmN0aW9uIGZvckVhY2hTZWFyY2hhYmxlSW5wdXQoKSB7XG4gICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ3ZhbHVlLW5vdC1lbXB0eScpO1xuICAgICAgICBpZiAoJCh0aGlzKS52YWwoKSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ3ZhbHVlLW5vdC1lbXB0eScpO1xuICAgICAgICAkKHRoaXMpLmFmdGVyKCc8aSBjbGFzcz1cImZhIGZhLXRpbWVzIGNsZWFyLXNlYXJjaFwiPjwvaT4nKTtcblxuICAgICAgICBkYXRhZ3JpZF9vYmplY3QuJGdjLmZpbmQoJy5jbGVhci1zZWFyY2gnKS5jbGljayhmdW5jdGlvbiBjbGVhclNlYXJjaCgpIHtcbiAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgndGQnKS5maW5kKCcuZ2Mtc2VhcmNoYWJsZS1pbnB1dCcpLnZhbCgnJykudHJpZ2dlcigna2V5dXAnKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUubGlzdGVuZXJQZXJQYWdlID0gZnVuY3Rpb24gbGlzdGVuZXJQZXJQYWdlKCkge1xuICAgIHRoaXMuJGdjLmZpbmQoJy4nICsgQ29uc3RhbnRzLkNMQVNTX1BFUl9QQUdFKS5jaGFuZ2UoZnVuY3Rpb24gcGVyUGFnZU9uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLiRnYy5maW5kKCcucGFnZS1udW1iZXItaGlkZGVuJykudmFsKCcxJyk7XG4gICAgICAgIEdyaWQuc2VhcmNoQW5kT3JkZXJpbmdUcmlnZ2VyLmFwcGx5KHRoaXMpO1xuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuY2xlYXJGaWx0ZXJpbmdMaXN0ZW5lciA9IGZ1bmN0aW9uIGNsZWFyRmlsdGVyaW5nTGlzdGVuZXIoJHNldHRpbmdzQ29udGFpbmVyKSB7XG4gICAgJHNldHRpbmdzQ29udGFpbmVyLmZpbmQoJy5jbGVhci1maWx0ZXJpbmcnKS5jbGljayhmdW5jdGlvbiBjbGVhckZpbHRlcmluZ0NsaWNrQnV0dG9uKCkge1xuICAgICAgICB0aGlzLmNsZWFyRmlsdGVyaW5nQ2FjaGUoKTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLmhpZGVTaG93RGVsZXRlQnV0dG9uID0gZnVuY3Rpb24gaGlkZVNob3dEZWxldGVCdXR0b24oKSB7XG5cbiAgICBpZiAodGhpcy4kZ2MuZmluZCgnLmdjLXNlbGVjdC1yb3c6Y2hlY2tlZCcpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmRlbGV0ZS1zZWxlY3RlZC1idXR0b24nKS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmRlbGV0ZS1zZWxlY3RlZC1idXR0b24nKS5hZGRDbGFzcygnaGlkZGVuJyk7XG4gICAgfVxufTtcblxuZXhwb3J0cy5Hcm9jZXJ5Q3J1ZCA9IEdyb2NlcnlDcnVkO1xuIiwidmFyIEdyb2NlcnlDcnVkID0gcmVxdWlyZSgnLi9ncm9jZXJ5LWNydWQnKS5Hcm9jZXJ5Q3J1ZCxcbiAgICAkID0galF1ZXJ5O1xuXG4kLmZuLmdyb2NlcnlDcnVkID0gZnVuY3Rpb24galF1ZXJ5Rm5EYXRhZ3JpZChvcHRpb25zKSB7XG4gICAgdmFyIHNldHRpbmdzID0gJC5leHRlbmQoe1xuICAgICAgICBhY3Rpb25CdXR0b25zOiBbXSxcbiAgICAgICAgaGFzaEV2ZW50czogdHJ1ZSxcbiAgICAgICAgZGF0YWdyaWRTZWFyY2hBbGxJbnB1dDogZmFsc2VcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuZWFjaChmdW5jdGlvbiBmb3JFYWNoRGF0YWdyaWQoKSB7XG4gICAgICAgIChuZXcgR3JvY2VyeUNydWQoJCh0aGlzKSwgc2V0dGluZ3MpKS5pbml0KCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG4iLCJjb25zdCAkID0galF1ZXJ5LFxuICAgIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyksXG4gICAgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vc2VjdGlvbnMvY29uc3RhbnRzJykuQ29uc3RhbnRzLFxuICAgIGFqYXhIZWxwZXIgPSBPYmplY3QuY3JlYXRlKHtcbiAgICAgICAgc2V0TG9hZGluZzogZnVuY3Rpb24gc2V0TG9hZGluZygpIHtcbiAgICAgICAgICAgIHRoaXMuJGdjXG4gICAgICAgICAgICAgICAgLmZpbmQoJy5sb2FkaW5nLW9wYWNpdHknKVxuICAgICAgICAgICAgICAgIC5jc3MoJ3dpZHRoJywgKHRoaXMuJGdjLndpZHRoKCkgKyAxNSkgKyAncHgnKVxuICAgICAgICAgICAgICAgIC5jc3MoJ2hlaWdodCcsIHRoaXMuJGdjLmhlaWdodCgpICsgJ3B4JylcbiAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgICB9LFxuICAgICAgICB1bnNldExvYWRpbmc6IGZ1bmN0aW9uIHVuc2V0TG9hZGluZygpIHtcbiAgICAgICAgICAgIHRoaXMuJGdjXG4gICAgICAgICAgICAgICAgLmZpbmQoJy5sb2FkaW5nLW9wYWNpdHknKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnaGlkZGVuJylcbiAgICAgICAgICAgICAgICAuY3NzKCd3aWR0aCcsICcwcHgnKVxuICAgICAgICAgICAgICAgIC5jc3MoJ2hlaWdodCcsICcwcHgnKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VuZEdldFJlcXVlc3Q6IGZ1bmN0aW9uIHNlbmRHZXRSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBhamF4SGVscGVyLnNlbmRBamF4UmVxdWVzdC5hcHBseSh0aGlzLCBbb3B0aW9ucywgJ2dldCddKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VuZFBvc3RSZXF1ZXN0OiBmdW5jdGlvbiBzZW5kUG9zdFJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGFqYXhIZWxwZXIuc2VuZEFqYXhSZXF1ZXN0LmFwcGx5KHRoaXMsIFtvcHRpb25zLCAncG9zdCddKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWpheE9uRmFpbDogZnVuY3Rpb24gYWpheE9uRmFpbChlcnJvckFzU3RyaW5nLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgICAgICAgYWpheEhlbHBlci51bnNldExvYWRpbmcuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZXJyb3ItbW9kYWwnKVxuICAgICAgICAgICAgICAgIC5maW5kKCcuZ2MtZXJyb3ItYm9keScpXG4gICAgICAgICAgICAgICAgLmh0bWwoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlYmFyc1RlbXBsYXRlKCcuZ2MtbW9kYWwtZXJyb3ItdGV4dC10ZW1wbGF0ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRTdGF0dXM6IHRleHRTdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclRocm93bjogZXJyb3JUaHJvd24sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckFzU3RyaW5nOiBlcnJvckFzU3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKC9cXDwoaHRtbHxzY3JpcHR8Ym9keXxzdHlsZXxsaW5rKVxcPi9pLnRlc3QoZXJyb3JBc1N0cmluZykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZXJyb3ItaHRtbC1wcmV2aWV3LWJ1dHRvbicpLmFkZENsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLWVycm9yLWh0bWwtcHJldmlldy1idXR0b24nKS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZXJyb3ItaHRtbC1wcmV2aWV3LWJ1dHRvbicpXG4gICAgICAgICAgICAgICAgICAgIC5jbGljayhmdW5jdGlvbiBlcnJvckhUTUxQcmV2aWV3Q2xpY2soKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtY29kZS1lcnJvci1yZXNwb25zZScpLmFkZENsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1lcnJvci1tZXNzYWdlLWh0bWwnKS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZXJyb3ItbWVzc2FnZS1odG1sJykuaHRtbChlcnJvckFzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1lcnJvci1odG1sLXByZXZpZXctYnV0dG9uJykuYWRkQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZXJyb3ItbW9kYWwnKS5nY19tb2RhbCh7XG4gICAgICAgICAgICAgICAgYmFja2Ryb3A6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VuZEFqYXhSZXF1ZXN0OiBmdW5jdGlvbiBzZW5kQWpheFJlcXVlc3Qob3B0aW9ucywgcmVxdWVzdE1ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuICQuYWpheCh7XG4gICAgICAgICAgICAgICAgYmVmb3JlU2VuZDogYWpheEhlbHBlci5zZXRMb2FkaW5nLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgZGF0YTogb3B0aW9ucy5kYXRhVG9TZW5kLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdE1ldGhvZCxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgIHVybDogb3B0aW9ucy51cmxcbiAgICAgICAgICAgIH0pLmRvbmUoZnVuY3Rpb24gYWpheENhbGxEb25lKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBhamF4SGVscGVyLnVuc2V0TG9hZGluZy5hcHBseSh0aGlzKTtcblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnN0YXR1cyA9PT0gQ29uc3RhbnRzLlJFU1BPTlNFLkZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWpheEhlbHBlci5zaG93RXJyb3JNb2RhbC5hcHBseSh0aGlzLCBbZGF0YS5tZXNzYWdlXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzQ2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgIC5mYWlsKGZ1bmN0aW9uIGFqYXhPbkZhaWwoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvckFzU3RyaW5nID0ganFYSFIucmVzcG9uc2VUZXh0O1xuXG4gICAgICAgICAgICAgICAgICAgIGFqYXhIZWxwZXIuYWpheE9uRmFpbC5hcHBseSh0aGlzLCBbZXJyb3JBc1N0cmluZywgdGV4dFN0YXR1cywgZXJyb3JUaHJvd25dKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lcnJvckNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JDYWxsYmFjayhlcnJvckFzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNob3dFcnJvck1vZGFsOiBmdW5jdGlvbiBzaG93RXJyb3JNb2RhbChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1lcnJvci1tb2RhbCcpXG4gICAgICAgICAgICAgICAgLmZpbmQoJy5nYy1lcnJvci1ib2R5JylcbiAgICAgICAgICAgICAgICAuaHRtbChlcnJvck1lc3NhZ2UpO1xuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZXJyb3ItbW9kYWwnKS5nY19tb2RhbCh7XG4gICAgICAgICAgICAgICAgYmFja2Ryb3A6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VXJsOiBmdW5jdGlvbiBnZXRVcmwoYWN0aW9uLCBkYXRhX3RvX3NlbmQpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSB0aGlzLnVybDtcblxuICAgICAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHVybCArPSAvXFw/Ly50ZXN0KHVybCkgPyAnJicgOiAnPyc7XG4gICAgICAgICAgICAgICAgdXJsICs9ICdhY3Rpb249JyArIGFjdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGFfdG9fc2VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgXy5lYWNoKGRhdGFfdG9fc2VuZCwgZnVuY3Rpb24gZm9yRWFjaERhdGFUb1NlbmQoX2ZpZWxkX3ZhbHVlLCBfZmllbGRfbmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChfZmllbGRfdmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBfLmVhY2goX2ZpZWxkX3ZhbHVlLCBmdW5jdGlvbiBmb3JFYWNoRmllbGRzKF9hcnJheV92YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9ICcmJyArIF9maWVsZF9uYW1lICsgJ1tdPScgKyBfYXJyYXlfdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX2ZpZWxkX3ZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChfZmllbGRfdmFsdWUsIGZ1bmN0aW9uIGZvckVhY2hGaWVsZHMob2JqZWN0RmllbGRWYWx1ZSwgb2JqZWN0RmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gJyYnICsgX2ZpZWxkX25hbWUgKyAnWycgKyBvYmplY3RGaWVsZE5hbWUgKyAnXT0nICsgb2JqZWN0RmllbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsICs9ICcmJyArIF9maWVsZF9uYW1lICsgJz0nICsgKF8uaXNVbmRlZmluZWQoX2ZpZWxkX3ZhbHVlKSA/ICcnIDogX2ZpZWxkX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UG9zdERhdGFGcm9tRm9ybTogZnVuY3Rpb24gZ2V0UG9zdERhdGFGcm9tRm9ybSgkanF1ZXJ5Rm9ybSkge1xuICAgICAgICAgICAgdmFyIHBvc3REYXRhID0ge307XG4gICAgICAgICAgICBfLmVhY2goJGpxdWVyeUZvcm0uc2VyaWFsaXplQXJyYXkoKSwgZnVuY3Rpb24gZWFjaEZvcm1GaWVsZHMoZmllbGQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YVR5cGUgPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmZpZWxkVHlwZXNbZmllbGQubmFtZV0uZGF0YVR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFUeXBlID09PSAncmVsYXRpb25hbF9uX24nIHx8IGRhdGFUeXBlID09PSAnbmF0aXZlX3JlbGF0aW9uYWxfbl9uJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zdERhdGFbZmllbGQubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdERhdGFbZmllbGQubmFtZV0gPSBbZmllbGQudmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdERhdGFbZmllbGQubmFtZV0ucHVzaChmaWVsZC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwb3N0RGF0YVtmaWVsZC5uYW1lXSA9IGZpZWxkLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBwb3N0RGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TXVsdGlsYXllclBvc3REYXRhRnJvbUZvcm06IGZ1bmN0aW9uIGdldE11bHRpbGF5ZXJQb3N0RGF0YUZyb21Gb3JtKCRqcXVlcnlGb3JtKSB7XG4gICAgICAgICAgICBsZXQgcG9zdERhdGEgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1EYXRhID0gJGpxdWVyeUZvcm0uc2VyaWFsaXplQXJyYXkoKTtcblxuICAgICAgICAgICAgZm9ybURhdGEuZm9yRWFjaChmdW5jdGlvbiBmb3JlYWNoRm9ybURhdGEoaXRlbSkge1xuICAgICAgICAgICAgICAgIHBvc3REYXRhW2l0ZW0ubmFtZV0gPSBpdGVtLnZhbHVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBwb3N0RGF0YTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5leHBvcnRzLmFqYXhIZWxwZXIgPSBhamF4SGVscGVyO1xuIiwidmFyIGxvY2FsU3RvcmFnZUhlbHBlciA9IE9iamVjdC5jcmVhdGUoe1xuXG4gICAgLy8gQnkgZGVmYXVsdCB0aGlzIGlzIGVtcHR5IGFzIHNvbWUgYnJvd3NlcnMgZG9lc24ndCBzdXBwb3J0IGxvY2FsU3RvcmFnZSBjYWNoZVxuICAgIHNldExvY2FsU3RvcmFnZUl0ZW06IGZ1bmN0aW9uIHNldExvY2FsU3RvcmFnZUl0ZW0oX19pdGVtLCBfX3ZhbHVlKSB7XG5cbiAgICB9LFxuXG4gICAgLy8gQnkgZGVmYXVsdCB0aGlzIGlzIGVtcHR5IGFzIHNvbWUgYnJvd3NlcnMgZG9lc24ndCBzdXBwb3J0IGxvY2FsU3RvcmFnZSBjYWNoZVxuICAgIHJlbW92ZUxvY2FsU3RvcmFnZUl0ZW06IGZ1bmN0aW9uIHJlbW92ZUxvY2FsU3RvcmFnZUl0ZW0oX19pdGVtKSB7XG5cbiAgICB9LFxuXG4gICAgLy8gQnkgZGVmYXVsdCB0aGlzIGlzIGVtcHR5IGFzIHNvbWUgYnJvd3NlcnMgZG9lc24ndCBzdXBwb3J0IGxvY2FsU3RvcmFnZSBjYWNoZVxuICAgIGdldExvY2FsU3RvcmFnZUl0ZW06IGZ1bmN0aW9uIGdldExvY2FsU3RvcmFnZUl0ZW0oX19pdGVtKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBUaGUgYmVsb3cgZnVuY3Rpb24gaXMgY29waWVkIGZyb20gdGhlIG1vZGVybml6ciBsb2NhbCBzdG9yYWdlIHN1cHBvcnRcbiAgICBicm93c2VyU3VwcG9ydHNMb2NhbFN0b3JhZ2U6IGZ1bmN0aW9uIGJyb3dzZXJTdXBwb3J0c0xvY2FsU3RvcmFnZSgpIHtcbiAgICAgICAgdmFyIG1vZCA9ICdtb2Rlcm5penInO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obW9kLCBtb2QpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0obW9kKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQ2hhbmdpbmcgdGhlIGRlZmF1bHQgZW1wdHkgdmFsdWVzIG9mIHRoZSBmdW5jdGlvbnMgdG8gc3VwcG9ydCBsb2NhbCBzdG9yYWdlLiBUaGUgYmVsb3cgZnVuY3Rpb25cbiAgICAvLyBpcyBjYWxsZWQgb25seSBvbmNlIGZvciBvcHRpbWl6aW5nIHJlYXNvbnNcbiAgICBzZXRMb2NhbFN0b3JhZ2VDYWNoZTogZnVuY3Rpb24gc2V0TG9jYWxTdG9yYWdlQ2FjaGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmJyb3dzZXJTdXBwb3J0c0xvY2FsU3RvcmFnZSgpKSB7XG4gICAgICAgICAgICAvL2lmIGJyb3dzZXIgaXMgc3VwcG9ydGluZyBsb2NhbCBzdG9yYWdlIG92ZXJyaWRlcyB0aGUgZW1wdHkgZnVuY3Rpb25zXG4gICAgICAgICAgICB0aGlzLnNldExvY2FsU3RvcmFnZUl0ZW0gPSBmdW5jdGlvbiBzZXRMb2NhbFN0b3JhZ2VJdGVtKGl0ZW0sIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oaXRlbSwgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTG9jYWxTdG9yYWdlSXRlbSA9IGZ1bmN0aW9uIHJlbW92ZUxvY2FsU3RvcmFnZUl0ZW0oaXRlbSkge1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGl0ZW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZ2V0TG9jYWxTdG9yYWdlSXRlbSA9IGZ1bmN0aW9uIGdldExvY2FsU3RvcmFnZUl0ZW0oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShpdGVtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxubG9jYWxTdG9yYWdlSGVscGVyLnNldExvY2FsU3RvcmFnZUNhY2hlKCk7XG5cbmV4cG9ydHMubG9jYWxTdG9yYWdlSGVscGVyID0gbG9jYWxTdG9yYWdlSGVscGVyOyIsIi8qIVxuQ2hvc2VuLCBhIFNlbGVjdCBCb3ggRW5oYW5jZXIgZm9yIGpRdWVyeSBhbmQgUHJvdG90eXBlXG5ieSBQYXRyaWNrIEZpbGxlciBmb3IgSGFydmVzdCwgaHR0cDovL2dldGhhcnZlc3QuY29tXG5cblZlcnNpb24gMS42LjJcbkZ1bGwgc291cmNlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9oYXJ2ZXN0aHEvY2hvc2VuXG5Db3B5cmlnaHQgKGMpIDIwMTEtMjAxNiBIYXJ2ZXN0IGh0dHA6Ly9nZXRoYXJ2ZXN0LmNvbVxuXG5NSVQgTGljZW5zZSwgaHR0cHM6Ly9naXRodWIuY29tL2hhcnZlc3RocS9jaG9zZW4vYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBgZ3J1bnQgYnVpbGRgLCBkbyBub3QgZWRpdCBpdCBieSBoYW5kLlxuKi9cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgJCwgQWJzdHJhY3RDaG9zZW4sIENob3NlbiwgU2VsZWN0UGFyc2VyLCBfcmVmLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9O1xuXG4gIFNlbGVjdFBhcnNlciA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTZWxlY3RQYXJzZXIoKSB7XG4gICAgICB0aGlzLm9wdGlvbnNfaW5kZXggPSAwO1xuICAgICAgdGhpcy5wYXJzZWQgPSBbXTtcbiAgICB9XG5cbiAgICBTZWxlY3RQYXJzZXIucHJvdG90eXBlLmFkZF9ub2RlID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIk9QVEdST1VQXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkX2dyb3VwKGNoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZF9vcHRpb24oY2hpbGQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBTZWxlY3RQYXJzZXIucHJvdG90eXBlLmFkZF9ncm91cCA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICB2YXIgZ3JvdXBfcG9zaXRpb24sIG9wdGlvbiwgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgZ3JvdXBfcG9zaXRpb24gPSB0aGlzLnBhcnNlZC5sZW5ndGg7XG4gICAgICB0aGlzLnBhcnNlZC5wdXNoKHtcbiAgICAgICAgYXJyYXlfaW5kZXg6IGdyb3VwX3Bvc2l0aW9uLFxuICAgICAgICBncm91cDogdHJ1ZSxcbiAgICAgICAgbGFiZWw6IHRoaXMuZXNjYXBlRXhwcmVzc2lvbihncm91cC5sYWJlbCksXG4gICAgICAgIHRpdGxlOiBncm91cC50aXRsZSA/IGdyb3VwLnRpdGxlIDogdm9pZCAwLFxuICAgICAgICBjaGlsZHJlbjogMCxcbiAgICAgICAgZGlzYWJsZWQ6IGdyb3VwLmRpc2FibGVkLFxuICAgICAgICBjbGFzc2VzOiBncm91cC5jbGFzc05hbWVcbiAgICAgIH0pO1xuICAgICAgX3JlZiA9IGdyb3VwLmNoaWxkTm9kZXM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIG9wdGlvbiA9IF9yZWZbX2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMuYWRkX29wdGlvbihvcHRpb24sIGdyb3VwX3Bvc2l0aW9uLCBncm91cC5kaXNhYmxlZCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBTZWxlY3RQYXJzZXIucHJvdG90eXBlLmFkZF9vcHRpb24gPSBmdW5jdGlvbihvcHRpb24sIGdyb3VwX3Bvc2l0aW9uLCBncm91cF9kaXNhYmxlZCkge1xuICAgICAgaWYgKG9wdGlvbi5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIk9QVElPTlwiKSB7XG4gICAgICAgIGlmIChvcHRpb24udGV4dCAhPT0gXCJcIikge1xuICAgICAgICAgIGlmIChncm91cF9wb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFtncm91cF9wb3NpdGlvbl0uY2hpbGRyZW4gKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wYXJzZWQucHVzaCh7XG4gICAgICAgICAgICBhcnJheV9pbmRleDogdGhpcy5wYXJzZWQubGVuZ3RoLFxuICAgICAgICAgICAgb3B0aW9uc19pbmRleDogdGhpcy5vcHRpb25zX2luZGV4LFxuICAgICAgICAgICAgdmFsdWU6IG9wdGlvbi52YWx1ZSxcbiAgICAgICAgICAgIHRleHQ6IG9wdGlvbi50ZXh0LFxuICAgICAgICAgICAgaHRtbDogb3B0aW9uLmlubmVySFRNTCxcbiAgICAgICAgICAgIHRpdGxlOiBvcHRpb24udGl0bGUgPyBvcHRpb24udGl0bGUgOiB2b2lkIDAsXG4gICAgICAgICAgICBzZWxlY3RlZDogb3B0aW9uLnNlbGVjdGVkLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGdyb3VwX2Rpc2FibGVkID09PSB0cnVlID8gZ3JvdXBfZGlzYWJsZWQgOiBvcHRpb24uZGlzYWJsZWQsXG4gICAgICAgICAgICBncm91cF9hcnJheV9pbmRleDogZ3JvdXBfcG9zaXRpb24sXG4gICAgICAgICAgICBncm91cF9sYWJlbDogZ3JvdXBfcG9zaXRpb24gIT0gbnVsbCA/IHRoaXMucGFyc2VkW2dyb3VwX3Bvc2l0aW9uXS5sYWJlbCA6IG51bGwsXG4gICAgICAgICAgICBjbGFzc2VzOiBvcHRpb24uY2xhc3NOYW1lLFxuICAgICAgICAgICAgc3R5bGU6IG9wdGlvbi5zdHlsZS5jc3NUZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYXJzZWQucHVzaCh7XG4gICAgICAgICAgICBhcnJheV9pbmRleDogdGhpcy5wYXJzZWQubGVuZ3RoLFxuICAgICAgICAgICAgb3B0aW9uc19pbmRleDogdGhpcy5vcHRpb25zX2luZGV4LFxuICAgICAgICAgICAgZW1wdHk6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zX2luZGV4ICs9IDE7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFNlbGVjdFBhcnNlci5wcm90b3R5cGUuZXNjYXBlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHZhciBtYXAsIHVuc2FmZV9jaGFycztcbiAgICAgIGlmICgodGV4dCA9PSBudWxsKSB8fCB0ZXh0ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIGlmICghL1tcXCZcXDxcXD5cXFwiXFwnXFxgXS8udGVzdCh0ZXh0KSkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cbiAgICAgIG1hcCA9IHtcbiAgICAgICAgXCI8XCI6IFwiJmx0O1wiLFxuICAgICAgICBcIj5cIjogXCImZ3Q7XCIsXG4gICAgICAgICdcIic6IFwiJnF1b3Q7XCIsXG4gICAgICAgIFwiJ1wiOiBcIiYjeDI3O1wiLFxuICAgICAgICBcImBcIjogXCImI3g2MDtcIlxuICAgICAgfTtcbiAgICAgIHVuc2FmZV9jaGFycyA9IC8mKD8hXFx3KzspfFtcXDxcXD5cXFwiXFwnXFxgXS9nO1xuICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSh1bnNhZmVfY2hhcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAgICByZXR1cm4gbWFwW2Nocl0gfHwgXCImYW1wO1wiO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZWxlY3RQYXJzZXI7XG5cbiAgfSkoKTtcblxuICBTZWxlY3RQYXJzZXIuc2VsZWN0X3RvX2FycmF5ID0gZnVuY3Rpb24oc2VsZWN0KSB7XG4gICAgdmFyIGNoaWxkLCBwYXJzZXIsIF9pLCBfbGVuLCBfcmVmO1xuICAgIHBhcnNlciA9IG5ldyBTZWxlY3RQYXJzZXIoKTtcbiAgICBfcmVmID0gc2VsZWN0LmNoaWxkTm9kZXM7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBjaGlsZCA9IF9yZWZbX2ldO1xuICAgICAgcGFyc2VyLmFkZF9ub2RlKGNoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZWQ7XG4gIH07XG5cbiAgQWJzdHJhY3RDaG9zZW4gPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RDaG9zZW4oZm9ybV9maWVsZCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkID0gZm9ybV9maWVsZDtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgICAgIGlmICghQWJzdHJhY3RDaG9zZW4uYnJvd3Nlcl9pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmlzX211bHRpcGxlID0gdGhpcy5mb3JtX2ZpZWxkLm11bHRpcGxlO1xuICAgICAgdGhpcy5zZXRfZGVmYXVsdF90ZXh0KCk7XG4gICAgICB0aGlzLnNldF9kZWZhdWx0X3ZhbHVlcygpO1xuICAgICAgdGhpcy5zZXR1cCgpO1xuICAgICAgdGhpcy5zZXRfdXBfaHRtbCgpO1xuICAgICAgdGhpcy5yZWdpc3Rlcl9vYnNlcnZlcnMoKTtcbiAgICAgIHRoaXMub25fcmVhZHkoKTtcbiAgICB9XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuc2V0X2RlZmF1bHRfdmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5jbGlja190ZXN0X2FjdGlvbiA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMudGVzdF9hY3RpdmVfY2xpY2soZXZ0KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmFjdGl2YXRlX2FjdGlvbiA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuYWN0aXZhdGVfZmllbGQoZXZ0KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmFjdGl2ZV9maWVsZCA9IGZhbHNlO1xuICAgICAgdGhpcy5tb3VzZV9vbl9jb250YWluZXIgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVzdWx0c19zaG93aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnJlc3VsdF9oaWdobGlnaHRlZCA9IG51bGw7XG4gICAgICB0aGlzLmFsbG93X3NpbmdsZV9kZXNlbGVjdCA9ICh0aGlzLm9wdGlvbnMuYWxsb3dfc2luZ2xlX2Rlc2VsZWN0ICE9IG51bGwpICYmICh0aGlzLmZvcm1fZmllbGQub3B0aW9uc1swXSAhPSBudWxsKSAmJiB0aGlzLmZvcm1fZmllbGQub3B0aW9uc1swXS50ZXh0ID09PSBcIlwiID8gdGhpcy5vcHRpb25zLmFsbG93X3NpbmdsZV9kZXNlbGVjdCA6IGZhbHNlO1xuICAgICAgdGhpcy5kaXNhYmxlX3NlYXJjaF90aHJlc2hvbGQgPSB0aGlzLm9wdGlvbnMuZGlzYWJsZV9zZWFyY2hfdGhyZXNob2xkIHx8IDA7XG4gICAgICB0aGlzLmRpc2FibGVfc2VhcmNoID0gdGhpcy5vcHRpb25zLmRpc2FibGVfc2VhcmNoIHx8IGZhbHNlO1xuICAgICAgdGhpcy5lbmFibGVfc3BsaXRfd29yZF9zZWFyY2ggPSB0aGlzLm9wdGlvbnMuZW5hYmxlX3NwbGl0X3dvcmRfc2VhcmNoICE9IG51bGwgPyB0aGlzLm9wdGlvbnMuZW5hYmxlX3NwbGl0X3dvcmRfc2VhcmNoIDogdHJ1ZTtcbiAgICAgIHRoaXMuZ3JvdXBfc2VhcmNoID0gdGhpcy5vcHRpb25zLmdyb3VwX3NlYXJjaCAhPSBudWxsID8gdGhpcy5vcHRpb25zLmdyb3VwX3NlYXJjaCA6IHRydWU7XG4gICAgICB0aGlzLnNlYXJjaF9jb250YWlucyA9IHRoaXMub3B0aW9ucy5zZWFyY2hfY29udGFpbnMgfHwgZmFsc2U7XG4gICAgICB0aGlzLnNpbmdsZV9iYWNrc3Ryb2tlX2RlbGV0ZSA9IHRoaXMub3B0aW9ucy5zaW5nbGVfYmFja3N0cm9rZV9kZWxldGUgIT0gbnVsbCA/IHRoaXMub3B0aW9ucy5zaW5nbGVfYmFja3N0cm9rZV9kZWxldGUgOiB0cnVlO1xuICAgICAgdGhpcy5tYXhfc2VsZWN0ZWRfb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5tYXhfc2VsZWN0ZWRfb3B0aW9ucyB8fCBJbmZpbml0eTtcbiAgICAgIHRoaXMuaW5oZXJpdF9zZWxlY3RfY2xhc3NlcyA9IHRoaXMub3B0aW9ucy5pbmhlcml0X3NlbGVjdF9jbGFzc2VzIHx8IGZhbHNlO1xuICAgICAgdGhpcy5kaXNwbGF5X3NlbGVjdGVkX29wdGlvbnMgPSB0aGlzLm9wdGlvbnMuZGlzcGxheV9zZWxlY3RlZF9vcHRpb25zICE9IG51bGwgPyB0aGlzLm9wdGlvbnMuZGlzcGxheV9zZWxlY3RlZF9vcHRpb25zIDogdHJ1ZTtcbiAgICAgIHRoaXMuZGlzcGxheV9kaXNhYmxlZF9vcHRpb25zID0gdGhpcy5vcHRpb25zLmRpc3BsYXlfZGlzYWJsZWRfb3B0aW9ucyAhPSBudWxsID8gdGhpcy5vcHRpb25zLmRpc3BsYXlfZGlzYWJsZWRfb3B0aW9ucyA6IHRydWU7XG4gICAgICB0aGlzLmluY2x1ZGVfZ3JvdXBfbGFiZWxfaW5fc2VsZWN0ZWQgPSB0aGlzLm9wdGlvbnMuaW5jbHVkZV9ncm91cF9sYWJlbF9pbl9zZWxlY3RlZCB8fCBmYWxzZTtcbiAgICAgIHRoaXMubWF4X3Nob3duX3Jlc3VsdHMgPSB0aGlzLm9wdGlvbnMubWF4X3Nob3duX3Jlc3VsdHMgfHwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgcmV0dXJuIHRoaXMuY2FzZV9zZW5zaXRpdmVfc2VhcmNoID0gdGhpcy5vcHRpb25zLmNhc2Vfc2Vuc2l0aXZlX3NlYXJjaCB8fCBmYWxzZTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnNldF9kZWZhdWx0X3RleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmZvcm1fZmllbGQuZ2V0QXR0cmlidXRlKFwiZGF0YS1wbGFjZWhvbGRlclwiKSkge1xuICAgICAgICB0aGlzLmRlZmF1bHRfdGV4dCA9IHRoaXMuZm9ybV9maWVsZC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBsYWNlaG9sZGVyXCIpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdF90ZXh0ID0gdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyX3RleHRfbXVsdGlwbGUgfHwgdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyX3RleHQgfHwgQWJzdHJhY3RDaG9zZW4uZGVmYXVsdF9tdWx0aXBsZV90ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0X3RleHQgPSB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXJfdGV4dF9zaW5nbGUgfHwgdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyX3RleHQgfHwgQWJzdHJhY3RDaG9zZW4uZGVmYXVsdF9zaW5nbGVfdGV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlc3VsdHNfbm9uZV9mb3VuZCA9IHRoaXMuZm9ybV9maWVsZC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW5vX3Jlc3VsdHNfdGV4dFwiKSB8fCB0aGlzLm9wdGlvbnMubm9fcmVzdWx0c190ZXh0IHx8IEFic3RyYWN0Q2hvc2VuLmRlZmF1bHRfbm9fcmVzdWx0X3RleHQ7XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5jaG9pY2VfbGFiZWwgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpZiAodGhpcy5pbmNsdWRlX2dyb3VwX2xhYmVsX2luX3NlbGVjdGVkICYmIChpdGVtLmdyb3VwX2xhYmVsICE9IG51bGwpKSB7XG4gICAgICAgIHJldHVybiBcIjxiIGNsYXNzPSdncm91cC1uYW1lJz5cIiArIGl0ZW0uZ3JvdXBfbGFiZWwgKyBcIjwvYj5cIiArIGl0ZW0uaHRtbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpdGVtLmh0bWw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5tb3VzZV9lbnRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubW91c2Vfb25fY29udGFpbmVyID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLm1vdXNlX2xlYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb3VzZV9vbl9jb250YWluZXIgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmlucHV0X2ZvY3VzID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZV9maWVsZCkge1xuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb250YWluZXJfbW91c2Vkb3duKCk7XG4gICAgICAgICAgfSksIDUwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZV9maWVsZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2YXRlX2ZpZWxkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmlucHV0X2JsdXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMubW91c2Vfb25fY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlX2ZpZWxkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuYmx1cl90ZXN0KCk7XG4gICAgICAgIH0pLCAxMDApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUucmVzdWx0c19vcHRpb25fYnVpbGQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY29udGVudCwgZGF0YSwgZGF0YV9jb250ZW50LCBzaG93bl9yZXN1bHRzLCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgIGNvbnRlbnQgPSAnJztcbiAgICAgIHNob3duX3Jlc3VsdHMgPSAwO1xuICAgICAgX3JlZiA9IHRoaXMucmVzdWx0c19kYXRhO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGRhdGEgPSBfcmVmW19pXTtcbiAgICAgICAgZGF0YV9jb250ZW50ID0gJyc7XG4gICAgICAgIGlmIChkYXRhLmdyb3VwKSB7XG4gICAgICAgICAgZGF0YV9jb250ZW50ID0gdGhpcy5yZXN1bHRfYWRkX2dyb3VwKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFfY29udGVudCA9IHRoaXMucmVzdWx0X2FkZF9vcHRpb24oZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFfY29udGVudCAhPT0gJycpIHtcbiAgICAgICAgICBzaG93bl9yZXN1bHRzKys7XG4gICAgICAgICAgY29udGVudCArPSBkYXRhX2NvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMuZmlyc3QgOiB2b2lkIDApIHtcbiAgICAgICAgICBpZiAoZGF0YS5zZWxlY3RlZCAmJiB0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLmNob2ljZV9idWlsZChkYXRhKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEuc2VsZWN0ZWQgJiYgIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2luZ2xlX3NldF9zZWxlY3RlZF90ZXh0KHRoaXMuY2hvaWNlX2xhYmVsKGRhdGEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3duX3Jlc3VsdHMgPj0gdGhpcy5tYXhfc2hvd25fcmVzdWx0cykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9hZGRfb3B0aW9uID0gZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICB2YXIgY2xhc3Nlcywgb3B0aW9uX2VsO1xuICAgICAgaWYgKCFvcHRpb24uc2VhcmNoX21hdGNoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5pbmNsdWRlX29wdGlvbl9pbl9yZXN1bHRzKG9wdGlvbikpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgY2xhc3NlcyA9IFtdO1xuICAgICAgaWYgKCFvcHRpb24uZGlzYWJsZWQgJiYgIShvcHRpb24uc2VsZWN0ZWQgJiYgdGhpcy5pc19tdWx0aXBsZSkpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKFwiYWN0aXZlLXJlc3VsdFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb24uZGlzYWJsZWQgJiYgIShvcHRpb24uc2VsZWN0ZWQgJiYgdGhpcy5pc19tdWx0aXBsZSkpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKFwiZGlzYWJsZWQtcmVzdWx0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICBjbGFzc2VzLnB1c2goXCJyZXN1bHQtc2VsZWN0ZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9uLmdyb3VwX2FycmF5X2luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKFwiZ3JvdXAtb3B0aW9uXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbi5jbGFzc2VzICE9PSBcIlwiKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChvcHRpb24uY2xhc3Nlcyk7XG4gICAgICB9XG4gICAgICBvcHRpb25fZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIik7XG4gICAgICBvcHRpb25fZWwuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKFwiIFwiKTtcbiAgICAgIG9wdGlvbl9lbC5zdHlsZS5jc3NUZXh0ID0gb3B0aW9uLnN0eWxlO1xuICAgICAgb3B0aW9uX2VsLnNldEF0dHJpYnV0ZShcImRhdGEtb3B0aW9uLWFycmF5LWluZGV4XCIsIG9wdGlvbi5hcnJheV9pbmRleCk7XG4gICAgICBvcHRpb25fZWwuaW5uZXJIVE1MID0gb3B0aW9uLnNlYXJjaF90ZXh0O1xuICAgICAgaWYgKG9wdGlvbi50aXRsZSkge1xuICAgICAgICBvcHRpb25fZWwudGl0bGUgPSBvcHRpb24udGl0bGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5vdXRlckhUTUwob3B0aW9uX2VsKTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9hZGRfZ3JvdXAgPSBmdW5jdGlvbihncm91cCkge1xuICAgICAgdmFyIGNsYXNzZXMsIGdyb3VwX2VsO1xuICAgICAgaWYgKCEoZ3JvdXAuc2VhcmNoX21hdGNoIHx8IGdyb3VwLmdyb3VwX21hdGNoKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICBpZiAoIShncm91cC5hY3RpdmVfb3B0aW9ucyA+IDApKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGNsYXNzZXMgPSBbXTtcbiAgICAgIGNsYXNzZXMucHVzaChcImdyb3VwLXJlc3VsdFwiKTtcbiAgICAgIGlmIChncm91cC5jbGFzc2VzKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChncm91cC5jbGFzc2VzKTtcbiAgICAgIH1cbiAgICAgIGdyb3VwX2VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpO1xuICAgICAgZ3JvdXBfZWwuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKFwiIFwiKTtcbiAgICAgIGdyb3VwX2VsLmlubmVySFRNTCA9IGdyb3VwLnNlYXJjaF90ZXh0O1xuICAgICAgaWYgKGdyb3VwLnRpdGxlKSB7XG4gICAgICAgIGdyb3VwX2VsLnRpdGxlID0gZ3JvdXAudGl0bGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5vdXRlckhUTUwoZ3JvdXBfZWwpO1xuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUucmVzdWx0c191cGRhdGVfZmllbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0X2RlZmF1bHRfdGV4dCgpO1xuICAgICAgaWYgKCF0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHRoaXMucmVzdWx0c19yZXNldF9jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc3VsdF9jbGVhcl9oaWdobGlnaHQoKTtcbiAgICAgIHRoaXMucmVzdWx0c19idWlsZCgpO1xuICAgICAgaWYgKHRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpbm5vd19yZXN1bHRzKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5yZXNldF9zaW5nbGVfc2VsZWN0X29wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHQsIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgIF9yZWYgPSB0aGlzLnJlc3VsdHNfZGF0YTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcmVzdWx0ID0gX3JlZltfaV07XG4gICAgICAgIGlmIChyZXN1bHQuc2VsZWN0ZWQpIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHJlc3VsdC5zZWxlY3RlZCA9IGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnJlc3VsdHNfdG9nZ2xlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3Nob3coKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnJlc3VsdHNfc2VhcmNoID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lubm93X3Jlc3VsdHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHNfc2hvdygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUud2lubm93X3Jlc3VsdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlc2NhcGVkU2VhcmNoVGV4dCwgb3B0aW9uLCByZWdleCwgcmVzdWx0cywgcmVzdWx0c19ncm91cCwgc2VhcmNoVGV4dCwgc3RhcnRwb3MsIHRleHQsIHpyZWdleCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgICB0aGlzLm5vX3Jlc3VsdHNfY2xlYXIoKTtcbiAgICAgIHJlc3VsdHMgPSAwO1xuICAgICAgc2VhcmNoVGV4dCA9IHRoaXMuZ2V0X3NlYXJjaF90ZXh0KCk7XG4gICAgICBlc2NhcGVkU2VhcmNoVGV4dCA9IHNlYXJjaFRleHQucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csIFwiXFxcXCQmXCIpO1xuICAgICAgenJlZ2V4ID0gbmV3IFJlZ0V4cChlc2NhcGVkU2VhcmNoVGV4dCwgJ2knKTtcbiAgICAgIHJlZ2V4ID0gdGhpcy5nZXRfc2VhcmNoX3JlZ2V4KGVzY2FwZWRTZWFyY2hUZXh0KTtcbiAgICAgIF9yZWYgPSB0aGlzLnJlc3VsdHNfZGF0YTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBvcHRpb24gPSBfcmVmW19pXTtcbiAgICAgICAgb3B0aW9uLnNlYXJjaF9tYXRjaCA9IGZhbHNlO1xuICAgICAgICByZXN1bHRzX2dyb3VwID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZV9vcHRpb25faW5fcmVzdWx0cyhvcHRpb24pKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbi5ncm91cCkge1xuICAgICAgICAgICAgb3B0aW9uLmdyb3VwX21hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICBvcHRpb24uYWN0aXZlX29wdGlvbnMgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKG9wdGlvbi5ncm91cF9hcnJheV9pbmRleCAhPSBudWxsKSAmJiB0aGlzLnJlc3VsdHNfZGF0YVtvcHRpb24uZ3JvdXBfYXJyYXlfaW5kZXhdKSB7XG4gICAgICAgICAgICByZXN1bHRzX2dyb3VwID0gdGhpcy5yZXN1bHRzX2RhdGFbb3B0aW9uLmdyb3VwX2FycmF5X2luZGV4XTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRzX2dyb3VwLmFjdGl2ZV9vcHRpb25zID09PSAwICYmIHJlc3VsdHNfZ3JvdXAuc2VhcmNoX21hdGNoKSB7XG4gICAgICAgICAgICAgIHJlc3VsdHMgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHNfZ3JvdXAuYWN0aXZlX29wdGlvbnMgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3B0aW9uLnNlYXJjaF90ZXh0ID0gb3B0aW9uLmdyb3VwID8gb3B0aW9uLmxhYmVsIDogb3B0aW9uLmh0bWw7XG4gICAgICAgICAgaWYgKCEob3B0aW9uLmdyb3VwICYmICF0aGlzLmdyb3VwX3NlYXJjaCkpIHtcbiAgICAgICAgICAgIG9wdGlvbi5zZWFyY2hfbWF0Y2ggPSB0aGlzLnNlYXJjaF9zdHJpbmdfbWF0Y2gob3B0aW9uLnNlYXJjaF90ZXh0LCByZWdleCk7XG4gICAgICAgICAgICBpZiAob3B0aW9uLnNlYXJjaF9tYXRjaCAmJiAhb3B0aW9uLmdyb3VwKSB7XG4gICAgICAgICAgICAgIHJlc3VsdHMgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb24uc2VhcmNoX21hdGNoKSB7XG4gICAgICAgICAgICAgIGlmIChzZWFyY2hUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0cG9zID0gb3B0aW9uLnNlYXJjaF90ZXh0LnNlYXJjaCh6cmVnZXgpO1xuICAgICAgICAgICAgICAgIHRleHQgPSBvcHRpb24uc2VhcmNoX3RleHQuc3Vic3RyKDAsIHN0YXJ0cG9zICsgc2VhcmNoVGV4dC5sZW5ndGgpICsgJzwvZW0+JyArIG9wdGlvbi5zZWFyY2hfdGV4dC5zdWJzdHIoc3RhcnRwb3MgKyBzZWFyY2hUZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlYXJjaF90ZXh0ID0gdGV4dC5zdWJzdHIoMCwgc3RhcnRwb3MpICsgJzxlbT4nICsgdGV4dC5zdWJzdHIoc3RhcnRwb3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHRzX2dyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzX2dyb3VwLmdyb3VwX21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICgob3B0aW9uLmdyb3VwX2FycmF5X2luZGV4ICE9IG51bGwpICYmIHRoaXMucmVzdWx0c19kYXRhW29wdGlvbi5ncm91cF9hcnJheV9pbmRleF0uc2VhcmNoX21hdGNoKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5zZWFyY2hfbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZXN1bHRfY2xlYXJfaGlnaGxpZ2h0KCk7XG4gICAgICBpZiAocmVzdWx0cyA8IDEgJiYgc2VhcmNoVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVfcmVzdWx0c19jb250ZW50KFwiXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5ub19yZXN1bHRzKHNlYXJjaFRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51cGRhdGVfcmVzdWx0c19jb250ZW50KHRoaXMucmVzdWx0c19vcHRpb25fYnVpbGQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLndpbm5vd19yZXN1bHRzX3NldF9oaWdobGlnaHQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmdldF9zZWFyY2hfcmVnZXggPSBmdW5jdGlvbihlc2NhcGVkX3NlYXJjaF9zdHJpbmcpIHtcbiAgICAgIHZhciByZWdleF9hbmNob3IsIHJlZ2V4X2ZsYWc7XG4gICAgICByZWdleF9hbmNob3IgPSB0aGlzLnNlYXJjaF9jb250YWlucyA/IFwiXCIgOiBcIl5cIjtcbiAgICAgIHJlZ2V4X2ZsYWcgPSB0aGlzLmNhc2Vfc2Vuc2l0aXZlX3NlYXJjaCA/IFwiXCIgOiBcImlcIjtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4X2FuY2hvciArIGVzY2FwZWRfc2VhcmNoX3N0cmluZywgcmVnZXhfZmxhZyk7XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5zZWFyY2hfc3RyaW5nX21hdGNoID0gZnVuY3Rpb24oc2VhcmNoX3N0cmluZywgcmVnZXgpIHtcbiAgICAgIHZhciBwYXJ0LCBwYXJ0cywgX2ksIF9sZW47XG4gICAgICBpZiAocmVnZXgudGVzdChzZWFyY2hfc3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5lbmFibGVfc3BsaXRfd29yZF9zZWFyY2ggJiYgKHNlYXJjaF9zdHJpbmcuaW5kZXhPZihcIiBcIikgPj0gMCB8fCBzZWFyY2hfc3RyaW5nLmluZGV4T2YoXCJbXCIpID09PSAwKSkge1xuICAgICAgICBwYXJ0cyA9IHNlYXJjaF9zdHJpbmcucmVwbGFjZSgvXFxbfFxcXS9nLCBcIlwiKS5zcGxpdChcIiBcIik7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHBhcnRzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBwYXJ0ID0gcGFydHNbX2ldO1xuICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QocGFydCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5jaG9pY2VzX2NvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0aW9uLCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkX29wdGlvbl9jb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkX29wdGlvbl9jb3VudDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VsZWN0ZWRfb3B0aW9uX2NvdW50ID0gMDtcbiAgICAgIF9yZWYgPSB0aGlzLmZvcm1fZmllbGQub3B0aW9ucztcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBvcHRpb24gPSBfcmVmW19pXTtcbiAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfb3B0aW9uX2NvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkX29wdGlvbl9jb3VudDtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmNob2ljZXNfY2xpY2sgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKCEodGhpcy5yZXN1bHRzX3Nob3dpbmcgfHwgdGhpcy5pc19kaXNhYmxlZCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19zaG93KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5rZXl1cF9jaGVja2VyID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgc3Ryb2tlLCBfcmVmO1xuICAgICAgc3Ryb2tlID0gKF9yZWYgPSBldnQud2hpY2gpICE9IG51bGwgPyBfcmVmIDogZXZ0LmtleUNvZGU7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZF9zY2FsZSgpO1xuICAgICAgc3dpdGNoIChzdHJva2UpIHtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlICYmIHRoaXMuYmFja3N0cm9rZV9sZW5ndGggPCAxICYmIHRoaXMuY2hvaWNlc19jb3VudCgpID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5ZG93bl9iYWNrc3Ryb2tlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5wZW5kaW5nX2JhY2tzdHJva2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19zZWFyY2goKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgaWYgKHRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRfc2VsZWN0KGV2dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIGlmICh0aGlzLnJlc3VsdHNfc2hvd2luZykge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzX2hpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgY2FzZSAzODpcbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgY2FzZSA5MTpcbiAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3NlYXJjaCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuY2xpcGJvYXJkX2V2ZW50X2NoZWNrZXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICByZXR1cm4gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5yZXN1bHRzX3NlYXJjaCgpO1xuICAgICAgfSksIDUwKTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmNvbnRhaW5lcl93aWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy53aWR0aCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJcIiArIHRoaXMuZm9ybV9maWVsZC5vZmZzZXRXaWR0aCArIFwicHhcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmluY2x1ZGVfb3B0aW9uX2luX3Jlc3VsdHMgPSBmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlICYmICghdGhpcy5kaXNwbGF5X3NlbGVjdGVkX29wdGlvbnMgJiYgb3B0aW9uLnNlbGVjdGVkKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZGlzcGxheV9kaXNhYmxlZF9vcHRpb25zICYmIG9wdGlvbi5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9uLmVtcHR5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuc2VhcmNoX3Jlc3VsdHNfdG91Y2hzdGFydCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdGhpcy50b3VjaF9zdGFydGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzX21vdXNlb3ZlcihldnQpO1xuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuc2VhcmNoX3Jlc3VsdHNfdG91Y2htb3ZlID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB0aGlzLnRvdWNoX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzX21vdXNlb3V0KGV2dCk7XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5zZWFyY2hfcmVzdWx0c190b3VjaGVuZCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKHRoaXMudG91Y2hfc3RhcnRlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfcmVzdWx0c19tb3VzZXVwKGV2dCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5vdXRlckhUTUwgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICB2YXIgdG1wO1xuICAgICAgaWYgKGVsZW1lbnQub3V0ZXJIVE1MKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50Lm91dGVySFRNTDtcbiAgICAgIH1cbiAgICAgIHRtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0bXAuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICByZXR1cm4gdG1wLmlubmVySFRNTDtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4uYnJvd3Nlcl9pc19zdXBwb3J0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChcIk1pY3Jvc29mdCBJbnRlcm5ldCBFeHBsb3JlclwiID09PSB3aW5kb3cubmF2aWdhdG9yLmFwcE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50TW9kZSA+PSA4O1xuICAgICAgfVxuICAgICAgaWYgKC9pUChvZHxob25lKS9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpIHx8IC9JRU1vYmlsZS9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpIHx8IC9XaW5kb3dzIFBob25lL2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgL0JsYWNrQmVycnkvaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSB8fCAvQkIxMC9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpIHx8IC9BbmRyb2lkLipNb2JpbGUvaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4uZGVmYXVsdF9tdWx0aXBsZV90ZXh0ID0gXCJTZWxlY3QgU29tZSBPcHRpb25zXCI7XG5cbiAgICBBYnN0cmFjdENob3Nlbi5kZWZhdWx0X3NpbmdsZV90ZXh0ID0gXCJTZWxlY3QgYW4gT3B0aW9uXCI7XG5cbiAgICBBYnN0cmFjdENob3Nlbi5kZWZhdWx0X25vX3Jlc3VsdF90ZXh0ID0gXCJObyByZXN1bHRzIG1hdGNoXCI7XG5cbiAgICByZXR1cm4gQWJzdHJhY3RDaG9zZW47XG5cbiAgfSkoKTtcblxuICAkID0galF1ZXJ5O1xuXG4gICQuZm4uZXh0ZW5kKHtcbiAgICBjaG9zZW46IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghQWJzdHJhY3RDaG9zZW4uYnJvd3Nlcl9pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaW5wdXRfZmllbGQpIHtcbiAgICAgICAgdmFyICR0aGlzLCBjaG9zZW47XG4gICAgICAgICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgY2hvc2VuID0gJHRoaXMuZGF0YSgnY2hvc2VuJyk7XG4gICAgICAgIGlmIChvcHRpb25zID09PSAnZGVzdHJveScpIHtcbiAgICAgICAgICBpZiAoY2hvc2VuIGluc3RhbmNlb2YgQ2hvc2VuKSB7XG4gICAgICAgICAgICBjaG9zZW4uZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoY2hvc2VuIGluc3RhbmNlb2YgQ2hvc2VuKSkge1xuICAgICAgICAgICR0aGlzLmRhdGEoJ2Nob3NlbicsIG5ldyBDaG9zZW4odGhpcywgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIENob3NlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2hvc2VuLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gQ2hvc2VuKCkge1xuICAgICAgX3JlZiA9IENob3Nlbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZm9ybV9maWVsZF9qcSA9ICQodGhpcy5mb3JtX2ZpZWxkKTtcbiAgICAgIHRoaXMuY3VycmVudF9zZWxlY3RlZEluZGV4ID0gdGhpcy5mb3JtX2ZpZWxkLnNlbGVjdGVkSW5kZXg7XG4gICAgICByZXR1cm4gdGhpcy5pc19ydGwgPSB0aGlzLmZvcm1fZmllbGRfanEuaGFzQ2xhc3MoXCJjaG9zZW4tcnRsXCIpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNldF91cF9odG1sID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29udGFpbmVyX2NsYXNzZXMsIGNvbnRhaW5lcl9wcm9wcztcbiAgICAgIGNvbnRhaW5lcl9jbGFzc2VzID0gW1wiY2hvc2VuLWNvbnRhaW5lclwiXTtcbiAgICAgIGNvbnRhaW5lcl9jbGFzc2VzLnB1c2goXCJjaG9zZW4tY29udGFpbmVyLVwiICsgKHRoaXMuaXNfbXVsdGlwbGUgPyBcIm11bHRpXCIgOiBcInNpbmdsZVwiKSk7XG4gICAgICBpZiAodGhpcy5pbmhlcml0X3NlbGVjdF9jbGFzc2VzICYmIHRoaXMuZm9ybV9maWVsZC5jbGFzc05hbWUpIHtcbiAgICAgICAgY29udGFpbmVyX2NsYXNzZXMucHVzaCh0aGlzLmZvcm1fZmllbGQuY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzX3J0bCkge1xuICAgICAgICBjb250YWluZXJfY2xhc3Nlcy5wdXNoKFwiY2hvc2VuLXJ0bFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnRhaW5lcl9wcm9wcyA9IHtcbiAgICAgICAgJ2NsYXNzJzogY29udGFpbmVyX2NsYXNzZXMuam9pbignICcpLFxuICAgICAgICAnc3R5bGUnOiBcIndpZHRoOiBcIiArICh0aGlzLmNvbnRhaW5lcl93aWR0aCgpKSArIFwiO1wiLFxuICAgICAgICAndGl0bGUnOiB0aGlzLmZvcm1fZmllbGQudGl0bGVcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5mb3JtX2ZpZWxkLmlkLmxlbmd0aCkge1xuICAgICAgICBjb250YWluZXJfcHJvcHMuaWQgPSB0aGlzLmZvcm1fZmllbGQuaWQucmVwbGFjZSgvW15cXHddL2csICdfJykgKyBcIl9jaG9zZW5cIjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyID0gJChcIjxkaXYgLz5cIiwgY29udGFpbmVyX3Byb3BzKTtcbiAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmh0bWwoJzx1bCBjbGFzcz1cImNob3Nlbi1jaG9pY2VzXCI+PGxpIGNsYXNzPVwic2VhcmNoLWZpZWxkXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgdmFsdWU9XCInICsgdGhpcy5kZWZhdWx0X3RleHQgKyAnXCIgY2xhc3M9XCJkZWZhdWx0XCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgc3R5bGU9XCJ3aWR0aDoyNXB4O1wiIC8+PC9saT48L3VsPjxkaXYgY2xhc3M9XCJjaG9zZW4tZHJvcFwiPjx1bCBjbGFzcz1cImNob3Nlbi1yZXN1bHRzXCI+PC91bD48L2Rpdj4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmh0bWwoJzxhIGNsYXNzPVwiY2hvc2VuLXNpbmdsZSBjaG9zZW4tZGVmYXVsdFwiPjxzcGFuPicgKyB0aGlzLmRlZmF1bHRfdGV4dCArICc8L3NwYW4+PGRpdj48Yj48L2I+PC9kaXY+PC9hPjxkaXYgY2xhc3M9XCJjaG9zZW4tZHJvcFwiPjxkaXYgY2xhc3M9XCJjaG9zZW4tc2VhcmNoXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgLz48L2Rpdj48dWwgY2xhc3M9XCJjaG9zZW4tcmVzdWx0c1wiPjwvdWw+PC9kaXY+Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLmZvcm1fZmllbGRfanEuaGlkZSgpLmFmdGVyKHRoaXMuY29udGFpbmVyKTtcbiAgICAgIHRoaXMuZHJvcGRvd24gPSB0aGlzLmNvbnRhaW5lci5maW5kKCdkaXYuY2hvc2VuLWRyb3AnKS5maXJzdCgpO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQgPSB0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dCcpLmZpcnN0KCk7XG4gICAgICB0aGlzLnNlYXJjaF9yZXN1bHRzID0gdGhpcy5jb250YWluZXIuZmluZCgndWwuY2hvc2VuLXJlc3VsdHMnKS5maXJzdCgpO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGRfc2NhbGUoKTtcbiAgICAgIHRoaXMuc2VhcmNoX25vX3Jlc3VsdHMgPSB0aGlzLmNvbnRhaW5lci5maW5kKCdsaS5uby1yZXN1bHRzJykuZmlyc3QoKTtcbiAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoX2Nob2ljZXMgPSB0aGlzLmNvbnRhaW5lci5maW5kKCd1bC5jaG9zZW4tY2hvaWNlcycpLmZpcnN0KCk7XG4gICAgICAgIHRoaXMuc2VhcmNoX2NvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLmZpbmQoJ2xpLnNlYXJjaC1maWVsZCcpLmZpcnN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlYXJjaF9jb250YWluZXIgPSB0aGlzLmNvbnRhaW5lci5maW5kKCdkaXYuY2hvc2VuLXNlYXJjaCcpLmZpcnN0KCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfaXRlbSA9IHRoaXMuY29udGFpbmVyLmZpbmQoJy5jaG9zZW4tc2luZ2xlJykuZmlyc3QoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzdWx0c19idWlsZCgpO1xuICAgICAgdGhpcy5zZXRfdGFiX2luZGV4KCk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRfbGFiZWxfYmVoYXZpb3IoKTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5vbl9yZWFkeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hvc2VuOnJlYWR5XCIsIHtcbiAgICAgICAgY2hvc2VuOiB0aGlzXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZWdpc3Rlcl9vYnNlcnZlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLmNvbnRhaW5lci5iaW5kKCd0b3VjaHN0YXJ0LmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5jb250YWluZXJfbW91c2Vkb3duKGV2dCk7XG4gICAgICAgIHJldHVybiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb250YWluZXIuYmluZCgndG91Y2hlbmQuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLmNvbnRhaW5lcl9tb3VzZXVwKGV2dCk7XG4gICAgICAgIHJldHVybiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb250YWluZXIuYmluZCgnbW91c2Vkb3duLmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5jb250YWluZXJfbW91c2Vkb3duKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmJpbmQoJ21vdXNldXAuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLmNvbnRhaW5lcl9tb3VzZXVwKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmJpbmQoJ21vdXNlZW50ZXIuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLm1vdXNlX2VudGVyKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmJpbmQoJ21vdXNlbGVhdmUuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLm1vdXNlX2xlYXZlKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX3Jlc3VsdHMuYmluZCgnbW91c2V1cC5jaG9zZW4nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3RoaXMuc2VhcmNoX3Jlc3VsdHNfbW91c2V1cChldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNlYXJjaF9yZXN1bHRzLmJpbmQoJ21vdXNlb3Zlci5jaG9zZW4nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3RoaXMuc2VhcmNoX3Jlc3VsdHNfbW91c2VvdmVyKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX3Jlc3VsdHMuYmluZCgnbW91c2VvdXQuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLnNlYXJjaF9yZXN1bHRzX21vdXNlb3V0KGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX3Jlc3VsdHMuYmluZCgnbW91c2V3aGVlbC5jaG9zZW4gRE9NTW91c2VTY3JvbGwuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLnNlYXJjaF9yZXN1bHRzX21vdXNld2hlZWwoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfcmVzdWx0cy5iaW5kKCd0b3VjaHN0YXJ0LmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5zZWFyY2hfcmVzdWx0c190b3VjaHN0YXJ0KGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX3Jlc3VsdHMuYmluZCgndG91Y2htb3ZlLmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5zZWFyY2hfcmVzdWx0c190b3VjaG1vdmUoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfcmVzdWx0cy5iaW5kKCd0b3VjaGVuZC5jaG9zZW4nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3RoaXMuc2VhcmNoX3Jlc3VsdHNfdG91Y2hlbmQoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLmJpbmQoXCJjaG9zZW46dXBkYXRlZC5jaG9zZW5cIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLnJlc3VsdHNfdXBkYXRlX2ZpZWxkKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS5iaW5kKFwiY2hvc2VuOmFjdGl2YXRlLmNob3NlblwiLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3RoaXMuYWN0aXZhdGVfZmllbGQoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLmJpbmQoXCJjaG9zZW46b3Blbi5jaG9zZW5cIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLmNvbnRhaW5lcl9tb3VzZWRvd24oZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLmJpbmQoXCJjaG9zZW46Y2xvc2UuY2hvc2VuXCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5pbnB1dF9ibHVyKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLmJpbmQoJ2JsdXIuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLmlucHV0X2JsdXIoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQuYmluZCgna2V5dXAuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLmtleXVwX2NoZWNrZXIoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQuYmluZCgna2V5ZG93bi5jaG9zZW4nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3RoaXMua2V5ZG93bl9jaGVja2VyKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLmJpbmQoJ2ZvY3VzLmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5pbnB1dF9mb2N1cyhldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZC5iaW5kKCdjdXQuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLmNsaXBib2FyZF9ldmVudF9jaGVja2VyKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLmJpbmQoJ3Bhc3RlLmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5jbGlwYm9hcmRfZXZlbnRfY2hlY2tlcihldnQpO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfY2hvaWNlcy5iaW5kKCdjbGljay5jaG9zZW4nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICBfdGhpcy5jaG9pY2VzX2NsaWNrKGV2dCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLmJpbmQoJ2NsaWNrLmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAkKHRoaXMuY29udGFpbmVyWzBdLm93bmVyRG9jdW1lbnQpLnVuYmluZChcImNsaWNrLmNob3NlblwiLCB0aGlzLmNsaWNrX3Rlc3RfYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLnNlYXJjaF9maWVsZFswXS50YWJJbmRleCkge1xuICAgICAgICB0aGlzLmZvcm1fZmllbGRfanFbMF0udGFiSW5kZXggPSB0aGlzLnNlYXJjaF9maWVsZFswXS50YWJJbmRleDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLnJlbW92ZURhdGEoJ2Nob3NlbicpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybV9maWVsZF9qcS5zaG93KCk7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2VhcmNoX2ZpZWxkX2Rpc2FibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzX2Rpc2FibGVkID0gdGhpcy5mb3JtX2ZpZWxkX2pxWzBdLmRpc2FibGVkO1xuICAgICAgaWYgKHRoaXMuaXNfZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoJ2Nob3Nlbi1kaXNhYmxlZCcpO1xuICAgICAgICB0aGlzLnNlYXJjaF9maWVsZFswXS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfaXRlbS51bmJpbmQoXCJmb2N1cy5jaG9zZW5cIiwgdGhpcy5hY3RpdmF0ZV9hY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlX2ZpZWxkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcygnY2hvc2VuLWRpc2FibGVkJyk7XG4gICAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkWzBdLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkX2l0ZW0uYmluZChcImZvY3VzLmNob3NlblwiLCB0aGlzLmFjdGl2YXRlX2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5jb250YWluZXJfbW91c2Vkb3duID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAoIXRoaXMuaXNfZGlzYWJsZWQpIHtcbiAgICAgICAgaWYgKGV2dCAmJiBldnQudHlwZSA9PT0gXCJtb3VzZWRvd25cIiAmJiAhdGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgoZXZ0ICE9IG51bGwpICYmICgkKGV2dC50YXJnZXQpKS5oYXNDbGFzcyhcInNlYXJjaC1jaG9pY2UtY2xvc2VcIikpKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZV9maWVsZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZWFyY2hfZmllbGQudmFsKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJCh0aGlzLmNvbnRhaW5lclswXS5vd25lckRvY3VtZW50KS5iaW5kKCdjbGljay5jaG9zZW4nLCB0aGlzLmNsaWNrX3Rlc3RfYWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0c19zaG93KCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc19tdWx0aXBsZSAmJiBldnQgJiYgKCgkKGV2dC50YXJnZXQpWzBdID09PSB0aGlzLnNlbGVjdGVkX2l0ZW1bMF0pIHx8ICQoZXZ0LnRhcmdldCkucGFyZW50cyhcImEuY2hvc2VuLXNpbmdsZVwiKS5sZW5ndGgpKSB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0c190b2dnbGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZhdGVfZmllbGQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmNvbnRhaW5lcl9tb3VzZXVwID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAoZXZ0LnRhcmdldC5ub2RlTmFtZSA9PT0gXCJBQkJSXCIgJiYgIXRoaXMuaXNfZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19yZXNldChldnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNlYXJjaF9yZXN1bHRzX21vdXNld2hlZWwgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBkZWx0YTtcbiAgICAgIGlmIChldnQub3JpZ2luYWxFdmVudCkge1xuICAgICAgICBkZWx0YSA9IGV2dC5vcmlnaW5hbEV2ZW50LmRlbHRhWSB8fCAtZXZ0Lm9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YSB8fCBldnQub3JpZ2luYWxFdmVudC5kZXRhaWw7XG4gICAgICB9XG4gICAgICBpZiAoZGVsdGEgIT0gbnVsbCkge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKGV2dC50eXBlID09PSAnRE9NTW91c2VTY3JvbGwnKSB7XG4gICAgICAgICAgZGVsdGEgPSBkZWx0YSAqIDQwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzLnNjcm9sbFRvcChkZWx0YSArIHRoaXMuc2VhcmNoX3Jlc3VsdHMuc2Nyb2xsVG9wKCkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmJsdXJfdGVzdCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKCF0aGlzLmFjdGl2ZV9maWVsZCAmJiB0aGlzLmNvbnRhaW5lci5oYXNDbGFzcyhcImNob3Nlbi1jb250YWluZXItYWN0aXZlXCIpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlX2ZpZWxkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY2xvc2VfZmllbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgICQodGhpcy5jb250YWluZXJbMF0ub3duZXJEb2N1bWVudCkudW5iaW5kKFwiY2xpY2suY2hvc2VuXCIsIHRoaXMuY2xpY2tfdGVzdF9hY3Rpb24pO1xuICAgICAgdGhpcy5hY3RpdmVfZmllbGQgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVzdWx0c19oaWRlKCk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcImNob3Nlbi1jb250YWluZXItYWN0aXZlXCIpO1xuICAgICAgdGhpcy5jbGVhcl9iYWNrc3Ryb2tlKCk7XG4gICAgICB0aGlzLnNob3dfc2VhcmNoX2ZpZWxkX2RlZmF1bHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZF9zY2FsZSgpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmFjdGl2YXRlX2ZpZWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcyhcImNob3Nlbi1jb250YWluZXItYWN0aXZlXCIpO1xuICAgICAgdGhpcy5hY3RpdmVfZmllbGQgPSB0cnVlO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQudmFsKHRoaXMuc2VhcmNoX2ZpZWxkLnZhbCgpKTtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZC5mb2N1cygpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnRlc3RfYWN0aXZlX2NsaWNrID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgYWN0aXZlX2NvbnRhaW5lcjtcbiAgICAgIGFjdGl2ZV9jb250YWluZXIgPSAkKGV2dC50YXJnZXQpLmNsb3Nlc3QoJy5jaG9zZW4tY29udGFpbmVyJyk7XG4gICAgICBpZiAoYWN0aXZlX2NvbnRhaW5lci5sZW5ndGggJiYgdGhpcy5jb250YWluZXJbMF0gPT09IGFjdGl2ZV9jb250YWluZXJbMF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlX2ZpZWxkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlX2ZpZWxkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0c19idWlsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wYXJzaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2VsZWN0ZWRfb3B0aW9uX2NvdW50ID0gbnVsbDtcbiAgICAgIHRoaXMucmVzdWx0c19kYXRhID0gU2VsZWN0UGFyc2VyLnNlbGVjdF90b19hcnJheSh0aGlzLmZvcm1fZmllbGQpO1xuICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hfY2hvaWNlcy5maW5kKFwibGkuc2VhcmNoLWNob2ljZVwiKS5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5zaW5nbGVfc2V0X3NlbGVjdGVkX3RleHQoKTtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZV9zZWFyY2ggfHwgdGhpcy5mb3JtX2ZpZWxkLm9wdGlvbnMubGVuZ3RoIDw9IHRoaXMuZGlzYWJsZV9zZWFyY2hfdGhyZXNob2xkKSB7XG4gICAgICAgICAgdGhpcy5zZWFyY2hfZmllbGRbMF0ucmVhZE9ubHkgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKFwiY2hvc2VuLWNvbnRhaW5lci1zaW5nbGUtbm9zZWFyY2hcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWFyY2hfZmllbGRbMF0ucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcImNob3Nlbi1jb250YWluZXItc2luZ2xlLW5vc2VhcmNoXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZV9yZXN1bHRzX2NvbnRlbnQodGhpcy5yZXN1bHRzX29wdGlvbl9idWlsZCh7XG4gICAgICAgIGZpcnN0OiB0cnVlXG4gICAgICB9KSk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZF9kaXNhYmxlZCgpO1xuICAgICAgdGhpcy5zaG93X3NlYXJjaF9maWVsZF9kZWZhdWx0KCk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZF9zY2FsZSgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2luZyA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9kb19oaWdobGlnaHQgPSBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGhpZ2hfYm90dG9tLCBoaWdoX3RvcCwgbWF4SGVpZ2h0LCB2aXNpYmxlX2JvdHRvbSwgdmlzaWJsZV90b3A7XG4gICAgICBpZiAoZWwubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICB0aGlzLnJlc3VsdF9oaWdobGlnaHQgPSBlbDtcbiAgICAgICAgdGhpcy5yZXN1bHRfaGlnaGxpZ2h0LmFkZENsYXNzKFwiaGlnaGxpZ2h0ZWRcIik7XG4gICAgICAgIG1heEhlaWdodCA9IHBhcnNlSW50KHRoaXMuc2VhcmNoX3Jlc3VsdHMuY3NzKFwibWF4SGVpZ2h0XCIpLCAxMCk7XG4gICAgICAgIHZpc2libGVfdG9wID0gdGhpcy5zZWFyY2hfcmVzdWx0cy5zY3JvbGxUb3AoKTtcbiAgICAgICAgdmlzaWJsZV9ib3R0b20gPSBtYXhIZWlnaHQgKyB2aXNpYmxlX3RvcDtcbiAgICAgICAgaGlnaF90b3AgPSB0aGlzLnJlc3VsdF9oaWdobGlnaHQucG9zaXRpb24oKS50b3AgKyB0aGlzLnNlYXJjaF9yZXN1bHRzLnNjcm9sbFRvcCgpO1xuICAgICAgICBoaWdoX2JvdHRvbSA9IGhpZ2hfdG9wICsgdGhpcy5yZXN1bHRfaGlnaGxpZ2h0Lm91dGVySGVpZ2h0KCk7XG4gICAgICAgIGlmIChoaWdoX2JvdHRvbSA+PSB2aXNpYmxlX2JvdHRvbSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzLnNjcm9sbFRvcCgoaGlnaF9ib3R0b20gLSBtYXhIZWlnaHQpID4gMCA/IGhpZ2hfYm90dG9tIC0gbWF4SGVpZ2h0IDogMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGlnaF90b3AgPCB2aXNpYmxlX3RvcCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzLnNjcm9sbFRvcChoaWdoX3RvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZXN1bHRfY2xlYXJfaGlnaGxpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5yZXN1bHRfaGlnaGxpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVzdWx0X2hpZ2hsaWdodC5yZW1vdmVDbGFzcyhcImhpZ2hsaWdodGVkXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0X2hpZ2hsaWdodCA9IG51bGw7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0c19zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSAmJiB0aGlzLm1heF9zZWxlY3RlZF9vcHRpb25zIDw9IHRoaXMuY2hvaWNlc19jb3VudCgpKSB7XG4gICAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hvc2VuOm1heHNlbGVjdGVkXCIsIHtcbiAgICAgICAgICBjaG9zZW46IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKFwiY2hvc2VuLXdpdGgtZHJvcFwiKTtcbiAgICAgIHRoaXMucmVzdWx0c19zaG93aW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLmZvY3VzKCk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZC52YWwodGhpcy5zZWFyY2hfZmllbGQudmFsKCkpO1xuICAgICAgdGhpcy53aW5ub3dfcmVzdWx0cygpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hvc2VuOnNob3dpbmdfZHJvcGRvd25cIiwge1xuICAgICAgICBjaG9zZW46IHRoaXNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnVwZGF0ZV9yZXN1bHRzX2NvbnRlbnQgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWFyY2hfcmVzdWx0cy5odG1sKGNvbnRlbnQpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdHNfaGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcImNob3Nlbi13aXRoLWRyb3BcIik7XG4gICAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hvc2VuOmhpZGluZ19kcm9wZG93blwiLCB7XG4gICAgICAgICAgY2hvc2VuOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19zaG93aW5nID0gZmFsc2U7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2V0X3RhYl9pbmRleCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgdGk7XG4gICAgICBpZiAodGhpcy5mb3JtX2ZpZWxkLnRhYkluZGV4KSB7XG4gICAgICAgIHRpID0gdGhpcy5mb3JtX2ZpZWxkLnRhYkluZGV4O1xuICAgICAgICB0aGlzLmZvcm1fZmllbGQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoX2ZpZWxkWzBdLnRhYkluZGV4ID0gdGk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2V0X2xhYmVsX2JlaGF2aW9yID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2xhYmVsID0gdGhpcy5mb3JtX2ZpZWxkX2pxLnBhcmVudHMoXCJsYWJlbFwiKTtcbiAgICAgIGlmICghdGhpcy5mb3JtX2ZpZWxkX2xhYmVsLmxlbmd0aCAmJiB0aGlzLmZvcm1fZmllbGQuaWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZm9ybV9maWVsZF9sYWJlbCA9ICQoXCJsYWJlbFtmb3I9J1wiICsgdGhpcy5mb3JtX2ZpZWxkLmlkICsgXCInXVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZvcm1fZmllbGRfbGFiZWwubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtX2ZpZWxkX2xhYmVsLmJpbmQoJ2NsaWNrLmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIGlmIChfdGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvbnRhaW5lcl9tb3VzZWRvd24oZXZ0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFjdGl2YXRlX2ZpZWxkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5zaG93X3NlYXJjaF9maWVsZF9kZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSAmJiB0aGlzLmNob2ljZXNfY291bnQoKSA8IDEgJiYgIXRoaXMuYWN0aXZlX2ZpZWxkKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLnZhbCh0aGlzLmRlZmF1bHRfdGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZC5hZGRDbGFzcyhcImRlZmF1bHRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlYXJjaF9maWVsZC52YWwoXCJcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZC5yZW1vdmVDbGFzcyhcImRlZmF1bHRcIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2VhcmNoX3Jlc3VsdHNfbW91c2V1cCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIHRhcmdldDtcbiAgICAgIHRhcmdldCA9ICQoZXZ0LnRhcmdldCkuaGFzQ2xhc3MoXCJhY3RpdmUtcmVzdWx0XCIpID8gJChldnQudGFyZ2V0KSA6ICQoZXZ0LnRhcmdldCkucGFyZW50cyhcIi5hY3RpdmUtcmVzdWx0XCIpLmZpcnN0KCk7XG4gICAgICBpZiAodGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLnJlc3VsdF9oaWdobGlnaHQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucmVzdWx0X3NlbGVjdChldnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfZmllbGQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5zZWFyY2hfcmVzdWx0c19tb3VzZW92ZXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciB0YXJnZXQ7XG4gICAgICB0YXJnZXQgPSAkKGV2dC50YXJnZXQpLmhhc0NsYXNzKFwiYWN0aXZlLXJlc3VsdFwiKSA/ICQoZXZ0LnRhcmdldCkgOiAkKGV2dC50YXJnZXQpLnBhcmVudHMoXCIuYWN0aXZlLXJlc3VsdFwiKS5maXJzdCgpO1xuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRfZG9faGlnaGxpZ2h0KHRhcmdldCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2VhcmNoX3Jlc3VsdHNfbW91c2VvdXQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGlmICgkKGV2dC50YXJnZXQpLmhhc0NsYXNzKFwiYWN0aXZlLXJlc3VsdFwiIHx8ICQoZXZ0LnRhcmdldCkucGFyZW50cygnLmFjdGl2ZS1yZXN1bHQnKS5maXJzdCgpKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRfY2xlYXJfaGlnaGxpZ2h0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY2hvaWNlX2J1aWxkID0gZnVuY3Rpb24oaXRlbSkge1xuICAgICAgdmFyIGNob2ljZSwgY2xvc2VfbGluayxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgY2hvaWNlID0gJCgnPGxpIC8+Jywge1xuICAgICAgICBcImNsYXNzXCI6IFwic2VhcmNoLWNob2ljZVwiXG4gICAgICB9KS5odG1sKFwiPHNwYW4+XCIgKyAodGhpcy5jaG9pY2VfbGFiZWwoaXRlbSkpICsgXCI8L3NwYW4+XCIpO1xuICAgICAgaWYgKGl0ZW0uZGlzYWJsZWQpIHtcbiAgICAgICAgY2hvaWNlLmFkZENsYXNzKCdzZWFyY2gtY2hvaWNlLWRpc2FibGVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9zZV9saW5rID0gJCgnPGEgLz4nLCB7XG4gICAgICAgICAgXCJjbGFzc1wiOiAnc2VhcmNoLWNob2ljZS1jbG9zZScsXG4gICAgICAgICAgJ2RhdGEtb3B0aW9uLWFycmF5LWluZGV4JzogaXRlbS5hcnJheV9pbmRleFxuICAgICAgICB9KTtcbiAgICAgICAgY2xvc2VfbGluay5iaW5kKCdjbGljay5jaG9zZW4nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuY2hvaWNlX2Rlc3Ryb3lfbGlua19jbGljayhldnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hvaWNlLmFwcGVuZChjbG9zZV9saW5rKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9jb250YWluZXIuYmVmb3JlKGNob2ljZSk7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY2hvaWNlX2Rlc3Ryb3lfbGlua19jbGljayA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBpZiAoIXRoaXMuaXNfZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hvaWNlX2Rlc3Ryb3koJChldnQudGFyZ2V0KSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY2hvaWNlX2Rlc3Ryb3kgPSBmdW5jdGlvbihsaW5rKSB7XG4gICAgICBpZiAodGhpcy5yZXN1bHRfZGVzZWxlY3QobGlua1swXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW9wdGlvbi1hcnJheS1pbmRleFwiKSkpIHtcbiAgICAgICAgdGhpcy5zaG93X3NlYXJjaF9maWVsZF9kZWZhdWx0KCk7XG4gICAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlICYmIHRoaXMuY2hvaWNlc19jb3VudCgpID4gMCAmJiB0aGlzLnNlYXJjaF9maWVsZC52YWwoKS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgdGhpcy5yZXN1bHRzX2hpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5rLnBhcmVudHMoJ2xpJykuZmlyc3QoKS5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoX2ZpZWxkX3NjYWxlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0c19yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZXNldF9zaW5nbGVfc2VsZWN0X29wdGlvbnMoKTtcbiAgICAgIHRoaXMuZm9ybV9maWVsZC5vcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2luZ2xlX3NldF9zZWxlY3RlZF90ZXh0KCk7XG4gICAgICB0aGlzLnNob3dfc2VhcmNoX2ZpZWxkX2RlZmF1bHQoKTtcbiAgICAgIHRoaXMucmVzdWx0c19yZXNldF9jbGVhbnVwKCk7XG4gICAgICB0aGlzLmZvcm1fZmllbGRfanEudHJpZ2dlcihcImNoYW5nZVwiKTtcbiAgICAgIGlmICh0aGlzLmFjdGl2ZV9maWVsZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX2hpZGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZXN1bHRzX3Jlc2V0X2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY3VycmVudF9zZWxlY3RlZEluZGV4ID0gdGhpcy5mb3JtX2ZpZWxkLnNlbGVjdGVkSW5kZXg7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZF9pdGVtLmZpbmQoXCJhYmJyXCIpLnJlbW92ZSgpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9zZWxlY3QgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBoaWdoLCBpdGVtO1xuICAgICAgaWYgKHRoaXMucmVzdWx0X2hpZ2hsaWdodCkge1xuICAgICAgICBoaWdoID0gdGhpcy5yZXN1bHRfaGlnaGxpZ2h0O1xuICAgICAgICB0aGlzLnJlc3VsdF9jbGVhcl9oaWdobGlnaHQoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUgJiYgdGhpcy5tYXhfc2VsZWN0ZWRfb3B0aW9ucyA8PSB0aGlzLmNob2ljZXNfY291bnQoKSkge1xuICAgICAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hvc2VuOm1heHNlbGVjdGVkXCIsIHtcbiAgICAgICAgICAgIGNob3NlbjogdGhpc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICAgIGhpZ2gucmVtb3ZlQ2xhc3MoXCJhY3RpdmUtcmVzdWx0XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVzZXRfc2luZ2xlX3NlbGVjdF9vcHRpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgaGlnaC5hZGRDbGFzcyhcInJlc3VsdC1zZWxlY3RlZFwiKTtcbiAgICAgICAgaXRlbSA9IHRoaXMucmVzdWx0c19kYXRhW2hpZ2hbMF0uZ2V0QXR0cmlidXRlKFwiZGF0YS1vcHRpb24tYXJyYXktaW5kZXhcIildO1xuICAgICAgICBpdGVtLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mb3JtX2ZpZWxkLm9wdGlvbnNbaXRlbS5vcHRpb25zX2luZGV4XS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfb3B0aW9uX2NvdW50ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgICB0aGlzLmNob2ljZV9idWlsZChpdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNpbmdsZV9zZXRfc2VsZWN0ZWRfdGV4dCh0aGlzLmNob2ljZV9sYWJlbChpdGVtKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoKGV2dC5tZXRhS2V5IHx8IGV2dC5jdHJsS2V5KSAmJiB0aGlzLmlzX211bHRpcGxlKSkge1xuICAgICAgICAgIHRoaXMucmVzdWx0c19oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaG93X3NlYXJjaF9maWVsZF9kZWZhdWx0KCk7XG4gICAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlIHx8IHRoaXMuZm9ybV9maWVsZC5zZWxlY3RlZEluZGV4ICE9PSB0aGlzLmN1cnJlbnRfc2VsZWN0ZWRJbmRleCkge1xuICAgICAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hhbmdlXCIsIHtcbiAgICAgICAgICAgICdzZWxlY3RlZCc6IHRoaXMuZm9ybV9maWVsZC5vcHRpb25zW2l0ZW0ub3B0aW9uc19pbmRleF0udmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRfc2VsZWN0ZWRJbmRleCA9IHRoaXMuZm9ybV9maWVsZC5zZWxlY3RlZEluZGV4O1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoX2ZpZWxkX3NjYWxlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2luZ2xlX3NldF9zZWxlY3RlZF90ZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgaWYgKHRleHQgPT0gbnVsbCkge1xuICAgICAgICB0ZXh0ID0gdGhpcy5kZWZhdWx0X3RleHQ7XG4gICAgICB9XG4gICAgICBpZiAodGV4dCA9PT0gdGhpcy5kZWZhdWx0X3RleHQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZF9pdGVtLmFkZENsYXNzKFwiY2hvc2VuLWRlZmF1bHRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNpbmdsZV9kZXNlbGVjdF9jb250cm9sX2J1aWxkKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfaXRlbS5yZW1vdmVDbGFzcyhcImNob3Nlbi1kZWZhdWx0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRfaXRlbS5maW5kKFwic3BhblwiKS5odG1sKHRleHQpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9kZXNlbGVjdCA9IGZ1bmN0aW9uKHBvcykge1xuICAgICAgdmFyIHJlc3VsdF9kYXRhO1xuICAgICAgcmVzdWx0X2RhdGEgPSB0aGlzLnJlc3VsdHNfZGF0YVtwb3NdO1xuICAgICAgaWYgKCF0aGlzLmZvcm1fZmllbGQub3B0aW9uc1tyZXN1bHRfZGF0YS5vcHRpb25zX2luZGV4XS5kaXNhYmxlZCkge1xuICAgICAgICByZXN1bHRfZGF0YS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZvcm1fZmllbGQub3B0aW9uc1tyZXN1bHRfZGF0YS5vcHRpb25zX2luZGV4XS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbGVjdGVkX29wdGlvbl9jb3VudCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgICB0aGlzLndpbm5vd19yZXN1bHRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLnRyaWdnZXIoXCJjaGFuZ2VcIiwge1xuICAgICAgICAgIGRlc2VsZWN0ZWQ6IHRoaXMuZm9ybV9maWVsZC5vcHRpb25zW3Jlc3VsdF9kYXRhLm9wdGlvbnNfaW5kZXhdLnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlYXJjaF9maWVsZF9zY2FsZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5zaW5nbGVfZGVzZWxlY3RfY29udHJvbF9idWlsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmFsbG93X3NpbmdsZV9kZXNlbGVjdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc2VsZWN0ZWRfaXRlbS5maW5kKFwiYWJiclwiKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZF9pdGVtLmZpbmQoXCJzcGFuXCIpLmZpcnN0KCkuYWZ0ZXIoXCI8YWJiciBjbGFzcz1cXFwic2VhcmNoLWNob2ljZS1jbG9zZVxcXCI+PC9hYmJyPlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkX2l0ZW0uYWRkQ2xhc3MoXCJjaG9zZW4tc2luZ2xlLXdpdGgtZGVzZWxlY3RcIik7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuZ2V0X3NlYXJjaF90ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJCgnPGRpdi8+JykudGV4dCgkLnRyaW0odGhpcy5zZWFyY2hfZmllbGQudmFsKCkpKS5odG1sKCk7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUud2lubm93X3Jlc3VsdHNfc2V0X2hpZ2hsaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRvX2hpZ2gsIHNlbGVjdGVkX3Jlc3VsdHM7XG4gICAgICBzZWxlY3RlZF9yZXN1bHRzID0gIXRoaXMuaXNfbXVsdGlwbGUgPyB0aGlzLnNlYXJjaF9yZXN1bHRzLmZpbmQoXCIucmVzdWx0LXNlbGVjdGVkLmFjdGl2ZS1yZXN1bHRcIikgOiBbXTtcbiAgICAgIGRvX2hpZ2ggPSBzZWxlY3RlZF9yZXN1bHRzLmxlbmd0aCA/IHNlbGVjdGVkX3Jlc3VsdHMuZmlyc3QoKSA6IHRoaXMuc2VhcmNoX3Jlc3VsdHMuZmluZChcIi5hY3RpdmUtcmVzdWx0XCIpLmZpcnN0KCk7XG4gICAgICBpZiAoZG9faGlnaCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdF9kb19oaWdobGlnaHQoZG9faGlnaCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUubm9fcmVzdWx0cyA9IGZ1bmN0aW9uKHRlcm1zKSB7XG4gICAgICB2YXIgbm9fcmVzdWx0c19odG1sO1xuICAgICAgbm9fcmVzdWx0c19odG1sID0gJCgnPGxpIGNsYXNzPVwibm8tcmVzdWx0c1wiPicgKyB0aGlzLnJlc3VsdHNfbm9uZV9mb3VuZCArICcgXCI8c3Bhbj48L3NwYW4+XCI8L2xpPicpO1xuICAgICAgbm9fcmVzdWx0c19odG1sLmZpbmQoXCJzcGFuXCIpLmZpcnN0KCkuaHRtbCh0ZXJtcyk7XG4gICAgICB0aGlzLnNlYXJjaF9yZXN1bHRzLmFwcGVuZChub19yZXN1bHRzX2h0bWwpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hvc2VuOm5vX3Jlc3VsdHNcIiwge1xuICAgICAgICBjaG9zZW46IHRoaXNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLm5vX3Jlc3VsdHNfY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzLmZpbmQoXCIubm8tcmVzdWx0c1wiKS5yZW1vdmUoKTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5rZXlkb3duX2Fycm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmV4dF9zaWI7XG4gICAgICBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcgJiYgdGhpcy5yZXN1bHRfaGlnaGxpZ2h0KSB7XG4gICAgICAgIG5leHRfc2liID0gdGhpcy5yZXN1bHRfaGlnaGxpZ2h0Lm5leHRBbGwoXCJsaS5hY3RpdmUtcmVzdWx0XCIpLmZpcnN0KCk7XG4gICAgICAgIGlmIChuZXh0X3NpYikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdF9kb19oaWdobGlnaHQobmV4dF9zaWIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3Nob3coKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5rZXl1cF9hcnJvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHByZXZfc2licztcbiAgICAgIGlmICghdGhpcy5yZXN1bHRzX3Nob3dpbmcgJiYgIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19zaG93KCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucmVzdWx0X2hpZ2hsaWdodCkge1xuICAgICAgICBwcmV2X3NpYnMgPSB0aGlzLnJlc3VsdF9oaWdobGlnaHQucHJldkFsbChcImxpLmFjdGl2ZS1yZXN1bHRcIik7XG4gICAgICAgIGlmIChwcmV2X3NpYnMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0X2RvX2hpZ2hsaWdodChwcmV2X3NpYnMuZmlyc3QoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuY2hvaWNlc19jb3VudCgpID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzX2hpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUua2V5ZG93bl9iYWNrc3Ryb2tlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmV4dF9hdmFpbGFibGVfZGVzdHJveTtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdfYmFja3N0cm9rZSkge1xuICAgICAgICB0aGlzLmNob2ljZV9kZXN0cm95KHRoaXMucGVuZGluZ19iYWNrc3Ryb2tlLmZpbmQoXCJhXCIpLmZpcnN0KCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jbGVhcl9iYWNrc3Ryb2tlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0X2F2YWlsYWJsZV9kZXN0cm95ID0gdGhpcy5zZWFyY2hfY29udGFpbmVyLnNpYmxpbmdzKFwibGkuc2VhcmNoLWNob2ljZVwiKS5sYXN0KCk7XG4gICAgICAgIGlmIChuZXh0X2F2YWlsYWJsZV9kZXN0cm95Lmxlbmd0aCAmJiAhbmV4dF9hdmFpbGFibGVfZGVzdHJveS5oYXNDbGFzcyhcInNlYXJjaC1jaG9pY2UtZGlzYWJsZWRcIikpIHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdfYmFja3N0cm9rZSA9IG5leHRfYXZhaWxhYmxlX2Rlc3Ryb3k7XG4gICAgICAgICAgaWYgKHRoaXMuc2luZ2xlX2JhY2tzdHJva2VfZGVsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlkb3duX2JhY2tzdHJva2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ19iYWNrc3Ryb2tlLmFkZENsYXNzKFwic2VhcmNoLWNob2ljZS1mb2N1c1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5jbGVhcl9iYWNrc3Ryb2tlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nX2JhY2tzdHJva2UpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nX2JhY2tzdHJva2UucmVtb3ZlQ2xhc3MoXCJzZWFyY2gtY2hvaWNlLWZvY3VzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ19iYWNrc3Ryb2tlID0gbnVsbDtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5rZXlkb3duX2NoZWNrZXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBzdHJva2UsIF9yZWYxO1xuICAgICAgc3Ryb2tlID0gKF9yZWYxID0gZXZ0LndoaWNoKSAhPSBudWxsID8gX3JlZjEgOiBldnQua2V5Q29kZTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkX3NjYWxlKCk7XG4gICAgICBpZiAoc3Ryb2tlICE9PSA4ICYmIHRoaXMucGVuZGluZ19iYWNrc3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuY2xlYXJfYmFja3N0cm9rZSgpO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChzdHJva2UpIHtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHRoaXMuYmFja3N0cm9rZV9sZW5ndGggPSB0aGlzLnNlYXJjaF9maWVsZC52YWwoKS5sZW5ndGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcgJiYgIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0X3NlbGVjdChldnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm1vdXNlX29uX2NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGlmICh0aGlzLnJlc3VsdHNfc2hvd2luZykge1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVfc2VhcmNoKSB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5rZXl1cF9hcnJvdygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMua2V5ZG93bl9hcnJvdygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNlYXJjaF9maWVsZF9zY2FsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRpdiwgZl93aWR0aCwgaCwgc3R5bGUsIHN0eWxlX2Jsb2NrLCBzdHlsZXMsIHcsIF9pLCBfbGVuO1xuICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgaCA9IDA7XG4gICAgICAgIHcgPSAwO1xuICAgICAgICBzdHlsZV9ibG9jayA9IFwicG9zaXRpb246YWJzb2x1dGU7IGxlZnQ6IC0xMDAwcHg7IHRvcDogLTEwMDBweDsgZGlzcGxheTpub25lO1wiO1xuICAgICAgICBzdHlsZXMgPSBbJ2ZvbnQtc2l6ZScsICdmb250LXN0eWxlJywgJ2ZvbnQtd2VpZ2h0JywgJ2ZvbnQtZmFtaWx5JywgJ2xpbmUtaGVpZ2h0JywgJ3RleHQtdHJhbnNmb3JtJywgJ2xldHRlci1zcGFjaW5nJ107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gc3R5bGVzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgc3R5bGUgPSBzdHlsZXNbX2ldO1xuICAgICAgICAgIHN0eWxlX2Jsb2NrICs9IHN0eWxlICsgXCI6XCIgKyB0aGlzLnNlYXJjaF9maWVsZC5jc3Moc3R5bGUpICsgXCI7XCI7XG4gICAgICAgIH1cbiAgICAgICAgZGl2ID0gJCgnPGRpdiAvPicsIHtcbiAgICAgICAgICAnc3R5bGUnOiBzdHlsZV9ibG9ja1xuICAgICAgICB9KTtcbiAgICAgICAgZGl2LnRleHQodGhpcy5zZWFyY2hfZmllbGQudmFsKCkpO1xuICAgICAgICAkKCdib2R5JykuYXBwZW5kKGRpdik7XG4gICAgICAgIHcgPSBkaXYud2lkdGgoKSArIDI1O1xuICAgICAgICBkaXYucmVtb3ZlKCk7XG4gICAgICAgIGZfd2lkdGggPSB0aGlzLmNvbnRhaW5lci5vdXRlcldpZHRoKCk7XG4gICAgICAgIGlmICh3ID4gZl93aWR0aCAtIDEwKSB7XG4gICAgICAgICAgdyA9IGZfd2lkdGggLSAxMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfZmllbGQuY3NzKHtcbiAgICAgICAgICAnd2lkdGgnOiB3ICsgJ3B4J1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIENob3NlbjtcblxuICB9KShBYnN0cmFjdENob3Nlbik7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogbW9kYWwuanMgdjMuMy42XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNtb2RhbHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gTU9EQUwgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIEdDX01vZGFsID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgICAgICAgICAgICAgPSBvcHRpb25zXG4gICAgdGhpcy4kYm9keSAgICAgICAgICAgICAgID0gJChkb2N1bWVudC5ib2R5KVxuICAgIHRoaXMuJGVsZW1lbnQgICAgICAgICAgICA9ICQoZWxlbWVudClcbiAgICB0aGlzLiRkaWFsb2cgICAgICAgICAgICAgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5tb2RhbC1kaWFsb2cnKVxuICAgIHRoaXMuJGJhY2tkcm9wICAgICAgICAgICA9IG51bGxcbiAgICB0aGlzLmlzU2hvd24gICAgICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5vcmlnaW5hbEJvZHlQYWQgICAgID0gbnVsbFxuICAgIHRoaXMuc2Nyb2xsYmFyV2lkdGggICAgICA9IDBcbiAgICB0aGlzLmlnbm9yZUJhY2tkcm9wQ2xpY2sgPSBmYWxzZVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdGUpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLmZpbmQoJy5tb2RhbC1jb250ZW50JylcbiAgICAgICAgLmxvYWQodGhpcy5vcHRpb25zLnJlbW90ZSwgJC5wcm94eShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdsb2FkZWQuYnMubW9kYWwnKVxuICAgICAgICB9LCB0aGlzKSlcbiAgICB9XG4gIH1cblxuICBHQ19Nb2RhbC5WRVJTSU9OICA9ICczLjMuNidcblxuICBHQ19Nb2RhbC5UUkFOU0lUSU9OX0RVUkFUSU9OID0gMzAwXG4gIEdDX01vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04gPSAxNTBcblxuICBHQ19Nb2RhbC5ERUZBVUxUUyA9IHtcbiAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICBrZXlib2FyZDogdHJ1ZSxcbiAgICBzaG93OiB0cnVlXG4gIH1cblxuICBHQ19Nb2RhbC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKF9yZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KF9yZWxhdGVkVGFyZ2V0KVxuICB9XG5cbiAgR0NfTW9kYWwucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoX3JlbGF0ZWRUYXJnZXQpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIGUgPSAkLkV2ZW50KCdzaG93LmJzLm1vZGFsJywgeyByZWxhdGVkVGFyZ2V0OiBfcmVsYXRlZFRhcmdldCB9KSxcbiAgICAgICAgbWF4SGVpZ2h0ID0gTWF0aC5tYXgoMjUwLCAkKHdpbmRvdykuaGVpZ2h0KCkgLSAyMDApLFxuICAgICAgICBtaW5IZWlnaHQgPSAyNTA7XG5cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSk7XG5cbiAgICBpZiAodGhpcy5pc1Nob3duIHx8IGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgdGhpcy5pc1Nob3duID0gdHJ1ZVxuXG4gICAgdGhpcy5jaGVja1Njcm9sbGJhcigpXG4gICAgdGhpcy5zZXRTY3JvbGxiYXIoKVxuICAgIHRoaXMuJGJvZHkuYWRkQ2xhc3MoJ21vZGFsLW9wZW4nKVxuXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAuZmluZCgnLm1vZGFsLWJvZHknKVxuICAgICAgICAuY3NzKCdtaW4taGVpZ2h0JywgbWluSGVpZ2h0ICsgJ3B4JylcbiAgICAgICAgLmNzcygnbWF4LWhlaWdodCcsIG1heEhlaWdodCArICdweCcpO1xuXG4gICAgdGhpcy5lc2NhcGUoKVxuICAgIHRoaXMucmVzaXplKClcblxuICAgIHRoaXMuJGVsZW1lbnQub24oJ2NsaWNrLmRpc21pc3MuYnMubW9kYWwnLCAnW2RhdGEtZGlzbWlzcz1cIm1vZGFsXCJdJywgJC5wcm94eSh0aGlzLmhpZGUsIHRoaXMpKVxuXG4gICAgdGhpcy4kZGlhbG9nLm9uKCdtb3VzZWRvd24uZGlzbWlzcy5icy5tb2RhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQuJGVsZW1lbnQub25lKCdtb3VzZXVwLmRpc21pc3MuYnMubW9kYWwnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoJChlLnRhcmdldCkuaXModGhhdC4kZWxlbWVudCkpIHRoYXQuaWdub3JlQmFja2Ryb3BDbGljayA9IHRydWVcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHRoaXMuYmFja2Ryb3AoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRyYW5zaXRpb24gPSAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiB0aGF0LiRlbGVtZW50Lmhhc0NsYXNzKCdmYWRlJylcblxuICAgICAgaWYgKCF0aGF0LiRlbGVtZW50LnBhcmVudCgpLmxlbmd0aCkge1xuICAgICAgICB0aGF0LiRlbGVtZW50LmFwcGVuZFRvKHRoYXQuJGJvZHkpIC8vIGRvbid0IG1vdmUgbW9kYWxzIGRvbSBwb3NpdGlvblxuICAgICAgfVxuXG4gICAgICB0aGF0LiRlbGVtZW50XG4gICAgICAgIC5zaG93KClcbiAgICAgICAgLnNjcm9sbFRvcCgwKVxuXG4gICAgICB0aGF0LmFkanVzdERpYWxvZygpXG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHRoYXQuJGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGggLy8gZm9yY2UgcmVmbG93XG4gICAgICB9XG5cbiAgICAgIHRoYXQuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2djLXZpc2libGUtYnV0LWhpZGRlbicpO1xuICAgICAgdGhhdC4kZWxlbWVudC5hZGRDbGFzcygnaW4nKS5hZGRDbGFzcygnc2hvdycpLmNzcygnZGlzcGxheScsICdibG9jaycpO1xuXG4gICAgICB0aGF0LmVuZm9yY2VGb2N1cygpXG5cbiAgICAgIHZhciBlID0gJC5FdmVudCgnc2hvd24uYnMubW9kYWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IF9yZWxhdGVkVGFyZ2V0IH0pXG5cbiAgICAgIHRyYW5zaXRpb24gP1xuICAgICAgICB0aGF0LiRkaWFsb2cgLy8gd2FpdCBmb3IgbW9kYWwgdG8gc2xpZGUgaW5cbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJykudHJpZ2dlcihlKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKEdDX01vZGFsLlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdmb2N1cycpLnRyaWdnZXIoZSlcbiAgICB9KVxuICB9XG5cbiAgR0NfTW9kYWwucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlKSBlLnByZXZlbnREZWZhdWx0KClcblxuICAgIGUgPSAkLkV2ZW50KCdoaWRlLmJzLm1vZGFsJylcblxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgaWYgKCF0aGlzLmlzU2hvd24gfHwgZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB0aGlzLmlzU2hvd24gPSBmYWxzZTtcblxuICAgIHRoaXMuZXNjYXBlKCk7XG4gICAgdGhpcy5yZXNpemUoKTtcblxuICAgICQoZG9jdW1lbnQpLm9mZignZm9jdXNpbi5icy5tb2RhbCcpO1xuXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ2luJylcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdzaG93JylcbiAgICAgICAgLm9mZignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcpXG4gICAgICAgIC5vZmYoJ21vdXNldXAuZGlzbWlzcy5icy5tb2RhbCcpXG4gICAgICAgIC5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuXG4gICAgdGhpcy4kZGlhbG9nLm9mZignbW91c2Vkb3duLmRpc21pc3MuYnMubW9kYWwnKVxuXG4gICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgJC5wcm94eSh0aGlzLmhpZGVHQ19Nb2RhbCwgdGhpcykpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChHQ19Nb2RhbC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICB0aGlzLmhpZGVHQ19Nb2RhbCgpXG4gIH1cblxuICBHQ19Nb2RhbC5wcm90b3R5cGUuZW5mb3JjZUZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICQoZG9jdW1lbnQpXG4gICAgICAub2ZmKCdmb2N1c2luLmJzLm1vZGFsJykgLy8gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXG4gICAgICAub24oJ2ZvY3VzaW4uYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLiRlbGVtZW50WzBdICE9PSBlLnRhcmdldFxuICAgICAgICAgICAgJiYgIXRoaXMuJGVsZW1lbnQuaGFzKGUudGFyZ2V0KS5sZW5ndGhcbiAgICAgICAgICAgICYmICEkKGUudGFyZ2V0LnBhcmVudE5vZGUpLmhhc0NsYXNzKCdja2VfZGlhbG9nX3VpX2lucHV0X3NlbGVjdCcpXG4gICAgICAgICAgICAmJiAhJChlLnRhcmdldC5wYXJlbnROb2RlKS5oYXNDbGFzcygnY2tlX2RpYWxvZ191aV9pbnB1dF90ZXh0JylcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdmb2N1cycpXG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpKVxuICB9XG5cbiAgR0NfTW9kYWwucHJvdG90eXBlLmVzY2FwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc1Nob3duICYmIHRoaXMub3B0aW9ucy5rZXlib2FyZCkge1xuICAgICAgdGhpcy4kZWxlbWVudC5vbigna2V5ZG93bi5kaXNtaXNzLmJzLm1vZGFsJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLndoaWNoID09IDI3ICYmIHRoaXMuaGlkZSgpXG4gICAgICB9LCB0aGlzKSlcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzU2hvd24pIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdrZXlkb3duLmRpc21pc3MuYnMubW9kYWwnKVxuICAgIH1cbiAgfVxuXG4gIEdDX01vZGFsLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNTaG93bikge1xuICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUuYnMubW9kYWwnLCAkLnByb3h5KHRoaXMuaGFuZGxlVXBkYXRlLCB0aGlzKSlcbiAgICB9IGVsc2Uge1xuICAgICAgJCh3aW5kb3cpLm9mZigncmVzaXplLmJzLm1vZGFsJylcbiAgICB9XG4gIH1cblxuICBHQ19Nb2RhbC5wcm90b3R5cGUuaGlkZUdDX01vZGFsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHRoaXMuJGVsZW1lbnQuaGlkZSgpXG4gICAgdGhpcy5iYWNrZHJvcChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LiRib2R5LnJlbW92ZUNsYXNzKCdtb2RhbC1vcGVuJylcbiAgICAgIHRoYXQucmVzZXRBZGp1c3RtZW50cygpXG4gICAgICB0aGF0LnJlc2V0U2Nyb2xsYmFyKClcbiAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignaGlkZGVuLmJzLm1vZGFsJylcbiAgICB9KVxuICB9XG5cbiAgR0NfTW9kYWwucHJvdG90eXBlLnJlbW92ZUJhY2tkcm9wID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJGJhY2tkcm9wICYmIHRoaXMuJGJhY2tkcm9wLnJlbW92ZSgpXG4gICAgdGhpcy4kYmFja2Ryb3AgPSBudWxsXG4gIH1cblxuICBHQ19Nb2RhbC5wcm90b3R5cGUuYmFja2Ryb3AgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICB2YXIgYW5pbWF0ZSA9IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/ICdmYWRlJyA6ICcnXG5cbiAgICBpZiAodGhpcy5pc1Nob3duICYmIHRoaXMub3B0aW9ucy5iYWNrZHJvcCkge1xuICAgICAgdmFyIGRvQW5pbWF0ZSA9ICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIGFuaW1hdGVcblxuICAgICAgdGhpcy4kYmFja2Ryb3AgPSAkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKVxuICAgICAgICAuYWRkQ2xhc3MoJ21vZGFsLWJhY2tkcm9wICcgKyBhbmltYXRlKVxuICAgICAgICAuYXBwZW5kVG8odGhpcy4kYm9keSlcblxuICAgICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaWdub3JlQmFja2Ryb3BDbGljaykge1xuICAgICAgICAgIHRoaXMuaWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQpIHJldHVyblxuICAgICAgICB0aGlzLm9wdGlvbnMuYmFja2Ryb3AgPT0gJ3N0YXRpYydcbiAgICAgICAgICA/IHRoaXMuJGVsZW1lbnRbMF0uZm9jdXMoKVxuICAgICAgICAgIDogdGhpcy5oaWRlKClcbiAgICAgIH0sIHRoaXMpKVxuXG4gICAgICBpZiAoZG9BbmltYXRlKSB0aGlzLiRiYWNrZHJvcFswXS5vZmZzZXRXaWR0aCAvLyBmb3JjZSByZWZsb3dcblxuICAgICAgdGhpcy4kYmFja2Ryb3AuYWRkQ2xhc3MoJ2luJykuYWRkQ2xhc3MoJ3Nob3cnKS5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKTtcblxuICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuXG5cbiAgICAgIGRvQW5pbWF0ZSA/XG4gICAgICAgIHRoaXMuJGJhY2tkcm9wXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY2FsbGJhY2spXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKEdDX01vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgY2FsbGJhY2soKVxuXG4gICAgfSBlbHNlIGlmICghdGhpcy5pc1Nob3duICYmIHRoaXMuJGJhY2tkcm9wKSB7XG4gICAgICB0aGlzLiRiYWNrZHJvcC5yZW1vdmVDbGFzcygnaW4nKS5yZW1vdmVDbGFzcygnc2hvdycpLmNzcygnZGlzcGxheScsICdub25lJyk7XG5cbiAgICAgIHZhciBjYWxsYmFja1JlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhhdC5yZW1vdmVCYWNrZHJvcCgpXG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICAgIH1cbiAgICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAgIHRoaXMuJGJhY2tkcm9wXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY2FsbGJhY2tSZW1vdmUpXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKEdDX01vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgY2FsbGJhY2tSZW1vdmUoKVxuXG4gICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIC8vIHRoZXNlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcblxuICBHQ19Nb2RhbC5wcm90b3R5cGUuaGFuZGxlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWRqdXN0RGlhbG9nKClcbiAgfVxuXG4gIEdDX01vZGFsLnByb3RvdHlwZS5hZGp1c3REaWFsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGFsSXNPdmVyZmxvd2luZyA9IHRoaXMuJGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuXG4gICAgdGhpcy4kZWxlbWVudC5jc3Moe1xuICAgICAgcGFkZGluZ0xlZnQ6ICAhdGhpcy5ib2R5SXNPdmVyZmxvd2luZyAmJiBtb2RhbElzT3ZlcmZsb3dpbmcgPyB0aGlzLnNjcm9sbGJhcldpZHRoIDogJycsXG4gICAgICBwYWRkaW5nUmlnaHQ6IHRoaXMuYm9keUlzT3ZlcmZsb3dpbmcgJiYgIW1vZGFsSXNPdmVyZmxvd2luZyA/IHRoaXMuc2Nyb2xsYmFyV2lkdGggOiAnJ1xuICAgIH0pXG4gIH1cblxuICBHQ19Nb2RhbC5wcm90b3R5cGUucmVzZXRBZGp1c3RtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRlbGVtZW50LmNzcyh7XG4gICAgICBwYWRkaW5nTGVmdDogJycsXG4gICAgICBwYWRkaW5nUmlnaHQ6ICcnXG4gICAgfSlcbiAgfVxuXG4gIEdDX01vZGFsLnByb3RvdHlwZS5jaGVja1Njcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZnVsbFdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGhcbiAgICBpZiAoIWZ1bGxXaW5kb3dXaWR0aCkgeyAvLyB3b3JrYXJvdW5kIGZvciBtaXNzaW5nIHdpbmRvdy5pbm5lcldpZHRoIGluIElFOFxuICAgICAgdmFyIGRvY3VtZW50RWxlbWVudFJlY3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIGZ1bGxXaW5kb3dXaWR0aCA9IGRvY3VtZW50RWxlbWVudFJlY3QucmlnaHQgLSBNYXRoLmFicyhkb2N1bWVudEVsZW1lbnRSZWN0LmxlZnQpXG4gICAgfVxuICAgIHRoaXMuYm9keUlzT3ZlcmZsb3dpbmcgPSBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoIDwgZnVsbFdpbmRvd1dpZHRoXG4gICAgdGhpcy5zY3JvbGxiYXJXaWR0aCA9IHRoaXMubWVhc3VyZVNjcm9sbGJhcigpXG4gIH1cblxuICBHQ19Nb2RhbC5wcm90b3R5cGUuc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBib2R5UGFkID0gcGFyc2VJbnQoKHRoaXMuJGJvZHkuY3NzKCdwYWRkaW5nLXJpZ2h0JykgfHwgMCksIDEwKVxuICAgIHRoaXMub3JpZ2luYWxCb2R5UGFkID0gZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgfHwgJydcbiAgICBpZiAodGhpcy5ib2R5SXNPdmVyZmxvd2luZykgdGhpcy4kYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnLCBib2R5UGFkICsgdGhpcy5zY3JvbGxiYXJXaWR0aClcbiAgfVxuXG4gIEdDX01vZGFsLnByb3RvdHlwZS5yZXNldFNjcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRib2R5LmNzcygncGFkZGluZy1yaWdodCcsIHRoaXMub3JpZ2luYWxCb2R5UGFkKVxuICB9XG5cbiAgR0NfTW9kYWwucHJvdG90eXBlLm1lYXN1cmVTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7IC8vIHRoeCB3YWxzaFxuICAgIHZhciBzY3JvbGxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHNjcm9sbERpdi5jbGFzc05hbWUgPSAnbW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmUnXG4gICAgdGhpcy4kYm9keS5hcHBlbmQoc2Nyb2xsRGl2KVxuICAgIHZhciBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbERpdi5vZmZzZXRXaWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aFxuICAgIHRoaXMuJGJvZHlbMF0ucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KVxuICAgIHJldHVybiBzY3JvbGxiYXJXaWR0aFxuICB9XG5cblxuICAvLyBNT0RBTCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIEdDX1BsdWdpbihvcHRpb24sIF9yZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMubW9kYWwnKVxuICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgR0NfTW9kYWwuREVGQVVMVFMsICR0aGlzLmRhdGEoKSwgdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb24pXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMubW9kYWwnLCAoZGF0YSA9IG5ldyBHQ19Nb2RhbCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKF9yZWxhdGVkVGFyZ2V0KVxuICAgICAgZWxzZSBpZiAob3B0aW9ucy5zaG93KSBkYXRhLnNob3coX3JlbGF0ZWRUYXJnZXQpXG4gICAgfSlcbiAgfVxuXG4gICQuZm4uZ2NfbW9kYWwgICAgICAgICAgICAgPSBHQ19QbHVnaW5cbiAgJC5mbi5nY19tb2RhbC5Db25zdHJ1Y3RvciA9IEdDX01vZGFsXG5cbiAgLy8gTU9EQUwgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT1cblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuXG4gICAgJChkb2N1bWVudCkub24oJ2NsaWNrLmJzLm1vZGFsLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZT1cIm1vZGFsXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgIHZhciBocmVmID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgICB2YXIgJHRhcmdldCA9ICQoJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKSB8fCAoaHJlZiAmJiBocmVmLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sICcnKSkpIC8vIHN0cmlwIGZvciBpZTdcbiAgICAgIHZhciBvcHRpb24gPSAkdGFyZ2V0LmRhdGEoJ2JzLm1vZGFsJykgPyAndG9nZ2xlJyA6ICQuZXh0ZW5kKHtyZW1vdGU6ICEvIy8udGVzdChocmVmKSAmJiBocmVmfSwgJHRhcmdldC5kYXRhKCksICR0aGlzLmRhdGEoKSlcblxuICAgICAgaWYgKCR0aGlzLmlzKCdhJykpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgICAkdGFyZ2V0Lm9uZSgnc2hvdy5icy5tb2RhbCcsIGZ1bmN0aW9uIChzaG93RXZlbnQpIHtcbiAgICAgICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuIC8vIG9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cbiAgICAgICAgJHRhcmdldC5vbmUoJ2hpZGRlbi5icy5tb2RhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAkdGhpcy5pcygnOnZpc2libGUnKSAmJiAkdGhpcy50cmlnZ2VyKCdmb2N1cycpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgR0NfUGx1Z2luLmNhbGwoJHRhcmdldCwgb3B0aW9uLCB0aGlzKTtcbiAgICB9KTtcblxuICAgICQod2luZG93KS5yZXNpemUoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWF4SGVpZ2h0ID0gTWF0aC5tYXgoMjUwLCAkKHdpbmRvdykuaGVpZ2h0KCkgLSAyMDApLFxuICAgICAgICAgIG1pbkhlaWdodCA9IDI1MDtcbiAgICAgICQoJy5nYy1jb250YWluZXInKVxuICAgICAgICAgIC5maW5kKCcubW9kYWwtYm9keScpXG4gICAgICAgICAgLmNzcygnbWF4LWhlaWdodCcsIG1heEhlaWdodCArICdweCcpXG4gICAgICAgICAgLmNzcygnbWluLWhlaWdodCcsIG1pbkhlaWdodCArICdweCcpO1xuICAgIH0pO1xuXG4gIH1cblxufShqUXVlcnkpO1xuIiwiLypcbiAqIHByaW50VGhpcyB2MS41XG4gKiBAZGVzYyBQcmludGluZyBwbHVnLWluIGZvciBqUXVlcnlcbiAqIEBhdXRob3IgSmFzb24gRGF5XG4gKlxuICogUmVzb3VyY2VzIChiYXNlZCBvbikgOlxuICogICAgICAgICAgICAgIGpQcmludEFyZWE6IGh0dHA6Ly9wbHVnaW5zLmpxdWVyeS5jb20vcHJvamVjdC9qUHJpbnRBcmVhXG4gKiAgICAgICAgICAgICAganFQcmludDogaHR0cHM6Ly9naXRodWIuY29tL3Blcm1hbmVudHRvdXJpc3QvanF1ZXJ5LmpxcHJpbnRcbiAqICAgICAgICAgICAgICBCZW4gTmFkYWw6IGh0dHA6Ly93d3cuYmVubmFkZWwuY29tL2Jsb2cvMTU5MS1Bc2stQmVuLVByaW50LVBhcnQtT2YtQS1XZWItUGFnZS1XaXRoLWpRdWVyeS5odG1cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2VuY2U6XG4gKiAgICAgICAgICAgICAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqXG4gKiAoYykgSmFzb24gRGF5IDIwMTVcbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAgJChcIiNteVNlbGVjdG9yXCIpLnByaW50VGhpcyh7XG4gKiAgICAgIGRlYnVnOiBmYWxzZSwgICAgICAgICAgICAgICAqIHNob3cgdGhlIGlmcmFtZSBmb3IgZGVidWdnaW5nXG4gKiAgICAgIGltcG9ydENTUzogdHJ1ZSwgICAgICAgICAgICAqIGltcG9ydCBwYWdlIENTU1xuICogICAgICBpbXBvcnRTdHlsZTogZmFsc2UsICAgICAgICAgKiBpbXBvcnQgc3R5bGUgdGFnc1xuICogICAgICBwcmludENvbnRhaW5lcjogdHJ1ZSwgICAgICAgKiBncmFiIG91dGVyIGNvbnRhaW5lciBhcyB3ZWxsIGFzIHRoZSBjb250ZW50cyBvZiB0aGUgc2VsZWN0b3JcbiAqICAgICAgbG9hZENTUzogXCJwYXRoL3RvL215LmNzc1wiLCAgKiBwYXRoIHRvIGFkZGl0aW9uYWwgY3NzIGZpbGUgLSB1cyBhbiBhcnJheSBbXSBmb3IgbXVsdGlwbGVcbiAqICAgICAgcGFnZVRpdGxlOiBcIlwiLCAgICAgICAgICAgICAgKiBhZGQgdGl0bGUgdG8gcHJpbnQgcGFnZVxuICogICAgICByZW1vdmVJbmxpbmU6IGZhbHNlLCAgICAgICAgKiByZW1vdmUgYWxsIGlubGluZSBzdHlsZXMgZnJvbSBwcmludCBlbGVtZW50c1xuICogICAgICBwcmludERlbGF5OiAzMzMsICAgICAgICAgICAgKiB2YXJpYWJsZSBwcmludCBkZWxheVxuICogICAgICBoZWFkZXI6IG51bGwsICAgICAgICAgICAgICAgKiBwcmVmaXggdG8gaHRtbFxuICogICAgICBmb3JtVmFsdWVzOiB0cnVlICAgICAgICAgICAgKiBwcmVzZXJ2ZSBpbnB1dC9mb3JtIHZhbHVlc1xuICogIH0pO1xuICpcbiAqIE5vdGVzOlxuICogIC0gdGhlIGxvYWRDU1Mgd2lsbCBsb2FkIGFkZGl0aW9uYWwgY3NzICh3aXRoIG9yIHdpdGhvdXQgQG1lZGlhIHByaW50KSBpbnRvIHRoZSBpZnJhbWUsIGFkanVzdGluZyBsYXlvdXRcbiAqL1xuKGZ1bmN0aW9uKCQpIHtcblxudmFyIG9wdDtcbiQuZm4ucHJpbnRUaGlzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdCA9ICQuZXh0ZW5kKHt9LCAkLmZuLnByaW50VGhpcy5kZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgdmFyICRlbGVtZW50ID0gdGhpcyBpbnN0YW5jZW9mIGpRdWVyeSA/IHRoaXMgOiAkKHRoaXMpO1xuXG4gICAgdmFyIHN0ckZyYW1lTmFtZSA9IFwicHJpbnRUaGlzLVwiICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgIGlmICh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgIT09IGRvY3VtZW50LmRvbWFpbiAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9tc2llL2kpKSB7XG4gICAgICAgIC8vIFVnbHkgSUUgaGFja3MgZHVlIHRvIElFIG5vdCBpbmhlcml0aW5nIGRvY3VtZW50LmRvbWFpbiBmcm9tIHBhcmVudFxuICAgICAgICAvLyBjaGVja3MgaWYgZG9jdW1lbnQuZG9tYWluIGlzIHNldCBieSBjb21wYXJpbmcgdGhlIGhvc3QgbmFtZSBhZ2FpbnN0IGRvY3VtZW50LmRvbWFpblxuICAgICAgICB2YXIgaWZyYW1lU3JjID0gXCJqYXZhc2NyaXB0OmRvY3VtZW50LndyaXRlKFxcXCI8aGVhZD48c2NyaXB0PmRvY3VtZW50LmRvbWFpbj1cXFxcXFxcIlwiICsgZG9jdW1lbnQuZG9tYWluICsgXCJcXFxcXFxcIjs8L3NjcmlwdD48L2hlYWQ+PGJvZHk+PC9ib2R5PlxcXCIpXCI7XG4gICAgICAgIHZhciBwcmludEkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgcHJpbnRJLm5hbWUgPSBcInByaW50SWZyYW1lXCI7XG4gICAgICAgIHByaW50SS5pZCA9IHN0ckZyYW1lTmFtZTtcbiAgICAgICAgcHJpbnRJLmNsYXNzTmFtZSA9IFwiTVNJRVwiO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHByaW50SSk7XG4gICAgICAgIHByaW50SS5zcmMgPSBpZnJhbWVTcmM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlciBicm93c2VycyBpbmhlcml0IGRvY3VtZW50LmRvbWFpbiwgYW5kIElFIHdvcmtzIGlmIGRvY3VtZW50LmRvbWFpbiBpcyBub3QgZXhwbGljaXRseSBzZXRcbiAgICAgICAgdmFyICRmcmFtZSA9ICQoXCI8aWZyYW1lIGlkPSdcIiArIHN0ckZyYW1lTmFtZSArIFwiJyBuYW1lPSdwcmludElmcmFtZScgLz5cIik7XG4gICAgICAgICRmcmFtZS5hcHBlbmRUbyhcImJvZHlcIik7XG4gICAgfVxuXG5cbiAgICB2YXIgJGlmcmFtZSA9ICQoXCIjXCIgKyBzdHJGcmFtZU5hbWUpO1xuXG4gICAgLy8gc2hvdyBmcmFtZSBpZiBpbiBkZWJ1ZyBtb2RlXG4gICAgaWYgKCFvcHQuZGVidWcpICRpZnJhbWUuY3NzKHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgd2lkdGg6IFwiMHB4XCIsXG4gICAgICAgIGhlaWdodDogXCIwcHhcIixcbiAgICAgICAgbGVmdDogXCItNjAwcHhcIixcbiAgICAgICAgdG9wOiBcIi02MDBweFwiXG4gICAgfSk7XG5cblxuICAgIC8vICRpZnJhbWUucmVhZHkoKSBhbmQgJGlmcmFtZS5sb2FkIHdlcmUgaW5jb25zaXN0ZW50IGJldHdlZW4gYnJvd3NlcnNcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIEFkZCBkb2N0eXBlIHRvIGZpeCB0aGUgc3R5bGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHByaW50aW5nIGFuZCByZW5kZXJcbiAgICAgICAgZnVuY3Rpb24gc2V0RG9jVHlwZSgkaWZyYW1lLGRvY3R5cGUpe1xuICAgICAgICAgICAgdmFyIHdpbiwgZG9jO1xuICAgICAgICAgICAgd2luID0gJGlmcmFtZS5nZXQoMCk7XG4gICAgICAgICAgICB3aW4gPSB3aW4uY29udGVudFdpbmRvdyB8fCB3aW4uY29udGVudERvY3VtZW50IHx8IHdpbjtcbiAgICAgICAgICAgIGRvYyA9IHdpbi5kb2N1bWVudCB8fCB3aW4uY29udGVudERvY3VtZW50IHx8IHdpbjtcbiAgICAgICAgICAgIGRvYy5vcGVuKCk7XG4gICAgICAgICAgICBkb2Mud3JpdGUoZG9jdHlwZSk7XG4gICAgICAgICAgICBkb2MuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZihvcHQuZG9jdHlwZVN0cmluZyl7XG4gICAgICAgICAgICBzZXREb2NUeXBlKCRpZnJhbWUsb3B0LmRvY3R5cGVTdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyICRkb2MgPSAkaWZyYW1lLmNvbnRlbnRzKCksXG4gICAgICAgICAgICAkaGVhZCA9ICRkb2MuZmluZChcImhlYWRcIiksXG4gICAgICAgICAgICAkYm9keSA9ICRkb2MuZmluZChcImJvZHlcIik7XG5cbiAgICAgICAgLy8gYWRkIGJhc2UgdGFnIHRvIGVuc3VyZSBlbGVtZW50cyB1c2UgdGhlIHBhcmVudCBkb21haW5cbiAgICAgICAgJGhlYWQuYXBwZW5kKCc8YmFzZSBocmVmPVwiJyArIGRvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGRvY3VtZW50LmxvY2F0aW9uLmhvc3QgKyAnXCI+Jyk7XG5cbiAgICAgICAgLy8gaW1wb3J0IHBhZ2Ugc3R5bGVzaGVldHNcbiAgICAgICAgaWYgKG9wdC5pbXBvcnRDU1MpICQoXCJsaW5rW3JlbD1zdHlsZXNoZWV0XVwiKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhyZWYgPSAkKHRoaXMpLmF0dHIoXCJocmVmXCIpO1xuICAgICAgICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVkaWEgPSAkKHRoaXMpLmF0dHIoXCJtZWRpYVwiKSB8fCBcImFsbFwiO1xuICAgICAgICAgICAgICAgICRoZWFkLmFwcGVuZChcIjxsaW5rIHR5cGU9J3RleHQvY3NzJyByZWw9J3N0eWxlc2hlZXQnIGhyZWY9J1wiICsgaHJlZiArIFwiJyBtZWRpYT0nXCIgKyBtZWRpYSArIFwiJz5cIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaW1wb3J0IHN0eWxlIHRhZ3NcbiAgICAgICAgaWYgKG9wdC5pbXBvcnRTdHlsZSkgJChcInN0eWxlXCIpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKHRoaXMpLmNsb25lKCkuYXBwZW5kVG8oJGhlYWQpO1xuICAgICAgICAgICAgLy8kaGVhZC5hcHBlbmQoJCh0aGlzKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vYWRkIHRpdGxlIG9mIHRoZSBwYWdlXG4gICAgICAgIGlmIChvcHQucGFnZVRpdGxlKSAkaGVhZC5hcHBlbmQoXCI8dGl0bGU+XCIgKyBvcHQucGFnZVRpdGxlICsgXCI8L3RpdGxlPlwiKTtcblxuICAgICAgICAvLyBpbXBvcnQgYWRkaXRpb25hbCBzdHlsZXNoZWV0KHMpXG4gICAgICAgIGlmIChvcHQubG9hZENTUykge1xuICAgICAgICAgICBpZiggJC5pc0FycmF5KG9wdC5sb2FkQ1NTKSkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5lYWNoKG9wdC5sb2FkQ1NTLCBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAkaGVhZC5hcHBlbmQoXCI8bGluayB0eXBlPSd0ZXh0L2NzcycgcmVsPSdzdHlsZXNoZWV0JyBocmVmPSdcIiArIHRoaXMgKyBcIic+XCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkaGVhZC5hcHBlbmQoXCI8bGluayB0eXBlPSd0ZXh0L2NzcycgcmVsPSdzdHlsZXNoZWV0JyBocmVmPSdcIiArIG9wdC5sb2FkQ1NTICsgXCInPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByaW50IGhlYWRlclxuICAgICAgICBpZiAob3B0LmhlYWRlcikgJGJvZHkuYXBwZW5kKG9wdC5oZWFkZXIpO1xuXG4gICAgICAgIC8vIGdyYWIgJC5zZWxlY3RvciBhcyBjb250YWluZXJcbiAgICAgICAgaWYgKG9wdC5wcmludENvbnRhaW5lcikgJGJvZHkuYXBwZW5kKCRlbGVtZW50Lm91dGVyKCkpO1xuXG4gICAgICAgIC8vIG90aGVyd2lzZSBqdXN0IHByaW50IGludGVyaW9yIGVsZW1lbnRzIG9mIGNvbnRhaW5lclxuICAgICAgICBlbHNlICRlbGVtZW50LmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkYm9keS5hcHBlbmQoJCh0aGlzKS5odG1sKCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjYXB0dXJlIGZvcm0vZmllbGQgdmFsdWVzXG4gICAgICAgIGlmIChvcHQuZm9ybVZhbHVlcykge1xuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGlucHV0c1xuICAgICAgICAgICAgdmFyICRpbnB1dCA9ICRlbGVtZW50LmZpbmQoJ2lucHV0Jyk7XG4gICAgICAgICAgICBpZiAoJGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICRpbnB1dC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJG5hbWUgPSAkKHRoaXMpLmF0dHIoJ25hbWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICRjaGVja2VyID0gJHRoaXMuaXMoJzpjaGVja2JveCcpIHx8ICR0aGlzLmlzKCc6cmFkaW8nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICRpZnJhbWVJbnB1dCA9ICRkb2MuZmluZCgnaW5wdXRbbmFtZT1cIicgKyAkbmFtZSArICdcIl0nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICR2YWx1ZSA9ICR0aGlzLnZhbCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vb3JkZXIgbWF0dGVycyBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmICghJGNoZWNrZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRpZnJhbWVJbnB1dC52YWwoJHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkdGhpcy5pcygnOmNoZWNrZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCR0aGlzLmlzKCc6Y2hlY2tib3gnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpZnJhbWVJbnB1dC5hdHRyKCdjaGVja2VkJywgJ2NoZWNrZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHRoaXMuaXMoJzpyYWRpbycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGRvYy5maW5kKCdpbnB1dFtuYW1lPVwiJyArICRuYW1lICsgJ1wiXVt2YWx1ZT0nICsgJHZhbHVlICsgJ10nKS5hdHRyKCdjaGVja2VkJywgJ2NoZWNrZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vbG9vcCB0aHJvdWdoIHNlbGVjdHNcbiAgICAgICAgICAgIHZhciAkc2VsZWN0ID0gJGVsZW1lbnQuZmluZCgnc2VsZWN0Jyk7XG4gICAgICAgICAgICBpZiAoJHNlbGVjdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAkc2VsZWN0LmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAkbmFtZSA9ICQodGhpcykuYXR0cignbmFtZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJHZhbHVlID0gJHRoaXMudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICRkb2MuZmluZCgnc2VsZWN0W25hbWU9XCInICsgJG5hbWUgKyAnXCJdJykudmFsKCR2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vbG9vcCB0aHJvdWdoIHRleHRhcmVhc1xuICAgICAgICAgICAgdmFyICR0ZXh0YXJlYSA9ICRlbGVtZW50LmZpbmQoJ3RleHRhcmVhJyk7XG4gICAgICAgICAgICBpZiAoJHRleHRhcmVhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICR0ZXh0YXJlYS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJG5hbWUgPSAkKHRoaXMpLmF0dHIoJ25hbWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICR2YWx1ZSA9ICR0aGlzLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICAkZG9jLmZpbmQoJ3RleHRhcmVhW25hbWU9XCInICsgJG5hbWUgKyAnXCJdJykudmFsKCR2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZW5kIGNhcHR1cmUgZm9ybS9maWVsZCB2YWx1ZXNcblxuICAgICAgICAvLyByZW1vdmUgaW5saW5lIHN0eWxlc1xuICAgICAgICBpZiAob3B0LnJlbW92ZUlubGluZSkge1xuICAgICAgICAgICAgLy8gJC5yZW1vdmVBdHRyIGF2YWlsYWJsZSBqUXVlcnkgMS43K1xuICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbigkLnJlbW92ZUF0dHIpKSB7XG4gICAgICAgICAgICAgICAgJGRvYy5maW5kKFwiYm9keSAqXCIpLnJlbW92ZUF0dHIoXCJzdHlsZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJGRvYy5maW5kKFwiYm9keSAqXCIpLmF0dHIoXCJzdHlsZVwiLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoJGlmcmFtZS5oYXNDbGFzcyhcIk1TSUVcIikpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgaWZyYW1lIHdhcyBjcmVhdGVkIHdpdGggdGhlIHVnbHkgaGFja1xuICAgICAgICAgICAgICAgIC8vIGFuZCBwZXJmb3JtIGFub3RoZXIgdWdseSBoYWNrIG91dCBvZiBuZWNjZXNzaXR5XG4gICAgICAgICAgICAgICAgd2luZG93LmZyYW1lc1tcInByaW50SWZyYW1lXCJdLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgJGhlYWQuYXBwZW5kKFwiPHNjcmlwdD4gIHdpbmRvdy5wcmludCgpOyA8L3NjcmlwdD5cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHByb3BlciBtZXRob2RcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlDb21tYW5kU3VwcG9ydGVkKFwicHJpbnRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgJGlmcmFtZVswXS5jb250ZW50V2luZG93LmRvY3VtZW50LmV4ZWNDb21tYW5kKFwicHJpbnRcIiwgZmFsc2UsIG51bGwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRpZnJhbWVbMF0uY29udGVudFdpbmRvdy5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAkaWZyYW1lWzBdLmNvbnRlbnRXaW5kb3cucHJpbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vcmVtb3ZlIGlmcmFtZSBhZnRlciBwcmludFxuICAgICAgICAgICAgaWYgKCFvcHQuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkaWZyYW1lLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sIG9wdC5wcmludERlbGF5KTtcblxuICAgIH0sIDMzMyk7XG5cbn07XG5cbi8vIGRlZmF1bHRzXG4kLmZuLnByaW50VGhpcy5kZWZhdWx0cyA9IHtcbiAgICBkZWJ1ZzogZmFsc2UsICAgICAgICAgICAvLyBzaG93IHRoZSBpZnJhbWUgZm9yIGRlYnVnZ2luZ1xuICAgIGltcG9ydENTUzogdHJ1ZSwgICAgICAgIC8vIGltcG9ydCBwYXJlbnQgcGFnZSBjc3NcbiAgICBpbXBvcnRTdHlsZTogZmFsc2UsICAgICAvLyBpbXBvcnQgc3R5bGUgdGFnc1xuICAgIHByaW50Q29udGFpbmVyOiB0cnVlLCAgIC8vIHByaW50IG91dGVyIGNvbnRhaW5lci8kLnNlbGVjdG9yXG4gICAgbG9hZENTUzogXCJcIiwgICAgICAgICAgICAvLyBsb2FkIGFuIGFkZGl0aW9uYWwgY3NzIGZpbGUgLSBsb2FkIG11bHRpcGxlIHN0eWxlc2hlZXRzIHdpdGggYW4gYXJyYXkgW11cbiAgICBwYWdlVGl0bGU6IFwiXCIsICAgICAgICAgIC8vIGFkZCB0aXRsZSB0byBwcmludCBwYWdlXG4gICAgcmVtb3ZlSW5saW5lOiBmYWxzZSwgICAgLy8gcmVtb3ZlIGFsbCBpbmxpbmUgc3R5bGVzXG4gICAgcHJpbnREZWxheTogMzMzLCAgICAgICAgLy8gdmFyaWFibGUgcHJpbnQgZGVsYXlcbiAgICBoZWFkZXI6IG51bGwsICAgICAgICAgICAvLyBwcmVmaXggdG8gaHRtbFxuICAgIGZvcm1WYWx1ZXM6IHRydWUsICAgICAgICAvLyBwcmVzZXJ2ZSBpbnB1dC9mb3JtIHZhbHVlc1xuICAgIGRvY3R5cGVTdHJpbmc6ICc8IURPQ1RZUEUgaHRtbD4nIC8vIGh0bWwgZG9jdHlwZVxufTtcbn0pKGpRdWVyeSk7XG5cbi8vICQuc2VsZWN0b3IgY29udGFpbmVyXG5qUXVlcnkuZm4ub3V0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJCgkKFwiPGRpdj48L2Rpdj5cIikuaHRtbCh0aGlzLmNsb25lKCkpKS5odG1sKClcbn0iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogdHJhbnNpdGlvbi5qcyB2My4zLjVcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI3RyYW5zaXRpb25zXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIENTUyBUUkFOU0lUSU9OIFNVUFBPUlQgKFNob3V0b3V0OiBodHRwOi8vd3d3Lm1vZGVybml6ci5jb20vKVxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZCgpIHtcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYm9vdHN0cmFwJylcblxuICAgICAgICB2YXIgdHJhbnNFbmRFdmVudE5hbWVzID0ge1xuICAgICAgICAgICAgV2Via2l0VHJhbnNpdGlvbiA6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAgICAgICAgIE1velRyYW5zaXRpb24gICAgOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgICAgICAgICBPVHJhbnNpdGlvbiAgICAgIDogJ29UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kJyxcbiAgICAgICAgICAgIHRyYW5zaXRpb24gICAgICAgOiAndHJhbnNpdGlvbmVuZCdcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdHJhbnNFbmRFdmVudE5hbWVzKSB7XG4gICAgICAgICAgICBpZiAoZWwuc3R5bGVbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVuZDogdHJhbnNFbmRFdmVudE5hbWVzW25hbWVdIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZSAvLyBleHBsaWNpdCBmb3IgaWU4ICggIC5fLilcbiAgICB9XG5cbiAgICAvLyBodHRwOi8vYmxvZy5hbGV4bWFjY2F3LmNvbS9jc3MtdHJhbnNpdGlvbnNcbiAgICAkLmZuLmVtdWxhdGVUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZVxuICAgICAgICB2YXIgJGVsID0gdGhpc1xuICAgICAgICAkKHRoaXMpLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgZnVuY3Rpb24gKCkgeyBjYWxsZWQgPSB0cnVlIH0pXG4gICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHsgaWYgKCFjYWxsZWQpICQoJGVsKS50cmlnZ2VyKCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCkgfVxuICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkdXJhdGlvbilcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRW5kKClcblxuICAgICAgICBpZiAoISQuc3VwcG9ydC50cmFuc2l0aW9uKSByZXR1cm5cblxuICAgICAgICAkLmV2ZW50LnNwZWNpYWwuYnNUcmFuc2l0aW9uRW5kID0ge1xuICAgICAgICAgICAgYmluZFR5cGU6ICQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCxcbiAgICAgICAgICAgIGRlbGVnYXRlVHlwZTogJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLFxuICAgICAgICAgICAgaGFuZGxlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcyh0aGlzKSkgcmV0dXJuIGUuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxufShqUXVlcnkpOyIsInZhciBIYW5kbGViYXJzID0gcmVxdWlyZSgnaGFuZGxlYmFycycpO1xuXG5IYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKCdpZkNvbmQnLCBmdW5jdGlvbiAodjEsIG9wZXJhdG9yLCB2Miwgb3B0aW9ucykge1xuXG4gICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgICAgICByZXR1cm4gKHYxID09IHYyKSA/IG9wdGlvbnMuZm4odGhpcykgOiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgICAgICByZXR1cm4gKHYxID09PSB2MikgPyBvcHRpb25zLmZuKHRoaXMpIDogb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgIHJldHVybiAodjEgPCB2MikgPyBvcHRpb25zLmZuKHRoaXMpIDogb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICByZXR1cm4gKHYxIDw9IHYyKSA/IG9wdGlvbnMuZm4odGhpcykgOiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgcmV0dXJuICh2MSA+IHYyKSA/IG9wdGlvbnMuZm4odGhpcykgOiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgIHJldHVybiAodjEgPj0gdjIpID8gb3B0aW9ucy5mbih0aGlzKSA6IG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICAgICAgY2FzZSAnJiYnOlxuICAgICAgICAgICAgcmV0dXJuICh2MSAmJiB2MikgPyBvcHRpb25zLmZuKHRoaXMpIDogb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgICAgICBjYXNlICd8fCc6XG4gICAgICAgICAgICByZXR1cm4gKHYxIHx8IHYyKSA/IG9wdGlvbnMuZm4odGhpcykgOiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgIH1cbn0pO1xuXG5leHBvcnRzLkhhbmRsZWJhcnMgPSBIYW5kbGViYXJzO1xuXG4iLCIvKiEgalF1ZXJ5IFRpbWVwaWNrZXIgQWRkb24gLSB2MS42LjMgLSAyMDE2LTA0LTIwXHJcbiogaHR0cDovL3RyZW50cmljaGFyZHNvbi5jb20vZXhhbXBsZXMvdGltZXBpY2tlclxyXG4qIENvcHlyaWdodCAoYykgMjAxNiBUcmVudCBSaWNoYXJkc29uOyBMaWNlbnNlZCBNSVQgKi9cclxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG5cdFx0ZGVmaW5lKFsnanF1ZXJ5JywgJ2pxdWVyeS11aSddLCBmYWN0b3J5KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZmFjdG9yeShqUXVlcnkpO1xyXG5cdH1cclxufShmdW5jdGlvbiAoJCkge1xyXG5cclxuXHQvKlxyXG5cdCogTGV0cyBub3QgcmVkZWZpbmUgdGltZXBpY2tlciwgUHJldmVudCBcIlVuY2F1Z2h0IFJhbmdlRXJyb3I6IE1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCJcclxuXHQqL1xyXG4gICAgJC51aSA9ICQudWkgfHwge307XHJcblx0JC51aS50aW1lcGlja2VyID0gJC51aS50aW1lcGlja2VyIHx8IHt9O1xyXG5cdGlmICgkLnVpLnRpbWVwaWNrZXIudmVyc2lvbikge1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0LypcclxuXHQqIEV4dGVuZCBqUXVlcnlVSSwgZ2V0IGl0IHN0YXJ0ZWQgd2l0aCBvdXIgdmVyc2lvbiBudW1iZXJcclxuXHQqL1xyXG5cdCQuZXh0ZW5kKCQudWksIHtcclxuXHRcdHRpbWVwaWNrZXI6IHtcclxuXHRcdFx0dmVyc2lvbjogXCIxLjYuM1wiXHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdC8qXHJcblx0KiBUaW1lcGlja2VyIG1hbmFnZXIuXHJcblx0KiBVc2UgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLCAkLnRpbWVwaWNrZXIsIHRvIGludGVyYWN0IHdpdGggdGhlIHRpbWUgcGlja2VyLlxyXG5cdCogU2V0dGluZ3MgZm9yIChncm91cHMgb2YpIHRpbWUgcGlja2VycyBhcmUgbWFpbnRhaW5lZCBpbiBhbiBpbnN0YW5jZSBvYmplY3QsXHJcblx0KiBhbGxvd2luZyBtdWx0aXBsZSBkaWZmZXJlbnQgc2V0dGluZ3Mgb24gdGhlIHNhbWUgcGFnZS5cclxuXHQqL1xyXG5cdHZhciBUaW1lcGlja2VyID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5yZWdpb25hbCA9IFtdOyAvLyBBdmFpbGFibGUgcmVnaW9uYWwgc2V0dGluZ3MsIGluZGV4ZWQgYnkgbGFuZ3VhZ2UgY29kZVxyXG5cdFx0dGhpcy5yZWdpb25hbFsnJ10gPSB7IC8vIERlZmF1bHQgcmVnaW9uYWwgc2V0dGluZ3NcclxuXHRcdFx0Y3VycmVudFRleHQ6ICdOb3cnLFxyXG5cdFx0XHRjbG9zZVRleHQ6ICdEb25lJyxcclxuXHRcdFx0YW1OYW1lczogWydBTScsICdBJ10sXHJcblx0XHRcdHBtTmFtZXM6IFsnUE0nLCAnUCddLFxyXG5cdFx0XHR0aW1lRm9ybWF0OiAnSEg6bW0nLFxyXG5cdFx0XHR0aW1lU3VmZml4OiAnJyxcclxuXHRcdFx0dGltZU9ubHlUaXRsZTogJ0Nob29zZSBUaW1lJyxcclxuXHRcdFx0dGltZVRleHQ6ICdUaW1lJyxcclxuXHRcdFx0aG91clRleHQ6ICdIb3VyJyxcclxuXHRcdFx0bWludXRlVGV4dDogJ01pbnV0ZScsXHJcblx0XHRcdHNlY29uZFRleHQ6ICdTZWNvbmQnLFxyXG5cdFx0XHRtaWxsaXNlY1RleHQ6ICdNaWxsaXNlY29uZCcsXHJcblx0XHRcdG1pY3Jvc2VjVGV4dDogJ01pY3Jvc2Vjb25kJyxcclxuXHRcdFx0dGltZXpvbmVUZXh0OiAnVGltZSBab25lJyxcclxuXHRcdFx0aXNSVEw6IGZhbHNlXHJcblx0XHR9O1xyXG5cdFx0dGhpcy5fZGVmYXVsdHMgPSB7IC8vIEdsb2JhbCBkZWZhdWx0cyBmb3IgYWxsIHRoZSBkYXRldGltZSBwaWNrZXIgaW5zdGFuY2VzXHJcblx0XHRcdHNob3dCdXR0b25QYW5lbDogdHJ1ZSxcclxuXHRcdFx0dGltZU9ubHk6IGZhbHNlLFxyXG5cdFx0XHR0aW1lT25seVNob3dEYXRlOiBmYWxzZSxcclxuXHRcdFx0c2hvd0hvdXI6IG51bGwsXHJcblx0XHRcdHNob3dNaW51dGU6IG51bGwsXHJcblx0XHRcdHNob3dTZWNvbmQ6IG51bGwsXHJcblx0XHRcdHNob3dNaWxsaXNlYzogbnVsbCxcclxuXHRcdFx0c2hvd01pY3Jvc2VjOiBudWxsLFxyXG5cdFx0XHRzaG93VGltZXpvbmU6IG51bGwsXHJcblx0XHRcdHNob3dUaW1lOiB0cnVlLFxyXG5cdFx0XHRzdGVwSG91cjogMSxcclxuXHRcdFx0c3RlcE1pbnV0ZTogMSxcclxuXHRcdFx0c3RlcFNlY29uZDogMSxcclxuXHRcdFx0c3RlcE1pbGxpc2VjOiAxLFxyXG5cdFx0XHRzdGVwTWljcm9zZWM6IDEsXHJcblx0XHRcdGhvdXI6IDAsXHJcblx0XHRcdG1pbnV0ZTogMCxcclxuXHRcdFx0c2Vjb25kOiAwLFxyXG5cdFx0XHRtaWxsaXNlYzogMCxcclxuXHRcdFx0bWljcm9zZWM6IDAsXHJcblx0XHRcdHRpbWV6b25lOiBudWxsLFxyXG5cdFx0XHRob3VyTWluOiAwLFxyXG5cdFx0XHRtaW51dGVNaW46IDAsXHJcblx0XHRcdHNlY29uZE1pbjogMCxcclxuXHRcdFx0bWlsbGlzZWNNaW46IDAsXHJcblx0XHRcdG1pY3Jvc2VjTWluOiAwLFxyXG5cdFx0XHRob3VyTWF4OiAyMyxcclxuXHRcdFx0bWludXRlTWF4OiA1OSxcclxuXHRcdFx0c2Vjb25kTWF4OiA1OSxcclxuXHRcdFx0bWlsbGlzZWNNYXg6IDk5OSxcclxuXHRcdFx0bWljcm9zZWNNYXg6IDk5OSxcclxuXHRcdFx0bWluRGF0ZVRpbWU6IG51bGwsXHJcblx0XHRcdG1heERhdGVUaW1lOiBudWxsLFxyXG5cdFx0XHRtYXhUaW1lOiBudWxsLFxyXG5cdFx0XHRtaW5UaW1lOiBudWxsLFxyXG5cdFx0XHRvblNlbGVjdDogbnVsbCxcclxuXHRcdFx0aG91ckdyaWQ6IDAsXHJcblx0XHRcdG1pbnV0ZUdyaWQ6IDAsXHJcblx0XHRcdHNlY29uZEdyaWQ6IDAsXHJcblx0XHRcdG1pbGxpc2VjR3JpZDogMCxcclxuXHRcdFx0bWljcm9zZWNHcmlkOiAwLFxyXG5cdFx0XHRhbHdheXNTZXRUaW1lOiB0cnVlLFxyXG5cdFx0XHRzZXBhcmF0b3I6ICcgJyxcclxuXHRcdFx0YWx0RmllbGRUaW1lT25seTogdHJ1ZSxcclxuXHRcdFx0YWx0VGltZUZvcm1hdDogbnVsbCxcclxuXHRcdFx0YWx0U2VwYXJhdG9yOiBudWxsLFxyXG5cdFx0XHRhbHRUaW1lU3VmZml4OiBudWxsLFxyXG5cdFx0XHRhbHRSZWRpcmVjdEZvY3VzOiB0cnVlLFxyXG5cdFx0XHRwaWNrZXJUaW1lRm9ybWF0OiBudWxsLFxyXG5cdFx0XHRwaWNrZXJUaW1lU3VmZml4OiBudWxsLFxyXG5cdFx0XHRzaG93VGltZXBpY2tlcjogdHJ1ZSxcclxuXHRcdFx0dGltZXpvbmVMaXN0OiBudWxsLFxyXG5cdFx0XHRhZGRTbGlkZXJBY2Nlc3M6IGZhbHNlLFxyXG5cdFx0XHRzbGlkZXJBY2Nlc3NBcmdzOiBudWxsLFxyXG5cdFx0XHRjb250cm9sVHlwZTogJ3NsaWRlcicsXHJcblx0XHRcdG9uZUxpbmU6IGZhbHNlLFxyXG5cdFx0XHRkZWZhdWx0VmFsdWU6IG51bGwsXHJcblx0XHRcdHBhcnNlOiAnc3RyaWN0JyxcclxuXHRcdFx0YWZ0ZXJJbmplY3Q6IG51bGxcclxuXHRcdH07XHJcblx0XHQkLmV4dGVuZCh0aGlzLl9kZWZhdWx0cywgdGhpcy5yZWdpb25hbFsnJ10pO1xyXG5cdH07XHJcblxyXG5cdCQuZXh0ZW5kKFRpbWVwaWNrZXIucHJvdG90eXBlLCB7XHJcblx0XHQkaW5wdXQ6IG51bGwsXHJcblx0XHQkYWx0SW5wdXQ6IG51bGwsXHJcblx0XHQkdGltZU9iajogbnVsbCxcclxuXHRcdGluc3Q6IG51bGwsXHJcblx0XHRob3VyX3NsaWRlcjogbnVsbCxcclxuXHRcdG1pbnV0ZV9zbGlkZXI6IG51bGwsXHJcblx0XHRzZWNvbmRfc2xpZGVyOiBudWxsLFxyXG5cdFx0bWlsbGlzZWNfc2xpZGVyOiBudWxsLFxyXG5cdFx0bWljcm9zZWNfc2xpZGVyOiBudWxsLFxyXG5cdFx0dGltZXpvbmVfc2VsZWN0OiBudWxsLFxyXG5cdFx0bWF4VGltZTogbnVsbCxcclxuXHRcdG1pblRpbWU6IG51bGwsXHJcblx0XHRob3VyOiAwLFxyXG5cdFx0bWludXRlOiAwLFxyXG5cdFx0c2Vjb25kOiAwLFxyXG5cdFx0bWlsbGlzZWM6IDAsXHJcblx0XHRtaWNyb3NlYzogMCxcclxuXHRcdHRpbWV6b25lOiBudWxsLFxyXG5cdFx0aG91ck1pbk9yaWdpbmFsOiBudWxsLFxyXG5cdFx0bWludXRlTWluT3JpZ2luYWw6IG51bGwsXHJcblx0XHRzZWNvbmRNaW5PcmlnaW5hbDogbnVsbCxcclxuXHRcdG1pbGxpc2VjTWluT3JpZ2luYWw6IG51bGwsXHJcblx0XHRtaWNyb3NlY01pbk9yaWdpbmFsOiBudWxsLFxyXG5cdFx0aG91ck1heE9yaWdpbmFsOiBudWxsLFxyXG5cdFx0bWludXRlTWF4T3JpZ2luYWw6IG51bGwsXHJcblx0XHRzZWNvbmRNYXhPcmlnaW5hbDogbnVsbCxcclxuXHRcdG1pbGxpc2VjTWF4T3JpZ2luYWw6IG51bGwsXHJcblx0XHRtaWNyb3NlY01heE9yaWdpbmFsOiBudWxsLFxyXG5cdFx0YW1wbTogJycsXHJcblx0XHRmb3JtYXR0ZWREYXRlOiAnJyxcclxuXHRcdGZvcm1hdHRlZFRpbWU6ICcnLFxyXG5cdFx0Zm9ybWF0dGVkRGF0ZVRpbWU6ICcnLFxyXG5cdFx0dGltZXpvbmVMaXN0OiBudWxsLFxyXG5cdFx0dW5pdHM6IFsnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2VjJywgJ21pY3Jvc2VjJ10sXHJcblx0XHRzdXBwb3J0OiB7fSxcclxuXHRcdGNvbnRyb2w6IG51bGwsXHJcblxyXG5cdFx0LypcclxuXHRcdCogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgc2V0dGluZ3MgZm9yIGFsbCBpbnN0YW5jZXMgb2YgdGhlIHRpbWUgcGlja2VyLlxyXG5cdFx0KiBAcGFyYW0gIHtPYmplY3R9IHNldHRpbmdzICBvYmplY3QgLSB0aGUgbmV3IHNldHRpbmdzIHRvIHVzZSBhcyBkZWZhdWx0cyAoYW5vbnltb3VzIG9iamVjdClcclxuXHRcdCogQHJldHVybiB7T2JqZWN0fSB0aGUgbWFuYWdlciBvYmplY3RcclxuXHRcdCovXHJcblx0XHRzZXREZWZhdWx0czogZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0XHRcdGV4dGVuZFJlbW92ZSh0aGlzLl9kZWZhdWx0cywgc2V0dGluZ3MgfHwge30pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblxyXG5cdFx0LypcclxuXHRcdCogQ3JlYXRlIGEgbmV3IFRpbWVwaWNrZXIgaW5zdGFuY2VcclxuXHRcdCovXHJcblx0XHRfbmV3SW5zdDogZnVuY3Rpb24gKCRpbnB1dCwgb3B0cykge1xyXG5cdFx0XHR2YXIgdHBfaW5zdCA9IG5ldyBUaW1lcGlja2VyKCksXHJcblx0XHRcdFx0aW5saW5lU2V0dGluZ3MgPSB7fSxcclxuXHRcdFx0XHRmbnMgPSB7fSxcclxuXHRcdFx0XHRvdmVycmlkZXMsIGk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBhdHRyTmFtZSBpbiB0aGlzLl9kZWZhdWx0cykge1xyXG5cdFx0XHRcdGlmICh0aGlzLl9kZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eShhdHRyTmFtZSkpIHtcclxuXHRcdFx0XHRcdHZhciBhdHRyVmFsdWUgPSAkaW5wdXQuYXR0cigndGltZTonICsgYXR0ck5hbWUpO1xyXG5cdFx0XHRcdFx0aWYgKGF0dHJWYWx1ZSkge1xyXG5cdFx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRcdGlubGluZVNldHRpbmdzW2F0dHJOYW1lXSA9IGV2YWwoYXR0clZhbHVlKTtcclxuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdFx0XHRcdFx0aW5saW5lU2V0dGluZ3NbYXR0ck5hbWVdID0gYXR0clZhbHVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvdmVycmlkZXMgPSB7XHJcblx0XHRcdFx0YmVmb3JlU2hvdzogZnVuY3Rpb24gKGlucHV0LCBkcF9pbnN0KSB7XHJcblx0XHRcdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKHRwX2luc3QuX2RlZmF1bHRzLmV2bnRzLmJlZm9yZVNob3cpKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0cF9pbnN0Ll9kZWZhdWx0cy5ldm50cy5iZWZvcmVTaG93LmNhbGwoJGlucHV0WzBdLCBpbnB1dCwgZHBfaW5zdCwgdHBfaW5zdCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRvbkNoYW5nZU1vbnRoWWVhcjogZnVuY3Rpb24gKHllYXIsIG1vbnRoLCBkcF9pbnN0KSB7XHJcblx0XHRcdFx0XHQvLyBVcGRhdGUgdGhlIHRpbWUgYXMgd2VsbCA6IHRoaXMgcHJldmVudHMgdGhlIHRpbWUgZnJvbSBkaXNhcHBlYXJpbmcgZnJvbSB0aGUgJGlucHV0IGZpZWxkLlxyXG5cdFx0XHRcdFx0Ly8gdHBfaW5zdC5fdXBkYXRlRGF0ZVRpbWUoZHBfaW5zdCk7XHJcblx0XHRcdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKHRwX2luc3QuX2RlZmF1bHRzLmV2bnRzLm9uQ2hhbmdlTW9udGhZZWFyKSkge1xyXG5cdFx0XHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5ldm50cy5vbkNoYW5nZU1vbnRoWWVhci5jYWxsKCRpbnB1dFswXSwgeWVhciwgbW9udGgsIGRwX2luc3QsIHRwX2luc3QpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0b25DbG9zZTogZnVuY3Rpb24gKGRhdGVUZXh0LCBkcF9pbnN0KSB7XHJcblx0XHRcdFx0XHRpZiAodHBfaW5zdC50aW1lRGVmaW5lZCA9PT0gdHJ1ZSAmJiAkaW5wdXQudmFsKCkgIT09ICcnKSB7XHJcblx0XHRcdFx0XHRcdHRwX2luc3QuX3VwZGF0ZURhdGVUaW1lKGRwX2luc3QpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCQuaXNGdW5jdGlvbih0cF9pbnN0Ll9kZWZhdWx0cy5ldm50cy5vbkNsb3NlKSkge1xyXG5cdFx0XHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5ldm50cy5vbkNsb3NlLmNhbGwoJGlucHV0WzBdLCBkYXRlVGV4dCwgZHBfaW5zdCwgdHBfaW5zdCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0XHRmb3IgKGkgaW4gb3ZlcnJpZGVzKSB7XHJcblx0XHRcdFx0aWYgKG92ZXJyaWRlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG5cdFx0XHRcdFx0Zm5zW2ldID0gb3B0c1tpXSB8fCB0aGlzLl9kZWZhdWx0c1tpXSB8fCBudWxsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgdGhpcy5fZGVmYXVsdHMsIGlubGluZVNldHRpbmdzLCBvcHRzLCBvdmVycmlkZXMsIHtcclxuXHRcdFx0XHRldm50czogZm5zLFxyXG5cdFx0XHRcdHRpbWVwaWNrZXI6IHRwX2luc3QgLy8gYWRkIHRpbWVwaWNrZXIgYXMgYSBwcm9wZXJ0eSBvZiBkYXRlcGlja2VyOiAkLmRhdGVwaWNrZXIuX2dldChkcF9pbnN0LCAndGltZXBpY2tlcicpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0dHBfaW5zdC5hbU5hbWVzID0gJC5tYXAodHBfaW5zdC5fZGVmYXVsdHMuYW1OYW1lcywgZnVuY3Rpb24gKHZhbCkge1xyXG5cdFx0XHRcdHJldHVybiB2YWwudG9VcHBlckNhc2UoKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRwX2luc3QucG1OYW1lcyA9ICQubWFwKHRwX2luc3QuX2RlZmF1bHRzLnBtTmFtZXMsIGZ1bmN0aW9uICh2YWwpIHtcclxuXHRcdFx0XHRyZXR1cm4gdmFsLnRvVXBwZXJDYXNlKCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly8gZGV0ZWN0IHdoaWNoIHVuaXRzIGFyZSBzdXBwb3J0ZWRcclxuXHRcdFx0dHBfaW5zdC5zdXBwb3J0ID0gZGV0ZWN0U3VwcG9ydChcclxuXHRcdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLnRpbWVGb3JtYXQgK1xyXG5cdFx0XHRcdFx0KHRwX2luc3QuX2RlZmF1bHRzLnBpY2tlclRpbWVGb3JtYXQgPyB0cF9pbnN0Ll9kZWZhdWx0cy5waWNrZXJUaW1lRm9ybWF0IDogJycpICtcclxuXHRcdFx0XHRcdCh0cF9pbnN0Ll9kZWZhdWx0cy5hbHRUaW1lRm9ybWF0ID8gdHBfaW5zdC5fZGVmYXVsdHMuYWx0VGltZUZvcm1hdCA6ICcnKSk7XHJcblxyXG5cdFx0XHQvLyBjb250cm9sVHlwZSBpcyBzdHJpbmcgLSBrZXkgdG8gb3VyIHRoaXMuX2NvbnRyb2xzXHJcblx0XHRcdGlmICh0eXBlb2YodHBfaW5zdC5fZGVmYXVsdHMuY29udHJvbFR5cGUpID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5jb250cm9sVHlwZSA9PT0gJ3NsaWRlcicgJiYgdHlwZW9mKCQudWkuc2xpZGVyKSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLmNvbnRyb2xUeXBlID0gJ3NlbGVjdCc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRwX2luc3QuY29udHJvbCA9IHRwX2luc3QuX2NvbnRyb2xzW3RwX2luc3QuX2RlZmF1bHRzLmNvbnRyb2xUeXBlXTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBjb250cm9sVHlwZSBpcyBhbiBvYmplY3QgYW5kIG11c3QgaW1wbGVtZW50IGNyZWF0ZSwgb3B0aW9ucywgdmFsdWUgbWV0aG9kc1xyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHR0cF9pbnN0LmNvbnRyb2wgPSB0cF9pbnN0Ll9kZWZhdWx0cy5jb250cm9sVHlwZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gcHJlcCB0aGUgdGltZXpvbmUgb3B0aW9uc1xyXG5cdFx0XHR2YXIgdGltZXpvbmVMaXN0ID0gWy03MjAsIC02NjAsIC02MDAsIC01NzAsIC01NDAsIC00ODAsIC00MjAsIC0zNjAsIC0zMDAsIC0yNzAsIC0yNDAsIC0yMTAsIC0xODAsIC0xMjAsIC02MCxcclxuXHRcdFx0XHRcdDAsIDYwLCAxMjAsIDE4MCwgMjEwLCAyNDAsIDI3MCwgMzAwLCAzMzAsIDM0NSwgMzYwLCAzOTAsIDQyMCwgNDgwLCA1MjUsIDU0MCwgNTcwLCA2MDAsIDYzMCwgNjYwLCA2OTAsIDcyMCwgNzY1LCA3ODAsIDg0MF07XHJcblx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy50aW1lem9uZUxpc3QgIT09IG51bGwpIHtcclxuXHRcdFx0XHR0aW1lem9uZUxpc3QgPSB0cF9pbnN0Ll9kZWZhdWx0cy50aW1lem9uZUxpc3Q7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIHR6bCA9IHRpbWV6b25lTGlzdC5sZW5ndGgsIHR6aSA9IDAsIHR6diA9IG51bGw7XHJcblx0XHRcdGlmICh0emwgPiAwICYmIHR5cGVvZiB0aW1lem9uZUxpc3RbMF0gIT09ICdvYmplY3QnKSB7XHJcblx0XHRcdFx0Zm9yICg7IHR6aSA8IHR6bDsgdHppKyspIHtcclxuXHRcdFx0XHRcdHR6diA9IHRpbWV6b25lTGlzdFt0emldO1xyXG5cdFx0XHRcdFx0dGltZXpvbmVMaXN0W3R6aV0gPSB7IHZhbHVlOiB0enYsIGxhYmVsOiAkLnRpbWVwaWNrZXIudGltZXpvbmVPZmZzZXRTdHJpbmcodHp2LCB0cF9pbnN0LnN1cHBvcnQuaXNvODYwMSkgfTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMudGltZXpvbmVMaXN0ID0gdGltZXpvbmVMaXN0O1xyXG5cclxuXHRcdFx0Ly8gc2V0IHRoZSBkZWZhdWx0IHVuaXRzXHJcblx0XHRcdHRwX2luc3QudGltZXpvbmUgPSB0cF9pbnN0Ll9kZWZhdWx0cy50aW1lem9uZSAhPT0gbnVsbCA/ICQudGltZXBpY2tlci50aW1lem9uZU9mZnNldE51bWJlcih0cF9pbnN0Ll9kZWZhdWx0cy50aW1lem9uZSkgOlxyXG5cdFx0XHRcdFx0XHRcdCgobmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIC0xKTtcclxuXHRcdFx0dHBfaW5zdC5ob3VyID0gdHBfaW5zdC5fZGVmYXVsdHMuaG91ciA8IHRwX2luc3QuX2RlZmF1bHRzLmhvdXJNaW4gPyB0cF9pbnN0Ll9kZWZhdWx0cy5ob3VyTWluIDpcclxuXHRcdFx0XHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5ob3VyID4gdHBfaW5zdC5fZGVmYXVsdHMuaG91ck1heCA/IHRwX2luc3QuX2RlZmF1bHRzLmhvdXJNYXggOiB0cF9pbnN0Ll9kZWZhdWx0cy5ob3VyO1xyXG5cdFx0XHR0cF9pbnN0Lm1pbnV0ZSA9IHRwX2luc3QuX2RlZmF1bHRzLm1pbnV0ZSA8IHRwX2luc3QuX2RlZmF1bHRzLm1pbnV0ZU1pbiA/IHRwX2luc3QuX2RlZmF1bHRzLm1pbnV0ZU1pbiA6XHJcblx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWludXRlID4gdHBfaW5zdC5fZGVmYXVsdHMubWludXRlTWF4ID8gdHBfaW5zdC5fZGVmYXVsdHMubWludXRlTWF4IDogdHBfaW5zdC5fZGVmYXVsdHMubWludXRlO1xyXG5cdFx0XHR0cF9pbnN0LnNlY29uZCA9IHRwX2luc3QuX2RlZmF1bHRzLnNlY29uZCA8IHRwX2luc3QuX2RlZmF1bHRzLnNlY29uZE1pbiA/IHRwX2luc3QuX2RlZmF1bHRzLnNlY29uZE1pbiA6XHJcblx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMuc2Vjb25kID4gdHBfaW5zdC5fZGVmYXVsdHMuc2Vjb25kTWF4ID8gdHBfaW5zdC5fZGVmYXVsdHMuc2Vjb25kTWF4IDogdHBfaW5zdC5fZGVmYXVsdHMuc2Vjb25kO1xyXG5cdFx0XHR0cF9pbnN0Lm1pbGxpc2VjID0gdHBfaW5zdC5fZGVmYXVsdHMubWlsbGlzZWMgPCB0cF9pbnN0Ll9kZWZhdWx0cy5taWxsaXNlY01pbiA/IHRwX2luc3QuX2RlZmF1bHRzLm1pbGxpc2VjTWluIDpcclxuXHRcdFx0XHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5taWxsaXNlYyA+IHRwX2luc3QuX2RlZmF1bHRzLm1pbGxpc2VjTWF4ID8gdHBfaW5zdC5fZGVmYXVsdHMubWlsbGlzZWNNYXggOiB0cF9pbnN0Ll9kZWZhdWx0cy5taWxsaXNlYztcclxuXHRcdFx0dHBfaW5zdC5taWNyb3NlYyA9IHRwX2luc3QuX2RlZmF1bHRzLm1pY3Jvc2VjIDwgdHBfaW5zdC5fZGVmYXVsdHMubWljcm9zZWNNaW4gPyB0cF9pbnN0Ll9kZWZhdWx0cy5taWNyb3NlY01pbiA6XHJcblx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWljcm9zZWMgPiB0cF9pbnN0Ll9kZWZhdWx0cy5taWNyb3NlY01heCA/IHRwX2luc3QuX2RlZmF1bHRzLm1pY3Jvc2VjTWF4IDogdHBfaW5zdC5fZGVmYXVsdHMubWljcm9zZWM7XHJcblx0XHRcdHRwX2luc3QuYW1wbSA9ICcnO1xyXG5cdFx0XHR0cF9pbnN0LiRpbnB1dCA9ICRpbnB1dDtcclxuXHJcblx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGaWVsZCkge1xyXG5cdFx0XHRcdHRwX2luc3QuJGFsdElucHV0ID0gJCh0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGaWVsZCk7XHJcblx0XHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLmFsdFJlZGlyZWN0Rm9jdXMgPT09IHRydWUpIHtcclxuXHRcdFx0XHRcdHRwX2luc3QuJGFsdElucHV0LmNzcyh7XHJcblx0XHRcdFx0XHRcdGN1cnNvcjogJ3BvaW50ZXInXHJcblx0XHRcdFx0XHR9KS5mb2N1cyhmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRcdCRpbnB1dC50cmlnZ2VyKFwiZm9jdXNcIik7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5taW5EYXRlID09PSAwIHx8IHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGVUaW1lID09PSAwKSB7XHJcblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZSA9IG5ldyBEYXRlKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGUgPT09IDAgfHwgdHBfaW5zdC5fZGVmYXVsdHMubWF4RGF0ZVRpbWUgPT09IDApIHtcclxuXHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlID0gbmV3IERhdGUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZGF0ZXBpY2tlciBuZWVkcyBtaW5EYXRlL21heERhdGUsIHRpbWVwaWNrZXIgbmVlZHMgbWluRGF0ZVRpbWUvbWF4RGF0ZVRpbWUuLlxyXG5cdFx0XHRpZiAodHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZSAhPT0gdW5kZWZpbmVkICYmIHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZVRpbWUgPSBuZXcgRGF0ZSh0cF9pbnN0Ll9kZWZhdWx0cy5taW5EYXRlLmdldFRpbWUoKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGVUaW1lICE9PSB1bmRlZmluZWQgJiYgdHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZVRpbWUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZSA9IG5ldyBEYXRlKHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGVUaW1lLmdldFRpbWUoKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGUgIT09IHVuZGVmaW5lZCAmJiB0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xyXG5cdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGVUaW1lID0gbmV3IERhdGUodHBfaW5zdC5fZGVmYXVsdHMubWF4RGF0ZS5nZXRUaW1lKCkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlVGltZSAhPT0gdW5kZWZpbmVkICYmIHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGVUaW1lIGluc3RhbmNlb2YgRGF0ZSkge1xyXG5cdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGUgPSBuZXcgRGF0ZSh0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlVGltZS5nZXRUaW1lKCkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRwX2luc3QuJGlucHV0LmJpbmQoJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHRwX2luc3QuX29uRm9jdXMoKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHBfaW5zdDtcclxuXHRcdH0sXHJcblxyXG5cdFx0LypcclxuXHRcdCogYWRkIG91ciBzbGlkZXJzIHRvIHRoZSBjYWxlbmRhclxyXG5cdFx0Ki9cclxuXHRcdF9hZGRUaW1lUGlja2VyOiBmdW5jdGlvbiAoZHBfaW5zdCkge1xyXG5cdFx0XHR2YXIgY3VyckRUID0gJC50cmltKCh0aGlzLiRhbHRJbnB1dCAmJiB0aGlzLl9kZWZhdWx0cy5hbHRGaWVsZFRpbWVPbmx5KSA/IHRoaXMuJGlucHV0LnZhbCgpICsgJyAnICsgdGhpcy4kYWx0SW5wdXQudmFsKCkgOiB0aGlzLiRpbnB1dC52YWwoKSk7XHJcblxyXG5cdFx0XHR0aGlzLnRpbWVEZWZpbmVkID0gdGhpcy5fcGFyc2VUaW1lKGN1cnJEVCk7XHJcblx0XHRcdHRoaXMuX2xpbWl0TWluTWF4RGF0ZVRpbWUoZHBfaW5zdCwgZmFsc2UpO1xyXG5cdFx0XHR0aGlzLl9pbmplY3RUaW1lUGlja2VyKCk7XHJcblx0XHRcdHRoaXMuX2FmdGVySW5qZWN0KCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qXHJcblx0XHQqIHBhcnNlIHRoZSB0aW1lIHN0cmluZyBmcm9tIGlucHV0IHZhbHVlIG9yIF9zZXRUaW1lXHJcblx0XHQqL1xyXG5cdFx0X3BhcnNlVGltZTogZnVuY3Rpb24gKHRpbWVTdHJpbmcsIHdpdGhEYXRlKSB7XHJcblx0XHRcdGlmICghdGhpcy5pbnN0KSB7XHJcblx0XHRcdFx0dGhpcy5pbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KHRoaXMuJGlucHV0WzBdKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHdpdGhEYXRlIHx8ICF0aGlzLl9kZWZhdWx0cy50aW1lT25seSkge1xyXG5cdFx0XHRcdHZhciBkcF9kYXRlRm9ybWF0ID0gJC5kYXRlcGlja2VyLl9nZXQodGhpcy5pbnN0LCAnZGF0ZUZvcm1hdCcpO1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHR2YXIgcGFyc2VSZXMgPSBwYXJzZURhdGVUaW1lSW50ZXJuYWwoZHBfZGF0ZUZvcm1hdCwgdGhpcy5fZGVmYXVsdHMudGltZUZvcm1hdCwgdGltZVN0cmluZywgJC5kYXRlcGlja2VyLl9nZXRGb3JtYXRDb25maWcodGhpcy5pbnN0KSwgdGhpcy5fZGVmYXVsdHMpO1xyXG5cdFx0XHRcdFx0aWYgKCFwYXJzZVJlcy50aW1lT2JqKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdCQuZXh0ZW5kKHRoaXMsIHBhcnNlUmVzLnRpbWVPYmopO1xyXG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0XHRcdFx0JC50aW1lcGlja2VyLmxvZyhcIkVycm9yIHBhcnNpbmcgdGhlIGRhdGUvdGltZSBzdHJpbmc6IFwiICsgZXJyICtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XCJcXG5kYXRlL3RpbWUgc3RyaW5nID0gXCIgKyB0aW1lU3RyaW5nICtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XCJcXG50aW1lRm9ybWF0ID0gXCIgKyB0aGlzLl9kZWZhdWx0cy50aW1lRm9ybWF0ICtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XCJcXG5kYXRlRm9ybWF0ID0gXCIgKyBkcF9kYXRlRm9ybWF0KTtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHRpbWVPYmogPSAkLmRhdGVwaWNrZXIucGFyc2VUaW1lKHRoaXMuX2RlZmF1bHRzLnRpbWVGb3JtYXQsIHRpbWVTdHJpbmcsIHRoaXMuX2RlZmF1bHRzKTtcclxuXHRcdFx0XHRpZiAoIXRpbWVPYmopIHtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0JC5leHRlbmQodGhpcywgdGltZU9iaik7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LypcclxuXHRcdCogSGFuZGxlIGNhbGxiYWNrIG9wdGlvbiBhZnRlciBpbmplY3RpbmcgdGltZXBpY2tlclxyXG5cdFx0Ki9cclxuXHRcdF9hZnRlckluamVjdDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciBvID0gdGhpcy5pbnN0LnNldHRpbmdzO1xyXG5cdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKG8uYWZ0ZXJJbmplY3QpKSB7XHJcblx0XHRcdFx0by5hZnRlckluamVjdC5jYWxsKHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qXHJcblx0XHQqIGdlbmVyYXRlIGFuZCBpbmplY3QgaHRtbCBmb3IgdGltZXBpY2tlciBpbnRvIHVpIGRhdGVwaWNrZXJcclxuXHRcdCovXHJcblx0XHRfaW5qZWN0VGltZVBpY2tlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgJGRwID0gdGhpcy5pbnN0LmRwRGl2LFxyXG5cdFx0XHRcdG8gPSB0aGlzLmluc3Quc2V0dGluZ3MsXHJcblx0XHRcdFx0dHBfaW5zdCA9IHRoaXMsXHJcblx0XHRcdFx0bGl0ZW0gPSAnJyxcclxuXHRcdFx0XHR1aXRlbSA9ICcnLFxyXG5cdFx0XHRcdHNob3cgPSBudWxsLFxyXG5cdFx0XHRcdG1heCA9IHt9LFxyXG5cdFx0XHRcdGdyaWRTaXplID0ge30sXHJcblx0XHRcdFx0c2l6ZSA9IG51bGwsXHJcblx0XHRcdFx0aSA9IDAsXHJcblx0XHRcdFx0bCA9IDA7XHJcblxyXG5cdFx0XHQvLyBQcmV2ZW50IGRpc3BsYXlpbmcgdHdpY2VcclxuXHRcdFx0aWYgKCRkcC5maW5kKFwiZGl2LnVpLXRpbWVwaWNrZXItZGl2XCIpLmxlbmd0aCA9PT0gMCAmJiBvLnNob3dUaW1lcGlja2VyKSB7XHJcblx0XHRcdFx0dmFyIG5vRGlzcGxheSA9ICcgdWlfdHBpY2tlcl91bml0X2hpZGUnLFxyXG5cdFx0XHRcdFx0aHRtbCA9ICc8ZGl2IGNsYXNzPVwidWktdGltZXBpY2tlci1kaXYnICsgKG8uaXNSVEwgPyAnIHVpLXRpbWVwaWNrZXItcnRsJyA6ICcnKSArIChvLm9uZUxpbmUgJiYgby5jb250cm9sVHlwZSA9PT0gJ3NlbGVjdCcgPyAnIHVpLXRpbWVwaWNrZXItb25lTGluZScgOiAnJykgKyAnXCI+PGRsPicgKyAnPGR0IGNsYXNzPVwidWlfdHBpY2tlcl90aW1lX2xhYmVsJyArICgoby5zaG93VGltZSkgPyAnJyA6IG5vRGlzcGxheSkgKyAnXCI+JyArIG8udGltZVRleHQgKyAnPC9kdD4nICtcclxuXHRcdFx0XHRcdFx0XHRcdCc8ZGQgY2xhc3M9XCJ1aV90cGlja2VyX3RpbWUgJysgKChvLnNob3dUaW1lKSA/ICcnIDogbm9EaXNwbGF5KSArICdcIj48aW5wdXQgY2xhc3M9XCJ1aV90cGlja2VyX3RpbWVfaW5wdXRcIiAnICsgKG8udGltZUlucHV0ID8gJycgOiAnZGlzYWJsZWQnKSArICcvPjwvZGQ+JztcclxuXHJcblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBtYXJrdXBcclxuXHRcdFx0XHRmb3IgKGkgPSAwLCBsID0gdGhpcy51bml0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdFx0XHRcdGxpdGVtID0gdGhpcy51bml0c1tpXTtcclxuXHRcdFx0XHRcdHVpdGVtID0gbGl0ZW0uc3Vic3RyKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBsaXRlbS5zdWJzdHIoMSk7XHJcblx0XHRcdFx0XHRzaG93ID0gb1snc2hvdycgKyB1aXRlbV0gIT09IG51bGwgPyBvWydzaG93JyArIHVpdGVtXSA6IHRoaXMuc3VwcG9ydFtsaXRlbV07XHJcblxyXG5cdFx0XHRcdFx0Ly8gQWRkZWQgYnkgUGV0ZXIgTWVkZWlyb3M6XHJcblx0XHRcdFx0XHQvLyAtIEZpZ3VyZSBvdXQgd2hhdCB0aGUgaG91ci9taW51dGUvc2Vjb25kIG1heCBzaG91bGQgYmUgYmFzZWQgb24gdGhlIHN0ZXAgdmFsdWVzLlxyXG5cdFx0XHRcdFx0Ly8gLSBFeGFtcGxlOiBpZiBzdGVwTWludXRlIGlzIDE1LCB0aGVuIG1pbk1heCBpcyA0NS5cclxuXHRcdFx0XHRcdG1heFtsaXRlbV0gPSBwYXJzZUludCgob1tsaXRlbSArICdNYXgnXSAtICgob1tsaXRlbSArICdNYXgnXSAtIG9bbGl0ZW0gKyAnTWluJ10pICUgb1snc3RlcCcgKyB1aXRlbV0pKSwgMTApO1xyXG5cdFx0XHRcdFx0Z3JpZFNpemVbbGl0ZW1dID0gMDtcclxuXHJcblx0XHRcdFx0XHRodG1sICs9ICc8ZHQgY2xhc3M9XCJ1aV90cGlja2VyXycgKyBsaXRlbSArICdfbGFiZWwnICsgKHNob3cgPyAnJyA6IG5vRGlzcGxheSkgKyAnXCI+JyArIG9bbGl0ZW0gKyAnVGV4dCddICsgJzwvZHQ+JyArXHJcblx0XHRcdFx0XHRcdFx0XHQnPGRkIGNsYXNzPVwidWlfdHBpY2tlcl8nICsgbGl0ZW0gKyAoc2hvdyA/ICcnIDogbm9EaXNwbGF5KSArICdcIj48ZGl2IGNsYXNzPVwidWlfdHBpY2tlcl8nICsgbGl0ZW0gKyAnX3NsaWRlcicgKyAoc2hvdyA/ICcnIDogbm9EaXNwbGF5KSArICdcIj48L2Rpdj4nO1xyXG5cclxuXHRcdFx0XHRcdGlmIChzaG93ICYmIG9bbGl0ZW0gKyAnR3JpZCddID4gMCkge1xyXG5cdFx0XHRcdFx0XHRodG1sICs9ICc8ZGl2IHN0eWxlPVwicGFkZGluZy1sZWZ0OiAxcHhcIj48dGFibGUgY2xhc3M9XCJ1aS10cGlja2VyLWdyaWQtbGFiZWxcIj48dHI+JztcclxuXHJcblx0XHRcdFx0XHRcdGlmIChsaXRlbSA9PT0gJ2hvdXInKSB7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaCA9IG9bbGl0ZW0gKyAnTWluJ107IGggPD0gbWF4W2xpdGVtXTsgaCArPSBwYXJzZUludChvW2xpdGVtICsgJ0dyaWQnXSwgMTApKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRncmlkU2l6ZVtsaXRlbV0rKztcclxuXHRcdFx0XHRcdFx0XHRcdHZhciB0bXBoID0gJC5kYXRlcGlja2VyLmZvcm1hdFRpbWUodGhpcy5zdXBwb3J0LmFtcG0gPyAnaGh0JyA6ICdISCcsIHtob3VyOiBofSwgbyk7XHJcblx0XHRcdFx0XHRcdFx0XHRodG1sICs9ICc8dGQgZGF0YS1mb3I9XCInICsgbGl0ZW0gKyAnXCI+JyArIHRtcGggKyAnPC90ZD4nO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBtID0gb1tsaXRlbSArICdNaW4nXTsgbSA8PSBtYXhbbGl0ZW1dOyBtICs9IHBhcnNlSW50KG9bbGl0ZW0gKyAnR3JpZCddLCAxMCkpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGdyaWRTaXplW2xpdGVtXSsrO1xyXG5cdFx0XHRcdFx0XHRcdFx0aHRtbCArPSAnPHRkIGRhdGEtZm9yPVwiJyArIGxpdGVtICsgJ1wiPicgKyAoKG0gPCAxMCkgPyAnMCcgOiAnJykgKyBtICsgJzwvdGQ+JztcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGh0bWwgKz0gJzwvdHI+PC90YWJsZT48L2Rpdj4nO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aHRtbCArPSAnPC9kZD4nO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gVGltZXpvbmVcclxuXHRcdFx0XHR2YXIgc2hvd1R6ID0gby5zaG93VGltZXpvbmUgIT09IG51bGwgPyBvLnNob3dUaW1lem9uZSA6IHRoaXMuc3VwcG9ydC50aW1lem9uZTtcclxuXHRcdFx0XHRodG1sICs9ICc8ZHQgY2xhc3M9XCJ1aV90cGlja2VyX3RpbWV6b25lX2xhYmVsJyArIChzaG93VHogPyAnJyA6IG5vRGlzcGxheSkgKyAnXCI+JyArIG8udGltZXpvbmVUZXh0ICsgJzwvZHQ+JztcclxuXHRcdFx0XHRodG1sICs9ICc8ZGQgY2xhc3M9XCJ1aV90cGlja2VyX3RpbWV6b25lJyArIChzaG93VHogPyAnJyA6IG5vRGlzcGxheSkgKyAnXCI+PC9kZD4nO1xyXG5cclxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGVsZW1lbnRzIGZyb20gc3RyaW5nXHJcblx0XHRcdFx0aHRtbCArPSAnPC9kbD48L2Rpdj4nO1xyXG5cdFx0XHRcdHZhciAkdHAgPSAkKGh0bWwpO1xyXG5cclxuXHRcdFx0XHQvLyBpZiB3ZSBvbmx5IHdhbnQgdGltZSBwaWNrZXIuLi5cclxuXHRcdFx0XHRpZiAoby50aW1lT25seSA9PT0gdHJ1ZSkge1xyXG5cdFx0XHRcdFx0JHRwLnByZXBlbmQoJzxkaXYgY2xhc3M9XCJ1aS13aWRnZXQtaGVhZGVyIHVpLWhlbHBlci1jbGVhcmZpeCB1aS1jb3JuZXItYWxsXCI+JyArICc8ZGl2IGNsYXNzPVwidWktZGF0ZXBpY2tlci10aXRsZVwiPicgKyBvLnRpbWVPbmx5VGl0bGUgKyAnPC9kaXY+JyArICc8L2Rpdj4nKTtcclxuXHRcdFx0XHRcdCRkcC5maW5kKCcudWktZGF0ZXBpY2tlci1oZWFkZXIsIC51aS1kYXRlcGlja2VyLWNhbGVuZGFyJykuaGlkZSgpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gYWRkIHNsaWRlcnMsIGFkanVzdCBncmlkcywgYWRkIGV2ZW50c1xyXG5cdFx0XHRcdGZvciAoaSA9IDAsIGwgPSB0cF9pbnN0LnVuaXRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHRcdFx0bGl0ZW0gPSB0cF9pbnN0LnVuaXRzW2ldO1xyXG5cdFx0XHRcdFx0dWl0ZW0gPSBsaXRlbS5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSArIGxpdGVtLnN1YnN0cigxKTtcclxuXHRcdFx0XHRcdHNob3cgPSBvWydzaG93JyArIHVpdGVtXSAhPT0gbnVsbCA/IG9bJ3Nob3cnICsgdWl0ZW1dIDogdGhpcy5zdXBwb3J0W2xpdGVtXTtcclxuXHJcblx0XHRcdFx0XHQvLyBhZGQgdGhlIHNsaWRlclxyXG5cdFx0XHRcdFx0dHBfaW5zdFtsaXRlbSArICdfc2xpZGVyJ10gPSB0cF9pbnN0LmNvbnRyb2wuY3JlYXRlKHRwX2luc3QsICR0cC5maW5kKCcudWlfdHBpY2tlcl8nICsgbGl0ZW0gKyAnX3NsaWRlcicpLCBsaXRlbSwgdHBfaW5zdFtsaXRlbV0sIG9bbGl0ZW0gKyAnTWluJ10sIG1heFtsaXRlbV0sIG9bJ3N0ZXAnICsgdWl0ZW1dKTtcclxuXHJcblx0XHRcdFx0XHQvLyBhZGp1c3QgdGhlIGdyaWQgYW5kIGFkZCBjbGljayBldmVudFxyXG5cdFx0XHRcdFx0aWYgKHNob3cgJiYgb1tsaXRlbSArICdHcmlkJ10gPiAwKSB7XHJcblx0XHRcdFx0XHRcdHNpemUgPSAxMDAgKiBncmlkU2l6ZVtsaXRlbV0gKiBvW2xpdGVtICsgJ0dyaWQnXSAvIChtYXhbbGl0ZW1dIC0gb1tsaXRlbSArICdNaW4nXSk7XHJcblx0XHRcdFx0XHRcdCR0cC5maW5kKCcudWlfdHBpY2tlcl8nICsgbGl0ZW0gKyAnIHRhYmxlJykuY3NzKHtcclxuXHRcdFx0XHRcdFx0XHR3aWR0aDogc2l6ZSArIFwiJVwiLFxyXG5cdFx0XHRcdFx0XHRcdG1hcmdpbkxlZnQ6IG8uaXNSVEwgPyAnMCcgOiAoKHNpemUgLyAoLTIgKiBncmlkU2l6ZVtsaXRlbV0pKSArIFwiJVwiKSxcclxuXHRcdFx0XHRcdFx0XHRtYXJnaW5SaWdodDogby5pc1JUTCA/ICgoc2l6ZSAvICgtMiAqIGdyaWRTaXplW2xpdGVtXSkpICsgXCIlXCIpIDogJzAnLFxyXG5cdFx0XHRcdFx0XHRcdGJvcmRlckNvbGxhcHNlOiAnY29sbGFwc2UnXHJcblx0XHRcdFx0XHRcdH0pLmZpbmQoXCJ0ZFwiKS5jbGljayhmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyICR0ID0gJCh0aGlzKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0aCA9ICR0Lmh0bWwoKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0biA9IHBhcnNlSW50KGgucmVwbGFjZSgvW14wLTldL2cpLCAxMCksXHJcblx0XHRcdFx0XHRcdFx0XHRcdGFwID0gaC5yZXBsYWNlKC9bXmFwbV0vaWcpLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRmID0gJHQuZGF0YSgnZm9yJyk7IC8vIGxvc2VzIHNjb3BlLCBzbyB3ZSB1c2UgZGF0YS1mb3JcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoZiA9PT0gJ2hvdXInKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChhcC5pbmRleE9mKCdwJykgIT09IC0xICYmIG4gPCAxMikge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG4gKz0gMTI7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGFwLmluZGV4T2YoJ2EnKSAhPT0gLTEgJiYgbiA9PT0gMTIpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG4gPSAwO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHRwX2luc3QuY29udHJvbC52YWx1ZSh0cF9pbnN0LCB0cF9pbnN0W2YgKyAnX3NsaWRlciddLCBsaXRlbSwgbik7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fb25UaW1lQ2hhbmdlKCk7XHJcblx0XHRcdFx0XHRcdFx0XHR0cF9pbnN0Ll9vblNlbGVjdEhhbmRsZXIoKTtcclxuXHRcdFx0XHRcdFx0XHR9KS5jc3Moe1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3Vyc29yOiAncG9pbnRlcicsXHJcblx0XHRcdFx0XHRcdFx0XHR3aWR0aDogKDEwMCAvIGdyaWRTaXplW2xpdGVtXSkgKyAnJScsXHJcblx0XHRcdFx0XHRcdFx0XHR0ZXh0QWxpZ246ICdjZW50ZXInLFxyXG5cdFx0XHRcdFx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nXHJcblx0XHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9IC8vIGVuZCBpZiBncmlkID4gMFxyXG5cdFx0XHRcdH0gLy8gZW5kIGZvciBsb29wXHJcblxyXG5cdFx0XHRcdC8vIEFkZCB0aW1lem9uZSBvcHRpb25zXHJcblx0XHRcdFx0dGhpcy50aW1lem9uZV9zZWxlY3QgPSAkdHAuZmluZCgnLnVpX3RwaWNrZXJfdGltZXpvbmUnKS5hcHBlbmQoJzxzZWxlY3Q+PC9zZWxlY3Q+JykuZmluZChcInNlbGVjdFwiKTtcclxuXHRcdFx0XHQkLmZuLmFwcGVuZC5hcHBseSh0aGlzLnRpbWV6b25lX3NlbGVjdCxcclxuXHRcdFx0XHQkLm1hcChvLnRpbWV6b25lTGlzdCwgZnVuY3Rpb24gKHZhbCwgaWR4KSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gJChcIjxvcHRpb24gLz5cIikudmFsKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgPyB2YWwudmFsdWUgOiB2YWwpLnRleHQodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiA/IHZhbC5sYWJlbCA6IHZhbCk7XHJcblx0XHRcdFx0fSkpO1xyXG5cdFx0XHRcdGlmICh0eXBlb2YodGhpcy50aW1lem9uZSkgIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy50aW1lem9uZSAhPT0gbnVsbCAmJiB0aGlzLnRpbWV6b25lICE9PSBcIlwiKSB7XHJcblx0XHRcdFx0XHR2YXIgbG9jYWxfdGltZXpvbmUgPSAobmV3IERhdGUodGhpcy5pbnN0LnNlbGVjdGVkWWVhciwgdGhpcy5pbnN0LnNlbGVjdGVkTW9udGgsIHRoaXMuaW5zdC5zZWxlY3RlZERheSwgMTIpKS5nZXRUaW1lem9uZU9mZnNldCgpICogLTE7XHJcblx0XHRcdFx0XHRpZiAobG9jYWxfdGltZXpvbmUgPT09IHRoaXMudGltZXpvbmUpIHtcclxuXHRcdFx0XHRcdFx0c2VsZWN0TG9jYWxUaW1lem9uZSh0cF9pbnN0KTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMudGltZXpvbmVfc2VsZWN0LnZhbCh0aGlzLnRpbWV6b25lKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZih0aGlzLmhvdXIpICE9PSBcInVuZGVmaW5lZFwiICYmIHRoaXMuaG91ciAhPT0gbnVsbCAmJiB0aGlzLmhvdXIgIT09IFwiXCIpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy50aW1lem9uZV9zZWxlY3QudmFsKG8udGltZXpvbmUpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0c2VsZWN0TG9jYWxUaW1lem9uZSh0cF9pbnN0KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy50aW1lem9uZV9zZWxlY3QuY2hhbmdlKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdHRwX2luc3QuX29uVGltZUNoYW5nZSgpO1xyXG5cdFx0XHRcdFx0dHBfaW5zdC5fb25TZWxlY3RIYW5kbGVyKCk7XHJcblx0XHRcdFx0XHR0cF9pbnN0Ll9hZnRlckluamVjdCgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdC8vIEVuZCB0aW1lem9uZSBvcHRpb25zXHJcblxyXG5cdFx0XHRcdC8vIGluamVjdCB0aW1lcGlja2VyIGludG8gZGF0ZXBpY2tlclxyXG5cdFx0XHRcdHZhciAkYnV0dG9uUGFuZWwgPSAkZHAuZmluZCgnLnVpLWRhdGVwaWNrZXItYnV0dG9ucGFuZScpO1xyXG5cdFx0XHRcdGlmICgkYnV0dG9uUGFuZWwubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHQkYnV0dG9uUGFuZWwuYmVmb3JlKCR0cCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdCRkcC5hcHBlbmQoJHRwKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuJHRpbWVPYmogPSAkdHAuZmluZCgnLnVpX3RwaWNrZXJfdGltZV9pbnB1dCcpO1xyXG5cdFx0XHRcdHRoaXMuJHRpbWVPYmouY2hhbmdlKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdHZhciB0aW1lRm9ybWF0ID0gdHBfaW5zdC5pbnN0LnNldHRpbmdzLnRpbWVGb3JtYXQ7XHJcblx0XHRcdFx0XHR2YXIgcGFyc2VkVGltZSA9ICQuZGF0ZXBpY2tlci5wYXJzZVRpbWUodGltZUZvcm1hdCwgdGhpcy52YWx1ZSk7XHJcblx0XHRcdFx0XHR2YXIgdXBkYXRlID0gbmV3IERhdGUoKTtcclxuXHRcdFx0XHRcdGlmIChwYXJzZWRUaW1lKSB7XHJcblx0XHRcdFx0XHRcdHVwZGF0ZS5zZXRIb3VycyhwYXJzZWRUaW1lLmhvdXIpO1xyXG5cdFx0XHRcdFx0XHR1cGRhdGUuc2V0TWludXRlcyhwYXJzZWRUaW1lLm1pbnV0ZSk7XHJcblx0XHRcdFx0XHRcdHVwZGF0ZS5zZXRTZWNvbmRzKHBhcnNlZFRpbWUuc2Vjb25kKTtcclxuXHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zZXRUaW1lKHRwX2luc3QuaW5zdCwgdXBkYXRlKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMudmFsdWUgPSB0cF9pbnN0LmZvcm1hdHRlZFRpbWU7XHJcblx0XHRcdFx0XHRcdHRoaXMuYmx1cigpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRpZiAodGhpcy5pbnN0ICE9PSBudWxsKSB7XHJcblx0XHRcdFx0XHR2YXIgdGltZURlZmluZWQgPSB0aGlzLnRpbWVEZWZpbmVkO1xyXG5cdFx0XHRcdFx0dGhpcy5fb25UaW1lQ2hhbmdlKCk7XHJcblx0XHRcdFx0XHR0aGlzLnRpbWVEZWZpbmVkID0gdGltZURlZmluZWQ7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBzbGlkZUFjY2VzcyBpbnRlZ3JhdGlvbjogaHR0cDovL3RyZW50cmljaGFyZHNvbi5jb20vMjAxMS8xMS8xMS9qcXVlcnktdWktc2xpZGVycy1hbmQtdG91Y2gtYWNjZXNzaWJpbGl0eS9cclxuXHRcdFx0XHRpZiAodGhpcy5fZGVmYXVsdHMuYWRkU2xpZGVyQWNjZXNzKSB7XHJcblx0XHRcdFx0XHR2YXIgc2xpZGVyQWNjZXNzQXJncyA9IHRoaXMuX2RlZmF1bHRzLnNsaWRlckFjY2Vzc0FyZ3MsXHJcblx0XHRcdFx0XHRcdHJ0bCA9IHRoaXMuX2RlZmF1bHRzLmlzUlRMO1xyXG5cdFx0XHRcdFx0c2xpZGVyQWNjZXNzQXJncy5pc1JUTCA9IHJ0bDtcclxuXHJcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgLy8gZml4IGZvciBpbmxpbmUgbW9kZVxyXG5cdFx0XHRcdFx0XHRpZiAoJHRwLmZpbmQoJy51aS1zbGlkZXItYWNjZXNzJykubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0JHRwLmZpbmQoJy51aS1zbGlkZXI6dmlzaWJsZScpLnNsaWRlckFjY2VzcyhzbGlkZXJBY2Nlc3NBcmdzKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gZml4IGFueSBncmlkcyBzaW5jZSBzbGlkZXJzIGFyZSBzaG9ydGVyXHJcblx0XHRcdFx0XHRcdFx0dmFyIHNsaWRlckFjY2Vzc1dpZHRoID0gJHRwLmZpbmQoJy51aS1zbGlkZXItYWNjZXNzOmVxKDApJykub3V0ZXJXaWR0aCh0cnVlKTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoc2xpZGVyQWNjZXNzV2lkdGgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdCR0cC5maW5kKCd0YWJsZTp2aXNpYmxlJykuZWFjaChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhciAkZyA9ICQodGhpcyksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0b2xkV2lkdGggPSAkZy5vdXRlcldpZHRoKCksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0b2xkTWFyZ2luTGVmdCA9ICRnLmNzcyhydGwgPyAnbWFyZ2luUmlnaHQnIDogJ21hcmdpbkxlZnQnKS50b1N0cmluZygpLnJlcGxhY2UoJyUnLCAnJyksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3V2lkdGggPSBvbGRXaWR0aCAtIHNsaWRlckFjY2Vzc1dpZHRoLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5ld01hcmdpbkxlZnQgPSAoKG9sZE1hcmdpbkxlZnQgKiBuZXdXaWR0aCkgLyBvbGRXaWR0aCkgKyAnJScsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y3NzID0geyB3aWR0aDogbmV3V2lkdGgsIG1hcmdpblJpZ2h0OiAwLCBtYXJnaW5MZWZ0OiAwIH07XHJcblx0XHRcdFx0XHRcdFx0XHRcdGNzc1tydGwgPyAnbWFyZ2luUmlnaHQnIDogJ21hcmdpbkxlZnQnXSA9IG5ld01hcmdpbkxlZnQ7XHJcblx0XHRcdFx0XHRcdFx0XHRcdCRnLmNzcyhjc3MpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LCAxMCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIGVuZCBzbGlkZUFjY2VzcyBpbnRlZ3JhdGlvblxyXG5cclxuXHRcdFx0XHR0cF9pbnN0Ll9saW1pdE1pbk1heERhdGVUaW1lKHRoaXMuaW5zdCwgdHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LypcclxuXHRcdCogVGhpcyBmdW5jdGlvbiB0cmllcyB0byBsaW1pdCB0aGUgYWJpbGl0eSB0byBnbyBvdXRzaWRlIHRoZVxyXG5cdFx0KiBtaW4vbWF4IGRhdGUgcmFuZ2VcclxuXHRcdCovXHJcblx0XHRfbGltaXRNaW5NYXhEYXRlVGltZTogZnVuY3Rpb24gKGRwX2luc3QsIGFkanVzdFNsaWRlcnMpIHtcclxuXHRcdFx0dmFyIG8gPSB0aGlzLl9kZWZhdWx0cyxcclxuXHRcdFx0XHRkcF9kYXRlID0gbmV3IERhdGUoZHBfaW5zdC5zZWxlY3RlZFllYXIsIGRwX2luc3Quc2VsZWN0ZWRNb250aCwgZHBfaW5zdC5zZWxlY3RlZERheSk7XHJcblxyXG5cdFx0XHRpZiAoIXRoaXMuX2RlZmF1bHRzLnNob3dUaW1lcGlja2VyKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9IC8vIE5vIHRpbWUgc28gbm90aGluZyB0byBjaGVjayBoZXJlXHJcblxyXG5cdFx0XHRpZiAoJC5kYXRlcGlja2VyLl9nZXQoZHBfaW5zdCwgJ21pbkRhdGVUaW1lJykgIT09IG51bGwgJiYgJC5kYXRlcGlja2VyLl9nZXQoZHBfaW5zdCwgJ21pbkRhdGVUaW1lJykgIT09IHVuZGVmaW5lZCAmJiBkcF9kYXRlKSB7XHJcblx0XHRcdFx0dmFyIG1pbkRhdGVUaW1lID0gJC5kYXRlcGlja2VyLl9nZXQoZHBfaW5zdCwgJ21pbkRhdGVUaW1lJyksXHJcblx0XHRcdFx0XHRtaW5EYXRlVGltZURhdGUgPSBuZXcgRGF0ZShtaW5EYXRlVGltZS5nZXRGdWxsWWVhcigpLCBtaW5EYXRlVGltZS5nZXRNb250aCgpLCBtaW5EYXRlVGltZS5nZXREYXRlKCksIDAsIDAsIDAsIDApO1xyXG5cclxuXHRcdFx0XHRpZiAodGhpcy5ob3VyTWluT3JpZ2luYWwgPT09IG51bGwgfHwgdGhpcy5taW51dGVNaW5PcmlnaW5hbCA9PT0gbnVsbCB8fCB0aGlzLnNlY29uZE1pbk9yaWdpbmFsID09PSBudWxsIHx8IHRoaXMubWlsbGlzZWNNaW5PcmlnaW5hbCA9PT0gbnVsbCB8fCB0aGlzLm1pY3Jvc2VjTWluT3JpZ2luYWwgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdHRoaXMuaG91ck1pbk9yaWdpbmFsID0gby5ob3VyTWluO1xyXG5cdFx0XHRcdFx0dGhpcy5taW51dGVNaW5PcmlnaW5hbCA9IG8ubWludXRlTWluO1xyXG5cdFx0XHRcdFx0dGhpcy5zZWNvbmRNaW5PcmlnaW5hbCA9IG8uc2Vjb25kTWluO1xyXG5cdFx0XHRcdFx0dGhpcy5taWxsaXNlY01pbk9yaWdpbmFsID0gby5taWxsaXNlY01pbjtcclxuXHRcdFx0XHRcdHRoaXMubWljcm9zZWNNaW5PcmlnaW5hbCA9IG8ubWljcm9zZWNNaW47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoZHBfaW5zdC5zZXR0aW5ncy50aW1lT25seSB8fCBtaW5EYXRlVGltZURhdGUuZ2V0VGltZSgpID09PSBkcF9kYXRlLmdldFRpbWUoKSkge1xyXG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuaG91ck1pbiA9IG1pbkRhdGVUaW1lLmdldEhvdXJzKCk7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5ob3VyIDw9IHRoaXMuX2RlZmF1bHRzLmhvdXJNaW4pIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5ob3VyID0gdGhpcy5fZGVmYXVsdHMuaG91ck1pbjtcclxuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWluID0gbWluRGF0ZVRpbWUuZ2V0TWludXRlcygpO1xyXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5taW51dGUgPD0gdGhpcy5fZGVmYXVsdHMubWludXRlTWluKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5taW51dGUgPSB0aGlzLl9kZWZhdWx0cy5taW51dGVNaW47XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuc2Vjb25kTWluID0gbWluRGF0ZVRpbWUuZ2V0U2Vjb25kcygpO1xyXG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLnNlY29uZCA8PSB0aGlzLl9kZWZhdWx0cy5zZWNvbmRNaW4pIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2Vjb25kID0gdGhpcy5fZGVmYXVsdHMuc2Vjb25kTWluO1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNaW4gPSBtaW5EYXRlVGltZS5nZXRNaWxsaXNlY29uZHMoKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLm1pbGxpc2VjIDw9IHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWluKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMubWlsbGlzZWMgPSB0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01pbjtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4gPSBtaW5EYXRlVGltZS5nZXRNaWNyb3NlY29uZHMoKTtcclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLm1pY3Jvc2VjIDwgdGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4pIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLm1pY3Jvc2VjID0gdGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW47XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4gPSB0aGlzLm1pY3Jvc2VjTWluT3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWluID0gdGhpcy5taWxsaXNlY01pbk9yaWdpbmFsO1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4gPSB0aGlzLm1pY3Jvc2VjTWluT3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1pbiA9IHRoaXMuc2Vjb25kTWluT3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNaW4gPSB0aGlzLm1pbGxpc2VjTWluT3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4gPSB0aGlzLm1pY3Jvc2VjTWluT3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1pbiA9IHRoaXMubWludXRlTWluT3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1pbiA9IHRoaXMuc2Vjb25kTWluT3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWluID0gdGhpcy5taWxsaXNlY01pbk9yaWdpbmFsO1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01pbiA9IHRoaXMubWljcm9zZWNNaW5PcmlnaW5hbDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuaG91ck1pbiA9IHRoaXMuaG91ck1pbk9yaWdpbmFsO1xyXG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWluID0gdGhpcy5taW51dGVNaW5PcmlnaW5hbDtcclxuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1pbiA9IHRoaXMuc2Vjb25kTWluT3JpZ2luYWw7XHJcblx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01pbiA9IHRoaXMubWlsbGlzZWNNaW5PcmlnaW5hbDtcclxuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWluID0gdGhpcy5taWNyb3NlY01pbk9yaWdpbmFsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCQuZGF0ZXBpY2tlci5fZ2V0KGRwX2luc3QsICdtYXhEYXRlVGltZScpICE9PSBudWxsICYmICQuZGF0ZXBpY2tlci5fZ2V0KGRwX2luc3QsICdtYXhEYXRlVGltZScpICE9PSB1bmRlZmluZWQgJiYgZHBfZGF0ZSkge1xyXG5cdFx0XHRcdHZhciBtYXhEYXRlVGltZSA9ICQuZGF0ZXBpY2tlci5fZ2V0KGRwX2luc3QsICdtYXhEYXRlVGltZScpLFxyXG5cdFx0XHRcdFx0bWF4RGF0ZVRpbWVEYXRlID0gbmV3IERhdGUobWF4RGF0ZVRpbWUuZ2V0RnVsbFllYXIoKSwgbWF4RGF0ZVRpbWUuZ2V0TW9udGgoKSwgbWF4RGF0ZVRpbWUuZ2V0RGF0ZSgpLCAwLCAwLCAwLCAwKTtcclxuXHJcblx0XHRcdFx0aWYgKHRoaXMuaG91ck1heE9yaWdpbmFsID09PSBudWxsIHx8IHRoaXMubWludXRlTWF4T3JpZ2luYWwgPT09IG51bGwgfHwgdGhpcy5zZWNvbmRNYXhPcmlnaW5hbCA9PT0gbnVsbCB8fCB0aGlzLm1pbGxpc2VjTWF4T3JpZ2luYWwgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdHRoaXMuaG91ck1heE9yaWdpbmFsID0gby5ob3VyTWF4O1xyXG5cdFx0XHRcdFx0dGhpcy5taW51dGVNYXhPcmlnaW5hbCA9IG8ubWludXRlTWF4O1xyXG5cdFx0XHRcdFx0dGhpcy5zZWNvbmRNYXhPcmlnaW5hbCA9IG8uc2Vjb25kTWF4O1xyXG5cdFx0XHRcdFx0dGhpcy5taWxsaXNlY01heE9yaWdpbmFsID0gby5taWxsaXNlY01heDtcclxuXHRcdFx0XHRcdHRoaXMubWljcm9zZWNNYXhPcmlnaW5hbCA9IG8ubWljcm9zZWNNYXg7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoZHBfaW5zdC5zZXR0aW5ncy50aW1lT25seSB8fCBtYXhEYXRlVGltZURhdGUuZ2V0VGltZSgpID09PSBkcF9kYXRlLmdldFRpbWUoKSkge1xyXG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuaG91ck1heCA9IG1heERhdGVUaW1lLmdldEhvdXJzKCk7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5ob3VyID49IHRoaXMuX2RlZmF1bHRzLmhvdXJNYXgpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5ob3VyID0gdGhpcy5fZGVmYXVsdHMuaG91ck1heDtcclxuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWF4ID0gbWF4RGF0ZVRpbWUuZ2V0TWludXRlcygpO1xyXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5taW51dGUgPj0gdGhpcy5fZGVmYXVsdHMubWludXRlTWF4KSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5taW51dGUgPSB0aGlzLl9kZWZhdWx0cy5taW51dGVNYXg7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuc2Vjb25kTWF4ID0gbWF4RGF0ZVRpbWUuZ2V0U2Vjb25kcygpO1xyXG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLnNlY29uZCA+PSB0aGlzLl9kZWZhdWx0cy5zZWNvbmRNYXgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2Vjb25kID0gdGhpcy5fZGVmYXVsdHMuc2Vjb25kTWF4O1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNYXggPSBtYXhEYXRlVGltZS5nZXRNaWxsaXNlY29uZHMoKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLm1pbGxpc2VjID49IHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWF4KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMubWlsbGlzZWMgPSB0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01heDtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXggPSBtYXhEYXRlVGltZS5nZXRNaWNyb3NlY29uZHMoKTtcclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLm1pY3Jvc2VjID4gdGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLm1pY3Jvc2VjID0gdGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXg7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXggPSB0aGlzLm1pY3Jvc2VjTWF4T3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWF4ID0gdGhpcy5taWxsaXNlY01heE9yaWdpbmFsO1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXggPSB0aGlzLm1pY3Jvc2VjTWF4T3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1heCA9IHRoaXMuc2Vjb25kTWF4T3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNYXggPSB0aGlzLm1pbGxpc2VjTWF4T3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXggPSB0aGlzLm1pY3Jvc2VjTWF4T3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1heCA9IHRoaXMubWludXRlTWF4T3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1heCA9IHRoaXMuc2Vjb25kTWF4T3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWF4ID0gdGhpcy5taWxsaXNlY01heE9yaWdpbmFsO1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01heCA9IHRoaXMubWljcm9zZWNNYXhPcmlnaW5hbDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuaG91ck1heCA9IHRoaXMuaG91ck1heE9yaWdpbmFsO1xyXG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWF4ID0gdGhpcy5taW51dGVNYXhPcmlnaW5hbDtcclxuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1heCA9IHRoaXMuc2Vjb25kTWF4T3JpZ2luYWw7XHJcblx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01heCA9IHRoaXMubWlsbGlzZWNNYXhPcmlnaW5hbDtcclxuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWF4ID0gdGhpcy5taWNyb3NlY01heE9yaWdpbmFsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGRwX2luc3Quc2V0dGluZ3MubWluVGltZSE9PW51bGwpIHtcclxuXHRcdFx0XHR2YXIgdGVtcE1pblRpbWU9bmV3IERhdGUoXCIwMS8wMS8xOTcwIFwiICsgZHBfaW5zdC5zZXR0aW5ncy5taW5UaW1lKTtcclxuXHRcdFx0XHRpZiAodGhpcy5ob3VyPHRlbXBNaW5UaW1lLmdldEhvdXJzKCkpIHtcclxuXHRcdFx0XHRcdHRoaXMuaG91cj10aGlzLl9kZWZhdWx0cy5ob3VyTWluPXRlbXBNaW5UaW1lLmdldEhvdXJzKCk7XHJcblx0XHRcdFx0XHR0aGlzLm1pbnV0ZT10aGlzLl9kZWZhdWx0cy5taW51dGVNaW49dGVtcE1pblRpbWUuZ2V0TWludXRlcygpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5ob3VyPT09dGVtcE1pblRpbWUuZ2V0SG91cnMoKSAmJiB0aGlzLm1pbnV0ZTx0ZW1wTWluVGltZS5nZXRNaW51dGVzKCkpIHtcclxuXHRcdFx0XHRcdHRoaXMubWludXRlPXRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1pbj10ZW1wTWluVGltZS5nZXRNaW51dGVzKCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmICh0aGlzLl9kZWZhdWx0cy5ob3VyTWluPHRlbXBNaW5UaW1lLmdldEhvdXJzKCkpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuaG91ck1pbj10ZW1wTWluVGltZS5nZXRIb3VycygpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taW51dGVNaW49dGVtcE1pblRpbWUuZ2V0TWludXRlcygpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9kZWZhdWx0cy5ob3VyTWluPT09dGVtcE1pblRpbWUuZ2V0SG91cnMoKT09PXRoaXMuaG91ciAmJiB0aGlzLl9kZWZhdWx0cy5taW51dGVNaW48dGVtcE1pblRpbWUuZ2V0TWludXRlcygpKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1pbj10ZW1wTWluVGltZS5nZXRNaW51dGVzKCk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taW51dGVNaW49MDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChkcF9pbnN0LnNldHRpbmdzLm1heFRpbWUhPT1udWxsKSB7XHJcblx0XHRcdFx0dmFyIHRlbXBNYXhUaW1lPW5ldyBEYXRlKFwiMDEvMDEvMTk3MCBcIiArIGRwX2luc3Quc2V0dGluZ3MubWF4VGltZSk7XHJcblx0XHRcdFx0aWYgKHRoaXMuaG91cj50ZW1wTWF4VGltZS5nZXRIb3VycygpKSB7XHJcblx0XHRcdFx0XHR0aGlzLmhvdXI9dGhpcy5fZGVmYXVsdHMuaG91ck1heD10ZW1wTWF4VGltZS5nZXRIb3VycygpO1xyXG5cdFx0XHRcdFx0dGhpcy5taW51dGU9dGhpcy5fZGVmYXVsdHMubWludXRlTWF4PXRlbXBNYXhUaW1lLmdldE1pbnV0ZXMoKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuaG91cj09PXRlbXBNYXhUaW1lLmdldEhvdXJzKCkgJiYgdGhpcy5taW51dGU+dGVtcE1heFRpbWUuZ2V0TWludXRlcygpKSB7XHJcblx0XHRcdFx0XHR0aGlzLm1pbnV0ZT10aGlzLl9kZWZhdWx0cy5taW51dGVNYXg9dGVtcE1heFRpbWUuZ2V0TWludXRlcygpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5fZGVmYXVsdHMuaG91ck1heD50ZW1wTWF4VGltZS5nZXRIb3VycygpKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLmhvdXJNYXg9dGVtcE1heFRpbWUuZ2V0SG91cnMoKTtcclxuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWF4PXRlbXBNYXhUaW1lLmdldE1pbnV0ZXMoKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fZGVmYXVsdHMuaG91ck1heD09PXRlbXBNYXhUaW1lLmdldEhvdXJzKCk9PT10aGlzLmhvdXIgJiYgdGhpcy5fZGVmYXVsdHMubWludXRlTWF4PnRlbXBNYXhUaW1lLmdldE1pbnV0ZXMoKSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taW51dGVNYXg9dGVtcE1heFRpbWUuZ2V0TWludXRlcygpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWF4PTU5O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGFkanVzdFNsaWRlcnMgIT09IHVuZGVmaW5lZCAmJiBhZGp1c3RTbGlkZXJzID09PSB0cnVlKSB7XHJcblx0XHRcdFx0dmFyIGhvdXJNYXggPSBwYXJzZUludCgodGhpcy5fZGVmYXVsdHMuaG91ck1heCAtICgodGhpcy5fZGVmYXVsdHMuaG91ck1heCAtIHRoaXMuX2RlZmF1bHRzLmhvdXJNaW4pICUgdGhpcy5fZGVmYXVsdHMuc3RlcEhvdXIpKSwgMTApLFxyXG5cdFx0XHRcdFx0bWluTWF4ID0gcGFyc2VJbnQoKHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1heCAtICgodGhpcy5fZGVmYXVsdHMubWludXRlTWF4IC0gdGhpcy5fZGVmYXVsdHMubWludXRlTWluKSAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBNaW51dGUpKSwgMTApLFxyXG5cdFx0XHRcdFx0c2VjTWF4ID0gcGFyc2VJbnQoKHRoaXMuX2RlZmF1bHRzLnNlY29uZE1heCAtICgodGhpcy5fZGVmYXVsdHMuc2Vjb25kTWF4IC0gdGhpcy5fZGVmYXVsdHMuc2Vjb25kTWluKSAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBTZWNvbmQpKSwgMTApLFxyXG5cdFx0XHRcdFx0bWlsbGlzZWNNYXggPSBwYXJzZUludCgodGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNYXggLSAoKHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWF4IC0gdGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNaW4pICUgdGhpcy5fZGVmYXVsdHMuc3RlcE1pbGxpc2VjKSksIDEwKSxcclxuXHRcdFx0XHRcdG1pY3Jvc2VjTWF4ID0gcGFyc2VJbnQoKHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWF4IC0gKCh0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01heCAtIHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWluKSAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBNaWNyb3NlYykpLCAxMCk7XHJcblxyXG5cdFx0XHRcdGlmICh0aGlzLmhvdXJfc2xpZGVyKSB7XHJcblx0XHRcdFx0XHR0aGlzLmNvbnRyb2wub3B0aW9ucyh0aGlzLCB0aGlzLmhvdXJfc2xpZGVyLCAnaG91cicsIHsgbWluOiB0aGlzLl9kZWZhdWx0cy5ob3VyTWluLCBtYXg6IGhvdXJNYXgsIHN0ZXA6IHRoaXMuX2RlZmF1bHRzLnN0ZXBIb3VyIH0pO1xyXG5cdFx0XHRcdFx0dGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMuaG91cl9zbGlkZXIsICdob3VyJywgdGhpcy5ob3VyIC0gKHRoaXMuaG91ciAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBIb3VyKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICh0aGlzLm1pbnV0ZV9zbGlkZXIpIHtcclxuXHRcdFx0XHRcdHRoaXMuY29udHJvbC5vcHRpb25zKHRoaXMsIHRoaXMubWludXRlX3NsaWRlciwgJ21pbnV0ZScsIHsgbWluOiB0aGlzLl9kZWZhdWx0cy5taW51dGVNaW4sIG1heDogbWluTWF4LCBzdGVwOiB0aGlzLl9kZWZhdWx0cy5zdGVwTWludXRlIH0pO1xyXG5cdFx0XHRcdFx0dGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMubWludXRlX3NsaWRlciwgJ21pbnV0ZScsIHRoaXMubWludXRlIC0gKHRoaXMubWludXRlICUgdGhpcy5fZGVmYXVsdHMuc3RlcE1pbnV0ZSkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAodGhpcy5zZWNvbmRfc2xpZGVyKSB7XHJcblx0XHRcdFx0XHR0aGlzLmNvbnRyb2wub3B0aW9ucyh0aGlzLCB0aGlzLnNlY29uZF9zbGlkZXIsICdzZWNvbmQnLCB7IG1pbjogdGhpcy5fZGVmYXVsdHMuc2Vjb25kTWluLCBtYXg6IHNlY01heCwgc3RlcDogdGhpcy5fZGVmYXVsdHMuc3RlcFNlY29uZCB9KTtcclxuXHRcdFx0XHRcdHRoaXMuY29udHJvbC52YWx1ZSh0aGlzLCB0aGlzLnNlY29uZF9zbGlkZXIsICdzZWNvbmQnLCB0aGlzLnNlY29uZCAtICh0aGlzLnNlY29uZCAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBTZWNvbmQpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHRoaXMubWlsbGlzZWNfc2xpZGVyKSB7XHJcblx0XHRcdFx0XHR0aGlzLmNvbnRyb2wub3B0aW9ucyh0aGlzLCB0aGlzLm1pbGxpc2VjX3NsaWRlciwgJ21pbGxpc2VjJywgeyBtaW46IHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWluLCBtYXg6IG1pbGxpc2VjTWF4LCBzdGVwOiB0aGlzLl9kZWZhdWx0cy5zdGVwTWlsbGlzZWMgfSk7XHJcblx0XHRcdFx0XHR0aGlzLmNvbnRyb2wudmFsdWUodGhpcywgdGhpcy5taWxsaXNlY19zbGlkZXIsICdtaWxsaXNlYycsIHRoaXMubWlsbGlzZWMgLSAodGhpcy5taWxsaXNlYyAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBNaWxsaXNlYykpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAodGhpcy5taWNyb3NlY19zbGlkZXIpIHtcclxuXHRcdFx0XHRcdHRoaXMuY29udHJvbC5vcHRpb25zKHRoaXMsIHRoaXMubWljcm9zZWNfc2xpZGVyLCAnbWljcm9zZWMnLCB7IG1pbjogdGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4sIG1heDogbWljcm9zZWNNYXgsIHN0ZXA6IHRoaXMuX2RlZmF1bHRzLnN0ZXBNaWNyb3NlYyB9KTtcclxuXHRcdFx0XHRcdHRoaXMuY29udHJvbC52YWx1ZSh0aGlzLCB0aGlzLm1pY3Jvc2VjX3NsaWRlciwgJ21pY3Jvc2VjJywgdGhpcy5taWNyb3NlYyAtICh0aGlzLm1pY3Jvc2VjICUgdGhpcy5fZGVmYXVsdHMuc3RlcE1pY3Jvc2VjKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHQvKlxyXG5cdFx0KiB3aGVuIGEgc2xpZGVyIG1vdmVzLCBzZXQgdGhlIGludGVybmFsIHRpbWUuLi5cclxuXHRcdCogb24gdGltZSBjaGFuZ2UgaXMgYWxzbyBjYWxsZWQgd2hlbiB0aGUgdGltZSBpcyB1cGRhdGVkIGluIHRoZSB0ZXh0IGZpZWxkXHJcblx0XHQqL1xyXG5cdFx0X29uVGltZUNoYW5nZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAoIXRoaXMuX2RlZmF1bHRzLnNob3dUaW1lcGlja2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBob3VyID0gKHRoaXMuaG91cl9zbGlkZXIpID8gdGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMuaG91cl9zbGlkZXIsICdob3VyJykgOiBmYWxzZSxcclxuXHRcdFx0XHRtaW51dGUgPSAodGhpcy5taW51dGVfc2xpZGVyKSA/IHRoaXMuY29udHJvbC52YWx1ZSh0aGlzLCB0aGlzLm1pbnV0ZV9zbGlkZXIsICdtaW51dGUnKSA6IGZhbHNlLFxyXG5cdFx0XHRcdHNlY29uZCA9ICh0aGlzLnNlY29uZF9zbGlkZXIpID8gdGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMuc2Vjb25kX3NsaWRlciwgJ3NlY29uZCcpIDogZmFsc2UsXHJcblx0XHRcdFx0bWlsbGlzZWMgPSAodGhpcy5taWxsaXNlY19zbGlkZXIpID8gdGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMubWlsbGlzZWNfc2xpZGVyLCAnbWlsbGlzZWMnKSA6IGZhbHNlLFxyXG5cdFx0XHRcdG1pY3Jvc2VjID0gKHRoaXMubWljcm9zZWNfc2xpZGVyKSA/IHRoaXMuY29udHJvbC52YWx1ZSh0aGlzLCB0aGlzLm1pY3Jvc2VjX3NsaWRlciwgJ21pY3Jvc2VjJykgOiBmYWxzZSxcclxuXHRcdFx0XHR0aW1lem9uZSA9ICh0aGlzLnRpbWV6b25lX3NlbGVjdCkgPyB0aGlzLnRpbWV6b25lX3NlbGVjdC52YWwoKSA6IGZhbHNlLFxyXG5cdFx0XHRcdG8gPSB0aGlzLl9kZWZhdWx0cyxcclxuXHRcdFx0XHRwaWNrZXJUaW1lRm9ybWF0ID0gby5waWNrZXJUaW1lRm9ybWF0IHx8IG8udGltZUZvcm1hdCxcclxuXHRcdFx0XHRwaWNrZXJUaW1lU3VmZml4ID0gby5waWNrZXJUaW1lU3VmZml4IHx8IG8udGltZVN1ZmZpeDtcclxuXHJcblx0XHRcdGlmICh0eXBlb2YoaG91cikgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdFx0aG91ciA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0eXBlb2YobWludXRlKSA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0XHRtaW51dGUgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodHlwZW9mKHNlY29uZCkgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdFx0c2Vjb25kID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHR5cGVvZihtaWxsaXNlYykgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdFx0bWlsbGlzZWMgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodHlwZW9mKG1pY3Jvc2VjKSA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0XHRtaWNyb3NlYyA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0eXBlb2YodGltZXpvbmUpID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRcdHRpbWV6b25lID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChob3VyICE9PSBmYWxzZSkge1xyXG5cdFx0XHRcdGhvdXIgPSBwYXJzZUludChob3VyLCAxMCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG1pbnV0ZSAhPT0gZmFsc2UpIHtcclxuXHRcdFx0XHRtaW51dGUgPSBwYXJzZUludChtaW51dGUsIDEwKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoc2Vjb25kICE9PSBmYWxzZSkge1xyXG5cdFx0XHRcdHNlY29uZCA9IHBhcnNlSW50KHNlY29uZCwgMTApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChtaWxsaXNlYyAhPT0gZmFsc2UpIHtcclxuXHRcdFx0XHRtaWxsaXNlYyA9IHBhcnNlSW50KG1pbGxpc2VjLCAxMCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG1pY3Jvc2VjICE9PSBmYWxzZSkge1xyXG5cdFx0XHRcdG1pY3Jvc2VjID0gcGFyc2VJbnQobWljcm9zZWMsIDEwKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGltZXpvbmUgIT09IGZhbHNlKSB7XHJcblx0XHRcdFx0dGltZXpvbmUgPSB0aW1lem9uZS50b1N0cmluZygpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgYW1wbSA9IG9baG91ciA8IDEyID8gJ2FtTmFtZXMnIDogJ3BtTmFtZXMnXVswXTtcclxuXHJcblx0XHRcdC8vIElmIHRoZSB1cGRhdGUgd2FzIGRvbmUgaW4gdGhlIGlucHV0IGZpZWxkLCB0aGUgaW5wdXQgZmllbGQgc2hvdWxkIG5vdCBiZSB1cGRhdGVkLlxyXG5cdFx0XHQvLyBJZiB0aGUgdXBkYXRlIHdhcyBkb25lIHVzaW5nIHRoZSBzbGlkZXJzLCB1cGRhdGUgdGhlIGlucHV0IGZpZWxkLlxyXG5cdFx0XHR2YXIgaGFzQ2hhbmdlZCA9IChcclxuXHRcdFx0XHRcdFx0aG91ciAhPT0gcGFyc2VJbnQodGhpcy5ob3VyLDEwKSB8fCAvLyBzbGlkZXJzIHNob3VsZCBhbGwgYmUgbnVtZXJpY1xyXG5cdFx0XHRcdFx0XHRtaW51dGUgIT09IHBhcnNlSW50KHRoaXMubWludXRlLDEwKSB8fFxyXG5cdFx0XHRcdFx0XHRzZWNvbmQgIT09IHBhcnNlSW50KHRoaXMuc2Vjb25kLDEwKSB8fFxyXG5cdFx0XHRcdFx0XHRtaWxsaXNlYyAhPT0gcGFyc2VJbnQodGhpcy5taWxsaXNlYywxMCkgfHxcclxuXHRcdFx0XHRcdFx0bWljcm9zZWMgIT09IHBhcnNlSW50KHRoaXMubWljcm9zZWMsMTApIHx8XHJcblx0XHRcdFx0XHRcdCh0aGlzLmFtcG0ubGVuZ3RoID4gMCAmJiAoaG91ciA8IDEyKSAhPT0gKCQuaW5BcnJheSh0aGlzLmFtcG0udG9VcHBlckNhc2UoKSwgdGhpcy5hbU5hbWVzKSAhPT0gLTEpKSB8fFxyXG5cdFx0XHRcdFx0XHQodGhpcy50aW1lem9uZSAhPT0gbnVsbCAmJiB0aW1lem9uZSAhPT0gdGhpcy50aW1lem9uZS50b1N0cmluZygpKSAvLyBjb3VsZCBiZSBudW1lcmljIG9yIFwiRVNUXCIgZm9ybWF0LCBzbyB1c2UgdG9TdHJpbmcoKVxyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdGlmIChoYXNDaGFuZ2VkKSB7XHJcblxyXG5cdFx0XHRcdGlmIChob3VyICE9PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0dGhpcy5ob3VyID0gaG91cjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKG1pbnV0ZSAhPT0gZmFsc2UpIHtcclxuXHRcdFx0XHRcdHRoaXMubWludXRlID0gbWludXRlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoc2Vjb25kICE9PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0dGhpcy5zZWNvbmQgPSBzZWNvbmQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChtaWxsaXNlYyAhPT0gZmFsc2UpIHtcclxuXHRcdFx0XHRcdHRoaXMubWlsbGlzZWMgPSBtaWxsaXNlYztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKG1pY3Jvc2VjICE9PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0dGhpcy5taWNyb3NlYyA9IG1pY3Jvc2VjO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAodGltZXpvbmUgIT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHR0aGlzLnRpbWV6b25lID0gdGltZXpvbmU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIXRoaXMuaW5zdCkge1xyXG5cdFx0XHRcdFx0dGhpcy5pbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KHRoaXMuJGlucHV0WzBdKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuX2xpbWl0TWluTWF4RGF0ZVRpbWUodGhpcy5pbnN0LCB0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGhpcy5zdXBwb3J0LmFtcG0pIHtcclxuXHRcdFx0XHR0aGlzLmFtcG0gPSBhbXBtO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBVcGRhdGVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgdGltZXBpY2tlclxyXG5cdFx0XHR0aGlzLmZvcm1hdHRlZFRpbWUgPSAkLmRhdGVwaWNrZXIuZm9ybWF0VGltZShvLnRpbWVGb3JtYXQsIHRoaXMsIG8pO1xyXG5cdFx0XHRpZiAodGhpcy4kdGltZU9iaikge1xyXG5cdFx0XHRcdGlmIChwaWNrZXJUaW1lRm9ybWF0ID09PSBvLnRpbWVGb3JtYXQpIHtcclxuXHRcdFx0XHRcdHRoaXMuJHRpbWVPYmoudmFsKHRoaXMuZm9ybWF0dGVkVGltZSArIHBpY2tlclRpbWVTdWZmaXgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMuJHRpbWVPYmoudmFsKCQuZGF0ZXBpY2tlci5mb3JtYXRUaW1lKHBpY2tlclRpbWVGb3JtYXQsIHRoaXMsIG8pICsgcGlja2VyVGltZVN1ZmZpeCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICh0aGlzLiR0aW1lT2JqWzBdLnNldFNlbGVjdGlvblJhbmdlKSB7XHJcblx0XHRcdFx0XHR2YXIgc1BvcyA9IHRoaXMuJHRpbWVPYmpbMF0uc2VsZWN0aW9uU3RhcnQ7XHJcblx0XHRcdFx0XHR2YXIgZVBvcyA9IHRoaXMuJHRpbWVPYmpbMF0uc2VsZWN0aW9uRW5kO1xyXG5cdFx0XHRcdFx0dGhpcy4kdGltZU9ialswXS5zZXRTZWxlY3Rpb25SYW5nZShzUG9zLCBlUG9zKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMudGltZURlZmluZWQgPSB0cnVlO1xyXG5cdFx0XHRpZiAoaGFzQ2hhbmdlZCkge1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZURhdGVUaW1lKCk7XHJcblx0XHRcdFx0Ly90aGlzLiRpbnB1dC5mb2N1cygpOyAvLyBtYXkgYXV0b21hdGljYWxseSBvcGVuIHRoZSBwaWNrZXIgb24gc2V0RGF0ZVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qXHJcblx0XHQqIGNhbGwgY3VzdG9tIG9uU2VsZWN0LlxyXG5cdFx0KiBiaW5kIHRvIHNsaWRlcnMgc2xpZGVzdG9wLCBhbmQgZ3JpZCBjbGljay5cclxuXHRcdCovXHJcblx0XHRfb25TZWxlY3RIYW5kbGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHZhciBvblNlbGVjdCA9IHRoaXMuX2RlZmF1bHRzLm9uU2VsZWN0IHx8IHRoaXMuaW5zdC5zZXR0aW5ncy5vblNlbGVjdDtcclxuXHRcdFx0dmFyIGlucHV0RWwgPSB0aGlzLiRpbnB1dCA/IHRoaXMuJGlucHV0WzBdIDogbnVsbDtcclxuXHRcdFx0aWYgKG9uU2VsZWN0ICYmIGlucHV0RWwpIHtcclxuXHRcdFx0XHRvblNlbGVjdC5hcHBseShpbnB1dEVsLCBbdGhpcy5mb3JtYXR0ZWREYXRlVGltZSwgdGhpc10pO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qXHJcblx0XHQqIHVwZGF0ZSBvdXIgaW5wdXQgd2l0aCB0aGUgbmV3IGRhdGUgdGltZS4uXHJcblx0XHQqL1xyXG5cdFx0X3VwZGF0ZURhdGVUaW1lOiBmdW5jdGlvbiAoZHBfaW5zdCkge1xyXG5cdFx0XHRkcF9pbnN0ID0gdGhpcy5pbnN0IHx8IGRwX2luc3Q7XHJcblx0XHRcdHZhciBkdFRtcCA9IChkcF9pbnN0LmN1cnJlbnRZZWFyID4gMD9cclxuXHRcdFx0XHRcdFx0XHRuZXcgRGF0ZShkcF9pbnN0LmN1cnJlbnRZZWFyLCBkcF9pbnN0LmN1cnJlbnRNb250aCwgZHBfaW5zdC5jdXJyZW50RGF5KSA6XHJcblx0XHRcdFx0XHRcdFx0bmV3IERhdGUoZHBfaW5zdC5zZWxlY3RlZFllYXIsIGRwX2luc3Quc2VsZWN0ZWRNb250aCwgZHBfaW5zdC5zZWxlY3RlZERheSkpLFxyXG5cdFx0XHRcdGR0ID0gJC5kYXRlcGlja2VyLl9kYXlsaWdodFNhdmluZ0FkanVzdChkdFRtcCksXHJcblx0XHRcdFx0Ly9kdCA9ICQuZGF0ZXBpY2tlci5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHBfaW5zdC5zZWxlY3RlZFllYXIsIGRwX2luc3Quc2VsZWN0ZWRNb250aCwgZHBfaW5zdC5zZWxlY3RlZERheSkpLFxyXG5cdFx0XHRcdC8vZHQgPSAkLmRhdGVwaWNrZXIuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRwX2luc3QuY3VycmVudFllYXIsIGRwX2luc3QuY3VycmVudE1vbnRoLCBkcF9pbnN0LmN1cnJlbnREYXkpKSxcclxuXHRcdFx0XHRkYXRlRm10ID0gJC5kYXRlcGlja2VyLl9nZXQoZHBfaW5zdCwgJ2RhdGVGb3JtYXQnKSxcclxuXHRcdFx0XHRmb3JtYXRDZmcgPSAkLmRhdGVwaWNrZXIuX2dldEZvcm1hdENvbmZpZyhkcF9pbnN0KSxcclxuXHRcdFx0XHR0aW1lQXZhaWxhYmxlID0gZHQgIT09IG51bGwgJiYgdGhpcy50aW1lRGVmaW5lZDtcclxuXHRcdFx0dGhpcy5mb3JtYXR0ZWREYXRlID0gJC5kYXRlcGlja2VyLmZvcm1hdERhdGUoZGF0ZUZtdCwgKGR0ID09PSBudWxsID8gbmV3IERhdGUoKSA6IGR0KSwgZm9ybWF0Q2ZnKTtcclxuXHRcdFx0dmFyIGZvcm1hdHRlZERhdGVUaW1lID0gdGhpcy5mb3JtYXR0ZWREYXRlO1xyXG5cclxuXHRcdFx0Ly8gaWYgYSBzbGlkZXIgd2FzIGNoYW5nZWQgYnV0IGRhdGVwaWNrZXIgZG9lc24ndCBoYXZlIGEgdmFsdWUgeWV0LCBzZXQgaXRcclxuXHRcdFx0aWYgKGRwX2luc3QubGFzdFZhbCA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgZHBfaW5zdC5jdXJyZW50WWVhciA9IGRwX2luc3Quc2VsZWN0ZWRZZWFyO1xyXG4gICAgICAgICAgICAgICAgZHBfaW5zdC5jdXJyZW50TW9udGggPSBkcF9pbnN0LnNlbGVjdGVkTW9udGg7XHJcbiAgICAgICAgICAgICAgICBkcF9pbnN0LmN1cnJlbnREYXkgPSBkcF9pbnN0LnNlbGVjdGVkRGF5O1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cdFx0XHQvKlxyXG5cdFx0XHQqIHJlbW92ZSBmb2xsb3dpbmcgbGluZXMgdG8gZm9yY2UgZXZlcnkgY2hhbmdlcyBpbiBkYXRlIHBpY2tlciB0byBjaGFuZ2UgdGhlIGlucHV0IHZhbHVlXHJcblx0XHRcdCogQnVnIGRlc2NyaXB0aW9uczogd2hlbiBhbiBpbnB1dCBmaWVsZCBoYXMgYSBkZWZhdWx0IHZhbHVlLCBhbmQgY2xpY2sgb24gdGhlIGZpZWxkIHRvIHBvcCB1cCB0aGUgZGF0ZSBwaWNrZXIuXHJcblx0XHRcdCogSWYgdGhlIHVzZXIgbWFudWFsbHkgZW1wdHkgdGhlIHZhbHVlIGluIHRoZSBpbnB1dCBmaWVsZCwgdGhlIGRhdGUgcGlja2VyIHdpbGwgbmV2ZXIgY2hhbmdlIHNlbGVjdGVkIHZhbHVlLlxyXG5cdFx0XHQqL1xyXG5cdFx0XHQvL2lmIChkcF9pbnN0Lmxhc3RWYWwgIT09IHVuZGVmaW5lZCAmJiAoZHBfaW5zdC5sYXN0VmFsLmxlbmd0aCA+IDAgJiYgdGhpcy4kaW5wdXQudmFsKCkubGVuZ3RoID09PSAwKSkge1xyXG5cdFx0XHQvL1x0cmV0dXJuO1xyXG5cdFx0XHQvL31cclxuXHJcblx0XHRcdGlmICh0aGlzLl9kZWZhdWx0cy50aW1lT25seSA9PT0gdHJ1ZSAmJiB0aGlzLl9kZWZhdWx0cy50aW1lT25seVNob3dEYXRlID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdGZvcm1hdHRlZERhdGVUaW1lID0gdGhpcy5mb3JtYXR0ZWRUaW1lO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCh0aGlzLl9kZWZhdWx0cy50aW1lT25seSAhPT0gdHJ1ZSAmJiAodGhpcy5fZGVmYXVsdHMuYWx3YXlzU2V0VGltZSB8fCB0aW1lQXZhaWxhYmxlKSkgfHwgKHRoaXMuX2RlZmF1bHRzLnRpbWVPbmx5ID09PSB0cnVlICYmIHRoaXMuX2RlZmF1bHRzLnRpbWVPbmx5U2hvd0RhdGUgPT09IHRydWUpKSB7XHJcblx0XHRcdFx0Zm9ybWF0dGVkRGF0ZVRpbWUgKz0gdGhpcy5fZGVmYXVsdHMuc2VwYXJhdG9yICsgdGhpcy5mb3JtYXR0ZWRUaW1lICsgdGhpcy5fZGVmYXVsdHMudGltZVN1ZmZpeDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5mb3JtYXR0ZWREYXRlVGltZSA9IGZvcm1hdHRlZERhdGVUaW1lO1xyXG5cclxuXHRcdFx0aWYgKCF0aGlzLl9kZWZhdWx0cy5zaG93VGltZXBpY2tlcikge1xyXG5cdFx0XHRcdHRoaXMuJGlucHV0LnZhbCh0aGlzLmZvcm1hdHRlZERhdGUpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuJGFsdElucHV0ICYmIHRoaXMuX2RlZmF1bHRzLnRpbWVPbmx5ID09PSBmYWxzZSAmJiB0aGlzLl9kZWZhdWx0cy5hbHRGaWVsZFRpbWVPbmx5ID09PSB0cnVlKSB7XHJcblx0XHRcdFx0dGhpcy4kYWx0SW5wdXQudmFsKHRoaXMuZm9ybWF0dGVkVGltZSk7XHJcblx0XHRcdFx0dGhpcy4kaW5wdXQudmFsKHRoaXMuZm9ybWF0dGVkRGF0ZSk7XHJcblx0XHRcdH0gZWxzZSBpZiAodGhpcy4kYWx0SW5wdXQpIHtcclxuXHRcdFx0XHR0aGlzLiRpbnB1dC52YWwoZm9ybWF0dGVkRGF0ZVRpbWUpO1xyXG5cdFx0XHRcdHZhciBhbHRGb3JtYXR0ZWREYXRlVGltZSA9ICcnLFxyXG5cdFx0XHRcdFx0YWx0U2VwYXJhdG9yID0gdGhpcy5fZGVmYXVsdHMuYWx0U2VwYXJhdG9yICE9PSBudWxsID8gdGhpcy5fZGVmYXVsdHMuYWx0U2VwYXJhdG9yIDogdGhpcy5fZGVmYXVsdHMuc2VwYXJhdG9yLFxyXG5cdFx0XHRcdFx0YWx0VGltZVN1ZmZpeCA9IHRoaXMuX2RlZmF1bHRzLmFsdFRpbWVTdWZmaXggIT09IG51bGwgPyB0aGlzLl9kZWZhdWx0cy5hbHRUaW1lU3VmZml4IDogdGhpcy5fZGVmYXVsdHMudGltZVN1ZmZpeDtcclxuXHJcblx0XHRcdFx0aWYgKCF0aGlzLl9kZWZhdWx0cy50aW1lT25seSkge1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMuX2RlZmF1bHRzLmFsdEZvcm1hdCkge1xyXG5cdFx0XHRcdFx0XHRhbHRGb3JtYXR0ZWREYXRlVGltZSA9ICQuZGF0ZXBpY2tlci5mb3JtYXREYXRlKHRoaXMuX2RlZmF1bHRzLmFsdEZvcm1hdCwgKGR0ID09PSBudWxsID8gbmV3IERhdGUoKSA6IGR0KSwgZm9ybWF0Q2ZnKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRhbHRGb3JtYXR0ZWREYXRlVGltZSA9IHRoaXMuZm9ybWF0dGVkRGF0ZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoYWx0Rm9ybWF0dGVkRGF0ZVRpbWUpIHtcclxuXHRcdFx0XHRcdFx0YWx0Rm9ybWF0dGVkRGF0ZVRpbWUgKz0gYWx0U2VwYXJhdG9yO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHRoaXMuX2RlZmF1bHRzLmFsdFRpbWVGb3JtYXQgIT09IG51bGwpIHtcclxuXHRcdFx0XHRcdGFsdEZvcm1hdHRlZERhdGVUaW1lICs9ICQuZGF0ZXBpY2tlci5mb3JtYXRUaW1lKHRoaXMuX2RlZmF1bHRzLmFsdFRpbWVGb3JtYXQsIHRoaXMsIHRoaXMuX2RlZmF1bHRzKSArIGFsdFRpbWVTdWZmaXg7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0YWx0Rm9ybWF0dGVkRGF0ZVRpbWUgKz0gdGhpcy5mb3JtYXR0ZWRUaW1lICsgYWx0VGltZVN1ZmZpeDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy4kYWx0SW5wdXQudmFsKGFsdEZvcm1hdHRlZERhdGVUaW1lKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLiRpbnB1dC52YWwoZm9ybWF0dGVkRGF0ZVRpbWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLiRpbnB1dC50cmlnZ2VyKFwiY2hhbmdlXCIpO1xyXG5cdFx0fSxcclxuXHJcblx0XHRfb25Gb2N1czogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAoIXRoaXMuJGlucHV0LnZhbCgpICYmIHRoaXMuX2RlZmF1bHRzLmRlZmF1bHRWYWx1ZSkge1xyXG5cdFx0XHRcdHRoaXMuJGlucHV0LnZhbCh0aGlzLl9kZWZhdWx0cy5kZWZhdWx0VmFsdWUpO1xyXG5cdFx0XHRcdHZhciBpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KHRoaXMuJGlucHV0LmdldCgwKSksXHJcblx0XHRcdFx0XHR0cF9pbnN0ID0gJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcclxuXHRcdFx0XHRpZiAodHBfaW5zdCkge1xyXG5cdFx0XHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLnRpbWVPbmx5ICYmIChpbnN0LmlucHV0LnZhbCgpICE9PSBpbnN0Lmxhc3RWYWwpKSB7XHJcblx0XHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xyXG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0XHRcdFx0XHQkLnRpbWVwaWNrZXIubG9nKGVycik7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LypcclxuXHRcdCogU21hbGwgYWJzdHJhY3Rpb24gdG8gY29udHJvbCB0eXBlc1xyXG5cdFx0KiBXZSBjYW4gYWRkIG1vcmUsIGp1c3QgYmUgc3VyZSB0byBmb2xsb3cgdGhlIHBhdHRlcm46IGNyZWF0ZSwgb3B0aW9ucywgdmFsdWVcclxuXHRcdCovXHJcblx0XHRfY29udHJvbHM6IHtcclxuXHRcdFx0Ly8gc2xpZGVyIG1ldGhvZHNcclxuXHRcdFx0c2xpZGVyOiB7XHJcblx0XHRcdFx0Y3JlYXRlOiBmdW5jdGlvbiAodHBfaW5zdCwgb2JqLCB1bml0LCB2YWwsIG1pbiwgbWF4LCBzdGVwKSB7XHJcblx0XHRcdFx0XHR2YXIgcnRsID0gdHBfaW5zdC5fZGVmYXVsdHMuaXNSVEw7IC8vIGlmIHJ0bCBnbyAtNjAtPjAgaW5zdGVhZCBvZiAwLT42MFxyXG5cdFx0XHRcdFx0cmV0dXJuIG9iai5wcm9wKCdzbGlkZScsIG51bGwpLnNsaWRlcih7XHJcblx0XHRcdFx0XHRcdG9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcclxuXHRcdFx0XHRcdFx0dmFsdWU6IHJ0bCA/IHZhbCAqIC0xIDogdmFsLFxyXG5cdFx0XHRcdFx0XHRtaW46IHJ0bCA/IG1heCAqIC0xIDogbWluLFxyXG5cdFx0XHRcdFx0XHRtYXg6IHJ0bCA/IG1pbiAqIC0xIDogbWF4LFxyXG5cdFx0XHRcdFx0XHRzdGVwOiBzdGVwLFxyXG5cdFx0XHRcdFx0XHRzbGlkZTogZnVuY3Rpb24gKGV2ZW50LCB1aSkge1xyXG5cdFx0XHRcdFx0XHRcdHRwX2luc3QuY29udHJvbC52YWx1ZSh0cF9pbnN0LCAkKHRoaXMpLCB1bml0LCBydGwgPyB1aS52YWx1ZSAqIC0xIDogdWkudmFsdWUpO1xyXG5cdFx0XHRcdFx0XHRcdHRwX2luc3QuX29uVGltZUNoYW5nZSgpO1xyXG5cdFx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0XHRzdG9wOiBmdW5jdGlvbiAoZXZlbnQsIHVpKSB7XHJcblx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fb25TZWxlY3RIYW5kbGVyKCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0b3B0aW9uczogZnVuY3Rpb24gKHRwX2luc3QsIG9iaiwgdW5pdCwgb3B0cywgdmFsKSB7XHJcblx0XHRcdFx0XHRpZiAodHBfaW5zdC5fZGVmYXVsdHMuaXNSVEwpIHtcclxuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZihvcHRzKSA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAob3B0cyA9PT0gJ21pbicgfHwgb3B0cyA9PT0gJ21heCcpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gb2JqLnNsaWRlcihvcHRzLCB2YWwgKiAtMSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gTWF0aC5hYnMob2JqLnNsaWRlcihvcHRzKSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiBvYmouc2xpZGVyKG9wdHMpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHZhciBtaW4gPSBvcHRzLm1pbixcclxuXHRcdFx0XHRcdFx0XHRtYXggPSBvcHRzLm1heDtcclxuXHRcdFx0XHRcdFx0b3B0cy5taW4gPSBvcHRzLm1heCA9IG51bGw7XHJcblx0XHRcdFx0XHRcdGlmIChtaW4gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRcdG9wdHMubWF4ID0gbWluICogLTE7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYgKG1heCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdFx0b3B0cy5taW4gPSBtYXggKiAtMTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gb2JqLnNsaWRlcihvcHRzKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICh0eXBlb2Yob3B0cykgPT09ICdzdHJpbmcnICYmIHZhbCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBvYmouc2xpZGVyKG9wdHMsIHZhbCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gb2JqLnNsaWRlcihvcHRzKTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHZhbHVlOiBmdW5jdGlvbiAodHBfaW5zdCwgb2JqLCB1bml0LCB2YWwpIHtcclxuXHRcdFx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5pc1JUTCkge1xyXG5cdFx0XHRcdFx0XHRpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gb2JqLnNsaWRlcigndmFsdWUnLCB2YWwgKiAtMSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0cmV0dXJuIE1hdGguYWJzKG9iai5zbGlkZXIoJ3ZhbHVlJykpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBvYmouc2xpZGVyKCd2YWx1ZScsIHZhbCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gb2JqLnNsaWRlcigndmFsdWUnKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdC8vIHNlbGVjdCBtZXRob2RzXHJcblx0XHRcdHNlbGVjdDoge1xyXG5cdFx0XHRcdGNyZWF0ZTogZnVuY3Rpb24gKHRwX2luc3QsIG9iaiwgdW5pdCwgdmFsLCBtaW4sIG1heCwgc3RlcCkge1xyXG5cdFx0XHRcdFx0dmFyIHNlbCA9ICc8c2VsZWN0IGNsYXNzPVwidWktdGltZXBpY2tlci1zZWxlY3QgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsXCIgZGF0YS11bml0PVwiJyArIHVuaXQgKyAnXCIgZGF0YS1taW49XCInICsgbWluICsgJ1wiIGRhdGEtbWF4PVwiJyArIG1heCArICdcIiBkYXRhLXN0ZXA9XCInICsgc3RlcCArICdcIj4nLFxyXG5cdFx0XHRcdFx0XHRmb3JtYXQgPSB0cF9pbnN0Ll9kZWZhdWx0cy5waWNrZXJUaW1lRm9ybWF0IHx8IHRwX2luc3QuX2RlZmF1bHRzLnRpbWVGb3JtYXQ7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IG1pbjsgaSA8PSBtYXg7IGkgKz0gc3RlcCkge1xyXG5cdFx0XHRcdFx0XHRzZWwgKz0gJzxvcHRpb24gdmFsdWU9XCInICsgaSArICdcIicgKyAoaSA9PT0gdmFsID8gJyBzZWxlY3RlZCcgOiAnJykgKyAnPic7XHJcblx0XHRcdFx0XHRcdGlmICh1bml0ID09PSAnaG91cicpIHtcclxuXHRcdFx0XHRcdFx0XHRzZWwgKz0gJC5kYXRlcGlja2VyLmZvcm1hdFRpbWUoJC50cmltKGZvcm1hdC5yZXBsYWNlKC9bXmh0IF0vaWcsICcnKSksIHtob3VyOiBpfSwgdHBfaW5zdC5fZGVmYXVsdHMpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHVuaXQgPT09ICdtaWxsaXNlYycgfHwgdW5pdCA9PT0gJ21pY3Jvc2VjJyB8fCBpID49IDEwKSB7IHNlbCArPSBpOyB9XHJcblx0XHRcdFx0XHRcdGVsc2Uge3NlbCArPSAnMCcgKyBpLnRvU3RyaW5nKCk7IH1cclxuXHRcdFx0XHRcdFx0c2VsICs9ICc8L29wdGlvbj4nO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c2VsICs9ICc8L3NlbGVjdD4nO1xyXG5cclxuXHRcdFx0XHRcdG9iai5jaGlsZHJlbignc2VsZWN0JykucmVtb3ZlKCk7XHJcblxyXG5cdFx0XHRcdFx0JChzZWwpLmFwcGVuZFRvKG9iaikuY2hhbmdlKGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0XHRcdHRwX2luc3QuX29uVGltZUNoYW5nZSgpO1xyXG5cdFx0XHRcdFx0XHR0cF9pbnN0Ll9vblNlbGVjdEhhbmRsZXIoKTtcclxuXHRcdFx0XHRcdFx0dHBfaW5zdC5fYWZ0ZXJJbmplY3QoKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBvYmo7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRvcHRpb25zOiBmdW5jdGlvbiAodHBfaW5zdCwgb2JqLCB1bml0LCBvcHRzLCB2YWwpIHtcclxuXHRcdFx0XHRcdHZhciBvID0ge30sXHJcblx0XHRcdFx0XHRcdCR0ID0gb2JqLmNoaWxkcmVuKCdzZWxlY3QnKTtcclxuXHRcdFx0XHRcdGlmICh0eXBlb2Yob3B0cykgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdFx0XHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiAkdC5kYXRhKG9wdHMpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdG9bb3B0c10gPSB2YWw7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIHsgbyA9IG9wdHM7IH1cclxuXHRcdFx0XHRcdHJldHVybiB0cF9pbnN0LmNvbnRyb2wuY3JlYXRlKHRwX2luc3QsIG9iaiwgJHQuZGF0YSgndW5pdCcpLCAkdC52YWwoKSwgby5taW4+PTAgPyBvLm1pbiA6ICR0LmRhdGEoJ21pbicpLCBvLm1heCB8fCAkdC5kYXRhKCdtYXgnKSwgby5zdGVwIHx8ICR0LmRhdGEoJ3N0ZXAnKSk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHR2YWx1ZTogZnVuY3Rpb24gKHRwX2luc3QsIG9iaiwgdW5pdCwgdmFsKSB7XHJcblx0XHRcdFx0XHR2YXIgJHQgPSBvYmouY2hpbGRyZW4oJ3NlbGVjdCcpO1xyXG5cdFx0XHRcdFx0aWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiAkdC52YWwodmFsKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiAkdC52YWwoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0gLy8gZW5kIF9jb250cm9sc1xyXG5cclxuXHR9KTtcclxuXHJcblx0JC5mbi5leHRlbmQoe1xyXG5cdFx0LypcclxuXHRcdCogc2hvcnRoYW5kIGp1c3QgdG8gdXNlIHRpbWVwaWNrZXIuXHJcblx0XHQqL1xyXG5cdFx0dGltZXBpY2tlcjogZnVuY3Rpb24gKG8pIHtcclxuXHRcdFx0byA9IG8gfHwge307XHJcblx0XHRcdHZhciB0bXBfYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcblxyXG5cdFx0XHRpZiAodHlwZW9mIG8gPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdFx0dG1wX2FyZ3NbMF0gPSAkLmV4dGVuZChvLCB7XHJcblx0XHRcdFx0XHR0aW1lT25seTogdHJ1ZVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHQkLmZuLmRhdGV0aW1lcGlja2VyLmFwcGx5KCQodGhpcyksIHRtcF9hcmdzKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qXHJcblx0XHQqIGV4dGVuZCB0aW1lcGlja2VyIHRvIGRhdGVwaWNrZXJcclxuXHRcdCovXHJcblx0XHRkYXRldGltZXBpY2tlcjogZnVuY3Rpb24gKG8pIHtcclxuXHRcdFx0byA9IG8gfHwge307XHJcblx0XHRcdHZhciB0bXBfYXJncyA9IGFyZ3VtZW50cztcclxuXHJcblx0XHRcdGlmICh0eXBlb2YobykgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdFx0aWYgKG8gPT09ICdnZXREYXRlJyAgfHwgKG8gPT09ICdvcHRpb24nICYmIHRtcF9hcmdzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgKHRtcF9hcmdzWzFdKSA9PT0gJ3N0cmluZycpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gJC5mbi5kYXRlcGlja2VyLmFwcGx5KCQodGhpc1swXSksIHRtcF9hcmdzKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRcdHZhciAkdCA9ICQodGhpcyk7XHJcblx0XHRcdFx0XHRcdCR0LmRhdGVwaWNrZXIuYXBwbHkoJHQsIHRtcF9hcmdzKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdHZhciAkdCA9ICQodGhpcyk7XHJcblx0XHRcdFx0XHQkdC5kYXRlcGlja2VyKCQudGltZXBpY2tlci5fbmV3SW5zdCgkdCwgbykuX2RlZmF1bHRzKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvKlxyXG5cdCogUHVibGljIFV0aWxpdHkgdG8gcGFyc2UgZGF0ZSBhbmQgdGltZVxyXG5cdCovXHJcbiAgICAkLmRhdGVwaWNrZXIgPSAkLmRhdGVwaWNrZXIgfHwge307XHJcblx0JC5kYXRlcGlja2VyLnBhcnNlRGF0ZVRpbWUgPSBmdW5jdGlvbiAoZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgZGF0ZVRpbWVTdHJpbmcsIGRhdGVTZXR0aW5ncywgdGltZVNldHRpbmdzKSB7XHJcblx0XHR2YXIgcGFyc2VSZXMgPSBwYXJzZURhdGVUaW1lSW50ZXJuYWwoZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgZGF0ZVRpbWVTdHJpbmcsIGRhdGVTZXR0aW5ncywgdGltZVNldHRpbmdzKTtcclxuXHRcdGlmIChwYXJzZVJlcy50aW1lT2JqKSB7XHJcblx0XHRcdHZhciB0ID0gcGFyc2VSZXMudGltZU9iajtcclxuXHRcdFx0cGFyc2VSZXMuZGF0ZS5zZXRIb3Vycyh0LmhvdXIsIHQubWludXRlLCB0LnNlY29uZCwgdC5taWxsaXNlYyk7XHJcblx0XHRcdHBhcnNlUmVzLmRhdGUuc2V0TWljcm9zZWNvbmRzKHQubWljcm9zZWMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYXJzZVJlcy5kYXRlO1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBQdWJsaWMgdXRpbGl0eSB0byBwYXJzZSB0aW1lXHJcblx0Ki9cclxuXHQkLmRhdGVwaWNrZXIucGFyc2VUaW1lID0gZnVuY3Rpb24gKHRpbWVGb3JtYXQsIHRpbWVTdHJpbmcsIG9wdGlvbnMpIHtcclxuXHRcdHZhciBvID0gZXh0ZW5kUmVtb3ZlKGV4dGVuZFJlbW92ZSh7fSwgJC50aW1lcGlja2VyLl9kZWZhdWx0cyksIG9wdGlvbnMgfHwge30pLFxyXG5cdFx0XHRpc284NjAxID0gKHRpbWVGb3JtYXQucmVwbGFjZSgvXFwnLio/XFwnL2csICcnKS5pbmRleE9mKCdaJykgIT09IC0xKTtcclxuXHJcblx0XHQvLyBTdHJpY3QgcGFyc2UgcmVxdWlyZXMgdGhlIHRpbWVTdHJpbmcgdG8gbWF0Y2ggdGhlIHRpbWVGb3JtYXQgZXhhY3RseVxyXG5cdFx0dmFyIHN0cmljdFBhcnNlID0gZnVuY3Rpb24gKGYsIHMsIG8pIHtcclxuXHJcblx0XHRcdC8vIHBhdHRlcm4gZm9yIHN0YW5kYXJkIGFuZCBsb2NhbGl6ZWQgQU0vUE0gbWFya2Vyc1xyXG5cdFx0XHR2YXIgZ2V0UGF0dGVybkFtcG0gPSBmdW5jdGlvbiAoYW1OYW1lcywgcG1OYW1lcykge1xyXG5cdFx0XHRcdHZhciBtYXJrZXJzID0gW107XHJcblx0XHRcdFx0aWYgKGFtTmFtZXMpIHtcclxuXHRcdFx0XHRcdCQubWVyZ2UobWFya2VycywgYW1OYW1lcyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChwbU5hbWVzKSB7XHJcblx0XHRcdFx0XHQkLm1lcmdlKG1hcmtlcnMsIHBtTmFtZXMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRtYXJrZXJzID0gJC5tYXAobWFya2VycywgZnVuY3Rpb24gKHZhbCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHZhbC5yZXBsYWNlKC9bLiorP3woKVxcW1xcXXt9XFxcXF0vZywgJ1xcXFwkJicpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHJldHVybiAnKCcgKyBtYXJrZXJzLmpvaW4oJ3wnKSArICcpPyc7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHQvLyBmaWd1cmUgb3V0IHBvc2l0aW9uIG9mIHRpbWUgZWxlbWVudHMuLiBjYXVzZSBqcyBjYW50IGRvIG5hbWVkIGNhcHR1cmVzXHJcblx0XHRcdHZhciBnZXRGb3JtYXRQb3NpdGlvbnMgPSBmdW5jdGlvbiAodGltZUZvcm1hdCkge1xyXG5cdFx0XHRcdHZhciBmaW5kcyA9IHRpbWVGb3JtYXQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGh7MSwyfXxtezEsMn18c3sxLDJ9fGx7MX18Y3sxfXx0ezEsMn18enwnLio/JykvZyksXHJcblx0XHRcdFx0XHRvcmRlcnMgPSB7XHJcblx0XHRcdFx0XHRcdGg6IC0xLFxyXG5cdFx0XHRcdFx0XHRtOiAtMSxcclxuXHRcdFx0XHRcdFx0czogLTEsXHJcblx0XHRcdFx0XHRcdGw6IC0xLFxyXG5cdFx0XHRcdFx0XHRjOiAtMSxcclxuXHRcdFx0XHRcdFx0dDogLTEsXHJcblx0XHRcdFx0XHRcdHo6IC0xXHJcblx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRpZiAoZmluZHMpIHtcclxuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZmluZHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0aWYgKG9yZGVyc1tmaW5kc1tpXS50b1N0cmluZygpLmNoYXJBdCgwKV0gPT09IC0xKSB7XHJcblx0XHRcdFx0XHRcdFx0b3JkZXJzW2ZpbmRzW2ldLnRvU3RyaW5nKCkuY2hhckF0KDApXSA9IGkgKyAxO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBvcmRlcnM7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHR2YXIgcmVnc3RyID0gJ14nICsgZi50b1N0cmluZygpXHJcblx0XHRcdFx0XHQucmVwbGFjZSgvKFtoSF17MSwyfXxtbT98c3M/fFt0VF17MSwyfXxbelpdfFtsY118Jy4qPycpL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBtbCA9IG1hdGNoLmxlbmd0aDtcclxuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKG1hdGNoLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpKSB7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAnaCc6XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbWwgPT09IDEgPyAnKFxcXFxkP1xcXFxkKScgOiAnKFxcXFxkeycgKyBtbCArICd9KSc7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAnbSc6XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbWwgPT09IDEgPyAnKFxcXFxkP1xcXFxkKScgOiAnKFxcXFxkeycgKyBtbCArICd9KSc7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAncyc6XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbWwgPT09IDEgPyAnKFxcXFxkP1xcXFxkKScgOiAnKFxcXFxkeycgKyBtbCArICd9KSc7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAnbCc6XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gJyhcXFxcZD9cXFxcZD9cXFxcZCknO1xyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2MnOlxyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICcoXFxcXGQ/XFxcXGQ/XFxcXGQpJztcclxuXHRcdFx0XHRcdFx0XHRjYXNlICd6JzpcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAnKHp8Wy0rXVxcXFxkXFxcXGQ6P1xcXFxkXFxcXGR8XFxcXFMrKT8nO1xyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3QnOlxyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFBhdHRlcm5BbXBtKG8uYW1OYW1lcywgby5wbU5hbWVzKTtcclxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OiAgICAvLyBsaXRlcmFsIGVzY2FwZWQgaW4gcXVvdGVzXHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gJygnICsgbWF0Y2gucmVwbGFjZSgvXFwnL2csIFwiXCIpLnJlcGxhY2UoLyhcXC58XFwkfFxcXnxcXFxcfFxcL3xcXCh8XFwpfFxcW3xcXF18XFw/fFxcK3xcXCopL2csIGZ1bmN0aW9uIChtKSB7IHJldHVybiBcIlxcXFxcIiArIG07IH0pICsgJyk/JztcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHQucmVwbGFjZSgvXFxzL2csICdcXFxccz8nKSArXHJcblx0XHRcdFx0XHRvLnRpbWVTdWZmaXggKyAnJCcsXHJcblx0XHRcdFx0b3JkZXIgPSBnZXRGb3JtYXRQb3NpdGlvbnMoZiksXHJcblx0XHRcdFx0YW1wbSA9ICcnLFxyXG5cdFx0XHRcdHRyZWc7XHJcblxyXG5cdFx0XHR0cmVnID0gcy5tYXRjaChuZXcgUmVnRXhwKHJlZ3N0ciwgJ2knKSk7XHJcblxyXG5cdFx0XHR2YXIgcmVzVGltZSA9IHtcclxuXHRcdFx0XHRob3VyOiAwLFxyXG5cdFx0XHRcdG1pbnV0ZTogMCxcclxuXHRcdFx0XHRzZWNvbmQ6IDAsXHJcblx0XHRcdFx0bWlsbGlzZWM6IDAsXHJcblx0XHRcdFx0bWljcm9zZWM6IDBcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGlmICh0cmVnKSB7XHJcblx0XHRcdFx0aWYgKG9yZGVyLnQgIT09IC0xKSB7XHJcblx0XHRcdFx0XHRpZiAodHJlZ1tvcmRlci50XSA9PT0gdW5kZWZpbmVkIHx8IHRyZWdbb3JkZXIudF0ubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdGFtcG0gPSAnJztcclxuXHRcdFx0XHRcdFx0cmVzVGltZS5hbXBtID0gJyc7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRhbXBtID0gJC5pbkFycmF5KHRyZWdbb3JkZXIudF0udG9VcHBlckNhc2UoKSwgJC5tYXAoby5hbU5hbWVzLCBmdW5jdGlvbiAoeCxpKSB7IHJldHVybiB4LnRvVXBwZXJDYXNlKCk7IH0pKSAhPT0gLTEgPyAnQU0nIDogJ1BNJztcclxuXHRcdFx0XHRcdFx0cmVzVGltZS5hbXBtID0gb1thbXBtID09PSAnQU0nID8gJ2FtTmFtZXMnIDogJ3BtTmFtZXMnXVswXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChvcmRlci5oICE9PSAtMSkge1xyXG5cdFx0XHRcdFx0aWYgKGFtcG0gPT09ICdBTScgJiYgdHJlZ1tvcmRlci5oXSA9PT0gJzEyJykge1xyXG5cdFx0XHRcdFx0XHRyZXNUaW1lLmhvdXIgPSAwOyAvLyAxMmFtID0gMCBob3VyXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRpZiAoYW1wbSA9PT0gJ1BNJyAmJiB0cmVnW29yZGVyLmhdICE9PSAnMTInKSB7XHJcblx0XHRcdFx0XHRcdFx0cmVzVGltZS5ob3VyID0gcGFyc2VJbnQodHJlZ1tvcmRlci5oXSwgMTApICsgMTI7IC8vIDEycG0gPSAxMiBob3VyLCBhbnkgb3RoZXIgcG0gPSBob3VyICsgMTJcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRyZXNUaW1lLmhvdXIgPSBOdW1iZXIodHJlZ1tvcmRlci5oXSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChvcmRlci5tICE9PSAtMSkge1xyXG5cdFx0XHRcdFx0cmVzVGltZS5taW51dGUgPSBOdW1iZXIodHJlZ1tvcmRlci5tXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChvcmRlci5zICE9PSAtMSkge1xyXG5cdFx0XHRcdFx0cmVzVGltZS5zZWNvbmQgPSBOdW1iZXIodHJlZ1tvcmRlci5zXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChvcmRlci5sICE9PSAtMSkge1xyXG5cdFx0XHRcdFx0cmVzVGltZS5taWxsaXNlYyA9IE51bWJlcih0cmVnW29yZGVyLmxdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKG9yZGVyLmMgIT09IC0xKSB7XHJcblx0XHRcdFx0XHRyZXNUaW1lLm1pY3Jvc2VjID0gTnVtYmVyKHRyZWdbb3JkZXIuY10pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAob3JkZXIueiAhPT0gLTEgJiYgdHJlZ1tvcmRlci56XSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRyZXNUaW1lLnRpbWV6b25lID0gJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0TnVtYmVyKHRyZWdbb3JkZXIuel0pO1xyXG5cdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRcdHJldHVybiByZXNUaW1lO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH07Ly8gZW5kIHN0cmljdFBhcnNlXHJcblxyXG5cdFx0Ly8gRmlyc3QgdHJ5IEpTIERhdGUsIGlmIHRoYXQgZmFpbHMsIHVzZSBzdHJpY3RQYXJzZVxyXG5cdFx0dmFyIGxvb3NlUGFyc2UgPSBmdW5jdGlvbiAoZiwgcywgbykge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdHZhciBkID0gbmV3IERhdGUoJzIwMTItMDEtMDEgJyArIHMpO1xyXG5cdFx0XHRcdGlmIChpc05hTihkLmdldFRpbWUoKSkpIHtcclxuXHRcdFx0XHRcdGQgPSBuZXcgRGF0ZSgnMjAxMi0wMS0wMVQnICsgcyk7XHJcblx0XHRcdFx0XHRpZiAoaXNOYU4oZC5nZXRUaW1lKCkpKSB7XHJcblx0XHRcdFx0XHRcdGQgPSBuZXcgRGF0ZSgnMDEvMDEvMjAxMiAnICsgcyk7XHJcblx0XHRcdFx0XHRcdGlmIChpc05hTihkLmdldFRpbWUoKSkpIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJvdyBcIlVuYWJsZSB0byBwYXJzZSB0aW1lIHdpdGggbmF0aXZlIERhdGU6IFwiICsgcztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdGhvdXI6IGQuZ2V0SG91cnMoKSxcclxuXHRcdFx0XHRcdG1pbnV0ZTogZC5nZXRNaW51dGVzKCksXHJcblx0XHRcdFx0XHRzZWNvbmQ6IGQuZ2V0U2Vjb25kcygpLFxyXG5cdFx0XHRcdFx0bWlsbGlzZWM6IGQuZ2V0TWlsbGlzZWNvbmRzKCksXHJcblx0XHRcdFx0XHRtaWNyb3NlYzogZC5nZXRNaWNyb3NlY29uZHMoKSxcclxuXHRcdFx0XHRcdHRpbWV6b25lOiBkLmdldFRpbWV6b25lT2Zmc2V0KCkgKiAtMVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdH1cclxuXHRcdFx0Y2F0Y2ggKGVycikge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gc3RyaWN0UGFyc2UoZiwgcywgbyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNhdGNoIChlcnIyKSB7XHJcblx0XHRcdFx0XHQkLnRpbWVwaWNrZXIubG9nKFwiVW5hYmxlIHRvIHBhcnNlIFxcbnRpbWVTdHJpbmc6IFwiICsgcyArIFwiXFxudGltZUZvcm1hdDogXCIgKyBmKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fTsgLy8gZW5kIGxvb3NlUGFyc2VcclxuXHJcblx0XHRpZiAodHlwZW9mIG8ucGFyc2UgPT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0XHRyZXR1cm4gby5wYXJzZSh0aW1lRm9ybWF0LCB0aW1lU3RyaW5nLCBvKTtcclxuXHRcdH1cclxuXHRcdGlmIChvLnBhcnNlID09PSAnbG9vc2UnKSB7XHJcblx0XHRcdHJldHVybiBsb29zZVBhcnNlKHRpbWVGb3JtYXQsIHRpbWVTdHJpbmcsIG8pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN0cmljdFBhcnNlKHRpbWVGb3JtYXQsIHRpbWVTdHJpbmcsIG8pO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFB1YmxpYyB1dGlsaXR5IHRvIGZvcm1hdCB0aGUgdGltZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgZm9ybWF0IG9mIHRoZSB0aW1lXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHRpbWUgT2JqZWN0IG5vdCBhIERhdGUgZm9yIHRpbWV6b25lc1xyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gZXNzZW50aWFsbHkgdGhlIHJlZ2lvbmFsW10uLiBhbU5hbWVzLCBwbU5hbWVzLCBhbXBtXHJcblx0ICogQHJldHVybnMge3N0cmluZ30gdGhlIGZvcm1hdHRlZCB0aW1lXHJcblx0ICovXHJcblx0JC5kYXRlcGlja2VyLmZvcm1hdFRpbWUgPSBmdW5jdGlvbiAoZm9ybWF0LCB0aW1lLCBvcHRpb25zKSB7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHRcdG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJC50aW1lcGlja2VyLl9kZWZhdWx0cywgb3B0aW9ucyk7XHJcblx0XHR0aW1lID0gJC5leHRlbmQoe1xyXG5cdFx0XHRob3VyOiAwLFxyXG5cdFx0XHRtaW51dGU6IDAsXHJcblx0XHRcdHNlY29uZDogMCxcclxuXHRcdFx0bWlsbGlzZWM6IDAsXHJcblx0XHRcdG1pY3Jvc2VjOiAwLFxyXG5cdFx0XHR0aW1lem9uZTogbnVsbFxyXG5cdFx0fSwgdGltZSk7XHJcblxyXG5cdFx0dmFyIHRtcHRpbWUgPSBmb3JtYXQsXHJcblx0XHRcdGFtcG1OYW1lID0gb3B0aW9ucy5hbU5hbWVzWzBdLFxyXG5cdFx0XHRob3VyID0gcGFyc2VJbnQodGltZS5ob3VyLCAxMCk7XHJcblxyXG5cdFx0aWYgKGhvdXIgPiAxMSkge1xyXG5cdFx0XHRhbXBtTmFtZSA9IG9wdGlvbnMucG1OYW1lc1swXTtcclxuXHRcdH1cclxuXHJcblx0XHR0bXB0aW1lID0gdG1wdGltZS5yZXBsYWNlKC8oPzpISD98aGg/fG1tP3xzcz98W3RUXXsxLDJ9fFt6Wl18W2xjXXwnLio/JykvZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcblx0XHRcdHN3aXRjaCAobWF0Y2gpIHtcclxuXHRcdFx0Y2FzZSAnSEgnOlxyXG5cdFx0XHRcdHJldHVybiAoJzAnICsgaG91cikuc2xpY2UoLTIpO1xyXG5cdFx0XHRjYXNlICdIJzpcclxuXHRcdFx0XHRyZXR1cm4gaG91cjtcclxuXHRcdFx0Y2FzZSAnaGgnOlxyXG5cdFx0XHRcdHJldHVybiAoJzAnICsgY29udmVydDI0dG8xMihob3VyKSkuc2xpY2UoLTIpO1xyXG5cdFx0XHRjYXNlICdoJzpcclxuXHRcdFx0XHRyZXR1cm4gY29udmVydDI0dG8xMihob3VyKTtcclxuXHRcdFx0Y2FzZSAnbW0nOlxyXG5cdFx0XHRcdHJldHVybiAoJzAnICsgdGltZS5taW51dGUpLnNsaWNlKC0yKTtcclxuXHRcdFx0Y2FzZSAnbSc6XHJcblx0XHRcdFx0cmV0dXJuIHRpbWUubWludXRlO1xyXG5cdFx0XHRjYXNlICdzcyc6XHJcblx0XHRcdFx0cmV0dXJuICgnMCcgKyB0aW1lLnNlY29uZCkuc2xpY2UoLTIpO1xyXG5cdFx0XHRjYXNlICdzJzpcclxuXHRcdFx0XHRyZXR1cm4gdGltZS5zZWNvbmQ7XHJcblx0XHRcdGNhc2UgJ2wnOlxyXG5cdFx0XHRcdHJldHVybiAoJzAwJyArIHRpbWUubWlsbGlzZWMpLnNsaWNlKC0zKTtcclxuXHRcdFx0Y2FzZSAnYyc6XHJcblx0XHRcdFx0cmV0dXJuICgnMDAnICsgdGltZS5taWNyb3NlYykuc2xpY2UoLTMpO1xyXG5cdFx0XHRjYXNlICd6JzpcclxuXHRcdFx0XHRyZXR1cm4gJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0U3RyaW5nKHRpbWUudGltZXpvbmUgPT09IG51bGwgPyBvcHRpb25zLnRpbWV6b25lIDogdGltZS50aW1lem9uZSwgZmFsc2UpO1xyXG5cdFx0XHRjYXNlICdaJzpcclxuXHRcdFx0XHRyZXR1cm4gJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0U3RyaW5nKHRpbWUudGltZXpvbmUgPT09IG51bGwgPyBvcHRpb25zLnRpbWV6b25lIDogdGltZS50aW1lem9uZSwgdHJ1ZSk7XHJcblx0XHRcdGNhc2UgJ1QnOlxyXG5cdFx0XHRcdHJldHVybiBhbXBtTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKTtcclxuXHRcdFx0Y2FzZSAnVFQnOlxyXG5cdFx0XHRcdHJldHVybiBhbXBtTmFtZS50b1VwcGVyQ2FzZSgpO1xyXG5cdFx0XHRjYXNlICd0JzpcclxuXHRcdFx0XHRyZXR1cm4gYW1wbU5hbWUuY2hhckF0KDApLnRvTG93ZXJDYXNlKCk7XHJcblx0XHRcdGNhc2UgJ3R0JzpcclxuXHRcdFx0XHRyZXR1cm4gYW1wbU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRyZXR1cm4gbWF0Y2gucmVwbGFjZSgvJy9nLCBcIlwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHRtcHRpbWU7XHJcblx0fTtcclxuXHJcblx0LypcclxuXHQqIHRoZSBiYWQgaGFjayA6LyBvdmVycmlkZSBkYXRlcGlja2VyIHNvIGl0IGRvZXNuJ3QgY2xvc2Ugb24gc2VsZWN0XHJcblx0Ly8gaW5zcGlyZWQ6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI1MjUxMi9qcXVlcnktZGF0ZXBpY2tlci1wcmV2ZW50LWNsb3NpbmctcGlja2VyLXdoZW4tY2xpY2tpbmctYS1kYXRlLzE3NjIzNzgjMTc2MjM3OFxyXG5cdCovXHJcblx0JC5kYXRlcGlja2VyLl9iYXNlX3NlbGVjdERhdGUgPSAkLmRhdGVwaWNrZXIuX3NlbGVjdERhdGU7XHJcblx0JC5kYXRlcGlja2VyLl9zZWxlY3REYXRlID0gZnVuY3Rpb24gKGlkLCBkYXRlU3RyKSB7XHJcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoJChpZClbMF0pLFxyXG5cdFx0XHR0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyksXHJcblx0XHRcdHdhc19pbmxpbmU7XHJcblxyXG5cdFx0aWYgKHRwX2luc3QgJiYgaW5zdC5zZXR0aW5ncy5zaG93VGltZXBpY2tlcikge1xyXG5cdFx0XHR0cF9pbnN0Ll9saW1pdE1pbk1heERhdGVUaW1lKGluc3QsIHRydWUpO1xyXG5cdFx0XHR3YXNfaW5saW5lID0gaW5zdC5pbmxpbmU7XHJcblx0XHRcdGluc3QuaW5saW5lID0gaW5zdC5zdGF5X29wZW4gPSB0cnVlO1xyXG5cdFx0XHQvL1RoaXMgd2F5IHRoZSBvblNlbGVjdCBoYW5kbGVyIGNhbGxlZCBmcm9tIGNhbGVuZGFycGlja2VyIGdldCB0aGUgZnVsbCBkYXRlVGltZVxyXG5cdFx0XHR0aGlzLl9iYXNlX3NlbGVjdERhdGUoaWQsIGRhdGVTdHIpO1xyXG5cdFx0XHRpbnN0LmlubGluZSA9IHdhc19pbmxpbmU7XHJcblx0XHRcdGluc3Quc3RheV9vcGVuID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuX25vdGlmeUNoYW5nZShpbnN0KTtcclxuXHRcdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX2Jhc2Vfc2VsZWN0RGF0ZShpZCwgZGF0ZVN0cik7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LypcclxuXHQqIHNlY29uZCBiYWQgaGFjayA6LyBvdmVycmlkZSBkYXRlcGlja2VyIHNvIGl0IHRyaWdnZXJzIGFuIGV2ZW50IHdoZW4gY2hhbmdpbmcgdGhlIGlucHV0IGZpZWxkXHJcblx0KiBhbmQgZG9lcyBub3QgcmVkcmF3IHRoZSBkYXRlcGlja2VyIG9uIGV2ZXJ5IHNlbGVjdERhdGUgZXZlbnRcclxuXHQqL1xyXG5cdCQuZGF0ZXBpY2tlci5fYmFzZV91cGRhdGVEYXRlcGlja2VyID0gJC5kYXRlcGlja2VyLl91cGRhdGVEYXRlcGlja2VyO1xyXG5cdCQuZGF0ZXBpY2tlci5fdXBkYXRlRGF0ZXBpY2tlciA9IGZ1bmN0aW9uIChpbnN0KSB7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgcG9wdXAgdGhlIGRhdGVwaWNrZXIgaWYgdGhlcmUgaXMgYW5vdGhlciBpbnN0YW5jZSBhbHJlYWR5IG9wZW5lZFxyXG5cdFx0dmFyIGlucHV0ID0gaW5zdC5pbnB1dFswXTtcclxuXHRcdGlmICgkLmRhdGVwaWNrZXIuX2N1ckluc3QgJiYgJC5kYXRlcGlja2VyLl9jdXJJbnN0ICE9PSBpbnN0ICYmICQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgJiYgJC5kYXRlcGlja2VyLl9sYXN0SW5wdXQgIT09IGlucHV0KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHlwZW9mKGluc3Quc3RheV9vcGVuKSAhPT0gJ2Jvb2xlYW4nIHx8IGluc3Quc3RheV9vcGVuID09PSBmYWxzZSkge1xyXG5cclxuXHRcdFx0dGhpcy5fYmFzZV91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xyXG5cclxuXHRcdFx0Ly8gUmVsb2FkIHRoZSB0aW1lIGNvbnRyb2wgd2hlbiBjaGFuZ2luZyBzb21ldGhpbmcgaW4gdGhlIGlucHV0IHRleHQgZmllbGQuXHJcblx0XHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XHJcblx0XHRcdGlmICh0cF9pbnN0KSB7XHJcblx0XHRcdFx0dHBfaW5zdC5fYWRkVGltZVBpY2tlcihpbnN0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiB0aGlyZCBiYWQgaGFjayA6LyBvdmVycmlkZSBkYXRlcGlja2VyIHNvIGl0IGFsbG93cyBzcGFjZXMgYW5kIGNvbG9uIGluIHRoZSBpbnB1dCBmaWVsZFxyXG5cdCovXHJcblx0JC5kYXRlcGlja2VyLl9iYXNlX2RvS2V5UHJlc3MgPSAkLmRhdGVwaWNrZXIuX2RvS2V5UHJlc3M7XHJcblx0JC5kYXRlcGlja2VyLl9kb0tleVByZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0XHR2YXIgaW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChldmVudC50YXJnZXQpLFxyXG5cdFx0XHR0cF9pbnN0ID0gJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcclxuXHJcblx0XHRpZiAodHBfaW5zdCkge1xyXG5cdFx0XHRpZiAoJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ2NvbnN0cmFpbklucHV0JykpIHtcclxuXHRcdFx0XHR2YXIgYW1wbSA9IHRwX2luc3Quc3VwcG9ydC5hbXBtLFxyXG5cdFx0XHRcdFx0dHogPSB0cF9pbnN0Ll9kZWZhdWx0cy5zaG93VGltZXpvbmUgIT09IG51bGwgPyB0cF9pbnN0Ll9kZWZhdWx0cy5zaG93VGltZXpvbmUgOiB0cF9pbnN0LnN1cHBvcnQudGltZXpvbmUsXHJcblx0XHRcdFx0XHRkYXRlQ2hhcnMgPSAkLmRhdGVwaWNrZXIuX3Bvc3NpYmxlQ2hhcnMoJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ2RhdGVGb3JtYXQnKSksXHJcblx0XHRcdFx0XHRkYXRldGltZUNoYXJzID0gdHBfaW5zdC5fZGVmYXVsdHMudGltZUZvcm1hdC50b1N0cmluZygpXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvW2htc10vZywgJycpXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvVFQvZywgYW1wbSA/ICdBUE0nIDogJycpXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvVHQvZywgYW1wbSA/ICdBYVBwTW0nIDogJycpXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvdFQvZywgYW1wbSA/ICdBYVBwTW0nIDogJycpXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvVC9nLCBhbXBtID8gJ0FQJyA6ICcnKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL3R0L2csIGFtcG0gPyAnYXBtJyA6ICcnKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL3QvZywgYW1wbSA/ICdhcCcgOiAnJykgK1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIgXCIgKyB0cF9pbnN0Ll9kZWZhdWx0cy5zZXBhcmF0b3IgK1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMudGltZVN1ZmZpeCArXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQodHogPyB0cF9pbnN0Ll9kZWZhdWx0cy50aW1lem9uZUxpc3Quam9pbignJykgOiAnJykgK1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KHRwX2luc3QuX2RlZmF1bHRzLmFtTmFtZXMuam9pbignJykpICsgKHRwX2luc3QuX2RlZmF1bHRzLnBtTmFtZXMuam9pbignJykpICtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRhdGVDaGFycyxcclxuXHRcdFx0XHRcdGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQuY2hhckNvZGUgPT09IHVuZGVmaW5lZCA/IGV2ZW50LmtleUNvZGUgOiBldmVudC5jaGFyQ29kZSk7XHJcblx0XHRcdFx0cmV0dXJuIGV2ZW50LmN0cmxLZXkgfHwgKGNociA8ICcgJyB8fCAhZGF0ZUNoYXJzIHx8IGRhdGV0aW1lQ2hhcnMuaW5kZXhPZihjaHIpID4gLTEpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuICQuZGF0ZXBpY2tlci5fYmFzZV9kb0tleVByZXNzKGV2ZW50KTtcclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCogRm91cnRoIGJhZCBoYWNrIDovIG92ZXJyaWRlIF91cGRhdGVBbHRlcm5hdGUgZnVuY3Rpb24gdXNlZCBpbiBpbmxpbmUgbW9kZSB0byBpbml0IGFsdEZpZWxkXHJcblx0KiBVcGRhdGUgYW55IGFsdGVybmF0ZSBmaWVsZCB0byBzeW5jaHJvbmlzZSB3aXRoIHRoZSBtYWluIGZpZWxkLlxyXG5cdCovXHJcblx0JC5kYXRlcGlja2VyLl9iYXNlX3VwZGF0ZUFsdGVybmF0ZSA9ICQuZGF0ZXBpY2tlci5fdXBkYXRlQWx0ZXJuYXRlO1xyXG5cdCQuZGF0ZXBpY2tlci5fdXBkYXRlQWx0ZXJuYXRlID0gZnVuY3Rpb24gKGluc3QpIHtcclxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XHJcblx0XHRpZiAodHBfaW5zdCkge1xyXG5cdFx0XHR2YXIgYWx0RmllbGQgPSB0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGaWVsZDtcclxuXHRcdFx0aWYgKGFsdEZpZWxkKSB7IC8vIHVwZGF0ZSBhbHRlcm5hdGUgZmllbGQgdG9vXHJcblx0XHRcdFx0dmFyIGFsdEZvcm1hdCA9IHRwX2luc3QuX2RlZmF1bHRzLmFsdEZvcm1hdCB8fCB0cF9pbnN0Ll9kZWZhdWx0cy5kYXRlRm9ybWF0LFxyXG5cdFx0XHRcdFx0ZGF0ZSA9IHRoaXMuX2dldERhdGUoaW5zdCksXHJcblx0XHRcdFx0XHRmb3JtYXRDZmcgPSAkLmRhdGVwaWNrZXIuX2dldEZvcm1hdENvbmZpZyhpbnN0KSxcclxuXHRcdFx0XHRcdGFsdEZvcm1hdHRlZERhdGVUaW1lID0gJycsXHJcblx0XHRcdFx0XHRhbHRTZXBhcmF0b3IgPSB0cF9pbnN0Ll9kZWZhdWx0cy5hbHRTZXBhcmF0b3IgPyB0cF9pbnN0Ll9kZWZhdWx0cy5hbHRTZXBhcmF0b3IgOiB0cF9pbnN0Ll9kZWZhdWx0cy5zZXBhcmF0b3IsXHJcblx0XHRcdFx0XHRhbHRUaW1lU3VmZml4ID0gdHBfaW5zdC5fZGVmYXVsdHMuYWx0VGltZVN1ZmZpeCA/IHRwX2luc3QuX2RlZmF1bHRzLmFsdFRpbWVTdWZmaXggOiB0cF9pbnN0Ll9kZWZhdWx0cy50aW1lU3VmZml4LFxyXG5cdFx0XHRcdFx0YWx0VGltZUZvcm1hdCA9IHRwX2luc3QuX2RlZmF1bHRzLmFsdFRpbWVGb3JtYXQgIT09IG51bGwgPyB0cF9pbnN0Ll9kZWZhdWx0cy5hbHRUaW1lRm9ybWF0IDogdHBfaW5zdC5fZGVmYXVsdHMudGltZUZvcm1hdDtcclxuXHJcblx0XHRcdFx0YWx0Rm9ybWF0dGVkRGF0ZVRpbWUgKz0gJC5kYXRlcGlja2VyLmZvcm1hdFRpbWUoYWx0VGltZUZvcm1hdCwgdHBfaW5zdCwgdHBfaW5zdC5fZGVmYXVsdHMpICsgYWx0VGltZVN1ZmZpeDtcclxuXHRcdFx0XHRpZiAoIXRwX2luc3QuX2RlZmF1bHRzLnRpbWVPbmx5ICYmICF0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGaWVsZFRpbWVPbmx5ICYmIGRhdGUgIT09IG51bGwpIHtcclxuXHRcdFx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGb3JtYXQpIHtcclxuXHRcdFx0XHRcdFx0YWx0Rm9ybWF0dGVkRGF0ZVRpbWUgPSAkLmRhdGVwaWNrZXIuZm9ybWF0RGF0ZSh0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGb3JtYXQsIGRhdGUsIGZvcm1hdENmZykgKyBhbHRTZXBhcmF0b3IgKyBhbHRGb3JtYXR0ZWREYXRlVGltZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRhbHRGb3JtYXR0ZWREYXRlVGltZSA9IHRwX2luc3QuZm9ybWF0dGVkRGF0ZSArIGFsdFNlcGFyYXRvciArIGFsdEZvcm1hdHRlZERhdGVUaW1lO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQkKGFsdEZpZWxkKS52YWwoIGluc3QuaW5wdXQudmFsKCkgPyBhbHRGb3JtYXR0ZWREYXRlVGltZSA6IFwiXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0JC5kYXRlcGlja2VyLl9iYXNlX3VwZGF0ZUFsdGVybmF0ZShpbnN0KTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCogT3ZlcnJpZGUga2V5IHVwIGV2ZW50IHRvIHN5bmMgbWFudWFsIGlucHV0IGNoYW5nZXMuXHJcblx0Ki9cclxuXHQkLmRhdGVwaWNrZXIuX2Jhc2VfZG9LZXlVcCA9ICQuZGF0ZXBpY2tlci5fZG9LZXlVcDtcclxuXHQkLmRhdGVwaWNrZXIuX2RvS2V5VXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHRcdHZhciBpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KGV2ZW50LnRhcmdldCksXHJcblx0XHRcdHRwX2luc3QgPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCAndGltZXBpY2tlcicpO1xyXG5cclxuXHRcdGlmICh0cF9pbnN0KSB7XHJcblx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy50aW1lT25seSAmJiAoaW5zdC5pbnB1dC52YWwoKSAhPT0gaW5zdC5sYXN0VmFsKSkge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XHJcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdFx0XHQkLnRpbWVwaWNrZXIubG9nKGVycik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuICQuZGF0ZXBpY2tlci5fYmFzZV9kb0tleVVwKGV2ZW50KTtcclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCogb3ZlcnJpZGUgXCJUb2RheVwiIGJ1dHRvbiB0byBhbHNvIGdyYWIgdGhlIHRpbWUgYW5kIHNldCBpdCB0byBpbnB1dCBmaWVsZC5cclxuXHQqL1xyXG5cdCQuZGF0ZXBpY2tlci5fYmFzZV9nb3RvVG9kYXkgPSAkLmRhdGVwaWNrZXIuX2dvdG9Ub2RheTtcclxuXHQkLmRhdGVwaWNrZXIuX2dvdG9Ub2RheSA9IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KCQoaWQpWzBdKTtcclxuXHRcdHRoaXMuX2Jhc2VfZ290b1RvZGF5KGlkKTtcclxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XHJcblx0XHRpZiAoIXRwX2luc3QpIHtcclxuXHRcdCAgcmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0em9mZnNldCA9ICQudGltZXBpY2tlci50aW1lem9uZU9mZnNldE51bWJlcih0cF9pbnN0LnRpbWV6b25lKTtcclxuXHRcdHZhciBub3cgPSBuZXcgRGF0ZSgpO1xyXG5cdFx0bm93LnNldE1pbnV0ZXMobm93LmdldE1pbnV0ZXMoKSArIG5vdy5nZXRUaW1lem9uZU9mZnNldCgpICsgcGFyc2VJbnQodHpvZmZzZXQsIDEwKSk7XHJcblx0XHR0aGlzLl9zZXRUaW1lKGluc3QsIG5vdyk7XHJcblx0XHR0aGlzLl9zZXREYXRlKGluc3QsIG5vdyk7XHJcblx0XHR0cF9pbnN0Ll9vblNlbGVjdEhhbmRsZXIoKTtcclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCogRGlzYWJsZSAmIGVuYWJsZSB0aGUgVGltZSBpbiB0aGUgZGF0ZXRpbWVwaWNrZXJcclxuXHQqL1xyXG5cdCQuZGF0ZXBpY2tlci5fZGlzYWJsZVRpbWVwaWNrZXJEYXRlcGlja2VyID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XHJcblx0XHRpZiAoIWluc3QpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XHJcblx0XHQkKHRhcmdldCkuZGF0ZXBpY2tlcignZ2V0RGF0ZScpOyAvLyBJbml0IHNlbGVjdGVkW1llYXJ8TW9udGh8RGF5XVxyXG5cdFx0aWYgKHRwX2luc3QpIHtcclxuXHRcdFx0aW5zdC5zZXR0aW5ncy5zaG93VGltZXBpY2tlciA9IGZhbHNlO1xyXG5cdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5zaG93VGltZXBpY2tlciA9IGZhbHNlO1xyXG5cdFx0XHR0cF9pbnN0Ll91cGRhdGVEYXRlVGltZShpbnN0KTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQkLmRhdGVwaWNrZXIuX2VuYWJsZVRpbWVwaWNrZXJEYXRlcGlja2VyID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XHJcblx0XHRpZiAoIWluc3QpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XHJcblx0XHQkKHRhcmdldCkuZGF0ZXBpY2tlcignZ2V0RGF0ZScpOyAvLyBJbml0IHNlbGVjdGVkW1llYXJ8TW9udGh8RGF5XVxyXG5cdFx0aWYgKHRwX2luc3QpIHtcclxuXHRcdFx0aW5zdC5zZXR0aW5ncy5zaG93VGltZXBpY2tlciA9IHRydWU7XHJcblx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLnNob3dUaW1lcGlja2VyID0gdHJ1ZTtcclxuXHRcdFx0dHBfaW5zdC5fYWRkVGltZVBpY2tlcihpbnN0KTsgLy8gQ291bGQgYmUgZGlzYWJsZWQgb24gcGFnZSBsb2FkXHJcblx0XHRcdHRwX2luc3QuX3VwZGF0ZURhdGVUaW1lKGluc3QpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBDcmVhdGUgb3VyIG93biBzZXQgdGltZSBmdW5jdGlvblxyXG5cdCovXHJcblx0JC5kYXRlcGlja2VyLl9zZXRUaW1lID0gZnVuY3Rpb24gKGluc3QsIGRhdGUpIHtcclxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XHJcblx0XHRpZiAodHBfaW5zdCkge1xyXG5cdFx0XHR2YXIgZGVmYXVsdHMgPSB0cF9pbnN0Ll9kZWZhdWx0cztcclxuXHJcblx0XHRcdC8vIGNhbGxpbmcgX3NldFRpbWUgd2l0aCBubyBkYXRlIHNldHMgdGltZSB0byBkZWZhdWx0c1xyXG5cdFx0XHR0cF9pbnN0LmhvdXIgPSBkYXRlID8gZGF0ZS5nZXRIb3VycygpIDogZGVmYXVsdHMuaG91cjtcclxuXHRcdFx0dHBfaW5zdC5taW51dGUgPSBkYXRlID8gZGF0ZS5nZXRNaW51dGVzKCkgOiBkZWZhdWx0cy5taW51dGU7XHJcblx0XHRcdHRwX2luc3Quc2Vjb25kID0gZGF0ZSA/IGRhdGUuZ2V0U2Vjb25kcygpIDogZGVmYXVsdHMuc2Vjb25kO1xyXG5cdFx0XHR0cF9pbnN0Lm1pbGxpc2VjID0gZGF0ZSA/IGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgOiBkZWZhdWx0cy5taWxsaXNlYztcclxuXHRcdFx0dHBfaW5zdC5taWNyb3NlYyA9IGRhdGUgPyBkYXRlLmdldE1pY3Jvc2Vjb25kcygpIDogZGVmYXVsdHMubWljcm9zZWM7XHJcblxyXG5cdFx0XHQvL2NoZWNrIGlmIHdpdGhpbiBtaW4vbWF4IHRpbWVzLi5cclxuXHRcdFx0dHBfaW5zdC5fbGltaXRNaW5NYXhEYXRlVGltZShpbnN0LCB0cnVlKTtcclxuXHJcblx0XHRcdHRwX2luc3QuX29uVGltZUNoYW5nZSgpO1xyXG5cdFx0XHR0cF9pbnN0Ll91cGRhdGVEYXRlVGltZShpbnN0KTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCogQ3JlYXRlIG5ldyBwdWJsaWMgbWV0aG9kIHRvIHNldCBvbmx5IHRpbWUsIGNhbGxhYmxlIGFzICQoKS5kYXRlcGlja2VyKCdzZXRUaW1lJywgZGF0ZSlcclxuXHQqL1xyXG5cdCQuZGF0ZXBpY2tlci5fc2V0VGltZURhdGVwaWNrZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBkYXRlLCB3aXRoRGF0ZSkge1xyXG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XHJcblx0XHRpZiAoIWluc3QpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XHJcblxyXG5cdFx0aWYgKHRwX2luc3QpIHtcclxuXHRcdFx0dGhpcy5fc2V0RGF0ZUZyb21GaWVsZChpbnN0KTtcclxuXHRcdFx0dmFyIHRwX2RhdGU7XHJcblx0XHRcdGlmIChkYXRlKSB7XHJcblx0XHRcdFx0aWYgKHR5cGVvZiBkYXRlID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdFx0XHR0cF9pbnN0Ll9wYXJzZVRpbWUoZGF0ZSwgd2l0aERhdGUpO1xyXG5cdFx0XHRcdFx0dHBfZGF0ZSA9IG5ldyBEYXRlKCk7XHJcblx0XHRcdFx0XHR0cF9kYXRlLnNldEhvdXJzKHRwX2luc3QuaG91ciwgdHBfaW5zdC5taW51dGUsIHRwX2luc3Quc2Vjb25kLCB0cF9pbnN0Lm1pbGxpc2VjKTtcclxuXHRcdFx0XHRcdHRwX2RhdGUuc2V0TWljcm9zZWNvbmRzKHRwX2luc3QubWljcm9zZWMpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0cF9kYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO1xyXG5cdFx0XHRcdFx0dHBfZGF0ZS5zZXRNaWNyb3NlY29uZHMoZGF0ZS5nZXRNaWNyb3NlY29uZHMoKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICh0cF9kYXRlLnRvU3RyaW5nKCkgPT09ICdJbnZhbGlkIERhdGUnKSB7XHJcblx0XHRcdFx0XHR0cF9kYXRlID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLl9zZXRUaW1lKGluc3QsIHRwX2RhdGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBvdmVycmlkZSBzZXREYXRlKCkgdG8gYWxsb3cgc2V0dGluZyB0aW1lIHRvbyB3aXRoaW4gRGF0ZSBvYmplY3RcclxuXHQqL1xyXG5cdCQuZGF0ZXBpY2tlci5fYmFzZV9zZXREYXRlRGF0ZXBpY2tlciA9ICQuZGF0ZXBpY2tlci5fc2V0RGF0ZURhdGVwaWNrZXI7XHJcblx0JC5kYXRlcGlja2VyLl9zZXREYXRlRGF0ZXBpY2tlciA9IGZ1bmN0aW9uICh0YXJnZXQsIF9kYXRlKSB7XHJcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0KTtcclxuXHRcdHZhciBkYXRlID0gX2RhdGU7XHJcblx0XHRpZiAoIWluc3QpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlb2YoX2RhdGUpID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRkYXRlID0gbmV3IERhdGUoX2RhdGUpO1xyXG5cdFx0XHRpZiAoIWRhdGUuZ2V0VGltZSgpKSB7XHJcblx0XHRcdFx0dGhpcy5fYmFzZV9zZXREYXRlRGF0ZXBpY2tlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdGRhdGUgPSAkKHRhcmdldCkuZGF0ZXBpY2tlcignZ2V0RGF0ZScpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRwX2luc3QgPSB0aGlzLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcclxuXHRcdHZhciB0cF9kYXRlO1xyXG5cdFx0aWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcblx0XHRcdHRwX2RhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7XHJcblx0XHRcdHRwX2RhdGUuc2V0TWljcm9zZWNvbmRzKGRhdGUuZ2V0TWljcm9zZWNvbmRzKCkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHBfZGF0ZSA9IGRhdGU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVGhpcyBpcyBpbXBvcnRhbnQgaWYgeW91IGFyZSB1c2luZyB0aGUgdGltZXpvbmUgb3B0aW9uLCBqYXZhc2NyaXB0J3MgRGF0ZVxyXG5cdFx0Ly8gb2JqZWN0IHdpbGwgb25seSByZXR1cm4gdGhlIHRpbWV6b25lIG9mZnNldCBmb3IgdGhlIGN1cnJlbnQgbG9jYWxlLCBzbyB3ZVxyXG5cdFx0Ly8gYWRqdXN0IGl0IGFjY29yZGluZ2x5LiAgSWYgbm90IHVzaW5nIHRpbWV6b25lIG9wdGlvbiB0aGlzIHdvbid0IG1hdHRlci4uXHJcblx0XHQvLyBJZiBhIHRpbWV6b25lIGlzIGRpZmZlcmVudCBpbiB0cCwga2VlcCB0aGUgdGltZXpvbmUgYXMgaXNcclxuXHRcdGlmICh0cF9pbnN0ICYmIHRwX2RhdGUpIHtcclxuXHRcdFx0Ly8gbG9vayBvdXQgZm9yIERTVCBpZiB0eiB3YXNuJ3Qgc3BlY2lmaWVkXHJcblx0XHRcdGlmICghdHBfaW5zdC5zdXBwb3J0LnRpbWV6b25lICYmIHRwX2luc3QuX2RlZmF1bHRzLnRpbWV6b25lID09PSBudWxsKSB7XHJcblx0XHRcdFx0dHBfaW5zdC50aW1lem9uZSA9IHRwX2RhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIC0xO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRhdGUgPSAkLnRpbWVwaWNrZXIudGltZXpvbmVBZGp1c3QoZGF0ZSwgJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0U3RyaW5nKC1kYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkpLCB0cF9pbnN0LnRpbWV6b25lKTtcclxuXHRcdFx0dHBfZGF0ZSA9ICQudGltZXBpY2tlci50aW1lem9uZUFkanVzdCh0cF9kYXRlLCAkLnRpbWVwaWNrZXIudGltZXpvbmVPZmZzZXRTdHJpbmcoLXRwX2RhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSksIHRwX2luc3QudGltZXpvbmUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XHJcblx0XHR0aGlzLl9iYXNlX3NldERhdGVEYXRlcGlja2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHR0aGlzLl9zZXRUaW1lRGF0ZXBpY2tlcih0YXJnZXQsIHRwX2RhdGUsIHRydWUpO1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBvdmVycmlkZSBnZXREYXRlKCkgdG8gYWxsb3cgZ2V0dGluZyB0aW1lIHRvbyB3aXRoaW4gRGF0ZSBvYmplY3RcclxuXHQqL1xyXG5cdCQuZGF0ZXBpY2tlci5fYmFzZV9nZXREYXRlRGF0ZXBpY2tlciA9ICQuZGF0ZXBpY2tlci5fZ2V0RGF0ZURhdGVwaWNrZXI7XHJcblx0JC5kYXRlcGlja2VyLl9nZXREYXRlRGF0ZXBpY2tlciA9IGZ1bmN0aW9uICh0YXJnZXQsIG5vRGVmYXVsdCkge1xyXG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XHJcblx0XHRpZiAoIWluc3QpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XHJcblxyXG5cdFx0aWYgKHRwX2luc3QpIHtcclxuXHRcdFx0Ly8gaWYgaXQgaGFzbid0IHlldCBiZWVuIGRlZmluZWQsIGdyYWIgZnJvbSBmaWVsZFxyXG5cdFx0XHRpZiAoaW5zdC5sYXN0VmFsID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHR0aGlzLl9zZXREYXRlRnJvbUZpZWxkKGluc3QsIG5vRGVmYXVsdCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fZ2V0RGF0ZShpbnN0KTtcclxuXHJcblx0XHRcdHZhciBjdXJyRFQgPSBudWxsO1xyXG5cclxuXHRcdFx0aWYgKHRwX2luc3QuJGFsdElucHV0ICYmIHRwX2luc3QuX2RlZmF1bHRzLmFsdEZpZWxkVGltZU9ubHkpIHtcclxuXHRcdFx0XHRjdXJyRFQgPSB0cF9pbnN0LiRpbnB1dC52YWwoKSArICcgJyArIHRwX2luc3QuJGFsdElucHV0LnZhbCgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHRwX2luc3QuJGlucHV0LmdldCgwKS50YWdOYW1lICE9PSAnSU5QVVQnICYmIHRwX2luc3QuJGFsdElucHV0KSB7XHJcblx0XHRcdFx0LyoqXHJcblx0XHRcdFx0ICogaW4gY2FzZSB0aGUgZGF0ZXRpbWVwaWNrZXIgaGFzIGJlZW4gYXBwbGllZCB0byBhIG5vbi1pbnB1dCB0YWcgZm9yIGlubGluZSBVSSxcclxuXHRcdFx0XHQgKiBhbmQgdGhlIHVzZXIgaGFzIG5vdCBjb25maWd1cmVkIHRoZSBwbHVnaW4gdG8gZGlzcGxheSBvbmx5IHRpbWUgaW4gYWx0SW5wdXQsXHJcblx0XHRcdFx0ICogcGljayBjdXJyZW50IGRhdGUgdGltZSBmcm9tIHRoZSBhbHRJbnB1dCAoYW5kIGhvcGUgZm9yIHRoZSBiZXN0LCBmb3Igbm93LCB1bnRpbCBcIkVSMVwiIGlzIGFwcGxpZWQpXHJcblx0XHRcdFx0ICpcclxuXHRcdFx0XHQgKiBAdG9kbyBFUjEuIFNpbmNlIGFsdElucHV0IGNhbiBoYXZlIGEgdG90YWxseSBkaWZmZXJlbmNlIGZvcm1hdCwgY29udmVydCBpdCB0byBzdGFuZGFyZCBmb3JtYXQgYnkgcmVhZGluZyBpbnB1dCBmb3JtYXQgZnJvbSBcImFsdEZvcm1hdFwiIGFuZCBcImFsdFRpbWVGb3JtYXRcIiBvcHRpb24gdmFsdWVzXHJcblx0XHRcdFx0ICovXHJcblx0XHRcdFx0Y3VyckRUID0gdHBfaW5zdC4kYWx0SW5wdXQudmFsKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0Y3VyckRUID0gdHBfaW5zdC4kaW5wdXQudmFsKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChkYXRlICYmIHRwX2luc3QuX3BhcnNlVGltZShjdXJyRFQsICFpbnN0LnNldHRpbmdzLnRpbWVPbmx5KSkge1xyXG5cdFx0XHRcdGRhdGUuc2V0SG91cnModHBfaW5zdC5ob3VyLCB0cF9pbnN0Lm1pbnV0ZSwgdHBfaW5zdC5zZWNvbmQsIHRwX2luc3QubWlsbGlzZWMpO1xyXG5cdFx0XHRcdGRhdGUuc2V0TWljcm9zZWNvbmRzKHRwX2luc3QubWljcm9zZWMpO1xyXG5cclxuXHRcdFx0XHQvLyBUaGlzIGlzIGltcG9ydGFudCBpZiB5b3UgYXJlIHVzaW5nIHRoZSB0aW1lem9uZSBvcHRpb24sIGphdmFzY3JpcHQncyBEYXRlXHJcblx0XHRcdFx0Ly8gb2JqZWN0IHdpbGwgb25seSByZXR1cm4gdGhlIHRpbWV6b25lIG9mZnNldCBmb3IgdGhlIGN1cnJlbnQgbG9jYWxlLCBzbyB3ZVxyXG5cdFx0XHRcdC8vIGFkanVzdCBpdCBhY2NvcmRpbmdseS4gIElmIG5vdCB1c2luZyB0aW1lem9uZSBvcHRpb24gdGhpcyB3b24ndCBtYXR0ZXIuLlxyXG5cdFx0XHRcdGlmICh0cF9pbnN0LnRpbWV6b25lICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdC8vIGxvb2sgb3V0IGZvciBEU1QgaWYgdHogd2Fzbid0IHNwZWNpZmllZFxyXG5cdFx0XHRcdFx0aWYgKCF0cF9pbnN0LnN1cHBvcnQudGltZXpvbmUgJiYgdHBfaW5zdC5fZGVmYXVsdHMudGltZXpvbmUgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0dHBfaW5zdC50aW1lem9uZSA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIC0xO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZGF0ZSA9ICQudGltZXBpY2tlci50aW1lem9uZUFkanVzdChkYXRlLCB0cF9pbnN0LnRpbWV6b25lLCAkLnRpbWVwaWNrZXIudGltZXpvbmVPZmZzZXRTdHJpbmcoLWRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZGF0ZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9iYXNlX2dldERhdGVEYXRlcGlja2VyKHRhcmdldCwgbm9EZWZhdWx0KTtcclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCogb3ZlcnJpZGUgcGFyc2VEYXRlKCkgYmVjYXVzZSBVSSAxLjguMTQgdGhyb3dzIGFuIGVycm9yIGFib3V0IFwiRXh0cmEgY2hhcmFjdGVyc1wiXHJcblx0KiBBbiBvcHRpb24gaW4gZGF0YXBpY2tlciB0byBpZ25vcmUgZXh0cmEgZm9ybWF0IGNoYXJhY3RlcnMgd291bGQgYmUgbmljZXIuXHJcblx0Ki9cclxuXHQkLmRhdGVwaWNrZXIuX2Jhc2VfcGFyc2VEYXRlID0gJC5kYXRlcGlja2VyLnBhcnNlRGF0ZTtcclxuXHQkLmRhdGVwaWNrZXIucGFyc2VEYXRlID0gZnVuY3Rpb24gKGZvcm1hdCwgdmFsdWUsIHNldHRpbmdzKSB7XHJcblx0XHR2YXIgZGF0ZTtcclxuXHRcdHRyeSB7XHJcblx0XHRcdGRhdGUgPSB0aGlzLl9iYXNlX3BhcnNlRGF0ZShmb3JtYXQsIHZhbHVlLCBzZXR0aW5ncyk7XHJcblx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0Ly8gSGFjayEgIFRoZSBlcnJvciBtZXNzYWdlIGVuZHMgd2l0aCBhIGNvbG9uLCBhIHNwYWNlLCBhbmRcclxuXHRcdFx0Ly8gdGhlIFwiZXh0cmFcIiBjaGFyYWN0ZXJzLiAgV2UgcmVseSBvbiB0aGF0IGluc3RlYWQgb2ZcclxuXHRcdFx0Ly8gYXR0ZW1wdGluZyB0byBwZXJmZWN0bHkgcmVwcm9kdWNlIHRoZSBwYXJzaW5nIGFsZ29yaXRobS5cclxuXHRcdFx0aWYgKGVyci5pbmRleE9mKFwiOlwiKSA+PSAwKSB7XHJcblx0XHRcdFx0ZGF0ZSA9IHRoaXMuX2Jhc2VfcGFyc2VEYXRlKGZvcm1hdCwgdmFsdWUuc3Vic3RyaW5nKDAsIHZhbHVlLmxlbmd0aCAtIChlcnIubGVuZ3RoIC0gZXJyLmluZGV4T2YoJzonKSAtIDIpKSwgc2V0dGluZ3MpO1xyXG5cdFx0XHRcdCQudGltZXBpY2tlci5sb2coXCJFcnJvciBwYXJzaW5nIHRoZSBkYXRlIHN0cmluZzogXCIgKyBlcnIgKyBcIlxcbmRhdGUgc3RyaW5nID0gXCIgKyB2YWx1ZSArIFwiXFxuZGF0ZSBmb3JtYXQgPSBcIiArIGZvcm1hdCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyb3cgZXJyO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZGF0ZTtcclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCogb3ZlcnJpZGUgZm9ybWF0RGF0ZSB0byBzZXQgZGF0ZSB3aXRoIHRpbWUgdG8gdGhlIGlucHV0XHJcblx0Ki9cclxuXHQkLmRhdGVwaWNrZXIuX2Jhc2VfZm9ybWF0RGF0ZSA9ICQuZGF0ZXBpY2tlci5fZm9ybWF0RGF0ZTtcclxuXHQkLmRhdGVwaWNrZXIuX2Zvcm1hdERhdGUgPSBmdW5jdGlvbiAoaW5zdCwgZGF5LCBtb250aCwgeWVhcikge1xyXG5cdFx0dmFyIHRwX2luc3QgPSB0aGlzLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcclxuXHRcdGlmICh0cF9pbnN0KSB7XHJcblx0XHRcdHRwX2luc3QuX3VwZGF0ZURhdGVUaW1lKGluc3QpO1xyXG5cdFx0XHRyZXR1cm4gdHBfaW5zdC4kaW5wdXQudmFsKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fYmFzZV9mb3JtYXREYXRlKGluc3QpO1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBvdmVycmlkZSBvcHRpb25zIHNldHRlciB0byBhZGQgdGltZSB0byBtYXhEYXRlKFRpbWUpIGFuZCBtaW5EYXRlKFRpbWUpLiBNYXhEYXRlXHJcblx0Ki9cclxuXHQkLmRhdGVwaWNrZXIuX2Jhc2Vfb3B0aW9uRGF0ZXBpY2tlciA9ICQuZGF0ZXBpY2tlci5fb3B0aW9uRGF0ZXBpY2tlcjtcclxuXHQkLmRhdGVwaWNrZXIuX29wdGlvbkRhdGVwaWNrZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xyXG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCksXHJcblx0XHRcdG5hbWVfY2xvbmU7XHJcblx0XHRpZiAoIWluc3QpIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRwX2luc3QgPSB0aGlzLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcclxuXHRcdGlmICh0cF9pbnN0KSB7XHJcblx0XHRcdHZhciBtaW4gPSBudWxsLFxyXG5cdFx0XHRcdG1heCA9IG51bGwsXHJcblx0XHRcdFx0b25zZWxlY3QgPSBudWxsLFxyXG5cdFx0XHRcdG92ZXJyaWRlcyA9IHRwX2luc3QuX2RlZmF1bHRzLmV2bnRzLFxyXG5cdFx0XHRcdGZucyA9IHt9LFxyXG5cdFx0XHRcdHByb3AsXHJcblx0XHRcdFx0cmV0LFxyXG5cdFx0XHRcdG9sZFZhbCxcclxuXHRcdFx0XHQkdGFyZ2V0O1xyXG5cdFx0XHRpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7IC8vIGlmIG1pbi9tYXggd2FzIHNldCB3aXRoIHRoZSBzdHJpbmdcclxuXHRcdFx0XHRpZiAobmFtZSA9PT0gJ21pbkRhdGUnIHx8IG5hbWUgPT09ICdtaW5EYXRlVGltZScpIHtcclxuXHRcdFx0XHRcdG1pbiA9IHZhbHVlO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAobmFtZSA9PT0gJ21heERhdGUnIHx8IG5hbWUgPT09ICdtYXhEYXRlVGltZScpIHtcclxuXHRcdFx0XHRcdG1heCA9IHZhbHVlO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAobmFtZSA9PT0gJ29uU2VsZWN0Jykge1xyXG5cdFx0XHRcdFx0b25zZWxlY3QgPSB2YWx1ZTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKG92ZXJyaWRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiAodmFsdWUpID09PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gb3ZlcnJpZGVzW25hbWVdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Zm5zW25hbWVdID0gdmFsdWU7XHJcblx0XHRcdFx0XHRuYW1lX2Nsb25lID0ge307IC8vZW1wdHkgcmVzdWx0cyBpbiBleGl0aW5nIGZ1bmN0aW9uIGFmdGVyIG92ZXJyaWRlcyB1cGRhdGVkXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JykgeyAvL2lmIG1pbi9tYXggd2FzIHNldCB3aXRoIHRoZSBKU09OXHJcblx0XHRcdFx0aWYgKG5hbWUubWluRGF0ZSkge1xyXG5cdFx0XHRcdFx0bWluID0gbmFtZS5taW5EYXRlO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAobmFtZS5taW5EYXRlVGltZSkge1xyXG5cdFx0XHRcdFx0bWluID0gbmFtZS5taW5EYXRlVGltZTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKG5hbWUubWF4RGF0ZSkge1xyXG5cdFx0XHRcdFx0bWF4ID0gbmFtZS5tYXhEYXRlO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAobmFtZS5tYXhEYXRlVGltZSkge1xyXG5cdFx0XHRcdFx0bWF4ID0gbmFtZS5tYXhEYXRlVGltZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Zm9yIChwcm9wIGluIG92ZXJyaWRlcykge1xyXG5cdFx0XHRcdFx0aWYgKG92ZXJyaWRlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBuYW1lW3Byb3BdKSB7XHJcblx0XHRcdFx0XHRcdGZuc1twcm9wXSA9IG5hbWVbcHJvcF07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGZvciAocHJvcCBpbiBmbnMpIHtcclxuXHRcdFx0XHRpZiAoZm5zLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcblx0XHRcdFx0XHRvdmVycmlkZXNbcHJvcF0gPSBmbnNbcHJvcF07XHJcblx0XHRcdFx0XHRpZiAoIW5hbWVfY2xvbmUpIHsgbmFtZV9jbG9uZSA9ICQuZXh0ZW5kKHt9LCBuYW1lKTsgfVxyXG5cdFx0XHRcdFx0ZGVsZXRlIG5hbWVfY2xvbmVbcHJvcF07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChuYW1lX2Nsb25lICYmIGlzRW1wdHlPYmplY3QobmFtZV9jbG9uZSkpIHsgcmV0dXJuOyB9XHJcblx0XHRcdGlmIChtaW4pIHsgLy9pZiBtaW4gd2FzIHNldFxyXG5cdFx0XHRcdGlmIChtaW4gPT09IDApIHtcclxuXHRcdFx0XHRcdG1pbiA9IG5ldyBEYXRlKCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdG1pbiA9IG5ldyBEYXRlKG1pbik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGUgPSBtaW47XHJcblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZVRpbWUgPSBtaW47XHJcblx0XHRcdH0gZWxzZSBpZiAobWF4KSB7IC8vaWYgbWF4IHdhcyBzZXRcclxuXHRcdFx0XHRpZiAobWF4ID09PSAwKSB7XHJcblx0XHRcdFx0XHRtYXggPSBuZXcgRGF0ZSgpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRtYXggPSBuZXcgRGF0ZShtYXgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlID0gbWF4O1xyXG5cdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGVUaW1lID0gbWF4O1xyXG5cdFx0XHR9IGVsc2UgaWYgKG9uc2VsZWN0KSB7XHJcblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMub25TZWxlY3QgPSBvbnNlbGVjdDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gRGF0ZXBpY2tlciB3aWxsIG92ZXJyaWRlIG91ciBkYXRlIHdoZW4gd2UgY2FsbCBfYmFzZV9vcHRpb25EYXRlcGlja2VyIHdoZW5cclxuXHRcdFx0Ly8gY2FsbGluZyBtaW5EYXRlL21heERhdGUsIHNvIHdlIHdpbGwgZmlyc3QgZ3JhYiB0aGUgdmFsdWUsIGNhbGxcclxuXHRcdFx0Ly8gX2Jhc2Vfb3B0aW9uRGF0ZXBpY2tlciwgdGhlbiBzZXQgb3VyIHZhbHVlIGJhY2suXHJcblx0XHRcdGlmKG1pbiB8fCBtYXgpe1xyXG5cdFx0XHRcdCR0YXJnZXQgPSAkKHRhcmdldCk7XHJcblx0XHRcdFx0b2xkVmFsID0gJHRhcmdldC5kYXRldGltZXBpY2tlcignZ2V0RGF0ZScpO1xyXG5cdFx0XHRcdHJldCA9IHRoaXMuX2Jhc2Vfb3B0aW9uRGF0ZXBpY2tlci5jYWxsKCQuZGF0ZXBpY2tlciwgdGFyZ2V0LCBuYW1lX2Nsb25lIHx8IG5hbWUsIHZhbHVlKTtcclxuXHRcdFx0XHQkdGFyZ2V0LmRhdGV0aW1lcGlja2VyKCdzZXREYXRlJywgb2xkVmFsKTtcclxuXHRcdFx0XHRyZXR1cm4gcmV0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fYmFzZV9vcHRpb25EYXRlcGlja2VyLmNhbGwoJC5kYXRlcGlja2VyLCB0YXJnZXQsIG5hbWUpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX2Jhc2Vfb3B0aW9uRGF0ZXBpY2tlci5jYWxsKCQuZGF0ZXBpY2tlciwgdGFyZ2V0LCBuYW1lX2Nsb25lIHx8IG5hbWUsIHZhbHVlKTtcclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCogalF1ZXJ5IGlzRW1wdHlPYmplY3QgZG9lcyBub3QgY2hlY2sgaGFzT3duUHJvcGVydHkgLSBpZiBzb21lb25lIGhhcyBhZGRlZCB0byB0aGUgb2JqZWN0IHByb3RvdHlwZSxcclxuXHQqIGl0IHdpbGwgcmV0dXJuIGZhbHNlIGZvciBhbGwgb2JqZWN0c1xyXG5cdCovXHJcblx0dmFyIGlzRW1wdHlPYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgcHJvcDtcclxuXHRcdGZvciAocHJvcCBpbiBvYmopIHtcclxuXHRcdFx0aWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fTtcclxuXHJcblx0LypcclxuXHQqIGpRdWVyeSBleHRlbmQgbm93IGlnbm9yZXMgbnVsbHMhXHJcblx0Ki9cclxuXHR2YXIgZXh0ZW5kUmVtb3ZlID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcHMpIHtcclxuXHRcdCQuZXh0ZW5kKHRhcmdldCwgcHJvcHMpO1xyXG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBwcm9wcykge1xyXG5cdFx0XHRpZiAocHJvcHNbbmFtZV0gPT09IG51bGwgfHwgcHJvcHNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHRhcmdldFtuYW1lXSA9IHByb3BzW25hbWVdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBEZXRlcm1pbmUgYnkgdGhlIHRpbWUgZm9ybWF0IHdoaWNoIHVuaXRzIGFyZSBzdXBwb3J0ZWRcclxuXHQqIFJldHVybnMgYW4gb2JqZWN0IG9mIGJvb2xlYW5zIGZvciBlYWNoIHVuaXRcclxuXHQqL1xyXG5cdHZhciBkZXRlY3RTdXBwb3J0ID0gZnVuY3Rpb24gKHRpbWVGb3JtYXQpIHtcclxuXHRcdHZhciB0ZiA9IHRpbWVGb3JtYXQucmVwbGFjZSgvJy4qPycvZywgJycpLnRvTG93ZXJDYXNlKCksIC8vIHJlbW92ZXMgbGl0ZXJhbHNcclxuXHRcdFx0aXNJbiA9IGZ1bmN0aW9uIChmLCB0KSB7IC8vIGRvZXMgdGhlIGZvcm1hdCBjb250YWluIHRoZSB0b2tlbj9cclxuXHRcdFx0XHRcdHJldHVybiBmLmluZGV4T2YodCkgIT09IC0xID8gdHJ1ZSA6IGZhbHNlO1xyXG5cdFx0XHRcdH07XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGhvdXI6IGlzSW4odGYsICdoJyksXHJcblx0XHRcdFx0bWludXRlOiBpc0luKHRmLCAnbScpLFxyXG5cdFx0XHRcdHNlY29uZDogaXNJbih0ZiwgJ3MnKSxcclxuXHRcdFx0XHRtaWxsaXNlYzogaXNJbih0ZiwgJ2wnKSxcclxuXHRcdFx0XHRtaWNyb3NlYzogaXNJbih0ZiwgJ2MnKSxcclxuXHRcdFx0XHR0aW1lem9uZTogaXNJbih0ZiwgJ3onKSxcclxuXHRcdFx0XHRhbXBtOiBpc0luKHRmLCAndCcpICYmIGlzSW4odGltZUZvcm1hdCwgJ2gnKSxcclxuXHRcdFx0XHRpc284NjAxOiBpc0luKHRpbWVGb3JtYXQsICdaJylcclxuXHRcdFx0fTtcclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCogQ29udmVydHMgMjQgaG91ciBmb3JtYXQgaW50byAxMiBob3VyXHJcblx0KiBSZXR1cm5zIDEyIGhvdXIgd2l0aG91dCBsZWFkaW5nIDBcclxuXHQqL1xyXG5cdHZhciBjb252ZXJ0MjR0bzEyID0gZnVuY3Rpb24gKGhvdXIpIHtcclxuXHRcdGhvdXIgJT0gMTI7XHJcblxyXG5cdFx0aWYgKGhvdXIgPT09IDApIHtcclxuXHRcdFx0aG91ciA9IDEyO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBTdHJpbmcoaG91cik7XHJcblx0fTtcclxuXHJcblx0dmFyIGNvbXB1dGVFZmZlY3RpdmVTZXR0aW5nID0gZnVuY3Rpb24gKHNldHRpbmdzLCBwcm9wZXJ0eSkge1xyXG5cdFx0cmV0dXJuIHNldHRpbmdzICYmIHNldHRpbmdzW3Byb3BlcnR5XSA/IHNldHRpbmdzW3Byb3BlcnR5XSA6ICQudGltZXBpY2tlci5fZGVmYXVsdHNbcHJvcGVydHldO1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBTcGxpdHMgZGF0ZXRpbWUgc3RyaW5nIGludG8gZGF0ZSBhbmQgdGltZSBzdWJzdHJpbmdzLlxyXG5cdCogVGhyb3dzIGV4Y2VwdGlvbiB3aGVuIGRhdGUgY2FuJ3QgYmUgcGFyc2VkXHJcblx0KiBSZXR1cm5zIHtkYXRlU3RyaW5nOiBkYXRlU3RyaW5nLCB0aW1lU3RyaW5nOiB0aW1lU3RyaW5nfVxyXG5cdCovXHJcblx0dmFyIHNwbGl0RGF0ZVRpbWUgPSBmdW5jdGlvbiAoZGF0ZVRpbWVTdHJpbmcsIHRpbWVTZXR0aW5ncykge1xyXG5cdFx0Ly8gVGhlIGlkZWEgaXMgdG8gZ2V0IHRoZSBudW1iZXIgc2VwYXJhdG9yIG9jY3VycmVuY2VzIGluIGRhdGV0aW1lIGFuZCB0aGUgdGltZSBmb3JtYXQgcmVxdWVzdGVkIChzaW5jZSB0aW1lIGhhc1xyXG5cdFx0Ly8gZmV3ZXIgdW5rbm93bnMsIG1vc3RseSBudW1iZXJzIGFuZCBhbS9wbSkuIFdlIHdpbGwgdXNlIHRoZSB0aW1lIHBhdHRlcm4gdG8gc3BsaXQuXHJcblx0XHR2YXIgc2VwYXJhdG9yID0gY29tcHV0ZUVmZmVjdGl2ZVNldHRpbmcodGltZVNldHRpbmdzLCAnc2VwYXJhdG9yJyksXHJcblx0XHRcdGZvcm1hdCA9IGNvbXB1dGVFZmZlY3RpdmVTZXR0aW5nKHRpbWVTZXR0aW5ncywgJ3RpbWVGb3JtYXQnKSxcclxuXHRcdFx0dGltZVBhcnRzID0gZm9ybWF0LnNwbGl0KHNlcGFyYXRvciksIC8vIGhvdyBtYW55IG9jY3VycmVuY2VzIG9mIHNlcGFyYXRvciBtYXkgYmUgaW4gb3VyIGZvcm1hdD9cclxuXHRcdFx0dGltZVBhcnRzTGVuID0gdGltZVBhcnRzLmxlbmd0aCxcclxuXHRcdFx0YWxsUGFydHMgPSBkYXRlVGltZVN0cmluZy5zcGxpdChzZXBhcmF0b3IpLFxyXG5cdFx0XHRhbGxQYXJ0c0xlbiA9IGFsbFBhcnRzLmxlbmd0aDtcclxuXHJcblx0XHRpZiAoYWxsUGFydHNMZW4gPiAxKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0ZGF0ZVN0cmluZzogYWxsUGFydHMuc3BsaWNlKDAsIGFsbFBhcnRzTGVuIC0gdGltZVBhcnRzTGVuKS5qb2luKHNlcGFyYXRvciksXHJcblx0XHRcdFx0dGltZVN0cmluZzogYWxsUGFydHMuc3BsaWNlKDAsIHRpbWVQYXJ0c0xlbikuam9pbihzZXBhcmF0b3IpXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0ZGF0ZVN0cmluZzogZGF0ZVRpbWVTdHJpbmcsXHJcblx0XHRcdHRpbWVTdHJpbmc6ICcnXHJcblx0XHR9O1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBJbnRlcm5hbCBmdW5jdGlvbiB0byBwYXJzZSBkYXRldGltZSBpbnRlcnZhbFxyXG5cdCogUmV0dXJuczoge2RhdGU6IERhdGUsIHRpbWVPYmo6IE9iamVjdH0sIHdoZXJlXHJcblx0KiAgIGRhdGUgLSBwYXJzZWQgZGF0ZSB3aXRob3V0IHRpbWUgKHR5cGUgRGF0ZSlcclxuXHQqICAgdGltZU9iaiA9IHtob3VyOiAsIG1pbnV0ZTogLCBzZWNvbmQ6ICwgbWlsbGlzZWM6ICwgbWljcm9zZWM6IH0gLSBwYXJzZWQgdGltZS4gT3B0aW9uYWxcclxuXHQqL1xyXG5cdHZhciBwYXJzZURhdGVUaW1lSW50ZXJuYWwgPSBmdW5jdGlvbiAoZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgZGF0ZVRpbWVTdHJpbmcsIGRhdGVTZXR0aW5ncywgdGltZVNldHRpbmdzKSB7XHJcblx0XHR2YXIgZGF0ZSxcclxuXHRcdFx0cGFydHMsXHJcblx0XHRcdHBhcnNlZFRpbWU7XHJcblxyXG5cdFx0cGFydHMgPSBzcGxpdERhdGVUaW1lKGRhdGVUaW1lU3RyaW5nLCB0aW1lU2V0dGluZ3MpO1xyXG5cdFx0ZGF0ZSA9ICQuZGF0ZXBpY2tlci5fYmFzZV9wYXJzZURhdGUoZGF0ZUZvcm1hdCwgcGFydHMuZGF0ZVN0cmluZywgZGF0ZVNldHRpbmdzKTtcclxuXHJcblx0XHRpZiAocGFydHMudGltZVN0cmluZyA9PT0gJycpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRkYXRlOiBkYXRlXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0cGFyc2VkVGltZSA9ICQuZGF0ZXBpY2tlci5wYXJzZVRpbWUodGltZUZvcm1hdCwgcGFydHMudGltZVN0cmluZywgdGltZVNldHRpbmdzKTtcclxuXHJcblx0XHRpZiAoIXBhcnNlZFRpbWUpIHtcclxuXHRcdFx0dGhyb3cgJ1dyb25nIHRpbWUgZm9ybWF0JztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRkYXRlOiBkYXRlLFxyXG5cdFx0XHR0aW1lT2JqOiBwYXJzZWRUaW1lXHJcblx0XHR9O1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBJbnRlcm5hbCBmdW5jdGlvbiB0byBzZXQgdGltZXpvbmVfc2VsZWN0IHRvIHRoZSBsb2NhbCB0aW1lem9uZVxyXG5cdCovXHJcblx0dmFyIHNlbGVjdExvY2FsVGltZXpvbmUgPSBmdW5jdGlvbiAodHBfaW5zdCwgZGF0ZSkge1xyXG5cdFx0aWYgKHRwX2luc3QgJiYgdHBfaW5zdC50aW1lem9uZV9zZWxlY3QpIHtcclxuXHRcdFx0dmFyIG5vdyA9IGRhdGUgfHwgbmV3IERhdGUoKTtcclxuXHRcdFx0dHBfaW5zdC50aW1lem9uZV9zZWxlY3QudmFsKC1ub3cuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LypcclxuXHQqIENyZWF0ZSBhIFNpbmdsZXRvbiBJbnN0YW5jZVxyXG5cdCovXHJcblx0JC50aW1lcGlja2VyID0gbmV3IFRpbWVwaWNrZXIoKTtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSB0aW1lem9uZSBvZmZzZXQgYXMgc3RyaW5nIGZyb20gYSBkYXRlIG9iamVjdCAoZWcgJyswNTMwJyBmb3IgVVRDKzUuNSlcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdHpNaW51dGVzIGlmIG5vdCBhIG51bWJlciwgbGVzcyB0aGFuIC03MjAgKC0xMjAwKSwgb3IgZ3JlYXRlciB0aGFuIDg0MCAoKzE0MDApIHRoaXMgdmFsdWUgaXMgcmV0dXJuZWRcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzbzg2MDEgaWYgdHJ1ZSBmb3JtYXRzIGluIGFjY29yZGFuY2UgdG8gaXNvODYwMSBcIisxMjo0NVwiXHJcblx0ICogQHJldHVybiB7c3RyaW5nfVxyXG5cdCAqL1xyXG5cdCQudGltZXBpY2tlci50aW1lem9uZU9mZnNldFN0cmluZyA9IGZ1bmN0aW9uICh0ek1pbnV0ZXMsIGlzbzg2MDEpIHtcclxuXHRcdGlmIChpc05hTih0ek1pbnV0ZXMpIHx8IHR6TWludXRlcyA+IDg0MCB8fCB0ek1pbnV0ZXMgPCAtNzIwKSB7XHJcblx0XHRcdHJldHVybiB0ek1pbnV0ZXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9mZiA9IHR6TWludXRlcyxcclxuXHRcdFx0bWludXRlcyA9IG9mZiAlIDYwLFxyXG5cdFx0XHRob3VycyA9IChvZmYgLSBtaW51dGVzKSAvIDYwLFxyXG5cdFx0XHRpc28gPSBpc284NjAxID8gJzonIDogJycsXHJcblx0XHRcdHR6ID0gKG9mZiA+PSAwID8gJysnIDogJy0nKSArICgnMCcgKyBNYXRoLmFicyhob3VycykpLnNsaWNlKC0yKSArIGlzbyArICgnMCcgKyBNYXRoLmFicyhtaW51dGVzKSkuc2xpY2UoLTIpO1xyXG5cclxuXHRcdGlmICh0eiA9PT0gJyswMDowMCcpIHtcclxuXHRcdFx0cmV0dXJuICdaJztcclxuXHRcdH1cclxuXHRcdHJldHVybiB0ejtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIG51bWJlciBpbiBtaW51dGVzIHRoYXQgcmVwcmVzZW50cyBhIHRpbWV6b25lIHN0cmluZ1xyXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gdHpTdHJpbmcgZm9ybWF0dGVkIGxpa2UgXCIrMDUwMFwiLCBcIi0xMjQ1XCIsIFwiWlwiXHJcblx0ICogQHJldHVybiB7bnVtYmVyfSB0aGUgb2Zmc2V0IG1pbnV0ZXMgb3IgdGhlIG9yaWdpbmFsIHN0cmluZyBpZiBpdCBkb2Vzbid0IG1hdGNoIGV4cGVjdGF0aW9uc1xyXG5cdCAqL1xyXG5cdCQudGltZXBpY2tlci50aW1lem9uZU9mZnNldE51bWJlciA9IGZ1bmN0aW9uICh0elN0cmluZykge1xyXG5cdFx0dmFyIG5vcm1hbGl6ZWQgPSB0elN0cmluZy50b1N0cmluZygpLnJlcGxhY2UoJzonLCAnJyk7IC8vIGV4Y3VzZSBhbnkgaXNvODYwMSwgZW5kIHVwIHdpdGggXCIrMTI0NVwiXHJcblxyXG5cdFx0aWYgKG5vcm1hbGl6ZWQudG9VcHBlckNhc2UoKSA9PT0gJ1onKSB7IC8vIGlmIGlzbzg2MDEgd2l0aCBaLCBpdHMgMCBtaW51dGUgb2Zmc2V0XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghL14oXFwtfFxcKylcXGR7NH0kLy50ZXN0KG5vcm1hbGl6ZWQpKSB7IC8vIHBvc3NpYmx5IGEgdXNlciBkZWZpbmVkIHR6LCBzbyBqdXN0IGdpdmUgaXQgYmFja1xyXG5cdFx0XHRyZXR1cm4gcGFyc2VJbnQodHpTdHJpbmcsIDEwKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKChub3JtYWxpemVkLnN1YnN0cigwLCAxKSA9PT0gJy0nID8gLTEgOiAxKSAqIC8vIHBsdXMgb3IgbWludXNcclxuXHRcdFx0XHRcdCgocGFyc2VJbnQobm9ybWFsaXplZC5zdWJzdHIoMSwgMiksIDEwKSAqIDYwKSArIC8vIGhvdXJzIChjb252ZXJ0ZWQgdG8gbWludXRlcylcclxuXHRcdFx0XHRcdHBhcnNlSW50KG5vcm1hbGl6ZWQuc3Vic3RyKDMsIDIpLCAxMCkpKTsgLy8gbWludXRlc1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIE5vIHdheSB0byBzZXQgdGltZXpvbmUgaW4ganMgRGF0ZSwgc28gd2UgbXVzdCBhZGp1c3QgdGhlIG1pbnV0ZXMgdG8gY29tcGVuc2F0ZS4gKHRoaW5rIHNldERhdGUsIGdldERhdGUpXHJcblx0ICogQHBhcmFtICB7RGF0ZX0gZGF0ZVxyXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gZnJvbVRpbWV6b25lIGZvcm1hdHRlZCBsaWtlIFwiKzA1MDBcIiwgXCItMTI0NVwiXHJcblx0ICogQHBhcmFtICB7c3RyaW5nfSB0b1RpbWV6b25lIGZvcm1hdHRlZCBsaWtlIFwiKzA1MDBcIiwgXCItMTI0NVwiXHJcblx0ICogQHJldHVybiB7RGF0ZX1cclxuXHQgKi9cclxuXHQkLnRpbWVwaWNrZXIudGltZXpvbmVBZGp1c3QgPSBmdW5jdGlvbiAoZGF0ZSwgZnJvbVRpbWV6b25lLCB0b1RpbWV6b25lKSB7XHJcblx0XHR2YXIgZnJvbVR6ID0gJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0TnVtYmVyKGZyb21UaW1lem9uZSk7XHJcblx0XHR2YXIgdG9UeiA9ICQudGltZXBpY2tlci50aW1lem9uZU9mZnNldE51bWJlcih0b1RpbWV6b25lKTtcclxuXHRcdGlmICghaXNOYU4odG9UeikpIHtcclxuXHRcdFx0ZGF0ZS5zZXRNaW51dGVzKGRhdGUuZ2V0TWludXRlcygpICsgKC1mcm9tVHopIC0gKC10b1R6KSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZGF0ZTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBDYWxscyBgdGltZXBpY2tlcigpYCBvbiB0aGUgYHN0YXJ0VGltZWAgYW5kIGBlbmRUaW1lYCBlbGVtZW50cywgYW5kIGNvbmZpZ3VyZXMgdGhlbSB0b1xyXG5cdCAqIGVuZm9yY2UgZGF0ZSByYW5nZSBsaW1pdHMuXHJcblx0ICogbi5iLiBUaGUgaW5wdXQgdmFsdWUgbXVzdCBiZSBjb3JyZWN0bHkgZm9ybWF0dGVkIChyZWZvcm1hdHRpbmcgaXMgbm90IHN1cHBvcnRlZClcclxuXHQgKiBAcGFyYW0gIHtFbGVtZW50fSBzdGFydFRpbWVcclxuXHQgKiBAcGFyYW0gIHtFbGVtZW50fSBlbmRUaW1lXHJcblx0ICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSB0aW1lcGlja2VyKCkgY2FsbFxyXG5cdCAqIEByZXR1cm4ge2pRdWVyeX1cclxuXHQgKi9cclxuXHQkLnRpbWVwaWNrZXIudGltZVJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0VGltZSwgZW5kVGltZSwgb3B0aW9ucykge1xyXG5cdFx0cmV0dXJuICQudGltZXBpY2tlci5oYW5kbGVSYW5nZSgndGltZXBpY2tlcicsIHN0YXJ0VGltZSwgZW5kVGltZSwgb3B0aW9ucyk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbHMgYGRhdGV0aW1lcGlja2VyYCBvbiB0aGUgYHN0YXJ0VGltZWAgYW5kIGBlbmRUaW1lYCBlbGVtZW50cywgYW5kIGNvbmZpZ3VyZXMgdGhlbSB0b1xyXG5cdCAqIGVuZm9yY2UgZGF0ZSByYW5nZSBsaW1pdHMuXHJcblx0ICogQHBhcmFtICB7RWxlbWVudH0gc3RhcnRUaW1lXHJcblx0ICogQHBhcmFtICB7RWxlbWVudH0gZW5kVGltZVxyXG5cdCAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgYHRpbWVwaWNrZXIoKWAgY2FsbC4gQWxzbyBzdXBwb3J0cyBgcmVmb3JtYXRgLFxyXG5cdCAqICAgYSBib29sZWFuIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVmb3JtYXQgdGhlIGlucHV0IHZhbHVlcyB0byB0aGUgYGRhdGVGb3JtYXRgLlxyXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gbWV0aG9kIENhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIHR5cGUgb2YgcGlja2VyIHRvIGJlIGFkZGVkXHJcblx0ICogQHJldHVybiB7alF1ZXJ5fVxyXG5cdCAqL1xyXG5cdCQudGltZXBpY2tlci5kYXRldGltZVJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0VGltZSwgZW5kVGltZSwgb3B0aW9ucykge1xyXG5cdFx0JC50aW1lcGlja2VyLmhhbmRsZVJhbmdlKCdkYXRldGltZXBpY2tlcicsIHN0YXJ0VGltZSwgZW5kVGltZSwgb3B0aW9ucyk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbHMgYGRhdGVwaWNrZXJgIG9uIHRoZSBgc3RhcnRUaW1lYCBhbmQgYGVuZFRpbWVgIGVsZW1lbnRzLCBhbmQgY29uZmlndXJlcyB0aGVtIHRvXHJcblx0ICogZW5mb3JjZSBkYXRlIHJhbmdlIGxpbWl0cy5cclxuXHQgKiBAcGFyYW0gIHtFbGVtZW50fSBzdGFydFRpbWVcclxuXHQgKiBAcGFyYW0gIHtFbGVtZW50fSBlbmRUaW1lXHJcblx0ICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBgdGltZXBpY2tlcigpYCBjYWxsLiBBbHNvIHN1cHBvcnRzIGByZWZvcm1hdGAsXHJcblx0ICogICBhIGJvb2xlYW4gdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZvcm1hdCB0aGUgaW5wdXQgdmFsdWVzIHRvIHRoZSBgZGF0ZUZvcm1hdGAuXHJcblx0ICogQHJldHVybiB7alF1ZXJ5fVxyXG5cdCAqL1xyXG5cdCQudGltZXBpY2tlci5kYXRlUmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnRUaW1lLCBlbmRUaW1lLCBvcHRpb25zKSB7XHJcblx0XHQkLnRpbWVwaWNrZXIuaGFuZGxlUmFuZ2UoJ2RhdGVwaWNrZXInLCBzdGFydFRpbWUsIGVuZFRpbWUsIG9wdGlvbnMpO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGxzIGBtZXRob2RgIG9uIHRoZSBgc3RhcnRUaW1lYCBhbmQgYGVuZFRpbWVgIGVsZW1lbnRzLCBhbmQgY29uZmlndXJlcyB0aGVtIHRvXHJcblx0ICogZW5mb3JjZSBkYXRlIHJhbmdlIGxpbWl0cy5cclxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IG1ldGhvZCBDYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSB0eXBlIG9mIHBpY2tlciB0byBiZSBhZGRlZFxyXG5cdCAqIEBwYXJhbSAge0VsZW1lbnR9IHN0YXJ0VGltZVxyXG5cdCAqIEBwYXJhbSAge0VsZW1lbnR9IGVuZFRpbWVcclxuXHQgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIGB0aW1lcGlja2VyKClgIGNhbGwuIEFsc28gc3VwcG9ydHMgYHJlZm9ybWF0YCxcclxuXHQgKiAgIGEgYm9vbGVhbiB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZm9ybWF0IHRoZSBpbnB1dCB2YWx1ZXMgdG8gdGhlIGBkYXRlRm9ybWF0YC5cclxuXHQgKiBAcmV0dXJuIHtqUXVlcnl9XHJcblx0ICovXHJcblx0JC50aW1lcGlja2VyLmhhbmRsZVJhbmdlID0gZnVuY3Rpb24gKG1ldGhvZCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBvcHRpb25zKSB7XHJcblx0XHRvcHRpb25zID0gJC5leHRlbmQoe30sIHtcclxuXHRcdFx0bWluSW50ZXJ2YWw6IDAsIC8vIG1pbiBhbGxvd2VkIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xyXG5cdFx0XHRtYXhJbnRlcnZhbDogMCwgLy8gbWF4IGFsbG93ZWQgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzXHJcblx0XHRcdHN0YXJ0OiB7fSwgICAgICAvLyBvcHRpb25zIGZvciBzdGFydCBwaWNrZXJcclxuXHRcdFx0ZW5kOiB7fSAgICAgICAgIC8vIG9wdGlvbnMgZm9yIGVuZCBwaWNrZXJcclxuXHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdC8vIGZvciB0aGUgbWVhbiB0aW1lIHRoaXMgZml4ZXMgYW4gaXNzdWUgd2l0aCBjYWxsaW5nIGdldERhdGUgd2l0aCB0aW1lcGlja2VyKClcclxuXHRcdHZhciB0aW1lT25seSA9IGZhbHNlO1xyXG5cdFx0aWYobWV0aG9kID09PSAndGltZXBpY2tlcicpe1xyXG5cdFx0XHR0aW1lT25seSA9IHRydWU7XHJcblx0XHRcdG1ldGhvZCA9ICdkYXRldGltZXBpY2tlcic7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gY2hlY2tEYXRlcyhjaGFuZ2VkLCBvdGhlcikge1xyXG5cdFx0XHR2YXIgc3RhcnRkdCA9IHN0YXJ0VGltZVttZXRob2RdKCdnZXREYXRlJyksXHJcblx0XHRcdFx0ZW5kZHQgPSBlbmRUaW1lW21ldGhvZF0oJ2dldERhdGUnKSxcclxuXHRcdFx0XHRjaGFuZ2VkZHQgPSBjaGFuZ2VkW21ldGhvZF0oJ2dldERhdGUnKTtcclxuXHJcblx0XHRcdGlmIChzdGFydGR0ICE9PSBudWxsKSB7XHJcblx0XHRcdFx0dmFyIG1pbkRhdGUgPSBuZXcgRGF0ZShzdGFydGR0LmdldFRpbWUoKSksXHJcblx0XHRcdFx0XHRtYXhEYXRlID0gbmV3IERhdGUoc3RhcnRkdC5nZXRUaW1lKCkpO1xyXG5cclxuXHRcdFx0XHRtaW5EYXRlLnNldE1pbGxpc2Vjb25kcyhtaW5EYXRlLmdldE1pbGxpc2Vjb25kcygpICsgb3B0aW9ucy5taW5JbnRlcnZhbCk7XHJcblx0XHRcdFx0bWF4RGF0ZS5zZXRNaWxsaXNlY29uZHMobWF4RGF0ZS5nZXRNaWxsaXNlY29uZHMoKSArIG9wdGlvbnMubWF4SW50ZXJ2YWwpO1xyXG5cclxuXHRcdFx0XHRpZiAob3B0aW9ucy5taW5JbnRlcnZhbCA+IDAgJiYgbWluRGF0ZSA+IGVuZGR0KSB7IC8vIG1pbkludGVydmFsIGNoZWNrXHJcblx0XHRcdFx0XHRlbmRUaW1lW21ldGhvZF0oJ3NldERhdGUnLCBtaW5EYXRlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAob3B0aW9ucy5tYXhJbnRlcnZhbCA+IDAgJiYgbWF4RGF0ZSA8IGVuZGR0KSB7IC8vIG1heCBpbnRlcnZhbCBjaGVja1xyXG5cdFx0XHRcdFx0ZW5kVGltZVttZXRob2RdKCdzZXREYXRlJywgbWF4RGF0ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKHN0YXJ0ZHQgPiBlbmRkdCkge1xyXG5cdFx0XHRcdFx0b3RoZXJbbWV0aG9kXSgnc2V0RGF0ZScsIGNoYW5nZWRkdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2VsZWN0ZWQoY2hhbmdlZCwgb3RoZXIsIG9wdGlvbikge1xyXG5cdFx0XHRpZiAoIWNoYW5nZWQudmFsKCkpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGRhdGUgPSBjaGFuZ2VkW21ldGhvZF0uY2FsbChjaGFuZ2VkLCAnZ2V0RGF0ZScpO1xyXG5cdFx0XHRpZiAoZGF0ZSAhPT0gbnVsbCAmJiBvcHRpb25zLm1pbkludGVydmFsID4gMCkge1xyXG5cdFx0XHRcdGlmIChvcHRpb24gPT09ICdtaW5EYXRlJykge1xyXG5cdFx0XHRcdFx0ZGF0ZS5zZXRNaWxsaXNlY29uZHMoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSArIG9wdGlvbnMubWluSW50ZXJ2YWwpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAob3B0aW9uID09PSAnbWF4RGF0ZScpIHtcclxuXHRcdFx0XHRcdGRhdGUuc2V0TWlsbGlzZWNvbmRzKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgLSBvcHRpb25zLm1pbkludGVydmFsKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChkYXRlLmdldFRpbWUpIHtcclxuXHRcdFx0XHRvdGhlclttZXRob2RdLmNhbGwob3RoZXIsICdvcHRpb24nLCBvcHRpb24sIGRhdGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0JC5mblttZXRob2RdLmNhbGwoc3RhcnRUaW1lLCAkLmV4dGVuZCh7XHJcblx0XHRcdHRpbWVPbmx5OiB0aW1lT25seSxcclxuXHRcdFx0b25DbG9zZTogZnVuY3Rpb24gKGRhdGVUZXh0LCBpbnN0KSB7XHJcblx0XHRcdFx0Y2hlY2tEYXRlcygkKHRoaXMpLCBlbmRUaW1lKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0b25TZWxlY3Q6IGZ1bmN0aW9uIChzZWxlY3RlZERhdGVUaW1lKSB7XHJcblx0XHRcdFx0c2VsZWN0ZWQoJCh0aGlzKSwgZW5kVGltZSwgJ21pbkRhdGUnKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwgb3B0aW9ucywgb3B0aW9ucy5zdGFydCkpO1xyXG5cdFx0JC5mblttZXRob2RdLmNhbGwoZW5kVGltZSwgJC5leHRlbmQoe1xyXG5cdFx0XHR0aW1lT25seTogdGltZU9ubHksXHJcblx0XHRcdG9uQ2xvc2U6IGZ1bmN0aW9uIChkYXRlVGV4dCwgaW5zdCkge1xyXG5cdFx0XHRcdGNoZWNrRGF0ZXMoJCh0aGlzKSwgc3RhcnRUaW1lKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0b25TZWxlY3Q6IGZ1bmN0aW9uIChzZWxlY3RlZERhdGVUaW1lKSB7XHJcblx0XHRcdFx0c2VsZWN0ZWQoJCh0aGlzKSwgc3RhcnRUaW1lLCAnbWF4RGF0ZScpO1xyXG5cdFx0XHR9XHJcblx0XHR9LCBvcHRpb25zLCBvcHRpb25zLmVuZCkpO1xyXG5cclxuXHRcdGNoZWNrRGF0ZXMoc3RhcnRUaW1lLCBlbmRUaW1lKTtcclxuXHJcblx0XHRzZWxlY3RlZChzdGFydFRpbWUsIGVuZFRpbWUsICdtaW5EYXRlJyk7XHJcblx0XHRzZWxlY3RlZChlbmRUaW1lLCBzdGFydFRpbWUsICdtYXhEYXRlJyk7XHJcblxyXG5cdFx0cmV0dXJuICQoW3N0YXJ0VGltZS5nZXQoMCksIGVuZFRpbWUuZ2V0KDApXSk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogTG9nIGVycm9yIG9yIGRhdGEgdG8gdGhlIGNvbnNvbGUgZHVyaW5nIGVycm9yIG9yIGRlYnVnZ2luZ1xyXG5cdCAqIEBwYXJhbSAge09iamVjdH0gZXJyIHBhc3MgYW55IHR5cGUgb2JqZWN0IHRvIGxvZyB0byB0aGUgY29uc29sZSBkdXJpbmcgZXJyb3Igb3IgZGVidWdnaW5nXHJcblx0ICogQHJldHVybiB7dm9pZH1cclxuXHQgKi9cclxuXHQkLnRpbWVwaWNrZXIubG9nID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gT2xkZXIgSUUgKDksIG1heWJlIDEwKSB0aHJvdyBlcnJvciBvbiBhY2Nlc3NpbmcgYHdpbmRvdy5jb25zb2xlLmxvZy5hcHBseWAsIHNvIGNoZWNrIGZpcnN0LlxyXG5cdFx0aWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmxvZyAmJiB3aW5kb3cuY29uc29sZS5sb2cuYXBwbHkpIHtcclxuXHRcdFx0d2luZG93LmNvbnNvbGUubG9nLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCAqIEFkZCB1dGlsIG9iamVjdCB0byBhbGxvdyBhY2Nlc3MgdG8gcHJpdmF0ZSBtZXRob2RzIGZvciB0ZXN0YWJpbGl0eS5cclxuXHQgKi9cclxuXHQkLnRpbWVwaWNrZXIuX3V0aWwgPSB7XHJcblx0XHRfZXh0ZW5kUmVtb3ZlOiBleHRlbmRSZW1vdmUsXHJcblx0XHRfaXNFbXB0eU9iamVjdDogaXNFbXB0eU9iamVjdCxcclxuXHRcdF9jb252ZXJ0MjR0bzEyOiBjb252ZXJ0MjR0bzEyLFxyXG5cdFx0X2RldGVjdFN1cHBvcnQ6IGRldGVjdFN1cHBvcnQsXHJcblx0XHRfc2VsZWN0TG9jYWxUaW1lem9uZTogc2VsZWN0TG9jYWxUaW1lem9uZSxcclxuXHRcdF9jb21wdXRlRWZmZWN0aXZlU2V0dGluZzogY29tcHV0ZUVmZmVjdGl2ZVNldHRpbmcsXHJcblx0XHRfc3BsaXREYXRlVGltZTogc3BsaXREYXRlVGltZSxcclxuXHRcdF9wYXJzZURhdGVUaW1lSW50ZXJuYWw6IHBhcnNlRGF0ZVRpbWVJbnRlcm5hbFxyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBNaWNyb3NlY29uZCBzdXBwb3J0XHJcblx0Ki9cclxuXHRpZiAoIURhdGUucHJvdG90eXBlLmdldE1pY3Jvc2Vjb25kcykge1xyXG5cdFx0RGF0ZS5wcm90b3R5cGUubWljcm9zZWNvbmRzID0gMDtcclxuXHRcdERhdGUucHJvdG90eXBlLmdldE1pY3Jvc2Vjb25kcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWljcm9zZWNvbmRzOyB9O1xyXG5cdFx0RGF0ZS5wcm90b3R5cGUuc2V0TWljcm9zZWNvbmRzID0gZnVuY3Rpb24gKG0pIHtcclxuXHRcdFx0dGhpcy5zZXRNaWxsaXNlY29uZHModGhpcy5nZXRNaWxsaXNlY29uZHMoKSArIE1hdGguZmxvb3IobSAvIDEwMDApKTtcclxuXHRcdFx0dGhpcy5taWNyb3NlY29uZHMgPSBtICUgMTAwMDtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0LypcclxuXHQqIEtlZXAgdXAgd2l0aCB0aGUgdmVyc2lvblxyXG5cdCovXHJcblx0JC50aW1lcGlja2VyLnZlcnNpb24gPSBcIjEuNi4zXCI7XHJcblxyXG59KSk7XHJcbiIsInJlcXVpcmUoJy4uL2RhdGFncmlkL2pxdWVyeS5nY3J1ZC5kYXRhZ3JpZC5qcycpO1xualF1ZXJ5KGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiBHcm9jZXJ5Q1JVRE9uRG9jdW1lbnRSZWFkeSgpIHtcbiAgICBqUXVlcnkoJy5nYy1jb250YWluZXInKS5ncm9jZXJ5Q3J1ZCgpO1xufSk7XG4iLCJ2YXIgJCA9IGpRdWVyeSxcbiAgICBpMThuID0gcmVxdWlyZSgnLi4vLi4vc2VjdGlvbnMvaTE4bicpLmkxOG4sXG4gICAgYWpheEhlbHBlciA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvYWpheC1oZWxwZXInKS5hamF4SGVscGVyLFxuICAgIGpRdWVyeVBsdWdpbnMgPSBPYmplY3QuY3JlYXRlKHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24galF1ZXJ5UGx1Z2luc0luaXQoKSB7XG4gICAgICAgICAgICAkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoe1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbklucHV0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93QnV0dG9uUGFuZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgY2hhbmdlTW9udGg6IHRydWUsXG4gICAgICAgICAgICAgICAgY2hhbmdlWWVhcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjbG9zZVRleHQ6IGkxOG4udCgnY2FsZW5kYXJfY2xvc2VfdGV4dCcpLFxuICAgICAgICAgICAgICAgIHByZXZUZXh0OiBpMThuLnQoJ2NhbGVuZGFyX3ByZXZfdGV4dCcpLFxuICAgICAgICAgICAgICAgIG5leHRUZXh0OiBpMThuLnQoJ2NhbGVuZGFyX25leHRfdGV4dCcpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0OiBpMThuLnQoJ2NhbGVuZGFyX2N1cnJlbnRfdGV4dCcpLFxuICAgICAgICAgICAgICAgIG1vbnRoTmFtZXM6IGkxOG4udCgnY2FsZW5kYXJfbW9udGhfbmFtZXMnKSxcbiAgICAgICAgICAgICAgICBtb250aE5hbWVzU2hvcnQ6IGkxOG4udCgnY2FsZW5kYXJfbW9udGhfbmFtZXNfc2hvcnQnKSxcbiAgICAgICAgICAgICAgICBkYXlOYW1lczogaTE4bi50KCdjYWxlbmRhcl9kYXlfbmFtZXMnKSxcbiAgICAgICAgICAgICAgICBkYXlOYW1lc1Nob3J0OiBpMThuLnQoJ2NhbGVuZGFyX2RheV9uYW1lc19zaG9ydCcpLFxuICAgICAgICAgICAgICAgIGRheU5hbWVzTWluOiBpMThuLnQoJ2NhbGVuZGFyX2RheV9uYW1lc19taW4nKSxcbiAgICAgICAgICAgICAgICB3ZWVrSGVhZGVyOiBpMThuLnQoJ2NhbGVuZGFyX3dlZWtfaGVhZGVyJylcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkLnRpbWVwaWNrZXIuc2V0RGVmYXVsdHMoe1xuICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQ6ICdISDptbTpzcycsXG4gICAgICAgICAgICAgICAgdGltZVRleHQ6IGkxOG4udCgndGltZV90ZXh0JyksXG4gICAgICAgICAgICAgICAgaG91clRleHQ6IGkxOG4udCgndGltZV9ob3VyX3RleHQnKSxcbiAgICAgICAgICAgICAgICBtaW51dGVUZXh0OiBpMThuLnQoJ3RpbWVfbWludXRlX3RleHQnKSxcbiAgICAgICAgICAgICAgICBzZWNvbmRUZXh0OiBpMThuLnQoJ3RpbWVfc2Vjb25kX3RleHQnKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRhdGVwaWNrZXI6IGZ1bmN0aW9uIGRhdGVwaWNrZXIoJHNlbGVjdG9yLCBnY0luc3RhbmNlKSB7XG4gICAgICAgICAgICAkc2VsZWN0b3IuZGF0ZXBpY2tlcih7XG4gICAgICAgICAgICAgICAgZGF0ZUZvcm1hdDogKGdjSW5zdGFuY2UgIT09IHVuZGVmaW5lZCA/IGdjSW5zdGFuY2UuZGF0ZUZvcm1hdCA6ICd5eS1tbS1kZCcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGF0ZXRpbWVwaWNrZXI6IGZ1bmN0aW9uIGRhdGV0aW1lcGlja2VyKCRzZWxlY3RvciwgZ2NJbnN0YW5jZSkge1xuICAgICAgICAgICAgJHNlbGVjdG9yLmRhdGV0aW1lcGlja2VyKHtcbiAgICAgICAgICAgICAgICBkYXRlRm9ybWF0OiAoZ2NJbnN0YW5jZSAhPT0gdW5kZWZpbmVkID8gZ2NJbnN0YW5jZS5kYXRlRm9ybWF0IDogJ3l5LW1tLWRkJylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB0ZXh0ZWRpdG9yOiBmdW5jdGlvbiB0ZXh0ZWRpdG9yKCRzZWxlY3Rvcikge1xuICAgICAgICAgICAgJHNlbGVjdG9yLmNrZWRpdG9yKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZVRleHRlZGl0b3I6IGZ1bmN0aW9uIHRleHRlZGl0b3IoZmllbGROYW1lLCBmaWVsZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIENLRURJVE9SLmluc3RhbmNlc1tmaWVsZE5hbWVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIENLRURJVE9SLmluc3RhbmNlc1tmaWVsZE5hbWVdLnNldERhdGEoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3lUZXh0ZWRpdG9yOiBmdW5jdGlvbiBkZXN0cm95VGV4dGVkaXRvcihmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgQ0tFRElUT1IuaW5zdGFuY2VzW2ZpZWxkTmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgQ0tFRElUT1IuaW5zdGFuY2VzW2ZpZWxkTmFtZV0uZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZWFyY2hhYmxlU2VsZWN0OiBmdW5jdGlvbiBzZWFyY2hhYmxlU2VsZWN0KCRzZWxlY3RvciwgaXNSZWFkT25seSkge1xuICAgICAgICAgICAgJHNlbGVjdG9yLmNob3NlbignZGVzdHJveScpO1xuXG4gICAgICAgICAgICAvLyBUaW1lb3V0IGFzIGpxdWVyeSBDaG9zZW4gaXMgZHluYW1pY2FsbHkgY2hlY2tpbmcgZm9yIHNlbGVjdCB3aWR0aFxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiB0aW1lT3V0Zm9yU2VhcmNoYWJsZVNlbGVjdCgpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmluZyBoaWRkZW4gY2xhc3MgaW4gb3JkZXIgdG8gY2FsY3VsYXRlIHRoZSB3aWR0aCB3aXRoIGNob3NlblxuICAgICAgICAgICAgICAgIGlmIChpc1JlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICRzZWxlY3Rvci5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRzZWxlY3Rvci5jaG9zZW4oe1xuICAgICAgICAgICAgICAgICAgICBhbGxvd19zaW5nbGVfZGVzZWxlY3Q6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWFkT25seSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQdXQgYmFjayB0aGUgaGlkZGVuIGNsYXNzIGZvciByZWFkIE9ubHlcbiAgICAgICAgICAgICAgICAgICAgJHNlbGVjdG9yLmFkZENsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgJHNlbGVjdG9yLm5leHQoKS5hZGRDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJHNlbGVjdG9yLm5leHQoKS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNlYXJjaGFibGVTZWxlY3RVcGRhdGU6IGZ1bmN0aW9uIHNlYXJjaGFibGVTZWxlY3RVcGRhdGUoJHNlbGVjdG9yLCBpc1JlYWRPbmx5KSB7XG4gICAgICAgICAgICBpZiAoaXNSZWFkT25seSkge1xuICAgICAgICAgICAgICAgICRzZWxlY3Rvci5uZXh0KCkuYWRkQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkc2VsZWN0b3IudHJpZ2dlcignY2hvc2VuOnVwZGF0ZWQnKTtcbiAgICAgICAgICAgICAgICAkc2VsZWN0b3IubmV4dCgpLnJlbW92ZUNsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2VhcmNoYWJsZUFqYXhTZWxlY3Q6IGZ1bmN0aW9uIHNlYXJjaGFibGVBamF4U2VsZWN0KCRzZWxlY3RvciwgZ2NJbnN0YW5jZSkge1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIHRpbWVPdXRTZWFyY2hhYmxlQWpheFNlbGVjdCgpIHtcbiAgICAgICAgICAgICAgICAkc2VsZWN0b3Iuc2VsZWN0Mih7XG4gICAgICAgICAgICAgICAgICAgIGFqYXg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYWpheEhlbHBlci5nZXRVcmwuYXBwbHkoZ2NJbnN0YW5jZSwgWydhamF4LXNlYXJjaCddKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdwb3N0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5OiAyNTAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBmdW5jdGlvbiBnZXREYXRhUGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hfdmFsdWU6IHBhcmFtcy50ZXJtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZF9uYW1lOiAnY291bnRyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2U6IHBhcmFtcy5wYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzUmVzdWx0czogZnVuY3Rpb24gYWpheFByb2Nlc3NSZXN1bHRzKGRhdGEsIHBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wYWdlID0gcGFyYW1zLnBhZ2UgfHwgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzOiBkYXRhLml0ZW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdpbmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3JlOiAocGFyYW1zLnBhZ2UgKiAzMCkgPCBkYXRhLnRvdGFsX2NvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFsbG93Q2xlYXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnU2VsZWN0IGFuIG9wdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZU1hcmt1cDogZnVuY3Rpb24gZXNjYXBlTWFya3VwTWFrZUl0V29yayhtYXJrdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXJrdXA7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW1JbnB1dExlbmd0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVSZXN1bHQ6IGZ1bmN0aW9uIHRlbXBsYXRlUmVzdWx0KGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnRpdGxlIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVNlbGVjdGlvbjogZnVuY3Rpb24gdGVtcGxhdGVTZWxlY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0udGl0bGUgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAkc2VsZWN0b3Iuc2VsZWN0Mih7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnR1InLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnR3JlZWNlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VhcmNoYWJsZUFqYXhTZWxlY3RVcGRhdGU6IGZ1bmN0aW9uIHNlYXJjaGFibGVBamF4U2VsZWN0VXBkYXRlKCRzZWxlY3Rvcikge1xuICAgICAgICAgICAgJHNlbGVjdG9yLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbmV4cG9ydHMualF1ZXJ5UGx1Z2lucyA9IGpRdWVyeVBsdWdpbnM7XG4iLCJcblxuY2xhc3MgUGVyUGFnZURyb3Bkb3duIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IGRlZmF1bHRQZXJQYWdlLCBwYWdpbmdPcHRpb25zIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8c2VsZWN0IG5hbWU9XCJwZXJfcGFnZVwiIGNsYXNzTmFtZT1cInBlcl9wYWdlIGZvcm0tY29udHJvbFwiIGRlZmF1bHRWYWx1ZT17ZGVmYXVsdFBlclBhZ2V9PlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGFnaW5nT3B0aW9ucy5tYXAoZnVuY3Rpb24gUGVyUGFnZURyb3BEb3duRm9yRWFjaChmaWVsZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPG9wdGlvbiB2YWx1ZT17ZmllbGRWYWx1ZX0ga2V5PXtmaWVsZFZhbHVlfT57ZmllbGRWYWx1ZX08L29wdGlvbj47XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQZXJQYWdlRHJvcGRvd247XG4iLCJ2YXIgQ29uc3RhbnRzID0ge1xuICAgIFBBR0lORzoge1xuICAgICAgICBDTEFTU19QRVJfUEFHRTogJ3Blcl9wYWdlJ1xuICAgIH0sXG5cbiAgICBSRVNQT05TRToge1xuICAgICAgICBTVUNDRVNTOiAnc3VjY2VzcycsXG4gICAgICAgIEZBSUxVUkU6ICdmYWlsdXJlJ1xuICAgIH0sXG5cbiAgICBGSUVMRF9UWVBFX1JFTEFUSU9OOiAncmVsYXRpb25hbCcsXG4gICAgRklFTERfVFlQRV9SRUxBVElPTl9OQVRJVkU6ICdyZWxhdGlvbmFsX25hdGl2ZScsXG4gICAgRklFTERfVFlQRV9SRUxBVElPTl9OX1RPX046ICdyZWxhdGlvbmFsX25fbicsXG4gICAgRklFTERfVFlQRV9OQVRJVkVfUkVMQVRJT05fTl9UT19OOiAnbmF0aXZlX3JlbGF0aW9uYWxfbl9uJyxcbiAgICBGSUVMRF9UWVBFX0RBVEU6ICdkYXRlJyxcbiAgICBGSUVMRF9UWVBFX0RBVEVUSU1FOiAnZGF0ZXRpbWUnLFxuICAgIEZJRUxEX1RZUEVfVElNRVNUQU1QOiAndGltZXN0YW1wJyxcbiAgICBTRUxFQ1RPUl9TVFJJTkdfVkFSSUFCTEVTOiAnLnN0cmluZy12YXJpYWJsZXMnLFxuICAgIFNFTEVDVE9SX0dSSURfVEFCTEU6ICcuZ3JvY2VyeS1jcnVkLXRhYmxlJyxcbiAgICBTRUxFQ1RPUl9QQUdFX05VTUJFUl9JTlBVVDogJy5wYWdlLW51bWJlci1pbnB1dCcsXG4gICAgU0VMRUNUT1JfSElEREVOX1BBR0VfTlVNQkVSOiAnLnBhZ2UtbnVtYmVyLWhpZGRlbicsXG4gICAgU0VMRUNUT1JfQUNUSVZFOiAnLmFjdGl2ZScsXG4gICAgU0VMRUNUT1JfVklTSUJMRV9DT0xVTU5fQ0hFQ0tCT1g6ICdpbnB1dFt0eXBlPWNoZWNrYm94XScsXG4gICAgU0VMRUNUT1JfREFUQUdSSURfQ09OVEFJTkVSOiAnLmdjLWdyaWQtY29udGFpbmVyJyxcbiAgICBTRUxFQ1RPUl9IRUFERVJfVE9PTFM6ICcuaGVhZGVyLXRvb2xzJyxcbiAgICBTRUxFQ1RPUl9TRVRUSU5HUzogJy5nYy1zZXR0aW5ncy1jb250YWluZXInLFxuICAgIFNFTEVDVE9SX01PREFMX0ZPUk06ICcuZ2MtZm9ybS1vcGVyYXRpb24tbW9kYWwnLFxuICAgIFNFTEVDVE9SX01PREFMX0FERF9GT1JNX0NPTlRBSU5FUjogJy5nYy1pbnNlcnQtbW9kYWwnLFxuICAgIFNFTEVDVE9SX01PREFMX0VESVRfRk9STV9DT05UQUlORVI6ICcuZ2MtdXBkYXRlLW1vZGFsJyxcbiAgICBTRUxFQ1RPUl9NT0RBTF9SRUFEX0ZPUk1fQ09OVEFJTkVSOiAnLmdjLXJlYWQtbW9kYWwnLFxuICAgIFNFTEVDVE9SX1NFQVJDSF9ST1c6ICcuZ2Mtc2VhcmNoLXJvdycsXG5cbiAgICBTRUxFQ1RPUl9TRUFSQ0hfRklFTERfSU5QVVQ6ICcuZ2Mtc2VhcmNoYWJsZS1pbnB1dCcsXG5cbiAgICBTRUxFQ1RPUl9GT1JNOiAnZm9ybScsXG4gICAgU0VMRUNUT1JfQ09MVU1OU19UUjogJy5oZWFkZXItY29sdW1ucycsXG5cbiAgICBDTEFTU19ESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBDTEFTU19DT0xVTU5fT05fSE9WRVI6ICdiZy1pbmZvJyxcbiAgICBDTEFTU19QQUdJTkdfUFJFVklPVVM6ICdwYWdpbmctcHJldmlvdXMnLFxuICAgIENMQVNTX1BBR0lOR19ORVhUOiAncGFnaW5nLW5leHQnLFxuICAgIENMQVNTX1BBR0lOR19GSVJTVDogJ3BhZ2luZy1maXJzdCcsXG4gICAgQ0xBU1NfUEFHSU5HX0xBU1Q6ICdwYWdpbmctbGFzdCcsXG4gICAgQ0xBU1NfUEVSX1BBR0U6ICdwZXJfcGFnZScsXG5cbiAgICBBQ1RJT05fREFUQUdSSUQ6ICdkYXRhZ3JpZCcsXG4gICAgQUNUSU9OX1BSSU5UOiAncHJpbnQnLFxuICAgIEFDVElPTl9BRERfRk9STTogJ2FkZC1mb3JtJyxcbiAgICBBQ1RJT05fRURJVF9GT1JNOiAnZWRpdC1mb3JtJyxcbiAgICBBQ1RJT05fQ0xPTkVfRk9STTogJ2Nsb25lLWZvcm0nLFxuICAgIEFDVElPTl9SRUFEX0ZPUk06ICdyZWFkLWZvcm0nLFxuICAgIEFDVElPTl9JTlNFUlQ6ICdpbnNlcnQnLFxuICAgIEFDVElPTl9DTE9ORTogJ2Nsb25lJyxcbiAgICBBQ1RJT05fVVBEQVRFOiAndXBkYXRlJyxcbiAgICBBQ1RJT05fUkVBRDogJ3JlYWQnLFxuICAgIEFDVElPTl9SRU1PVkVfT05FOiAncmVtb3ZlLW9uZScsXG4gICAgQUNUSU9OX1JFTU9WRV9NVUxUSVBMRTogJ3JlbW92ZS1tdWx0aXBsZScsXG4gICAgQUNUSU9OX0lOSVRfREFUQTogJ2luaXRpYWwnLFxuXG4gICAgU0VMRUNUT1JfQlVUVE9OX0FERDogJy5idXR0b24tYWRkJyxcblxuICAgIEZJRUxEX05BTUVfQUNUSU9OOiAnYWN0aW9uJyxcblxuICAgIEhBTkRMRUJBUlNfVEVNUExBVEVfUk9XOiAnLmdjLXRhYmxlLXJvdycsXG4gICAgSEFORExFQkFSU19URU1QTEFURV9IRUFERVJfQ09MVU1OUzogJy5nYy10YWJsZS1oZWFkZXItY29sdW1ucycsXG4gICAgSEFORExFQkFSU19URU1QTEFURV9DQVBUSU9OX1RJVExFOiAnLmdjLXRhYmxlLXRpdGxlLWNhcHRpb24nLFxuICAgIEhBTkRMRUJBUlNfQUREX0JVVFRPTjogJy5nYy1hZGQtYnV0dG9uJyxcbiAgICBIQU5ETEVCQVJTX0FDVElPTlNfVElUTEU6ICcuZ2MtaGVhZGVyLWFjdGlvbnMtdGl0bGUnLFxuICAgIEhBTkRMRUJBUlNfRVhQT1JUX0JVVFRPTjogJy5nYy1leHBvcnQtYnV0dG9uJyxcbiAgICBIQU5ETEVCQVJTX1BSSU5UX0JVVFRPTjogJy5nYy1wcmludC1idXR0b24nLFxuICAgIEhBTkRMRUJBUlNfSU5TRVJUX01PREFMOiAnLmdjLWluc2VydC1tb2RhbC10ZW1wbGF0ZScsXG4gICAgSEFORExFQkFSU19SRUFEX01PREFMOiAnLmdjLXJlYWQtbW9kYWwtdGVtcGxhdGUnLFxuICAgIEhBTkRMRUJBUlNfUkVBRF9GSUVMRF9ST1c6ICcuZ2MtcmVhZC1maWVsZC1yb3cnLFxuICAgIEhBTkRMRUJBUlNfRVJST1I6ICcuZ2MtZXJyb3InLFxuICAgIEhBTkRMRUJBUlNfU0VUVElOR1NfQlVUVE9OUzogJy5nYy1zZXR0aW5ncy1idXR0b25zLXRlbXBsYXRlJyxcbiAgICBIQU5ETEVCQVJTX0RFTEVURV9TSU5HTEVfTU9EQUw6ICcuZ2MtY29uZmlybS1kZWxldGUtc2luZ2xlJyxcbiAgICBIQU5ETEVCQVJTX0RFTEVURV9NVVRMSVBMRV9NT0RBTDogJy5nYy1jb25maXJtLWRlbGV0ZS1tdWx0aXBsZScsXG4gICAgSEFORExFQkFSU19QUklOVF9DT05UQUlORVI6ICcuZ2MtcHJpbnQtdGVtcGxhdGUnLFxuICAgIEhBTkRMRUJBUlNfUFJJTlRfSEVBREVSOiAnLmdjLXByaW50LWhlYWRlcicsXG5cbiAgICBTRUxFQ1RPUl9QQUdJTkdfUFJFVklPVVM6ICcucGFnaW5nLXByZXZpb3VzJyxcbiAgICBTRUxFQ1RPUl9QQUdJTkdfTkVYVDogJy5wYWdpbmctbmV4dCcsXG4gICAgU0VMRUNUT1JfUEFHSU5HX0ZJUlNUOiAnLnBhZ2luZy1maXJzdCcsXG4gICAgU0VMRUNUT1JfUEFHSU5HX0xBU1Q6ICcucGFnaW5nLWxhc3QnLFxuXG4gICAgQ0FOQ0VMX0JVVFRPTjogJy5nYy1jYW5jZWwtYnV0dG9uJyxcblxuICAgIFNFTEVDVE9SX0RFTEVURV9CVVRUT046ICcuZ2MtZGVsZXRlLXNpbmdsZScsXG4gICAgU0VMRUNUT1JfREVMRVRFX0NPTkZJUk1BVElPTl9CVVRUT046ICcuZGVsZXRlLXNpbmdsZS1jb25maXJtYXRpb24tYnV0dG9uJyxcbiAgICBTRUxFQ1RPUl9ERUxFVEVfRk9STV9NT0RBTDogJy5kZWxldGUtc2luZ2xlLWNvbmZpcm1hdGlvbicsXG5cbiAgICBTRUxFQ1RPUl9NVUxUSVBMRV9ERUxFVEVfRk9STV9NT0RBTDogJy5nYy1kZWxldGUtbXVsdGlwbGUtY29uZmlybWF0aW9uJyxcbiAgICBTRUxFQ1RPUl9NVUxUSVBMRV9ERUxFVEVfQ09ORklSTUFUSU9OX0JVVFRPTjogJy5kZWxldGUtbXVsdGlwbGUtY29uZmlybWF0aW9uLWJ1dHRvbicsXG5cbiAgICBTRUxFQ1RPUl9ERUxFVEVfQ0hFQ0tCT1g6ICdpbnB1dC5nYy1zZWxlY3Qtcm93JyxcbiAgICBTRUxFQ1RPUl9ERUxFVEVfQ0hFQ0tCT1hfQ0hFQ0tFRDogJ2lucHV0LmdjLXNlbGVjdC1yb3c6Y2hlY2tlZCcsXG5cbiAgICBTRUxFQ1RPUl9FRElUX0JVVFRPTjogJy5nYy1lZGl0LWJ1dHRvbicsXG4gICAgU0VMRUNUT1JfUkVBRF9CVVRUT046ICcuZ2MtcmVhZC1idXR0b24nLFxuXG4gICAgU0VMRUNUT1JfTU9EQUxfQk9EWTogJy5tb2RhbC1ib2R5JyxcblxuICAgIFNFTEVDVE9SX1RZUEVfREFURV9JTlBVVDogJy5nYy1kYXRlJyxcbiAgICBTRUxFQ1RPUl9UWVBFX0RBVEVUSU1FX0lOUFVUOiAnLmdjLWRhdGV0aW1lJ1xufTtcblxuZXhwb3J0cy5Db25zdGFudHMgPSBDb25zdGFudHM7XG4iLCJpbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcblxudmFyIFJlbGF0aW9uTnRvTiA9IHJlcXVpcmUoJy4uL3R5cGVzL3JlbGF0aW9uLW4tbicpLlJlbGF0aW9uTnRvTixcbiAgICBSZWxhdGlvbiA9IHJlcXVpcmUoJy4uL3R5cGVzL3JlbGF0aW9uJykuUmVsYXRpb24sXG4gICAgRW51bSA9IHJlcXVpcmUoJy4uL3R5cGVzL2VudW0nKS5FbnVtLFxuICAgIERyb3Bkb3duID0gcmVxdWlyZSgnLi4vdHlwZXMvZHJvcGRvd24nKS5Ecm9wZG93bixcbiAgICBNdWx0aXBsZVNlbGVjdCA9IHJlcXVpcmUoJy4uL3R5cGVzL211bHRpcGxlLXNlbGVjdCcpLk11bHRpcGxlU2VsZWN0LFxuICAgIENoZWNrYm94Qm9vbGVhbiA9IHJlcXVpcmUoJy4uL3R5cGVzL2NoZWNrYm94LWJvb2xlYW4nKS5DaGVja2JveEJvb2xlYW4sXG4gICAgRGF0ZUFuZFRpbWUgPSByZXF1aXJlKCcuLi90eXBlcy9kYXRlLWFuZC10aW1lJykuRGF0ZUFuZFRpbWUsXG4gICAgVXBsb2FkID0gcmVxdWlyZSgnLi4vdHlwZXMvdXBsb2FkJykuVXBsb2FkLFxuICAgIFRleHRlZGl0b3IgPSByZXF1aXJlKCcuLi90eXBlcy90ZXh0ZWRpdG9yJykuVGV4dGVkaXRvcixcbiAgICBDYWxsYmFja0NvbHVtbiA9IHJlcXVpcmUoJy4uL3R5cGVzL2NhbGxiYWNrLWNvbHVtbicpLkNhbGxiYWNrQ29sdW1uLFxuICAgIENvbHVtbiA9IE9iamVjdC5jcmVhdGUoe1xuICAgICAgICBpbml0Q2FjaGVkRGF0YTogZnVuY3Rpb24gaW5pdENhY2hlZERhdGEoKSB7XG4gICAgICAgICAgICBSZWxhdGlvbk50b04uaW5pdERhdGEuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICBSZWxhdGlvbi5pbml0RGF0YS5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgIEVudW0uaW5pdERhdGEuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICBEYXRlQW5kVGltZS5pbml0RGF0YS5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgIFVwbG9hZC5pbml0RGF0YS5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgIERyb3Bkb3duLmluaXREYXRhLmFwcGx5KHRoaXMpO1xuICAgICAgICAgICAgQ2hlY2tib3hCb29sZWFuLmluaXREYXRhLmFwcGx5KHRoaXMpO1xuICAgICAgICAgICAgTXVsdGlwbGVTZWxlY3QuaW5pdERhdGEuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICBUZXh0ZWRpdG9yLmluaXREYXRhLmFwcGx5KHRoaXMpO1xuICAgICAgICAgICAgQ2FsbGJhY2tDb2x1bW4uaW5pdERhdGEuYXBwbHkodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFJvd3NEYXRhOiBmdW5jdGlvbiBnZXRSb3dzRGF0YShkYXRhT2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcm93RGF0YSA9IHt9O1xuXG4gICAgICAgICAgICByb3dEYXRhLmJhY2tlbmRBY3Rpb25CdXR0b25zID0gZGF0YU9iamVjdC5ncm9jZXJ5X2NydWRfZXh0cmFzLmFjdGlvbkJ1dHRvbnM7XG4gICAgICAgICAgICByb3dEYXRhLnByaW1hcnlLZXlWYWx1ZSA9IGRhdGFPYmplY3QuZ3JvY2VyeV9jcnVkX2V4dHJhcy5wcmltYXJ5S2V5VmFsdWU7XG5cbiAgICAgICAgICAgIHJvd0RhdGEuY29sdW1uc0RhdGEgPSBbXTtcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLnZpc2libGVDb2x1bW5zLCBmdW5jdGlvbiBlYWNoVmlzaWJsZUNvbHVtbnMoY29sdW1uTmFtZSkge1xuICAgICAgICAgICAgICAgIGxldCByb3dWYWx1ZSA9IGRhdGFPYmplY3RbY29sdW1uTmFtZV0sXG4gICAgICAgICAgICAgICAgICAgIGlzSHRtbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChyb3dWYWx1ZSA9PT0gbnVsbCB8fCByb3dWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1ZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChSZWxhdGlvbk50b04uaXNOdG9OLmFwcGx5KHRoaXMsIFtjb2x1bW5OYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93VmFsdWUgPSBSZWxhdGlvbk50b04udHJhbnNmb3JtRGF0YS5hcHBseSh0aGlzLCBbY29sdW1uTmFtZSwgcm93VmFsdWVdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFVwbG9hZC5pc1VwbG9hZFR5cGUuYXBwbHkodGhpcywgW2NvbHVtbk5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICByb3dWYWx1ZSA9IFVwbG9hZC5mb3JtYXRVcGxvYWQuYXBwbHkodGhpcywgW2NvbHVtbk5hbWUsIHJvd1ZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgIGlzSHRtbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChEcm9wZG93bi5pc0Ryb3Bkb3duLmFwcGx5KHRoaXMsIFtjb2x1bW5OYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93VmFsdWUgPSBEcm9wZG93bi5mb3JtYXRWYWx1ZS5hcHBseSh0aGlzLCBbY29sdW1uTmFtZSwgcm93VmFsdWVdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKENoZWNrYm94Qm9vbGVhbi5pc0NoZWNrYm94Qm9vbGVhbi5hcHBseSh0aGlzLCBbY29sdW1uTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1ZhbHVlID0gQ2hlY2tib3hCb29sZWFuLmZvcm1hdFZhbHVlLmFwcGx5KHRoaXMsIFtyb3dWYWx1ZV0pO1xuICAgICAgICAgICAgICAgICAgICBpc0h0bWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoUmVsYXRpb24uaXNSZWxhdGlvbmFsLmFwcGx5KHRoaXMsIFtjb2x1bW5OYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93VmFsdWUgPSBSZWxhdGlvbi50cmFuc2Zvcm1EYXRhLmFwcGx5KHRoaXMsIFtjb2x1bW5OYW1lLCByb3dWYWx1ZV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTXVsdGlwbGVTZWxlY3QuaXNUaGlzVHlwZS5hcHBseSh0aGlzLCBbY29sdW1uTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1ZhbHVlID0gTXVsdGlwbGVTZWxlY3QudHJhbnNmb3JtRGF0YS5hcHBseSh0aGlzLCBbY29sdW1uTmFtZSwgcm93VmFsdWVdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFRleHRlZGl0b3IuaXNUaGlzVHlwZS5hcHBseSh0aGlzLCBbY29sdW1uTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzSHRtbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChDYWxsYmFja0NvbHVtbi5pc1RoaXNUeXBlLmFwcGx5KHRoaXMsIFtjb2x1bW5OYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNIdG1sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByb3dEYXRhLmNvbHVtbnNEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBjb2x1bW5OYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcm93VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGlzSHRtbDogaXNIdG1sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICByZXR1cm4gcm93RGF0YTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5leHBvcnRzLkNvbHVtbiA9IENvbHVtbjsiLCJ2YXIgR3JpZCA9IHJlcXVpcmUoJy4vZGF0YWdyaWQuZ3JpZC5qcycpLkdyaWQsXG4gICAgalF1ZXJ5UGx1Z2lucyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvanF1ZXJ5L2pxdWVyeS1wbHVnaW5zJykualF1ZXJ5UGx1Z2lucyxcbiAgICBsb2NhbFN0b3JhZ2VIZWxwZXIgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL2xvY2FsLXN0b3JhZ2UtaGVscGVyJykubG9jYWxTdG9yYWdlSGVscGVyLFxuICAgIEhhbmRsZWJhcnMgPSByZXF1aXJlKCdoYW5kbGViYXJzJyksXG4gICAgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuQ29uc3RhbnRzLFxuICAgIERhdGFncmlkQ29sdW1ucyA9IE9iamVjdC5jcmVhdGUoe1xuICAgICAgICBzZXRWaXNpYmxlQ29sdW1uczogZnVuY3Rpb24gc2V0VmlzaWJsZUNvbHVtbnMoKSB7XG4gICAgICAgICAgICBsZXQgdmlzaWJsZUNvbHVtbnNDYWNoZSxcbiAgICAgICAgICAgICAgICB2aXNpYmxlQ29sdW1ucztcblxuICAgICAgICAgICAgdmlzaWJsZUNvbHVtbnNDYWNoZSA9IERhdGFncmlkQ29sdW1ucy5nZXRDYWNoZUZvclZpc2libGVDb2x1bW5zLmFwcGx5KHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAodmlzaWJsZUNvbHVtbnNDYWNoZSkge1xuICAgICAgICAgICAgICAgIC8vIEB0b2RvOiBIYW5kbGUgSlNPTi5wYXJzZVxuICAgICAgICAgICAgICAgIHZpc2libGVDb2x1bW5zQ2FjaGUgPSBKU09OLnBhcnNlKHZpc2libGVDb2x1bW5zQ2FjaGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmlzaWJsZUNvbHVtbnNDYWNoZSkge1xuICAgICAgICAgICAgICAgIHZpc2libGVDb2x1bW5zID0gRGF0YWdyaWRDb2x1bW5zLmZpbHRlclZpc2libGVDb2x1bW5zLmFwcGx5KHRoaXMsIFt2aXNpYmxlQ29sdW1uc0NhY2hlXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHdlIGRvbid0IGhhdmUgYW55IHZpc2libGUgY29sdW1ucyB0aGVuIGFkZCBhbGwgdGhlIGNvbHVtbnMgYXMgY2hlY2tlZFxuICAgICAgICAgICAgICAgIGlmICh2aXNpYmxlQ29sdW1ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUNvbHVtbnMgPSB0aGlzLmNvbHVtbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlQ29sdW1ucyA9IHRoaXMuY29sdW1ucztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgRGF0YWdyaWRDb2x1bW5zLnRyaWdnZXJDb2x1bW5zUmVuZGVyLmFwcGx5KHRoaXMsIFt2aXNpYmxlQ29sdW1uc10pO1xuICAgICAgICB9LFxuICAgICAgICBmaWx0ZXJWaXNpYmxlQ29sdW1uczogZnVuY3Rpb24gZmlsdGVyVmlzaWJsZUNvbHVtbnModmlzaWJsZUNvbHVtbnMpIHtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZFZpc2libGVDb2x1bW5zID0gdGhpcy5jb2x1bW5zLmZpbHRlcigoY29sdW1uKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2libGVDb2x1bW5zLmluZGV4T2YoY29sdW1uLmNvbHVtbk5hbWUpID4gLTFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoZmlsdGVyZWRWaXNpYmxlQ29sdW1ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZFZpc2libGVDb2x1bW5zID0gdGhpcy5jb2x1bW5zO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWRWaXNpYmxlQ29sdW1ucztcbiAgICAgICAgfSxcbiAgICAgICAgdGVtcGxhdGVPYmplY3RGaWVsZFR5cGVzOiBmdW5jdGlvbiB0ZW1wbGF0ZU9iamVjdEZpZWxkVHlwZXMoY29sdW1uKSB7XG4gICAgICAgICAgICBsZXQgZmllbGQsXG4gICAgICAgICAgICAgICAgaXNFbnVtLFxuICAgICAgICAgICAgICAgIGlzRGF0ZSxcbiAgICAgICAgICAgICAgICBpc0RhdGV0aW1lLFxuICAgICAgICAgICAgICAgIGlzRHJvcGRvd24sXG4gICAgICAgICAgICAgICAgaXNSZWxhdGlvbmFsLFxuICAgICAgICAgICAgICAgIGlzTnRvTlJlbGF0aW9uYWwsXG4gICAgICAgICAgICAgICAgaXNTZWFyY2hhYmxlLFxuICAgICAgICAgICAgICAgIGlzQm9vbGVhbjtcblxuICAgICAgICAgICAgZmllbGQgPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmZpZWxkVHlwZXNbY29sdW1uLmNvbHVtbk5hbWVdO1xuXG4gICAgICAgICAgICBpZiAoZmllbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBmaW5kIGNvbHVtbiBuYW1lOiBcIicgKyBjb2x1bW4uY29sdW1uTmFtZSArICdcIiBpbiBmaWVsZFR5cGVzLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1RoaXMgaXMgdXN1YWxseSBhbiBlcnJvciB0aGF0IHlvdSB3aWxsIHNlZSB3aGVuIHlvdVxcJ3ZlIGFkZGVkIGEgZmllbGQgbmFtZSB0aGF0IGRvZXNuXFwndCBleGlzdCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2luIHRoZSBkYXRhYmFzZS4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXNFbnVtID0gKFxuICAgICAgICAgICAgICAgIGZpZWxkLmRhdGFUeXBlID09PSAnZW51bScgfHxcbiAgICAgICAgICAgICAgICBmaWVsZC5kYXRhVHlwZSA9PT0gJ2VudW1fc2VhcmNoYWJsZSdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpc0RhdGUgPSAoXG4gICAgICAgICAgICAgICAgZmllbGQuZGF0YVR5cGUgPT09ICdkYXRlJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlzRGF0ZXRpbWUgPSAoXG4gICAgICAgICAgICAgICAgZmllbGQuZGF0YVR5cGUgPT09ICdkYXRldGltZScgfHxcbiAgICAgICAgICAgICAgICBmaWVsZC5kYXRhVHlwZSA9PT0gJ3RpbWVzdGFtcCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpc0Ryb3Bkb3duID0gKFxuICAgICAgICAgICAgICAgIGZpZWxkLmRhdGFUeXBlID09PSAnZHJvcGRvd24nIHx8XG4gICAgICAgICAgICAgICAgZmllbGQuZGF0YVR5cGUgPT09ICdkcm9wZG93bl9zZWFyY2gnIHx8XG4gICAgICAgICAgICAgICAgZmllbGQuZGF0YVR5cGUgPT09ICdtdWx0aXNlbGVjdF9zZWFyY2hhYmxlJyB8fFxuICAgICAgICAgICAgICAgIGZpZWxkLmRhdGFUeXBlID09PSAnbXVsdGlzZWxlY3RfbmF0aXZlJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlzUmVsYXRpb25hbCA9IChcbiAgICAgICAgICAgICAgICBmaWVsZC5kYXRhVHlwZSA9PT0gJ3JlbGF0aW9uYWwnIHx8XG4gICAgICAgICAgICAgICAgZmllbGQuZGF0YVR5cGUgPT09ICdyZWxhdGlvbmFsX25hdGl2ZSdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpc050b05SZWxhdGlvbmFsID0gKFxuICAgICAgICAgICAgICAgIGZpZWxkLmRhdGFUeXBlID09PSAncmVsYXRpb25hbF9uX24nIHx8XG4gICAgICAgICAgICAgICAgZmllbGQuZGF0YVR5cGUgPT09ICduYXRpdmVfcmVsYXRpb25hbF9uX24nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaXNTZWFyY2hhYmxlID0gKFxuICAgICAgICAgICAgICAgIGZpZWxkLmRhdGFUeXBlID09PSAncmVsYXRpb25hbF9uX24nIHx8XG4gICAgICAgICAgICAgICAgZmllbGQuZGF0YVR5cGUgPT09ICdyZWxhdGlvbmFsJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlzQm9vbGVhbiA9IChcbiAgICAgICAgICAgICAgICBmaWVsZC5kYXRhVHlwZSA9PT0gJ2NoZWNrYm94X2Jvb2xlYW4nXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2x1bW4uY29sdW1uTmFtZSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5X25hbWU6IGNvbHVtbi5kaXNwbGF5QXMsXG4gICAgICAgICAgICAgICAgY29sdW1uSW5mbzogZmllbGQsXG4gICAgICAgICAgICAgICAgaXNFbnVtLFxuICAgICAgICAgICAgICAgIGlzRHJvcGRvd24sXG4gICAgICAgICAgICAgICAgaXNSZWxhdGlvbmFsLFxuICAgICAgICAgICAgICAgIGlzTnRvTlJlbGF0aW9uYWwsXG4gICAgICAgICAgICAgICAgaXNEYXRlLFxuICAgICAgICAgICAgICAgIGlzRGF0ZXRpbWUsXG4gICAgICAgICAgICAgICAgaXNTZWFyY2hhYmxlLFxuICAgICAgICAgICAgICAgIGlzQm9vbGVhbixcbiAgICAgICAgICAgICAgICBrbm93bkZpZWxkOiAoXG4gICAgICAgICAgICAgICAgICAgIGlzRW51bSB8fFxuICAgICAgICAgICAgICAgICAgICBpc0Ryb3Bkb3duIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzUmVsYXRpb25hbCB8fFxuICAgICAgICAgICAgICAgICAgICBpc050b05SZWxhdGlvbmFsIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzRGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICBpc0RhdGV0aW1lIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzQm9vbGVhblxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaGFzT3JkZXJpbmc6IChcbiAgICAgICAgICAgICAgICAgICAgIWlzUmVsYXRpb25hbCAmJlxuICAgICAgICAgICAgICAgICAgICAhaXNEcm9wZG93blxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXJDb2x1bW5zUmVuZGVyOiBmdW5jdGlvbiB0cmlnZ2VyQ29sdW1uc1JlbmRlcih2aXNpYmxlQ29sdW1uc1Jhdykge1xuICAgICAgICAgICAgbGV0IGNvbHVtbnNUZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZU9iamVjdCxcbiAgICAgICAgICAgICAgICBzZWFyY2hDb2x1bW5zVGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgaTE4blN0cmluZ3MgPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmkxOG4sXG4gICAgICAgICAgICAgICAgdmlzaWJsZUNvbHVtbnM7XG5cbiAgICAgICAgICAgIEhhbmRsZWJhcnMucmVnaXN0ZXJIZWxwZXIoJ2lmQ29uZCcsIGZ1bmN0aW9uKHYxLCB2Miwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmKHYxID09PSB2Mikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5mbih0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBIYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKCdpZk5vdCcsIGZ1bmN0aW9uKHYxLCB2Miwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmKHYxICE9PSB2Mikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5mbih0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0ZW1wbGF0ZU9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICB0YWJsZV9jb2x1bW5zOiBbXSxcbiAgICAgICAgICAgICAgICBpMThuOiBpMThuU3RyaW5ncyxcbiAgICAgICAgICAgICAgICBoYXNBY3Rpb25zOiB0aGlzLmRhdGFncmlkSGFzQWN0aW9ucy5hcHBseSh0aGlzKSxcbiAgICAgICAgICAgICAgICBzZWFyY2hCeUNvbHVtbjogIUdyaWQuaGFzRXh0ZW5kZWRTZWFyY2guYXBwbHkodGhpcylcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh2aXNpYmxlQ29sdW1uc1Jhdykge1xuICAgICAgICAgICAgICAgIHZpc2libGVDb2x1bW5zID0gdmlzaWJsZUNvbHVtbnNSYXc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmlzaWJsZUNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZpc2libGVDb2x1bW5zID0gRGF0YWdyaWRDb2x1bW5zLmZpbHRlclZpc2libGVDb2x1bW5zLmFwcGx5KHRoaXMsIFt0aGlzLnZpc2libGVDb2x1bW5zXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlcnJvciEnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGVtcGxhdGVPYmplY3QudGFibGVfY29sdW1ucyA9IHZpc2libGVDb2x1bW5zLm1hcChEYXRhZ3JpZENvbHVtbnMudGVtcGxhdGVPYmplY3RGaWVsZFR5cGVzLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlQ29sdW1ucyA9IHZpc2libGVDb2x1bW5zLm1hcCgoY29sdW1uKSA9PiBjb2x1bW4uY29sdW1uTmFtZSk7XG5cbiAgICAgICAgICAgIGNvbHVtbnNUZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKENvbnN0YW50cy5IQU5ETEVCQVJTX1RFTVBMQVRFX0hFQURFUl9DT0xVTU5TKS5odG1sKClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZWFyY2hDb2x1bW5zVGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUodGhpcy4kZ2MuZmluZCgnLmdjLXNlYXJjaC1jb2x1bW5zJykuaHRtbCgpLCB7XG4gICAgICAgICAgICAgICAgaTE4bjogaTE4blN0cmluZ3NcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2Mtc2VhcmNoLWNvbHVtbicpLnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy4kZ2MuZmluZChDb25zdGFudHMuU0VMRUNUT1JfQ09MVU1OU19UUikuaHRtbChjb2x1bW5zVGVtcGxhdGUodGVtcGxhdGVPYmplY3QpKTtcbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1zZWFyY2gtcm93JykuYXBwZW5kKHNlYXJjaENvbHVtbnNUZW1wbGF0ZSh0ZW1wbGF0ZU9iamVjdCkpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy4kZ2MuZmluZCgnLmdjLXNlYXJjaGFibGUtZGF0ZScpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnlQbHVnaW5zLmRhdGVwaWNrZXIodGhpcy4kZ2MuZmluZCgnLmdjLXNlYXJjaGFibGUtZGF0ZScpLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiRnYy5maW5kKCcuZ2Mtc2VhcmNoYWJsZS1kYXRldGltZScpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnlQbHVnaW5zLmRhdGV0aW1lcGlja2VyKHRoaXMuJGdjLmZpbmQoJy5nYy1zZWFyY2hhYmxlLWRhdGV0aW1lJyksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuJGdjLmZpbmQoJy5nYy13aXRoLXNlYXJjaC1wbHVnaW4nKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5UGx1Z2lucy5zZWFyY2hhYmxlU2VsZWN0KHRoaXMuJGdjLmZpbmQoJy5nYy13aXRoLXNlYXJjaC1wbHVnaW4nKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEdyaWQuYWN0aXZhdGVPcmRlcmluZ0NvbHVtbi5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgIEdyaWQuYWN0aXZhdGVPcmRlcmluZ1Jvd3MuYXBwbHkodGhpcyk7XG5cbiAgICAgICAgICAgIEdyaWQubGlzdGVuZXJDb2x1bW5XaXRoT3JkZXJpbmcuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICBHcmlkLmxpc3RlbmVyU2VhcmNoSW5wdXQuYXBwbHkodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldENhY2hlRm9yVmlzaWJsZUNvbHVtbnM6IGZ1bmN0aW9uIHNldENhY2hlRm9yVmlzaWJsZUNvbHVtbnModmlzaWJsZUNvbHVtbnMpIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZUhlbHBlci5zZXRMb2NhbFN0b3JhZ2VJdGVtKCdnY3J1ZFZpc2libGVDb2x1bW5zXycgKyB0aGlzLnVuaXF1ZUlkLCBKU09OLnN0cmluZ2lmeSh2aXNpYmxlQ29sdW1ucykpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRDYWNoZUZvclZpc2libGVDb2x1bW5zOiBmdW5jdGlvbiBnZXRDYWNoZUZvclZpc2libGVDb2x1bW5zKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZUhlbHBlci5nZXRMb2NhbFN0b3JhZ2VJdGVtKCdnY3J1ZFZpc2libGVDb2x1bW5zXycgKyB0aGlzLnVuaXF1ZUlkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5leHBvcnRzLkRhdGFncmlkQ29sdW1ucyA9IERhdGFncmlkQ29sdW1ucztcbiIsInZhciAkID0galF1ZXJ5LFxuICAgIGxvY2FsU3RvcmFnZUhlbHBlciA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvbG9jYWwtc3RvcmFnZS1oZWxwZXInKS5sb2NhbFN0b3JhZ2VIZWxwZXIsXG4gICAgYWpheEhlbHBlciA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvYWpheC1oZWxwZXInKS5hamF4SGVscGVyLFxuICAgIERhdGFncmlkUGFnaW5nID0gcmVxdWlyZSgnLi9kYXRhZ3JpZC5wYWdpbmcnKS5EYXRhZ3JpZFBhZ2luZyxcbiAgICBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKS5Db25zdGFudHMsXG4gICAgR3JpZCA9IE9iamVjdC5jcmVhdGUoe1xuICAgICAgICBzZWFyY2hBbmRPcmRlcmluZ1RyaWdnZXI6IGZ1bmN0aW9uIHNlYXJjaEFuZE9yZGVyaW5nVHJpZ2dlcihoaWdobGlnaHRSb3dJZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YWdyaWRfb2JqZWN0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBnY3J1ZF9jb250YWluZXIgPSBkYXRhZ3JpZF9vYmplY3QuJGdjLFxuICAgICAgICAgICAgICAgIGFqYXhfbGlzdF91cmwgPSBnY3J1ZF9jb250YWluZXIuZGF0YSgndXJsJyk7XG4gICAgICAgICAgICBsZXQgZGF0YVRvU2VuZDtcblxuICAgICAgICAgICAgRGF0YWdyaWRQYWdpbmcucGFnaW5nQ2FsY3VsYXRpb25zLmFwcGx5KHRoaXMpO1xuXG4gICAgICAgICAgICBkYXRhVG9TZW5kID0gR3JpZC5nZXREYXRhVG9TZW5kLmFwcGx5KHRoaXMpO1xuXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2VIZWxwZXIuc2V0TG9jYWxTdG9yYWdlSXRlbSgnZ2NydWRJbml0aWFsRGF0YV8nICsgdGhpcy51bmlxdWVJZCwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIG9yZGVyX2J5OiBkYXRhVG9TZW5kLm9yZGVyX2J5LFxuICAgICAgICAgICAgICAgIHNvcnRpbmc6IGRhdGFUb1NlbmQuc29ydGluZ1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2VIZWxwZXIuc2V0TG9jYWxTdG9yYWdlSXRlbSgnZ2NydWRQcmVmZXJlbmNlcycsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBwZXJfcGFnZTogZGF0YVRvU2VuZC5wZXJfcGFnZVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBHcmlkLnNldEV4cG9ydFVybC5hcHBseSh0aGlzLCBbZGF0YVRvU2VuZF0pO1xuICAgICAgICAgICAgZGF0YVRvU2VuZC5hY3Rpb24gPSAnZGF0YWdyaWQnO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jYWNoZWRJbml0aWFsRGF0YS5jc3JmVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBkYXRhVG9TZW5kW3RoaXMuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuLmlucHV0TmFtZV0gPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbi5pbnB1dFZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNlbmRQb3N0UmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiBhamF4X2xpc3RfdXJsLFxuICAgICAgICAgICAgICAgIGRhdGFUb1NlbmQ6IGRhdGFUb1NlbmQsXG4gICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrOiBmdW5jdGlvbiBhamF4U3VjY2Vzc0NhbGxiYWNrKGpzb25SZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvblJlc3BvbnNlLmNzcmZUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5jc3JmVG9rZW4gPSBqc29uUmVzcG9uc2UuY3NyZlRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVEYXRhZ3JpZChqc29uUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBHcmlkLnVwZGF0ZUdyaWREZXRhaWxzLmFwcGx5KHRoaXMsIFsganNvblJlc3BvbnNlLCBoaWdobGlnaHRSb3dJZCBdKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjazogZnVuY3Rpb24gZGF0YWdyaWRFcnJvckNhbGxiYWNrKCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2VIZWxwZXIucmVtb3ZlTG9jYWxTdG9yYWdlSXRlbSgnZ2NydWRJbml0aWFsRGF0YV8nICsgdGhpcy51bmlxdWVJZCk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0RXhwb3J0VXJsOiBmdW5jdGlvbiBzZXRFeHBvcnRVcmwoZGF0YV90b19zZW5kKSB7XG4gICAgICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgICAgIC5maW5kKCcuZ2MtZXhwb3J0JylcbiAgICAgICAgICAgICAgICAuYXR0cignaHJlZicsXG4gICAgICAgICAgICAgICAgICAgIGFqYXhIZWxwZXIuZ2V0VXJsLmFwcGx5KHRoaXMsIFsnZXhwb3J0JywgZGF0YV90b19zZW5kXSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBnZXRTZWFyY2hEYXRhOiBmdW5jdGlvbiBnZXRTZWFyY2hEYXRhKCkge1xuICAgICAgICAgICAgY29uc3QgJHNlYXJjaF9hbGxfaW5wdXQgPSB0aGlzLiRnYy5maW5kKCcuc2VhcmNoLWJ1dHRvbiA+IGlucHV0LmdjLXNlYXJjaC1pbnB1dCcpO1xuXG4gICAgICAgICAgICBsZXQgc2VhcmNoX2ZpZWxkcyA9IFtdLFxuICAgICAgICAgICAgICAgIHNlYXJjaF90ZXh0cyA9IFtdLFxuICAgICAgICAgICAgICAgIHNlYXJjaCA9IHt9O1xuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2Mtc2VhcmNoLXJvdycpLmZpbmQoJy5nYy1zZWFyY2hhYmxlLWlucHV0LC5nYy1zZWFyY2hhYmxlLXNlbGVjdCcpLmVhY2goZnVuY3Rpb24gZm9yRWFjaFNlYXJjaGFibGVJbnB1dCgpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VhcmNoVmFsdWUgPSAkKHRoaXMpLnZhbCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaFZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hfZmllbGRzLnB1c2goJCh0aGlzKS5hdHRyKCduYW1lJykpO1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hfdGV4dHMucHVzaChzZWFyY2hWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1zZWFyY2gtcm93JykuZmluZCgnaW5wdXQuZ2Mtc2VhcmNoYWJsZS1jaGVja2JveCcpLmVhY2goZnVuY3Rpb24gZm9yRWFjaFNlYXJjaGFibGVJbnB1dCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoJCh0aGlzKS5pcygnOmNoZWNrZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hfZmllbGRzLnB1c2goJCh0aGlzKS5hdHRyKCduYW1lJykpO1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hfdGV4dHMucHVzaCgnMScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoc2VhcmNoX2ZpZWxkcy5sZW5ndGggPiAwICYmICRzZWFyY2hfYWxsX2lucHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAkc2VhcmNoX2FsbF9pbnB1dC52YWwoJycpO1xuICAgICAgICAgICAgICAgICRzZWFyY2hfYWxsX2lucHV0LnRyaWdnZXIoJ2JsdXInKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCRzZWFyY2hfYWxsX2lucHV0Lmxlbmd0aCA+IDAgJiYgJHNlYXJjaF9hbGxfaW5wdXQudmFsKCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgLy9MZXQncyB0YWtlIGFkdmFudGFnZSB0aGF0IEphdmFTY3JpcHQgaXMgbm90IHN0cm9uZyB0eXBlIVxuICAgICAgICAgICAgICAgIHNlYXJjaF9maWVsZHMgPSAnJztcbiAgICAgICAgICAgICAgICBzZWFyY2hfdGV4dHMgPSAkc2VhcmNoX2FsbF9pbnB1dC52YWwoKTtcbiAgICAgICAgICAgICAgICBzZWFyY2guX2djcnVkX3NlYXJjaF9hbGwgPSAkc2VhcmNoX2FsbF9pbnB1dC52YWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoX2ZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIGZvckVhY2hTZWFyY2hGaWVsZHMoc2VhcmNoZmllbGROYW1lLCBzZWFyY2hJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hbc2VhcmNoZmllbGROYW1lXSA9IHNlYXJjaF90ZXh0c1tzZWFyY2hJbmRleF07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNlYXJjaDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0T3JkZXJCeTogZnVuY3Rpb24gZ2V0T3JkZXJCeSgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yZGVyX2J5ID0gdGhpcy4kZ2MuZmluZCgnLmdjLW9yZGVyLWJ5LWhpZGRlbicpLnZhbCgpO1xuXG4gICAgICAgICAgICBpZiAob3JkZXJfYnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JkZXJfYnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRnYy5maW5kKCcuY29sdW1uLXdpdGgtb3JkZXJpbmcuYWN0aXZlOmZpcnN0JykuZGF0YSgnb3JkZXItYnknKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U29ydGluZzogZnVuY3Rpb24gZ2V0U29ydGluZygpIHtcbiAgICAgICAgICAgIGxldCAkY29sdW1uV2l0aE9yZGVyaW5nLFxuICAgICAgICAgICAgICAgIHNvcnRpbmcgPSB0aGlzLiRnYy5maW5kKCcuZ2Mtc29ydGluZy1oaWRkZW4nKS52YWwoKTtcblxuICAgICAgICAgICAgaWYgKHNvcnRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc29ydGluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJGNvbHVtbldpdGhPcmRlcmluZyA9IHRoaXMuJGdjLmZpbmQoJy5jb2x1bW4td2l0aC1vcmRlcmluZy5hY3RpdmU6Zmlyc3QnKTtcblxuICAgICAgICAgICAgaWYgKCRjb2x1bW5XaXRoT3JkZXJpbmcuaGFzQ2xhc3MoJ29yZGVyaW5nLWRlc2MnKSkge1xuICAgICAgICAgICAgICAgIHNvcnRpbmcgPSAnZGVzYyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRjb2x1bW5XaXRoT3JkZXJpbmcuaGFzQ2xhc3MoJ29yZGVyaW5nLWFzYycpKSB7XG4gICAgICAgICAgICAgICAgc29ydGluZyA9ICdhc2MnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc29ydGluZztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UGVyUGFnZTogZnVuY3Rpb24gZ2V0UGVyUGFnZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRnYy5maW5kKCcucGVyX3BhZ2UnKS52YWwoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UGFnZTogZnVuY3Rpb24gZ2V0UGFnZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRnYy5maW5kKCdpbnB1dFtuYW1lPVwicGFnZV9udW1iZXJcIl0nKS52YWwoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0QmFzaWNPcGVyYXRvcjogZnVuY3Rpb24gZ2V0QmFzaWNPcGVyYXRvcigpIHtcbiAgICAgICAgICAgIGNvbnN0ICRpbnB1dEJhc2ljT3BlcmF0b3IgPSB0aGlzLiRnYy5maW5kKCcuZ2MtaGlkZGVuLXNlYXJjaC1pbnB1dHMnKS5maW5kKCdpbnB1dFtuYW1lPVwiYmFzaWNfb3BlcmF0b3JcIl0nKTtcblxuICAgICAgICAgICAgaWYgKCRpbnB1dEJhc2ljT3BlcmF0b3IubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkaW5wdXRCYXNpY09wZXJhdG9yLnZhbCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0RXh0ZW5kZWRTZWFyY2g6IGZ1bmN0aW9uIGdldEV4dGVuZGVkU2VhcmNoKCkge1xuICAgICAgICAgICAgY29uc3QgJHNlYXJjaElucHV0cyA9IHRoaXMuJGdjLmZpbmQoJy5nYy1oaWRkZW4tc2VhcmNoLWlucHV0cycpLmZpbmQoJy5nYy1leHRlbmRlZC1zZWFyY2gtaW5wdXQnKTtcbiAgICAgICAgICAgIGxldCBzZWFyY2hJbnB1dHMgPSB7fTtcblxuICAgICAgICAgICAgaWYgKCRzZWFyY2hJbnB1dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICRzZWFyY2hJbnB1dHMuZWFjaChmdW5jdGlvbiBmb3JFYWNoU2VhcmNoSW5wdXRzKCkge1xuICAgICAgICAgICAgICAgIHNlYXJjaElucHV0c1skKHRoaXMpLmF0dHIoJ25hbWUnKV0gPSAkKHRoaXMpLnZhbCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWFyY2hJbnB1dHM7XG4gICAgICAgIH0sXG4gICAgICAgIGhhc0V4dGVuZGVkU2VhcmNoOiBmdW5jdGlvbiBoYXNFeHRlbmRlZFNlYXJjaCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRnYy5maW5kKCcuZ2MtaGlkZGVuLXNlYXJjaC1pbnB1dHMnKS5maW5kKCcuZ2MtZXh0ZW5kZWQtc2VhcmNoLWlucHV0JykubGVuZ3RoID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0RGF0YVRvU2VuZDogZnVuY3Rpb24gZ2V0RGF0YVRvU2VuZCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBHcmlkLmdldFBhZ2UuYXBwbHkodGhpcyksXG4gICAgICAgICAgICAgICAgcGVyX3BhZ2UgPSBHcmlkLmdldFBlclBhZ2UuYXBwbHkodGhpcyksXG4gICAgICAgICAgICAgICAgb3JkZXJfYnkgPSBHcmlkLmdldE9yZGVyQnkuYXBwbHkodGhpcyksXG4gICAgICAgICAgICAgICAgc29ydGluZyA9IEdyaWQuZ2V0U29ydGluZy5hcHBseSh0aGlzKSxcbiAgICAgICAgICAgICAgICBzZWFyY2ggPSBHcmlkLmdldFNlYXJjaERhdGEuYXBwbHkodGhpcyksXG4gICAgICAgICAgICAgICAgYmFzaWNfb3BlcmF0b3IgPSBHcmlkLmdldEJhc2ljT3BlcmF0b3IuYXBwbHkodGhpcyksXG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRfc2VhcmNoID0gR3JpZC5nZXRFeHRlbmRlZFNlYXJjaC5hcHBseSh0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYWdlLFxuICAgICAgICAgICAgICAgIHBlcl9wYWdlLFxuICAgICAgICAgICAgICAgIG9yZGVyX2J5LFxuICAgICAgICAgICAgICAgIHNvcnRpbmcsXG4gICAgICAgICAgICAgICAgc2VhcmNoLFxuICAgICAgICAgICAgICAgIGJhc2ljX29wZXJhdG9yLFxuICAgICAgICAgICAgICAgIGV4dGVuZGVkX3NlYXJjaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYWN0aXZhdGVPcmRlcmluZ1Jvd3M6IGZ1bmN0aW9uIGFjdGl2YXRlT3JkZXJpbmdSb3dzKCkge1xuICAgICAgICAgICAgY29uc3QgJGFjdGl2ZV9jb2x1bW4gPSB0aGlzLiRnYy5maW5kKCcuY29sdW1uLXdpdGgtb3JkZXJpbmcuYWN0aXZlOmZpcnN0JyksXG4gICAgICAgICAgICAgICAgY29sdW1uSW5kZXggPSAkYWN0aXZlX2NvbHVtbi5pbmRleCgpICsgMTtcblxuICAgICAgICAgICAgaWYgKCRhY3RpdmVfY29sdW1uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ3JvY2VyeS1jcnVkLXRhYmxlJylcbiAgICAgICAgICAgICAgICAgICAgLmZpbmQoJ3RoZWFkIHRyIHRkOm50aC1jaGlsZCgnICsgY29sdW1uSW5kZXggKyAnKScpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnYWN0aXZlIHRhYmxlLWFjdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVHcmlkRGV0YWlsczogZnVuY3Rpb24gdXBkYXRlR3JpZERldGFpbHMoanNvblJlc3BvbnNlLCBoaWdobGlnaHRSb3dJZCkge1xuICAgICAgICAgICAgY29uc3QgcGVyX3BhZ2VfdmFsdWUgPSB0aGlzLiRnYy5maW5kKCcucGVyX3BhZ2UnKS52YWwoKTtcbiAgICAgICAgICAgIGxldCBwYWdpbmdfZW5kcztcblxuICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLnNlbGVjdC1hbGwtbm9uZScpLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuY3VycmVudC10b3RhbC1yZXN1bHRzJykuaHRtbChqc29uUmVzcG9uc2UuZmlsdGVyZWRfdG90YWwpO1xuXG4gICAgICAgICAgICBpZiAoanNvblJlc3BvbnNlLmZpbHRlcmVkX3RvdGFsID4gMTApIHtcbiAgICAgICAgICAgICAgICBwYWdpbmdfZW5kcyA9IHBhcnNlSW50KHRoaXMuJGdjLmZpbmQoJ2lucHV0W25hbWU9XCJwYWdlX251bWJlclwiXScpLnZhbCgpLCAxMCkgKiBwZXJfcGFnZV92YWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChwYWdpbmdfZW5kcyA+IGpzb25SZXNwb25zZS5maWx0ZXJlZF90b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICBwYWdpbmdfZW5kcyA9IGpzb25SZXNwb25zZS5maWx0ZXJlZF90b3RhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLnBhZ2luZy1lbmRzJykuaHRtbChwYWdpbmdfZW5kcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5wYWdpbmctZW5kcycpLmh0bWwoanNvblJlc3BvbnNlLmZpbHRlcmVkX3RvdGFsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGpzb25SZXNwb25zZS5jc3JmVG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbiA9IGpzb25SZXNwb25zZS5jc3JmVG9rZW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5wYWdpbmctc3RhcnRzJykuaHRtbCgocGFyc2VJbnQodGhpcy4kZ2MuZmluZCgnaW5wdXRbbmFtZT1cInBhZ2VfbnVtYmVyXCJdJykudmFsKCksIDEwKSAtIDEpICogcGVyX3BhZ2VfdmFsdWUgKyAxKTtcblxuICAgICAgICAgICAgR3JpZC5hY3RpdmF0ZU9yZGVyaW5nUm93cy5hcHBseSh0aGlzKTtcblxuICAgICAgICAgICAgaWYgKGpzb25SZXNwb25zZS5maWx0ZXJlZF90b3RhbCA8IHBhcnNlSW50KHRoaXMuJGdjLmZpbmQoJy5mdWxsLXRvdGFsJykuaHRtbCgpLCAxMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZnVsbC10b3RhbC1jb250YWluZXInKS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5mdWxsLXRvdGFsLWNvbnRhaW5lcicpLmFkZENsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hcHBlbmRTZWFyY2hDbGVhckJ1dHRvbnMoKTtcbiAgICAgICAgICAgIERhdGFncmlkUGFnaW5nLnBhZ2luZ0NhbGN1bGF0aW9ucy5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZVNob3dEZWxldGVCdXR0b24oKTtcbiAgICAgICAgICAgIGlmIChoaWdobGlnaHRSb3dJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJ3RyW2RhdGEtaWQ9JyArIGhpZ2hsaWdodFJvd0lkICsgJ10nKS5hZGRDbGFzcygnZmxhc2ggYW5pbWF0ZWQnKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIHRpbWVvdXRSZW1vdmVGbGFzaGluZygpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgndHJbZGF0YS1pZD0nICsgaGlnaGxpZ2h0Um93SWQgKyAnXScpLnJlbW92ZUNsYXNzKCdmbGFzaCBhbmltYXRlZCcpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RlbmVyUGFnaW5nQnV0dG9uczogZnVuY3Rpb24gbGlzdGVuZXJQYWdpbmdCdXR0b25zKCkge1xuICAgICAgICAgICAgdmFyIGRhdGFncmlkX29iamVjdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzX2Zvcl9hbGxfYnV0dG9ucyA9IENvbnN0YW50cy5TRUxFQ1RPUl9QQUdJTkdfUFJFVklPVVMgKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgQ29uc3RhbnRzLlNFTEVDVE9SX1BBR0lOR19ORVhUICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIENvbnN0YW50cy5TRUxFQ1RPUl9QQUdJTkdfRklSU1QgKyAnLCcgK1xuICAgICAgICAgICAgICAgICAgICBDb25zdGFudHMuU0VMRUNUT1JfUEFHSU5HX0xBU1QsXG4gICAgICAgICAgICAgICAgcGFnZV9udW1iZXJfaW5wdXRfaGlkZGVuID0gZGF0YWdyaWRfb2JqZWN0LiRnYy5maW5kKCcucGFnZS1udW1iZXItaGlkZGVuJyk7XG5cbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoc2VsZWN0b3JzX2Zvcl9hbGxfYnV0dG9ucykuY2xpY2soZnVuY3Rpb24gZm9yRWFjaEJ1dHRvbnNTZWxlY3RvcnMoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgLy9JZiBpdCBpcyBkaXNhYmxlZCB0aGVuIGRvIG5vdGhpbmchXG4gICAgICAgICAgICAgICAgaWYgKCQodGhpcykuaGFzQ2xhc3MoQ29uc3RhbnRzLkNMQVNTX0RJU0FCTEVEKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCQodGhpcykuaGFzQ2xhc3MoQ29uc3RhbnRzLkNMQVNTX1BBR0lOR19QUkVWSU9VUykpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZV9udW1iZXJfaW5wdXRfaGlkZGVuLnZhbChwYXJzZUludChwYWdlX251bWJlcl9pbnB1dF9oaWRkZW4udmFsKCksIDEwKSAtIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJCh0aGlzKS5oYXNDbGFzcyhDb25zdGFudHMuQ0xBU1NfUEFHSU5HX05FWFQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VfbnVtYmVyX2lucHV0X2hpZGRlbi52YWwocGFyc2VJbnQocGFnZV9udW1iZXJfaW5wdXRfaGlkZGVuLnZhbCgpLCAxMCkgKyAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCQodGhpcykuaGFzQ2xhc3MoQ29uc3RhbnRzLkNMQVNTX1BBR0lOR19GSVJTVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZV9udW1iZXJfaW5wdXRfaGlkZGVuLnZhbCgnMScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJCh0aGlzKS5oYXNDbGFzcyhDb25zdGFudHMuQ0xBU1NfUEFHSU5HX0xBU1QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VfbnVtYmVyX2lucHV0X2hpZGRlbi52YWwoRGF0YWdyaWRQYWdpbmcuZ2V0TWF4UGFnaW5nLmFwcGx5KGRhdGFncmlkX29iamVjdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBHcmlkLnNlYXJjaEFuZE9yZGVyaW5nVHJpZ2dlci5hcHBseShkYXRhZ3JpZF9vYmplY3QpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX1BBR0VfTlVNQkVSX0lOUFVUKS5jaGFuZ2UoZnVuY3Rpb24gcGFnZU51bWJlcklucHV0T25DaGFuZ2UoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihwYXJzZUludCgkKHRoaXMpLnZhbCgpLCAxMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VfbnVtYmVyX2lucHV0X2hpZGRlbi52YWwocGFyc2VJbnQoJCh0aGlzKS52YWwoKSwgMTApKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYWdlX251bWJlcl9pbnB1dF9oaWRkZW4udmFsKCcxJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgR3JpZC5zZWFyY2hBbmRPcmRlcmluZ1RyaWdnZXIuYXBwbHkoZGF0YWdyaWRfb2JqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG4gICAgICAgIGFjdGl2YXRlT3JkZXJpbmdDb2x1bW46IGZ1bmN0aW9uIGFjdGl2YXRlT3JkZXJpbmdDb2x1bW4oKSB7XG4gICAgICAgICAgICBjb25zdCBvcmRlcl9ieSA9IHRoaXMuJGdjLmZpbmQoJy5nYy1vcmRlci1ieS1oaWRkZW4nKS52YWwoKSxcbiAgICAgICAgICAgICAgICBzb3J0aW5nID0gdGhpcy4kZ2MuZmluZCgnLmdjLXNvcnRpbmctaGlkZGVuJykudmFsKCk7XG4gICAgICAgICAgICBpZiAob3JkZXJfYnkgJiYgc29ydGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuJGdjXG4gICAgICAgICAgICAgICAgICAgIC5maW5kKCcuY29sdW1uLXdpdGgtb3JkZXJpbmdbZGF0YS1vcmRlci1ieT1cIicgKyBvcmRlcl9ieSArICdcIl0nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2FjdGl2ZSB0YWJsZS1hY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgICAgICAgICAuZmluZCgnLmNvbHVtbi13aXRoLW9yZGVyaW5nW2RhdGEtb3JkZXItYnk9XCInICsgb3JkZXJfYnkgKyAnXCJdJylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdvcmRlcmluZy0nICsgc29ydGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RlbmVyQ29sdW1uV2l0aE9yZGVyaW5nOiBmdW5jdGlvbiBsaXN0ZW5lckNvbHVtbldpdGhPcmRlcmluZygpIHtcbiAgICAgICAgICAgIGxldCBkYXRhZ3JpZF9vYmplY3QgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuY29sdW1uLXdpdGgtb3JkZXJpbmcnKS5jbGljayhmdW5jdGlvbiBvbkNvbHVtbk9yZGVyaW5nQ2xpY2soKSB7XG4gICAgICAgICAgICAgICAgbGV0IGdjcnVkX2NvbnRhaW5lciA9ICQodGhpcykuY2xvc2VzdCgnLmdjLWNvbnRhaW5lcicpLFxuICAgICAgICAgICAgICAgICAgICAkdGFibGUgPSAkKHRoaXMpLmNsb3Nlc3QoJy5ncm9jZXJ5LWNydWQtdGFibGUnKSxcbiAgICAgICAgICAgICAgICAgICAgc29ydGluZztcblxuICAgICAgICAgICAgICAgICR0YWJsZS5maW5kKCd0aGVhZCcpLmZpbmQoJ3RoLmFjdGl2ZSwgdGQuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZSB0YWJsZS1hY3RpdmUnKTtcblxuICAgICAgICAgICAgICAgICQodGhpcykucGFyZW50KCkuZmluZCgnLmNvbHVtbi13aXRoLW9yZGVyaW5nJykuZWFjaChmdW5jdGlvbiBmb3JlYWNoQ29sdW1uc1dpdGhPcmRlcmluZygpIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5odG1sKCc8ZGl2PicgKyAkLnRyaW0oJCh0aGlzKS50ZXh0KCkpICsgJzwvZGl2PicpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcygnYWN0aXZlIHRhYmxlLWFjdGl2ZScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCQodGhpcykuaGFzQ2xhc3MoJ29yZGVyaW5nLWFzYycpKSB7XG4gICAgICAgICAgICAgICAgICAgICR0YWJsZS5maW5kKCd0aCcpLnJlbW92ZUNsYXNzKCdvcmRlcmluZy1kZXNjJykucmVtb3ZlQ2xhc3MoJ29yZGVyaW5nLWFzYycpO1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdvcmRlcmluZy1kZXNjJykucmVtb3ZlQ2xhc3MoJ29yZGVyaW5nLWFzYycpO1xuICAgICAgICAgICAgICAgICAgICBzb3J0aW5nID0gJ2Rlc2MnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICR0YWJsZS5maW5kKCd0aCcpLnJlbW92ZUNsYXNzKCdvcmRlcmluZy1kZXNjJykucmVtb3ZlQ2xhc3MoJ29yZGVyaW5nLWFzYycpO1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdvcmRlcmluZy1hc2MnKS5yZW1vdmVDbGFzcygnb3JkZXJpbmctZGVzYycpO1xuICAgICAgICAgICAgICAgICAgICBzb3J0aW5nID0gJ2FzYyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZ2NydWRfY29udGFpbmVyLmZpbmQoJ2lucHV0W25hbWU9XCJwYWdlX251bWJlclwiXScpLnZhbCgnMScpO1xuXG4gICAgICAgICAgICAgICAgZ2NydWRfY29udGFpbmVyLmZpbmQoJy5nYy1vcmRlci1ieS1oaWRkZW4nKS52YWwoJCh0aGlzKS5kYXRhKCdvcmRlci1ieScpKTtcbiAgICAgICAgICAgICAgICBnY3J1ZF9jb250YWluZXIuZmluZCgnLmdjLXNvcnRpbmctaGlkZGVuJykudmFsKHNvcnRpbmcpO1xuXG4gICAgICAgICAgICAgICAgR3JpZC5zZWFyY2hBbmRPcmRlcmluZ1RyaWdnZXIuYXBwbHkoZGF0YWdyaWRfb2JqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBsaXN0ZW5lclNlYXJjaElucHV0OiBmdW5jdGlvbiBsaXN0ZW5lclNlYXJjaElucHV0KCkge1xuICAgICAgICAgICAgbGV0IGRhdGFncmlkX29iamVjdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1zZWFyY2hhYmxlLWlucHV0Jykub24oJ2tleXVwIGNoYW5nZScsIGZ1bmN0aW9uIG9uQ2hhbmdlU2VhcmNoSW5wdXQoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAvL0lmIHRoZSBrZXkgaXMgRW50ZXIgb3IgZW1wdHksIHRoZW4gZG9uJ3Qgd2FpdCEgSnVzdCBzdGFydCBzZWFyY2hpbmcuLi5cbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lclRpbWVvdXQgPSBldmVudC5rZXlDb2RlID09PSA5IHx8IGV2ZW50LmtleUNvZGUgPT09IDEzIHx8ICQodGhpcykudmFsKCkgPT09ICcnID8gMSA6IDEwMDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YWdyaWRfb2JqZWN0LnNlYXJjaF90aW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoZGF0YWdyaWRfb2JqZWN0LnNlYXJjaF90aW1lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGFncmlkX29iamVjdC5zZWFyY2hfdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIHNlYXJjaFRpbWVyVGltZW91dENhbGxiYWNrKCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhZ3JpZF9vYmplY3QuJGdjLmZpbmQoJy5wYWdlLW51bWJlci1oaWRkZW4nKS52YWwoJzEnKTtcbiAgICAgICAgICAgICAgICAgICAgR3JpZC5zZWFyY2hBbmRPcmRlcmluZ1RyaWdnZXIuYXBwbHkoZGF0YWdyaWRfb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lclRpbWVvdXQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1zZWFyY2hhYmxlLXNlbGVjdCwuZ2Mtc2VhcmNoYWJsZS1jaGVja2JveCcpLmNoYW5nZShmdW5jdGlvbiBvbkNoYW5nZVNlYXJjaElucHV0KCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5wYWdlLW51bWJlci1oaWRkZW4nKS52YWwoJzEnKTtcbiAgICAgICAgICAgICAgICBHcmlkLnNlYXJjaEFuZE9yZGVyaW5nVHJpZ2dlci5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1kYXRlLW9wZXJhdG9yJykuY2hhbmdlKGZ1bmN0aW9uIG9uQ2hhbmdlU2VhcmNoSW5wdXQoKSB7XG4gICAgICAgICAgICAgICAgR3JpZC5zZWFyY2hBbmRPcmRlcmluZ1RyaWdnZXIuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbkdyaWQuQ0xBU1NfUEVSX1BBR0UgPSAncGVyX3BhZ2UnO1xuXG5leHBvcnRzLkdyaWQgPSBHcmlkO1xuIiwidmFyICQgPSBqUXVlcnksXG4gICAgYWpheEhlbHBlciA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvYWpheC1oZWxwZXInKS5hamF4SGVscGVyLFxuICAgIEhhbmRsZWJhcnMgPSByZXF1aXJlKCdoYW5kbGViYXJzJyksXG4gICAgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKSxcbiAgICBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKS5Db25zdGFudHMsXG4gICAgR3JpZCA9IHJlcXVpcmUoJy4vZGF0YWdyaWQuZ3JpZCcpLkdyaWQsXG4gICAgRGF0YWdyaWRIZWFkZXJBY3Rpb25zID0gT2JqZWN0LmNyZWF0ZSh7XG4gICAgICAgIGxpc3RlbmVyUHJpbnRCdXR0b246IGZ1bmN0aW9uIGxpc3RlbmVyUHJpbnRCdXR0b24oKSB7XG4gICAgICAgICAgICB2YXIgcHJpbnRDb250YWluZXJIdG1sID0gSGFuZGxlYmFycy5jb21waWxlKFxuICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoQ29uc3RhbnRzLkhBTkRMRUJBUlNfUFJJTlRfQ09OVEFJTkVSKS5odG1sKClcbiAgICAgICAgICAgICkoKTtcblxuICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLXByaW50JykuY2xpY2soZnVuY3Rpb24gcHJpbnRCdXR0b25PbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVRvU2VuZCA9IEdyaWQuZ2V0RGF0YVRvU2VuZC5hcHBseSh0aGlzKTtcblxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRHZXRSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBhamF4SGVscGVyLmdldFVybC5hcHBseSh0aGlzLCBbRGF0YWdyaWRIZWFkZXJBY3Rpb25zLkFDVElPTl9QUklOVCwgZGF0YVRvU2VuZF0pLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2s6IGZ1bmN0aW9uIHN1Y2Nlc3NDYWxsYmFjayhqc29uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0ICRwcmludENvbnRhaW5lciA9ICQocHJpbnRDb250YWluZXJIdG1sKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25SZXNwb25zZS5jc3JmVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbiA9IGpzb25SZXNwb25zZS5jc3JmVG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICRwcmludENvbnRhaW5lci5maW5kKCd0aGVhZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmh0bWwoRGF0YWdyaWRIZWFkZXJBY3Rpb25zLmdldFByaW50VGFibGVIZWFkZXIuYXBwbHkodGhpcykpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAkcHJpbnRDb250YWluZXIuZmluZCgndGJvZHknKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKHRoaXMuZ2V0VGFibGVCb2R5RnJvbVJlc3BvbnNlKGpzb25SZXNwb25zZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNsb3Nlc3QoJyN0YWJsZS1jb250YWluZXInKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcmludFRoaXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRQcmludFRhYmxlSGVhZGVyOiBmdW5jdGlvbiBnZXRQcmludFRhYmxlSGVhZGVyKCkge1xuICAgICAgICAgICAgdmFyIGhlYWRlckNvbHVtbnMgPSBbXTtcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLnZpc2libGVDb2x1bW5zLCBmdW5jdGlvbiBlYWNoVmlzaWJsZUNvbHVtbnMoY29sdW1uTmFtZSkge1xuICAgICAgICAgICAgICAgIGhlYWRlckNvbHVtbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGNvbHVtbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlBczogdGhpcy5pbmRleGVkQ29sdW1uc1tjb2x1bW5OYW1lXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgcmV0dXJuIEhhbmRsZWJhcnMuY29tcGlsZShcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKENvbnN0YW50cy5IQU5ETEVCQVJTX1BSSU5UX0hFQURFUikuaHRtbCgpXG4gICAgICAgICAgICApKHtcbiAgICAgICAgICAgICAgICBoZWFkZXJDb2x1bW5zOiBoZWFkZXJDb2x1bW5zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5EYXRhZ3JpZEhlYWRlckFjdGlvbnMuQUNUSU9OX1BSSU5UID0gJ3ByaW50JztcblxuZXhwb3J0cy5EYXRhZ3JpZEhlYWRlckFjdGlvbnMgPSBEYXRhZ3JpZEhlYWRlckFjdGlvbnM7XG4iLCJ2YXIgJCA9IGpRdWVyeSxcbiAgICBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKS5Db25zdGFudHMsXG4gICAgRGF0YWdyaWRQYWdpbmcgPSBPYmplY3QuY3JlYXRlKHtcbiAgICAgICAgZ2V0TWF4UGFnaW5nOiBmdW5jdGlvbiBnZXRNYXhQYWdpbmcoKSB7XG4gICAgICAgICAgICB2YXIgdG90YWxfcmVzdWx0cyA9IHBhcnNlSW50KHRoaXMuJGdjLmZpbmQoJy5jdXJyZW50LXRvdGFsLXJlc3VsdHMnKS5odG1sKCksIDEwKSxcbiAgICAgICAgICAgICAgICBwZXJfcGFnZSA9IHBhcnNlSW50KHRoaXMuJGdjLmZpbmQoJy4nICsgQ29uc3RhbnRzLkNMQVNTX1BFUl9QQUdFKS52YWwoKSwgMTApLFxuICAgICAgICAgICAgICAgIG1heF9wYWdpbmcgPSB0b3RhbF9yZXN1bHRzID09PSAwID8gMSA6IE1hdGguY2VpbCh0b3RhbF9yZXN1bHRzIC8gcGVyX3BhZ2UpO1xuXG4gICAgICAgICAgICByZXR1cm4gbWF4X3BhZ2luZztcbiAgICAgICAgfSxcbiAgICAgICAgcGFnaW5nQ2FsY3VsYXRpb25zOiBmdW5jdGlvbiBwYWdpbmdDYWxjdWxhdGlvbnMoKSB7XG4gICAgICAgICAgICB2YXIgcGFnZV9udW1iZXJfdmFsdWUgPSBwYXJzZUludCh0aGlzLiRnYy5maW5kKCcucGFnZS1udW1iZXItaGlkZGVuJykudmFsKCksIDEwKSxcbiAgICAgICAgICAgICAgICBtYXhfcGFnaW5nID0gRGF0YWdyaWRQYWdpbmcuZ2V0TWF4UGFnaW5nLmFwcGx5KHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAocGFnZV9udW1iZXJfdmFsdWUgPD0gMCkge1xuICAgICAgICAgICAgICAgIHBhZ2VfbnVtYmVyX3ZhbHVlID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcucGFnZS1udW1iZXItaGlkZGVuJykudmFsKCcxJyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZChDb25zdGFudHMuU0VMRUNUT1JfUEFHRV9OVU1CRVJfSU5QVVQpLnZhbCgnMScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFnZV9udW1iZXJfdmFsdWUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcucGFnaW5nLWZpcnN0JykuYWRkQ2xhc3MoQ29uc3RhbnRzLkNMQVNTX0RJU0FCTEVEKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcucGFnaW5nLXByZXZpb3VzJykuYWRkQ2xhc3MoQ29uc3RhbnRzLkNMQVNTX0RJU0FCTEVEKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLnBhZ2luZy1maXJzdCcpLnJlbW92ZUNsYXNzKENvbnN0YW50cy5DTEFTU19ESVNBQkxFRCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLnBhZ2luZy1wcmV2aW91cycpLnJlbW92ZUNsYXNzKENvbnN0YW50cy5DTEFTU19ESVNBQkxFRCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYWdlX251bWJlcl92YWx1ZSArIDEgPiBtYXhfcGFnaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLnBhZ2luZy1sYXN0JykuYWRkQ2xhc3MoQ29uc3RhbnRzLkNMQVNTX0RJU0FCTEVEKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcucGFnaW5nLW5leHQnKS5hZGRDbGFzcyhDb25zdGFudHMuQ0xBU1NfRElTQUJMRUQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcucGFnaW5nLWxhc3QnKS5yZW1vdmVDbGFzcyhDb25zdGFudHMuQ0xBU1NfRElTQUJMRUQpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5wYWdpbmctbmV4dCcpLnJlbW92ZUNsYXNzKENvbnN0YW50cy5DTEFTU19ESVNBQkxFRCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX1BBR0VfTlVNQkVSX0lOUFVUKS52YWwocGFnZV9udW1iZXJfdmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAocGFnZV9udW1iZXJfdmFsdWUgPiBtYXhfcGFnaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLnBhZ2UtbnVtYmVyLWhpZGRlbicpLnZhbChtYXhfcGFnaW5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9QQUdFX05VTUJFUl9JTlBVVCkudmFsKG1heF9wYWdpbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9KTtcblxuZXhwb3J0cy5EYXRhZ3JpZFBhZ2luZyA9IERhdGFncmlkUGFnaW5nO1xuIiwidmFyICQgPSBqUXVlcnksXG4gICAgR3JpZCA9IHJlcXVpcmUoJy4vZGF0YWdyaWQuZ3JpZC5qcycpLkdyaWQsXG4gICAgRGF0YWdyaWRDb2x1bW5zID0gcmVxdWlyZSgnLi9kYXRhZ3JpZC5jb2x1bW5zJykuRGF0YWdyaWRDb2x1bW5zLFxuICAgIERhdGFncmlkU2VhcmNoID0gT2JqZWN0LmNyZWF0ZSh7XG4gICAgICAgIGxpc3RlbmVyU2VhcmNoQnV0dG9uOiBmdW5jdGlvbiBsaXN0ZW5lclNlYXJjaEJ1dHRvbigpIHtcbiAgICAgICAgICAgIHZhciBkYXRhZ3JpZF9vYmplY3QgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5kYXRhZ3JpZFNlYXJjaEFsbElucHV0KSB7XG4gICAgICAgICAgICAgICAgRGF0YWdyaWRTZWFyY2guc2VhcmNoQWxsQnV0dG9uLmFwcGx5KHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZmlsdGVyLWJ1dHRvbicpLmNsaWNrKGZ1bmN0aW9uIHNlYXJjaEJ1dHRvbk9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLWZpbHRlcmluZy1tb2RhbCcpLmdjX21vZGFsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tkcm9wOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtcmVtb3ZlLWZpbHRlci1idXR0b24nKS5jbGljayhmdW5jdGlvbiByZW1vdmVGaWx0ZXJzQnV0dG9uT25DbGljayhldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtaGlkZGVuLXNlYXJjaC1pbnB1dHMnKS5odG1sKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgRGF0YWdyaWRDb2x1bW5zLnRyaWdnZXJDb2x1bW5zUmVuZGVyLmFwcGx5KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBHcmlkLnNlYXJjaEFuZE9yZGVyaW5nVHJpZ2dlci5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLXJlbW92ZS1maWx0ZXItY29udGFpbmVyJykuYWRkQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZmlsdGVyLWJ1dHRvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ2J0bi1zdWNjZXNzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnYnRuLW91dGxpbmUtZGFyaycpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZmlsdGVyLXRleHQnKS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1maWx0ZXItY291bnRlcicpLmFkZENsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuc2VhcmNoLWJ1dHRvbj5pbnB1dC5nYy1zZWFyY2gtaW5wdXQnKS5jaGFuZ2UoZnVuY3Rpb24gc2VhcmNoSW5wdXRPbkNoYW5nZSgpIHtcbiAgICAgICAgICAgICAgICBkYXRhZ3JpZF9vYmplY3QuJGdjLmZpbmQoJy5zZWFyY2gtYnV0dG9uIC5jbGVhci1hbGwtc2VhcmNoJykucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoJCh0aGlzKS52YWwoKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5hZnRlcignPGkgY2xhc3M9XCJmYSBmYS10aW1lcyBjbGVhci1hbGwtc2VhcmNoXCI+PC9pPicpO1xuXG4gICAgICAgICAgICAgICAgICAgIGRhdGFncmlkX29iamVjdC4kZ2MuZmluZCgnLnNlYXJjaC1idXR0b24gLmNsZWFyLWFsbC1zZWFyY2gnKS5jbGljayhmdW5jdGlvbiBzZWFyY2hDbGVhckFsbE9uQ2xpY2soKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhZ3JpZF9vYmplY3QuJGdjLmZpbmQoJy5zZWFyY2gtYnV0dG9uPmlucHV0LmdjLXNlYXJjaC1pbnB1dCcpLnZhbCgnJykudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRhdGFncmlkX29iamVjdC4kZ2MuZmluZCgnLnBhZ2UtbnVtYmVyLWhpZGRlbicpLnZhbCgnMScpO1xuICAgICAgICAgICAgICAgIGRhdGFncmlkX29iamVjdC4kZ2MuZmluZCgnLmdjLXNlYXJjaGFibGUtaW5wdXQnKS52YWwoJycpO1xuICAgICAgICAgICAgICAgIEdyaWQuc2VhcmNoQW5kT3JkZXJpbmdUcmlnZ2VyLmFwcGx5KGRhdGFncmlkX29iamVjdCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLnNlYXJjaC1idXR0b24+aW5wdXQuZ2Mtc2VhcmNoLWlucHV0JykuYmx1cihmdW5jdGlvbiBzZWFyY2hJbnB1dE9uQmx1cigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VhcmNoX2J1dHRvbiA9ICQodGhpcykuY2xvc2VzdCgnLnNlYXJjaC1idXR0b24nKTtcblxuICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLnZhbCgpID09PSAnJyAmJiBzZWFyY2hfYnV0dG9uLmhhc0NsYXNzKCdzZWFyY2gtYnV0dG9uLWJpZycpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vTWFrZSBzdXJlIHRoYXQgd2UgYXJlIGJsdXIgOilcbiAgICAgICAgICAgICAgICAgICAgZGF0YWdyaWRfb2JqZWN0LiRnYy5maW5kKCcuc2VhcmNoLWJ1dHRvbiAuY2xlYXItYWxsLXNlYXJjaCcpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKCdnYy1zZWFyY2gtaW5wdXQtYmlnJyk7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaF9idXR0b24ucmVtb3ZlQ2xhc3MoJ3NlYXJjaC1idXR0b24tYmlnJyk7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaF9idXR0b24ucmVtb3ZlQ2xhc3MoJ2J0bi1kZWZhdWx0JykuYWRkQ2xhc3MoJ2J0bi1wcmltYXJ5Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNlYXJjaEFsbEJ1dHRvbjogZnVuY3Rpb24gc2VhcmNoQWxsQnV0dG9uKCkge1xuICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLnNlYXJjaC1idXR0b24nKS5jbGljayhmdW5jdGlvbiBzZWFyY2hCdXR0b25PbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0ICRzZWFyY2hfYnV0dG9uID0gJCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICAkc2VhcmNoX2J1dHRvbi5yZW1vdmVDbGFzcygnYnRuLXByaW1hcnknKS5hZGRDbGFzcygnYnRuLWRlZmF1bHQnKTtcbiAgICAgICAgICAgICAgICAkc2VhcmNoX2J1dHRvbi5maW5kKCdpbnB1dC5nYy1zZWFyY2gtaW5wdXQnKS5hZGRDbGFzcygnZ2Mtc2VhcmNoLWlucHV0LWJpZycpO1xuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0Q2FsbGJhY2soKSB7XG4gICAgICAgICAgICAgICAgICAgICRzZWFyY2hfYnV0dG9uLmZpbmQoJ2lucHV0LmdjLXNlYXJjaC1pbnB1dCcpLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfSwgNDAwKTtcblxuICAgICAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ3NlYXJjaC1idXR0b24tYmlnJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5leHBvcnRzLkRhdGFncmlkU2VhcmNoID0gRGF0YWdyaWRTZWFyY2g7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKSxcbiAgICBpMThuID0gT2JqZWN0LmNyZWF0ZSh7XG4gICAgICAgIHRyYW5zbGF0aW9uczoge30sXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIGluaXRJMThuKGkxOG5WYXJpYWJsZXMpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNsYXRpb25zID0gaTE4blZhcmlhYmxlcztcbiAgICAgICAgfSxcbiAgICAgICAgdDogZnVuY3Rpb24gdCh0cmFuc2xhdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNsYXRpb25zW3RyYW5zbGF0aW9uXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0aW9uc1t0cmFuc2xhdGlvbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24gZm9ybWF0KHN0clJhdywgYXJncykge1xuICAgICAgICAgICAgdmFyIHN0ciA9IHN0clJhdztcbiAgICAgICAgICAgIGlmICghYXJncyAmJiAhYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXy5lYWNoKGFyZ3MsIGZ1bmN0aW9uIGVhY2hBcmdzKGFyZywgYXJnTmFtZSkge1xuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKFJlZ0V4cCgnXFxcXHsnICsgYXJnTmFtZSArICdcXFxcfScsICdnaScpLCBhcmcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgfSk7XG5cbmV4cG9ydHMuaTE4biA9IGkxOG47XG4iLCJ2YXIgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuQ29uc3RhbnRzLFxuICAgIGhhc2hlciA9IHJlcXVpcmUoJ2hhc2hlcicpLFxuICAgIE9wZXJhdGlvbnNDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpLk9wZXJhdGlvbnNDb21tb24sXG4gICAgT3BlcmF0aW9uQWRkID0gT2JqZWN0LmNyZWF0ZSh7XG4gICAgICAgIGFjdGlvbkFkZDogZnVuY3Rpb24gZXZlbnRBZGQoKSB7XG4gICAgICAgICAgICBPcGVyYXRpb25zQ29tbW9uLm9wZXJhdGlvbkRpc3BhdGNoLmFwcGx5KHRoaXMsIFt7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBDb25zdGFudHMuQUNUSU9OX0FERF9GT1JNLFxuICAgICAgICAgICAgICAgIGZpZWxkc0xpc3ROYW1lOiAnaW5zZXJ0RmllbGRzJyxcbiAgICAgICAgICAgICAgICBmaWVsZExpc3Q6ICdhZGRGaWVsZHMnLFxuICAgICAgICAgICAgICAgIHJlYWRPbmx5RmllbGRzOiAncmVhZE9ubHlBZGRGaWVsZHMnLFxuICAgICAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrQWZ0ZXJSZW5kZXI6IE9wZXJhdGlvbkFkZC5jYWxsYmFja0FmdGVyTW9kYWwuYmluZCh0aGlzKVxuICAgICAgICAgICAgfV0pO1xuICAgICAgICB9LFxuICAgICAgICBjYWxsYmFja0FmdGVyTW9kYWw6IGZ1bmN0aW9uIGNhbGxiYWNrQWZ0ZXJNb2RhbCgpIHtcbiAgICAgICAgICAgIHRoaXMuJGdjXG4gICAgICAgICAgICAgICAgLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX01PREFMX0ZPUk0pXG4gICAgICAgICAgICAgICAgLmZpbmQoJ2lucHV0LCB0ZXh0YXJlYScpXG4gICAgICAgICAgICAgICAgLmZpcnN0KClcbiAgICAgICAgICAgICAgICAuZm9jdXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuZXJBZGRCdXR0b246IGZ1bmN0aW9uIGxpc3RlbmVyQWRkQnV0dG9uKCkge1xuXG4gICAgICAgICAgICBPcGVyYXRpb25zQ29tbW9uLmhpZGVNb2RhbE9uQ2xvc2UuYXBwbHkodGhpcywgW0NvbnN0YW50cy5TRUxFQ1RPUl9NT0RBTF9GT1JNXSk7XG4gICAgICAgICAgICAvLyBHQy0xNzQ6IFVnbHkgd29ya2Fyb3VuZCB0byBhbHNvIGhhdmUgYW4gZXZlbnQgdG8gYWRkIGFuIGVtcHR5IGhhc2ggb24gZXJyb3IgY2xvc2VcbiAgICAgICAgICAgIE9wZXJhdGlvbnNDb21tb24uaGlkZU1vZGFsT25DbG9zZS5hcHBseSh0aGlzLCBbJy5nYy1lcnJvci1tb2RhbCddKTtcblxuICAgICAgICAgICAgdGhpcy4kZ2MuZmluZChDb25zdGFudHMuU0VMRUNUT1JfQlVUVE9OX0FERCkuY2xpY2soZnVuY3Rpb24gYWRkQnV0dG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuaGFzaEV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBoYXNoZXIuc2V0SGFzaCh0aGlzLmhhc2hFdmVudC5hZGRJdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPcGVyYXRpb25BZGQuYWN0aW9uQWRkLmFwcGx5KHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbmV4cG9ydHMuT3BlcmF0aW9uQWRkID0gT3BlcmF0aW9uQWRkO1xuIiwibGV0IENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpLkNvbnN0YW50cyxcbiAgICBoYXNoZXIgPSByZXF1aXJlKCdoYXNoZXInKSxcbiAgICBPcGVyYXRpb25zQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKS5PcGVyYXRpb25zQ29tbW9uLFxuICAgIE9wZXJhdGlvbkNsb25lID0gT2JqZWN0LmNyZWF0ZSh7XG4gICAgICAgIGFjdGlvbkNsb25lOiBmdW5jdGlvbiBldmVudEVkaXQocHJpbWFyeUtleVZhbHVlKSB7XG5cbiAgICAgICAgICAgIE9wZXJhdGlvbnNDb21tb24ub3BlcmF0aW9uRGlzcGF0Y2guYXBwbHkodGhpcywgW3tcbiAgICAgICAgICAgICAgICBhY3Rpb246IENvbnN0YW50cy5BQ1RJT05fQ0xPTkVfRk9STSxcbiAgICAgICAgICAgICAgICBmaWVsZHNMaXN0TmFtZTogJ2Nsb25lRmllbGRzJyxcbiAgICAgICAgICAgICAgICBmaWVsZExpc3Q6ICdjbG9uZUZpZWxkcycsXG4gICAgICAgICAgICAgICAgZmllbGRUeXBlczogJ2ZpZWxkVHlwZXNDbG9uZUZvcm0nLFxuICAgICAgICAgICAgICAgIHJlYWRPbmx5RmllbGRzOiAncmVhZE9ubHlDbG9uZUZpZWxkcycsXG4gICAgICAgICAgICAgICAgcHJpbWFyeUtleVZhbHVlOiBwcmltYXJ5S2V5VmFsdWVcbiAgICAgICAgICAgIH1dKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DbG9uZUNsaWNrOiBmdW5jdGlvbiBvbkNsb25lQ2xpY2socHJpbWFyeUtleVZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5oYXNoRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgaGFzaGVyLnNldEhhc2godGhpcy5oYXNoRXZlbnQuY2xvbmVJdGVtICsgJy8nICsgcHJpbWFyeUtleVZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgT3BlcmF0aW9uQ2xvbmUuYWN0aW9uQ2xvbmUuYXBwbHkodGhpcywgW3ByaW1hcnlLZXlWYWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbmV4cG9ydHMuT3BlcmF0aW9uQ2xvbmUgPSBPcGVyYXRpb25DbG9uZTtcbiIsImltcG9ydCBGaWVsZExpc3QgZnJvbSAnLi4vLi4vLi4vLi4vLi4vUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9maWVsZC1saXN0LmpzeCc7XG5pbXBvcnQgTW9kYWxUaXRsZSBmcm9tICcuLi8uLi8uLi8uLi8uLi9SZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL21vZGFsL3RpdGxlLmpzeCc7XG5pbXBvcnQgRmllbGRJbnB1dCBmcm9tICcuLi8uLi8uLi8uLi8uLi9SZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL2ZpZWxkLWlucHV0LmpzeCc7XG5cbmltcG9ydCB7IGNyZWF0ZVN0b3JlIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHJlZHVjZXIgZnJvbSAnLi9yZWR1Y2VyLmpzJztcbmltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG52YXJcbiAgICAkID0galF1ZXJ5LFxuICAgIGFqYXhIZWxwZXIgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL2FqYXgtaGVscGVyJykuYWpheEhlbHBlcixcbiAgICBHcmlkID0gcmVxdWlyZSgnLi8uLi9kYXRhZ3JpZC9kYXRhZ3JpZC5ncmlkLmpzJykuR3JpZCxcbiAgICBpMThuID0gcmVxdWlyZSgnLi8uLi9pMThuJykuaTE4bixcbiAgICBoYXNoZXIgPSByZXF1aXJlKCdoYXNoZXInKSxcbiAgICBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKS5Db25zdGFudHMsXG4gICAgT3BlcmF0aW9uc0NvbW1vbiA9IE9iamVjdC5jcmVhdGUoe1xuICAgICAgICBnZXRGb3JtRG9tQ29udGFpbmVyOiBmdW5jdGlvbiBnZXRGb3JtRG9tQ29udGFpbmVyKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGZvcm1Eb21Db250YWluZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGZvcm1Eb21Db250YWluZXIgPSB0aGlzLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX01PREFMX0ZPUk0pLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX01PREFMX0JPRFkpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGZvcm1Eb21Db250YWluZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE1vZGFsVGl0bGVEb206IGZ1bmN0aW9uIGdldE1vZGFsVGl0bGVEb20oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kbW9kYWxUaXRsZURvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kbW9kYWxUaXRsZURvbSA9IHRoaXMuZmluZChDb25zdGFudHMuU0VMRUNUT1JfTU9EQUxfRk9STSkuZmluZCgnLm1vZGFsLWhlYWRlcicpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG1vZGFsVGl0bGVEb207XG4gICAgICAgIH0sXG4gICAgICAgIG9wZXJhdGlvbkRpc3BhdGNoOiBmdW5jdGlvbiBvcGVyYXRpb25EaXNwYXRjaChvcHRpb25zUmF3KSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogQ29uc3RhbnRzLkFDVElPTl9BRERfRk9STSxcbiAgICAgICAgICAgICAgICBmaWVsZHNMaXN0TmFtZTogJ2luc2VydEZpZWxkcycsXG4gICAgICAgICAgICAgICAgZmllbGRMaXN0OiAnYWRkRmllbGRzJyxcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGVzOiAnZmllbGRUeXBlc0FkZEZvcm0nLFxuICAgICAgICAgICAgICAgIHByaW1hcnlLZXlWYWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjYWNoZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVhZE9ubHlGaWVsZHM6IG51bGwsXG4gICAgICAgICAgICAgICAgaXNSZWFkT25seTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tBZnRlclJlbmRlcjogZnVuY3Rpb24gY2FsbGJhY2tBZnRlclJlbmRlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG9wdGlvbnNSYXcpO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYWNoZSAmJiB0aGlzW29wdGlvbnMuZmllbGRzTGlzdE5hbWVdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBPcGVyYXRpb25zQ29tbW9uLnNob3dNb2RhbC5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBPcGVyYXRpb25zQ29tbW9uLmNvbGxlY3REYXRhQW5kRGlzcGF0Y2guYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGxheUFzOiBmdW5jdGlvbihmaWVsZE5hbWUsIGZpZWxkTGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIF8uZmluZChmaWVsZExpc3QsIChjb2x1bW4pID0+IChjb2x1bW4ubmFtZSA9PT0gZmllbGROYW1lKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbGxlY3REYXRhQW5kRGlzcGF0Y2g6IGZ1bmN0aW9uIGNvbGxlY3REYXRhKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBkYXRhVG9TZW5kID0ge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogb3B0aW9ucy5hY3Rpb25cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnByaW1hcnlLZXlWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGFUb1NlbmQucGtfdmFsdWUgPSBvcHRpb25zLnByaW1hcnlLZXlWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZW5kR2V0UmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLiRnYy5kYXRhKCd1cmwnKSxcbiAgICAgICAgICAgICAgICBkYXRhVG9TZW5kOiBkYXRhVG9TZW5kLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjazogZnVuY3Rpb24gc3VjY2Vzc0NhbGxiYWNrKGpzb25SZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZExpc3QgPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhW29wdGlvbnMuZmllbGRMaXN0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5RmllbGRMaXN0ID0gb3B0aW9ucy5yZWFkT25seUZpZWxkcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmNhY2hlZEluaXRpYWxEYXRhW29wdGlvbnMucmVhZE9ubHlGaWVsZHNdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbb3B0aW9ucy5maWVsZHNMaXN0TmFtZV0gPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvblJlc3BvbnNlLmNzcmZUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5jc3JmVG9rZW4gPSBqc29uUmVzcG9uc2UuY3NyZlRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGZpZWxkTGlzdCwgZnVuY3Rpb24ganNvblJlc3BvbnNlRm9yRWFjaChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGROYW1lID0gZmllbGQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFR5cGUgPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhW29wdGlvbnMuZmllbGRUeXBlc11bZmllbGROYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGZpbmQgZmllbGQgbmFtZTogXCInICsgZmllbGROYW1lICsgJ1wiIGluIGZpZWxkVHlwZXMuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhpcyBpcyB1c3VhbGx5IGFuIGVycm9yIHRoYXQgeW91IHdpbGwgc2VlIHdoZW4geW91XFwndmUgYWRkZWQgYSBmaWVsZCBuYW1lIHRoYXQgZG9lc25cXCd0IGV4aXN0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaW4gdGhlIGRhdGFiYXNlLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW29wdGlvbnMuZmllbGRzTGlzdE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlBczogT3BlcmF0aW9uc0NvbW1vbi5kaXNwbGF5QXMuYXBwbHkodGhpcywgW2ZpZWxkTmFtZSwgZmllbGRMaXN0XSkuZGlzcGxheUFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkVmFsdWU6IGpzb25SZXNwb25zZS5kYXRhW2ZpZWxkTmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRUeXBlOiB0aGlzLmNhY2hlZEluaXRpYWxEYXRhW29wdGlvbnMuZmllbGRUeXBlc11bZmllbGROYW1lXS5kYXRhVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFZhbHVlczogdGhpcy5jYWNoZWRJbml0aWFsRGF0YVtvcHRpb25zLmZpZWxkVHlwZXNdW2ZpZWxkTmFtZV0ucGVybWl0dGVkVmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdGhpcy5jYWNoZWRJbml0aWFsRGF0YVtvcHRpb25zLmZpZWxkVHlwZXNdW2ZpZWxkTmFtZV0uZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dEZWZhdWx0VmFsdWU6IChvcHRpb25zLmFjdGlvbiA9PT0gJ2FkZC1mb3JtJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOdWxsYWJsZTogdGhpcy5jYWNoZWRJbml0aWFsRGF0YVtvcHRpb25zLmZpZWxkVHlwZXNdW2ZpZWxkTmFtZV0uaXNOdWxsYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JlcXVpcmVkOiB0aGlzLmNhY2hlZEluaXRpYWxEYXRhW29wdGlvbnMuZmllbGRUeXBlc11bZmllbGROYW1lXS5pc1JlcXVpcmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVhZE9ubHk6IHJlYWRPbmx5RmllbGRMaXN0W2ZpZWxkTmFtZV0gfHwgb3B0aW9ucy5pc1JlYWRPbmx5IHx8IHRoaXMuY2FjaGVkSW5pdGlhbERhdGFbb3B0aW9ucy5maWVsZFR5cGVzXVtmaWVsZE5hbWVdLmlzUmVhZE9ubHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogKHRoaXMuY2FjaGVkSW5pdGlhbERhdGFbb3B0aW9ucy5maWVsZFR5cGVzXVtmaWVsZE5hbWVdLm9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5jYWNoZWRJbml0aWFsRGF0YVtvcHRpb25zLmZpZWxkVHlwZXNdW2ZpZWxkTmFtZV0ub3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LiBiaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgICAgICAgICBPcGVyYXRpb25zQ29tbW9uLnNob3dNb2RhbC5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNob3dNb2RhbDogZnVuY3Rpb24gc2hvd01vZGFsKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuJGdjXG4gICAgICAgICAgICAgICAgLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX01PREFMX0ZPUk0pXG4gICAgICAgICAgICAgICAgLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX0ZPUk0pLmRhdGEoJ2FjdGlvbicsIG9wdGlvbnMuYWN0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy4kZ2NcbiAgICAgICAgICAgICAgICAuZmluZChDb25zdGFudHMuU0VMRUNUT1JfTU9EQUxfRk9STSlcbiAgICAgICAgICAgICAgICAuZmluZChDb25zdGFudHMuU0VMRUNUT1JfRk9STSlcbiAgICAgICAgICAgICAgICAuZGF0YSgncHJpbWFyeS1rZXktdmFsdWUnLCBvcHRpb25zLnByaW1hcnlLZXlWYWx1ZSAhPT0gbnVsbCA/IG9wdGlvbnMucHJpbWFyeUtleVZhbHVlIDogJycpO1xuXG4gICAgICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBvcHRpb25zLmFjdGlvbixcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHRoaXNbb3B0aW9ucy5maWVsZHNMaXN0TmFtZV1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9NT0RBTF9GT1JNKS5nY19tb2RhbCh7XG4gICAgICAgICAgICAgICAgYmFja2Ryb3A6IGZhbHNlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWN0aW9uID09PSAncmVhZC1mb3JtJykge1xuICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5vcHRpb25zLW9uLXNhdmUnKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLnNhdmUtY2hhbmdlcycpLmhpZGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLm9wdGlvbnMtb24tc2F2ZScpLnNob3coKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuc2F2ZS1jaGFuZ2VzJykuc2hvdygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrQWZ0ZXJSZW5kZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VGl0bGU6IGZ1bmN0aW9uIGdldFRpdGxlKHRpdGxlVHlwZSkge1xuICAgICAgICAgICAgY29uc3Qgc3ViamVjdFNpbmdsZSA9IHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuc3ViamVjdC5zdWJqZWN0X3NpbmdsZTtcblxuICAgICAgICAgICAgc3dpdGNoICh0aXRsZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIENvbnN0YW50cy5BQ1RJT05fQUREX0ZPUk06XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpMThuLmZvcm1hdChpMThuLnQoJ2FkZF9pdGVtJyksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3Q6IHN1YmplY3RTaW5nbGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FzZSBDb25zdGFudHMuQUNUSU9OX0VESVRfRk9STTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkxOG4uZm9ybWF0KGkxOG4udCgnZWRpdF9pdGVtJyksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3Q6IHN1YmplY3RTaW5nbGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjYXNlIENvbnN0YW50cy5BQ1RJT05fUkVBRF9GT1JNOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTE4bi5mb3JtYXQoaTE4bi50KCd2aWV3X2l0ZW0nKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdDogc3ViamVjdFNpbmdsZVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzLkFDVElPTl9DTE9ORV9GT1JNOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTE4bi5mb3JtYXQoaTE4bi50KCdhZGRfaXRlbScpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0OiBzdWJqZWN0U2luZ2xlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpdGxlVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW5pdFJlZHV4U3RvcmU6IGZ1bmN0aW9uIGluaXRSZWR1eFN0b3JlKCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yZSA9IGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fKCkpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWVsZExpc3QgPSBmdW5jdGlvbiByZW5kZXJGaWVsZExpc3QoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IE9wZXJhdGlvbnNDb21tb24uZ2V0VGl0bGUuYXBwbHkodGhpcywgW2N1cnJlbnRTdGF0ZS50eXBlXSksXG4gICAgICAgICAgICAgICAgICAgIHsgRmllbGRSb3dXcmFwcGVyLCBNb2RhbFRpdGxlV3JhcHBlciB9ID0gdGhpcy5jb21wb25lbnRzO1xuXG4gICAgICAgICAgICAgICAgUmVhY3RET00ucmVuZGVyKFxuICAgICAgICAgICAgICAgICAgICA8TW9kYWxUaXRsZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e3RpdGxlfVxuICAgICAgICAgICAgICAgICAgICAgICAgTW9kYWxUaXRsZVdyYXBwZXI9e01vZGFsVGl0bGVXcmFwcGVyfVxuICAgICAgICAgICAgICAgICAgICAvPiwgT3BlcmF0aW9uc0NvbW1vbi5nZXRNb2RhbFRpdGxlRG9tLmFwcGx5KHRoaXMpKTtcbiAgICAgICAgICAgICAgICBSZWFjdERPTS5yZW5kZXIoXG4gICAgICAgICAgICAgICAgICAgIDxGaWVsZExpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkcz17Y3VycmVudFN0YXRlLmZpZWxkc31cbiAgICAgICAgICAgICAgICAgICAgICAgIGdjcnVkSW5zdGFuY2U9e3RoaXN9XG4gICAgICAgICAgICAgICAgICAgICAgICBGaWVsZElucHV0Q29tcG9uZW50PXtGaWVsZElucHV0fVxuICAgICAgICAgICAgICAgICAgICAgICAgRmllbGRSb3dXcmFwcGVyPXtGaWVsZFJvd1dyYXBwZXJ9XG4gICAgICAgICAgICAgICAgICAgIC8+LCBPcGVyYXRpb25zQ29tbW9uLmdldEZvcm1Eb21Db250YWluZXIuYXBwbHkodGhpcykpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zdG9yZS5zdWJzY3JpYmUodGhpcy5yZW5kZXJGaWVsZExpc3QpO1xuICAgICAgICB9LFxuICAgICAgICBoaWRlTW9kYWxPbkNsb3NlOiBmdW5jdGlvbiBoaWRlTW9kYWxPbkNsb3NlKHNlbGVjdG9yU3RyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKHNlbGVjdG9yU3RyaW5nKVxuICAgICAgICAgICAgICAgIC5vbignaGlkZGVuLmJzLm1vZGFsJywgZnVuY3Rpb24gb25Nb2RhbEhpZGVPbkNsb3NlKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5oYXNoRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoZXIuc2V0SGFzaCgnIScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuZXJTdWJtaXRGb3JtOiBmdW5jdGlvbiBsaXN0ZW5lckluc2VydEZvcm0oKSB7XG4gICAgICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgICAgIC5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9NT0RBTF9GT1JNKVxuICAgICAgICAgICAgICAgIC5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9GT1JNKVxuICAgICAgICAgICAgICAgIC5zdWJtaXQoZnVuY3Rpb24gU3VibWl0QWRkRm9ybShldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YVRvU2VuZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEFjdGlvbiA9ICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YSgnYWN0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgICAgICBkYXRhVG9TZW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhamF4SGVscGVyLmdldFBvc3REYXRhRnJvbUZvcm0uYXBwbHkodGhpcywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9NT0RBTF9GT1JNKS5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9GT1JNKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBY3Rpb24gPT09IENvbnN0YW50cy5BQ1RJT05fQUREX0ZPUk0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUb1NlbmQuYWN0aW9uID0gQ29uc3RhbnRzLkFDVElPTl9JTlNFUlQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEFjdGlvbiA9PT0gQ29uc3RhbnRzLkFDVElPTl9FRElUX0ZPUk0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUb1NlbmQuYWN0aW9uID0gQ29uc3RhbnRzLkFDVElPTl9VUERBVEU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVG9TZW5kLnBrX3ZhbHVlID0gJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKCdwcmltYXJ5LWtleS12YWx1ZScpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRBY3Rpb24gPT09IENvbnN0YW50cy5BQ1RJT05fQ0xPTkVfRk9STSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRvU2VuZC5hY3Rpb24gPSBDb25zdGFudHMuQUNUSU9OX0NMT05FO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVG9TZW5kW3RoaXMuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuLmlucHV0TmFtZV0gPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbi5pbnB1dFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kUG9zdFJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLiRnYy5kYXRhKCd1cmwnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUb1NlbmQ6IGRhdGFUb1NlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2s6IGZ1bmN0aW9uIHN1Y2Nlc3NDYWxsYmFjayhqc29uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcm93VG9IaWdobGlnaHQsIGVycm9ycztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uUmVzcG9uc2UuY3NyZlRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuID0ganNvblJlc3BvbnNlLmNzcmZUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvblJlc3BvbnNlLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd1RvSGlnaGxpZ2h0ID0gZGF0YVRvU2VuZC5hY3Rpb24gPT09IENvbnN0YW50cy5BQ1RJT05fSU5TRVJUXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGpzb25SZXNwb25zZS5pbnNlcnRJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkYXRhVG9TZW5kLnBrX3ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4kZ2MuZmluZCgnLmNsb3NlLW1vZGFsLW9uLXNhdmUnKS5pcygnOmNoZWNrZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZChDb25zdGFudHMuU0VMRUNUT1JfTU9EQUxfRk9STSkuZ2NfbW9kYWwoJ2hpZGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHcmlkLnNlYXJjaEFuZE9yZGVyaW5nVHJpZ2dlci5hcHBseSh0aGlzLCBbcm93VG9IaWdobGlnaHRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpzb25SZXNwb25zZS5zdGF0dXMgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChqc29uUmVzcG9uc2UuZXJyb3JzLCBmdW5jdGlvbiBmb3JFYWNoRXJyb3JzKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBfLnVuaW9uKGVycm9ycywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZXJyb3ItbW9kYWwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoJy5nYy1lcnJvci1ib2R5JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKCctICcgKyBlcnJvcnMuam9pbignPGJyLz4tICcpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZXJyb3ItbW9kYWwnKS5nY19tb2RhbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZHJvcDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5leHBvcnRzLk9wZXJhdGlvbnNDb21tb24gPSBPcGVyYXRpb25zQ29tbW9uO1xuIiwidmFyICQgPSBqUXVlcnksXG4gICAgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKSxcbiAgICBHcmlkID0gcmVxdWlyZSgnLi8uLi9kYXRhZ3JpZC9kYXRhZ3JpZC5ncmlkLmpzJykuR3JpZCxcbiAgICBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKS5Db25zdGFudHMsXG4gICAgT3BlcmF0aW9uc0NvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJykuT3BlcmF0aW9uc0NvbW1vbixcbiAgICBoYXNoZXIgPSByZXF1aXJlKCdoYXNoZXInKSxcbiAgICBPcGVyYXRpb25EZWxldGUgPSBPYmplY3QuY3JlYXRlKHtcbiAgICAgICAgYWN0aW9uRGVsZXRlOiBmdW5jdGlvbiBhY3Rpb25EZWxldGUocHJpbWFyeUtleVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY29uZmlybWF0aW9uVGFibGU7XG4gICAgICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgICAgIC5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9ERUxFVEVfQ09ORklSTUFUSU9OX0JVVFRPTilcbiAgICAgICAgICAgICAgICAuZGF0YSgnZGVsZXRlLWlkJywgcHJpbWFyeUtleVZhbHVlKTtcblxuICAgICAgICAgICAgY29uZmlybWF0aW9uVGFibGUgPSBPcGVyYXRpb25EZWxldGUuY29uZmlybWF0aW9uVGFibGUuYXBwbHkodGhpcywgW1xuICAgICAgICAgICAgICAgIFtwcmltYXJ5S2V5VmFsdWVdXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgdGhpcy4kZ2NcbiAgICAgICAgICAgICAgICAuZmluZCgnLmRlbGV0ZS1zaW5nbGUtY29uZmlybWF0aW9uJylcbiAgICAgICAgICAgICAgICAuZmluZCgnLmNvbnRlbnQtdG8tZGVsZXRlJylcbiAgICAgICAgICAgICAgICAuaHRtbChjb25maXJtYXRpb25UYWJsZSk7XG5cbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX0RFTEVURV9GT1JNX01PREFMKS5nY19tb2RhbCgpO1xuICAgICAgICAgICAgdGhpcy4kZ2NcbiAgICAgICAgICAgICAgICAuZmluZChDb25zdGFudHMuU0VMRUNUT1JfREVMRVRFX0ZPUk1fTU9EQUwpXG4gICAgICAgICAgICAgICAgLmZpbmQoQ29uc3RhbnRzLkNBTkNFTF9CVVRUT04pLmZvY3VzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RlbmVyRGVsZXRlTXVsdGlwbGU6IGZ1bmN0aW9uIGxpc3RlbmVyRGVsZXRlTXVsdGlwbGUoKSB7XG4gICAgICAgICAgICAvL1NlbGVjdCBBbGwvTm9uZVxuICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLnNlbGVjdC1hbGwtbm9uZScpLmNsaWNrKGZ1bmN0aW9uIHNlbGVjdEFsbE5vbmVPbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCQoZXZlbnQuY3VycmVudFRhcmdldCkuaXMoJzpjaGVja2VkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLXNlbGVjdC1yb3cnKS5lYWNoKGZ1bmN0aW9uIGZvckVhY2hTZWxlY3RSb3coKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb3AoJ2NoZWNrZWQnLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbG9zZXN0KCd0cicpLmFkZENsYXNzKCd3YXJuaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLXNlbGVjdC1yb3cnKS5lYWNoKGZ1bmN0aW9uIGZvckVhY2hTZWxlY3RSb3coKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2xvc2VzdCgndHInKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnd2FybmluZycpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVTaG93RGVsZXRlQnV0dG9uKCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZGVsZXRlLXNlbGVjdGVkLWJ1dHRvbicpLmNsaWNrKGZ1bmN0aW9uIGRlbGV0ZVNlbGVjdGVkQnV0dG9uT25DbGljayhldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsZUlkcyA9IE9wZXJhdGlvbkRlbGV0ZS5nZXRNdWx0aXBsZURlbGV0ZUlkcy5hcHBseSh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9uVGFibGU7XG5cbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZGVsZXRlLWNvdW50JykuaHRtbChtdWx0aXBsZUlkcy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgY29uZmlybWF0aW9uVGFibGUgPSBPcGVyYXRpb25EZWxldGUuY29uZmlybWF0aW9uVGFibGUuYXBwbHkodGhpcywgW211bHRpcGxlSWRzXSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgICAgICAgICAuZmluZCgnLmdjLWRlbGV0ZS1tdWx0aXBsZS1jb25maXJtYXRpb24nKVxuICAgICAgICAgICAgICAgICAgICAuZmluZCgnLmNvbnRlbnQtdG8tZGVsZXRlJylcbiAgICAgICAgICAgICAgICAgICAgLmh0bWwoY29uZmlybWF0aW9uVGFibGUpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZChDb25zdGFudHMuU0VMRUNUT1JfTVVMVElQTEVfREVMRVRFX0ZPUk1fTU9EQUwpLmdjX21vZGFsKCk7XG5cbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlybWF0aW9uVGFibGU6IGZ1bmN0aW9uIGNvbmZpcm1hdGlvblRhYmxlKGRhdGFJZHMpIHtcbiAgICAgICAgICAgIHZhciAkdGFibGUgPSB0aGlzLiRnYy5maW5kKCcuZ3JvY2VyeS1jcnVkLXRhYmxlJyksXG4gICAgICAgICAgICAgICAgJGhlYWRlclRyID0gJHRhYmxlLmZpbmQoJy5oZWFkZXItY29sdW1ucycpLmNsb25lKCksXG4gICAgICAgICAgICAgICAgdGFibGVPdXRwdXQsXG4gICAgICAgICAgICAgICAgZGF0YVJvd3MgPSAnJztcblxuICAgICAgICAgICAgXy5lYWNoKGRhdGFJZHMsIGZ1bmN0aW9uIGZvcmVhY2hEYXRhSWRzKGRhdGFJZCkge1xuICAgICAgICAgICAgICAgIHZhciAkdHIgPSAkdGFibGUuZmluZCgndHJbZGF0YS1pZD1cIicgKyBkYXRhSWQgKyAnXCJdJykuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoJHRyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICR0ci5maW5kKCd0ZC5nYy1yb3ctY2hlY2tib3gnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAkdHIuZmluZCgndGQuZ2MtYWN0aW9ucycpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICR0ci5maW5kKCd0ZCcpLnJlbW92ZUNsYXNzKCk7XG4gICAgICAgICAgICAgICAgZGF0YVJvd3MgKz0gJzx0cj4nICsgJHRyLmh0bWwoKSArICc8L3RyPic7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgJGhlYWRlclRyLmZpbmQoJy5oZWFkZXItYWN0aW9ucycpLnJlbW92ZSgpO1xuICAgICAgICAgICAgJGhlYWRlclRyLmZpbmQoJ3RoPmknKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICRoZWFkZXJUci5maW5kKCd0aCcpLnJlbW92ZUNsYXNzKCk7XG5cbiAgICAgICAgICAgIHRhYmxlT3V0cHV0ID0gJzx0YWJsZSBjbGFzcz1cInRhYmxlIHRhYmxlLWJvcmRlcmVkIHRhYmxlLWhvdmVyXCI+JztcbiAgICAgICAgICAgIHRhYmxlT3V0cHV0ICs9ICc8dHI+JyArICRoZWFkZXJUci5odG1sKCkgKyAnPC90cj4nO1xuICAgICAgICAgICAgdGFibGVPdXRwdXQgKz0gZGF0YVJvd3M7XG4gICAgICAgICAgICB0YWJsZU91dHB1dCArPSAnPC90YWJsZT4nO1xuXG4gICAgICAgICAgICByZXR1cm4gdGFibGVPdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRGVsZXRlQ2xpY2s6IGZ1bmN0aW9uIG9uRGVsZXRlQ2xpY2socHJpbWFyeUtleVZhbHVlKSB7XG4gICAgICAgICAgICBPcGVyYXRpb25EZWxldGUuYWN0aW9uRGVsZXRlLmFwcGx5KHRoaXMsIFtwcmltYXJ5S2V5VmFsdWVdKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuZXJEZWxldGVTaW5nbGVNb2RhbDogZnVuY3Rpb24gbGlzdGVuZXJEZWxldGVTaW5nbGVNb2RhbCgpIHtcbiAgICAgICAgICAgIHRoaXMuJGdjXG4gICAgICAgICAgICAgICAgLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX0RFTEVURV9DT05GSVJNQVRJT05fQlVUVE9OKVxuICAgICAgICAgICAgICAgIC5jbGljayhmdW5jdGlvbiBkZWxldGVDb25maXJtYXRpb25DbGljayhldmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YVRvU2VuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXlWYWx1ZTogJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKCdkZWxldGUtaWQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogQ29uc3RhbnRzLkFDVElPTl9SRU1PVkVfT05FXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVG9TZW5kW3RoaXMuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuLmlucHV0TmFtZV0gPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbi5pbnB1dFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kUG9zdFJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLiRnYy5kYXRhKCd1cmwnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUb1NlbmQ6IGRhdGFUb1NlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2s6IGZ1bmN0aW9uIHN1Y2Nlc3NDYWxsYmFjayhqc29uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgJGZ1bGxUb3RhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvblJlc3BvbnNlLmNzcmZUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbiA9IGpzb25SZXNwb25zZS5jc3JmVG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25SZXNwb25zZS5zdGF0dXMgPT09IENvbnN0YW50cy5SRVNQT05TRS5TVUNDRVNTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRmdWxsVG90YWwgPSB0aGlzLiRnYy5maW5kKCcuZnVsbC10b3RhbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX0RFTEVURV9GT1JNX01PREFMKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdjX21vZGFsKCdoaWRlJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwgPSAocGFyc2VJbnQoJGZ1bGxUb3RhbC50ZXh0KCksIDEwKSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG90YWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZnVsbFRvdGFsLmh0bWwoJycgKyB0b3RhbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiBzZWFyY2hBbmRPcmRlcmluZ1RpbWVvdXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHcmlkLnNlYXJjaEFuZE9yZGVyaW5nVHJpZ2dlci5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAyMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RlbmVyRGVsZXRlTXVsdGlwbGVNb2RhbDogZnVuY3Rpb24gbGlzdGVuZXJEZWxldGVTaW5nbGVNb2RhbCgpIHtcbiAgICAgICAgICAgIHRoaXMuJGdjXG4gICAgICAgICAgICAgICAgLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX01VTFRJUExFX0RFTEVURV9DT05GSVJNQVRJT05fQlVUVE9OKVxuICAgICAgICAgICAgICAgIC5jbGljayhmdW5jdGlvbiBkZWxldGVNdWx0aXBsZUNvbmZpcm1hdGlvbkNsaWNrKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YVRvU2VuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5czogT3BlcmF0aW9uRGVsZXRlLmdldE11bHRpcGxlRGVsZXRlSWRzLmFwcGx5KHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogQ29uc3RhbnRzLkFDVElPTl9SRU1PVkVfTVVMVElQTEVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpZHNUb0RlbGV0ZSA9IGRhdGFUb1NlbmQucHJpbWFyeUtleXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRvU2VuZFt0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbi5pbnB1dE5hbWVdID0gdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5jc3JmVG9rZW4uaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZFBvc3RSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUb1NlbmQ6IGRhdGFUb1NlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2s6IGZ1bmN0aW9uIHN1Y2Nlc3NDYWxsYmFjayhqc29uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvblJlc3BvbnNlLmNzcmZUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbiA9IGpzb25SZXNwb25zZS5jc3JmVG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25SZXNwb25zZS5zdGF0dXMgPT09ICdzdWNjZXNzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX01VTFRJUExFX0RFTEVURV9GT1JNX01PREFMKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdjX21vZGFsKCdoaWRlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGdjXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluZCgnLmZ1bGwtdG90YWwnKS5odG1sKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KHRoaXMuJGdjLmZpbmQoJy5mdWxsLXRvdGFsJykudGV4dCgpLCAxMCkgLSBpZHNUb0RlbGV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgR3JpZC5zZWFyY2hBbmRPcmRlcmluZ1RyaWdnZXIuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TXVsdGlwbGVEZWxldGVJZHM6IGZ1bmN0aW9uIGdldE11bHRpcGxlRGVsZXRlSWRzKCkge1xuICAgICAgICAgICAgdmFyIGRlbGV0ZUlkcyA9IFtdO1xuXG4gICAgICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgICAgIC5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9ERUxFVEVfQ0hFQ0tCT1hfQ0hFQ0tFRClcbiAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbiBmb3JFYWNoR2V0TXVsdGlwbGVJZHMoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUlkcy5wdXNoKCQodGhpcykuZGF0YSgnaWQnKSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBkZWxldGVJZHM7XG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RlbmVyU2VsZWN0Um93OiBmdW5jdGlvbiBsaXN0ZW5lclNlbGVjdFJvdygpIHtcbiAgICAgICAgICAgIHZhciBkYXRhZ3JpZF9vYmplY3QgPSB0aGlzO1xuXG4gICAgICAgICAgICBkYXRhZ3JpZF9vYmplY3QuJGdjLmZpbmQoJy5nYy1zZWxlY3Qtcm93JykuY2xpY2soZnVuY3Rpb24gc2VsZWN0Um93T25DbGljaygpIHtcbiAgICAgICAgICAgICAgICBpZiAoJCh0aGlzKS5pcygnOmNoZWNrZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ3RyJykuYWRkQ2xhc3MoJ3dhcm5pbmcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ3RyJykucmVtb3ZlQ2xhc3MoJ3dhcm5pbmcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXRhZ3JpZF9vYmplY3QuaGlkZVNob3dEZWxldGVCdXR0b24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbmV4cG9ydHMuT3BlcmF0aW9uRGVsZXRlID0gT3BlcmF0aW9uRGVsZXRlO1xuIiwibGV0IENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpLkNvbnN0YW50cyxcbiAgICBoYXNoZXIgPSByZXF1aXJlKCdoYXNoZXInKSxcbiAgICBPcGVyYXRpb25zQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKS5PcGVyYXRpb25zQ29tbW9uLFxuICAgIE9wZXJhdGlvbkVkaXQgPSBPYmplY3QuY3JlYXRlKHtcbiAgICAgICAgYWN0aW9uRWRpdDogZnVuY3Rpb24gZXZlbnRFZGl0KHByaW1hcnlLZXlWYWx1ZSkge1xuXG4gICAgICAgICAgICBPcGVyYXRpb25zQ29tbW9uLm9wZXJhdGlvbkRpc3BhdGNoLmFwcGx5KHRoaXMsIFt7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBDb25zdGFudHMuQUNUSU9OX0VESVRfRk9STSxcbiAgICAgICAgICAgICAgICBmaWVsZHNMaXN0TmFtZTogJ3VwZGF0ZUZpZWxkcycsXG4gICAgICAgICAgICAgICAgZmllbGRMaXN0OiAnZWRpdEZpZWxkcycsXG4gICAgICAgICAgICAgICAgZmllbGRUeXBlczogJ2ZpZWxkVHlwZXNFZGl0Rm9ybScsXG4gICAgICAgICAgICAgICAgcmVhZE9ubHlGaWVsZHM6ICdyZWFkT25seUVkaXRGaWVsZHMnLFxuICAgICAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcmltYXJ5S2V5VmFsdWU6IHByaW1hcnlLZXlWYWx1ZVxuICAgICAgICAgICAgfV0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkVkaXRDbGljazogZnVuY3Rpb24gb25FZGl0Q2xpY2socHJpbWFyeUtleVZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5oYXNoRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgaGFzaGVyLnNldEhhc2godGhpcy5oYXNoRXZlbnQuZWRpdEl0ZW0gKyAnLycgKyBwcmltYXJ5S2V5VmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBPcGVyYXRpb25FZGl0LmFjdGlvbkVkaXQuYXBwbHkodGhpcywgW3ByaW1hcnlLZXlWYWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbmV4cG9ydHMuT3BlcmF0aW9uRWRpdCA9IE9wZXJhdGlvbkVkaXQ7XG4iLCJ2YXIgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuQ29uc3RhbnRzLFxuICAgIGhhc2hlciA9IHJlcXVpcmUoJ2hhc2hlcicpLFxuICAgIE9wZXJhdGlvbnNDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpLk9wZXJhdGlvbnNDb21tb24sXG4gICAgT3BlcmF0aW9uUmVhZCA9IE9iamVjdC5jcmVhdGUoe1xuICAgICAgICBhY3Rpb25SZWFkOiBmdW5jdGlvbiBhY3Rpb25SZWFkKHByaW1hcnlLZXlWYWx1ZSkge1xuICAgICAgICAgICAgT3BlcmF0aW9uc0NvbW1vbi5vcGVyYXRpb25EaXNwYXRjaC5hcHBseSh0aGlzLCBbe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogQ29uc3RhbnRzLkFDVElPTl9SRUFEX0ZPUk0sXG4gICAgICAgICAgICAgICAgZmllbGRzTGlzdE5hbWU6ICdyZWFkRmllbGRzJyxcbiAgICAgICAgICAgICAgICBmaWVsZExpc3Q6ICdyZWFkRmllbGRzJyxcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGVzOiAnZmllbGRUeXBlc1JlYWRGb3JtJyxcbiAgICAgICAgICAgICAgICBjYWNoZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNSZWFkT25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwcmltYXJ5S2V5VmFsdWU6IHByaW1hcnlLZXlWYWx1ZVxuICAgICAgICAgICAgfV0pO1xuICAgICAgICB9LFxuICAgICAgICBvblJlYWRDbGljazogZnVuY3Rpb24gb25SZWFkQ2xpY2socHJpbWFyeUtleVZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5oYXNoRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgaGFzaGVyLnNldEhhc2godGhpcy5oYXNoRXZlbnQucmVhZEl0ZW0gKyAnLycgKyBwcmltYXJ5S2V5VmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBPcGVyYXRpb25SZWFkLmFjdGlvblJlYWQuYXBwbHkodGhpcywgW3ByaW1hcnlLZXlWYWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbmV4cG9ydHMuT3BlcmF0aW9uUmVhZCA9IE9wZXJhdGlvblJlYWQ7XG4iLCJleHBvcnQgZGVmYXVsdCAoc3RhdGUgPSAnJywgYWN0aW9uKSA9PiB7XG4gICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogYWN0aW9uLnR5cGUsXG4gICAgICAgICAgICBmaWVsZHM6IFtdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbjtcbn1cbiIsInZhciBoYXNoZXIgPSByZXF1aXJlKCdoYXNoZXInKSxcbiAgICB0aGlzSW5jcmVhc2UgPSAwLFxuICAgIGNyb3Nzcm9hZHMgPSByZXF1aXJlKCdjcm9zc3JvYWRzJyksXG4gICAgT3BlcmF0aW9uQWRkID0gcmVxdWlyZSgnLi4vb3BlcmF0aW9ucy9hZGQnKS5PcGVyYXRpb25BZGQsXG4gICAgT3BlcmF0aW9uRWRpdCA9IHJlcXVpcmUoJy4uL29wZXJhdGlvbnMvZWRpdCcpLk9wZXJhdGlvbkVkaXQsXG4gICAgT3BlcmF0aW9uQ2xvbmUgPSByZXF1aXJlKCcuLi9vcGVyYXRpb25zL2Nsb25lJykuT3BlcmF0aW9uQ2xvbmUsXG4gICAgT3BlcmF0aW9uUmVhZCA9IHJlcXVpcmUoJy4uL29wZXJhdGlvbnMvcmVhZCcpLk9wZXJhdGlvblJlYWQsXG4gICAgUm91dGVyID0ge1xuICAgICAgICBzZXRSb3V0ZXM6IGZ1bmN0aW9uIHNldFJvdXRlcygpIHtcbiAgICAgICAgICAgIHZhciBzdGFydGluZ1N0cmluZyA9ICcnO1xuXG4gICAgICAgICAgICBpZiAodGhpc0luY3JlYXNlID4gMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0aW5nU3RyaW5nID0gdGhpc0luY3JlYXNlICsgJy8nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmhhc2hFdmVudCA9IHt9O1xuICAgICAgICAgICAgdGhpcy5oYXNoRXZlbnQuYWRkSXRlbSA9IHN0YXJ0aW5nU3RyaW5nICsgJ2FkZCc7XG4gICAgICAgICAgICB0aGlzLmhhc2hFdmVudC5lZGl0SXRlbSA9IHN0YXJ0aW5nU3RyaW5nICsgJ2VkaXQnO1xuICAgICAgICAgICAgdGhpcy5oYXNoRXZlbnQuY2xvbmVJdGVtID0gc3RhcnRpbmdTdHJpbmcgKyAnY2xvbmUnO1xuICAgICAgICAgICAgdGhpcy5oYXNoRXZlbnQucmVhZEl0ZW0gPSBzdGFydGluZ1N0cmluZyArICdyZWFkJztcbiAgICAgICAgICAgIHRoaXMuaGFzaEV2ZW50LmRlbGV0ZUl0ZW0gPSBzdGFydGluZ1N0cmluZyArICdkZWxldGUnO1xuICAgICAgICAgICAgdGhpcy5oYXNoRXZlbnQudXJsVW5pcXVlSGFzaCA9IHN0YXJ0aW5nU3RyaW5nO1xuICAgICAgICB9LFxuICAgICAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICAgICAgdmFyIHBhcnNlSGFzaCA9IGZ1bmN0aW9uIHBhcnNlSGFzaChuZXdIYXNoKSB7XG4gICAgICAgICAgICAgICAgY3Jvc3Nyb2Fkcy5wYXJzZShuZXdIYXNoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFRoaXMgbGluZSBpcyBpbiBvcmRlciB0byBjYWxsIHRoZSByb3V0ZSBhcyBtYW55IHRpbWVzIGFzIHdlIHdhbnQhXG4gICAgICAgICAgICBjcm9zc3JvYWRzLmlnbm9yZVN0YXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuaGFzaEV2ZW50cykge1xuICAgICAgICAgICAgICAgIGNyb3Nzcm9hZHMuYWRkUm91dGUodGhpcy5oYXNoRXZlbnQuYWRkSXRlbSwgZnVuY3Rpb24gb3BlcmF0aW9uQWRkUm91dGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIE9wZXJhdGlvbkFkZC5hY3Rpb25BZGQuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgICAgIGNyb3Nzcm9hZHMuYWRkUm91dGUodGhpcy5oYXNoRXZlbnQuZWRpdEl0ZW0gKyAnL3twcmltYXJ5S2V5VmFsdWV9JywgZnVuY3Rpb24gb3BlcmF0aW9uRWRpdFJvdXRlKHByaW1hcnlLZXlWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBPcGVyYXRpb25FZGl0LmFjdGlvbkVkaXQuYXBwbHkodGhpcywgW3ByaW1hcnlLZXlWYWx1ZV0pO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgICAgICBjcm9zc3JvYWRzLmFkZFJvdXRlKHRoaXMuaGFzaEV2ZW50LmNsb25lSXRlbSArICcve3ByaW1hcnlLZXlWYWx1ZX0nLCBmdW5jdGlvbiBvcGVyYXRpb25DbG9uZVJvdXRlKHByaW1hcnlLZXlWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBPcGVyYXRpb25DbG9uZS5hY3Rpb25DbG9uZS5hcHBseSh0aGlzLCBbcHJpbWFyeUtleVZhbHVlXSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgICAgIGNyb3Nzcm9hZHMuYWRkUm91dGUodGhpcy5oYXNoRXZlbnQucmVhZEl0ZW0gKyAnL3twcmltYXJ5S2V5VmFsdWV9JywgZnVuY3Rpb24gb3BlcmF0aW9uUmVhZFJvdXRlKHByaW1hcnlLZXlWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBPcGVyYXRpb25SZWFkLmFjdGlvblJlYWQuYXBwbHkodGhpcywgW3ByaW1hcnlLZXlWYWx1ZV0pO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzSW5jcmVhc2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICBoYXNoZXIuaW5pdGlhbGl6ZWQuYWRkKHBhcnNlSGFzaCk7XG4gICAgICAgICAgICAgICAgaGFzaGVyLmNoYW5nZWQuYWRkKHBhcnNlSGFzaCk7XG5cbiAgICAgICAgICAgICAgICAvLyBzdGFydCBsaXN0ZW5pbmcgZm9yIGhpc3RvcnkgY2hhbmdlc1xuICAgICAgICAgICAgICAgIGhhc2hlci5pbml0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXNJbmNyZWFzZSsrO1xuICAgICAgICB9XG4gICAgfTtcblxuZXhwb3J0cy5Sb3V0ZXIgPSBPYmplY3QuY3JlYXRlKFJvdXRlcik7XG4iLCJpbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcblxudmFyIENhbGxiYWNrQ29sdW1uID0gT2JqZWN0LmNyZWF0ZSh7XG4gICAgaW5pdERhdGE6IGZ1bmN0aW9uIGluaXREYXRhKCkge1xuICAgICAgICBfLmVhY2godGhpcy5jYWNoZWRJbml0aWFsRGF0YS5maWVsZFR5cGVzQ29sdW1ucywgZnVuY3Rpb24gZmllbGRUeXBlcyhmaWVsZERhdGEsIGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgaWYgKGZpZWxkRGF0YS5kYXRhVHlwZSA9PT0gJ2NhbGxiYWNrX2NvbHVtbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrQ29sdW1uRmllbGRzW2ZpZWxkTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG4gICAgaXNUaGlzVHlwZTogZnVuY3Rpb24gaXNUaGlzVHlwZShmaWVsZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbGJhY2tDb2x1bW5GaWVsZHNbZmllbGROYW1lXTtcbiAgICB9XG59KTtcblxuZXhwb3J0cy5DYWxsYmFja0NvbHVtbiA9IENhbGxiYWNrQ29sdW1uOyIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG52YXIgQ2hlY2tib3hCb29sZWFuID0gT2JqZWN0LmNyZWF0ZSh7XG4gICAgaW5pdERhdGE6IGZ1bmN0aW9uIGluaXREYXRhKCkge1xuICAgICAgICBfLmVhY2godGhpcy5jYWNoZWRJbml0aWFsRGF0YS5maWVsZFR5cGVzQ29sdW1ucywgZnVuY3Rpb24gZmllbGRUeXBlcyhmaWVsZERhdGEsIGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgaWYgKGZpZWxkRGF0YS5kYXRhVHlwZSA9PT0gJ2NoZWNrYm94X2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja2JveEJvb2xlYW5GaWVsZHMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tib3hCb29sZWFuRmllbGRzRGF0YVtmaWVsZE5hbWVdID0ge307XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrYm94Qm9vbGVhbkZpZWxkc0RhdGFbZmllbGROYW1lXSA9IGZpZWxkRGF0YS5wZXJtaXR0ZWRWYWx1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSxcbiAgICBpc0NoZWNrYm94Qm9vbGVhbjogZnVuY3Rpb24gaXNDaGVja2JveEJvb2xlYW4oZmllbGROYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrYm94Qm9vbGVhbkZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNoZWNrYm94Qm9vbGVhbkZpZWxkcy5pbmRleE9mKGZpZWxkTmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBmb3JtYXRWYWx1ZTogZnVuY3Rpb24gZm9ybWF0VmFsdWUoZmllbGRWYWx1ZSkge1xuICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gJzEnKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxpIGNsYXNzPVwiZmEgZmEtY2hlY2tcIj48L2k+JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59KTtcblxuZXhwb3J0cy5DaGVja2JveEJvb2xlYW4gPSBDaGVja2JveEJvb2xlYW47XG4iLCJpbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcblxudmFyXG4gICAgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuQ29uc3RhbnRzLFxuICAgIERhdGVBbmRUaW1lID0gT2JqZWN0LmNyZWF0ZSh7XG4gICAgICAgIGluaXREYXRhOiBmdW5jdGlvbiBpbml0RGF0YSgpIHtcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmZpZWxkVHlwZXNDb2x1bW5zLCBmdW5jdGlvbiBmaWVsZFR5cGVzKGZpZWxkRGF0YSwgZmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkRGF0YS5kYXRhVHlwZSA9PT0gQ29uc3RhbnRzLkZJRUxEX1RZUEVfREFURSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGVGaWVsZHMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoL14oZGF0ZXRpbWV8dGltZXN0YW1wKSQvaS50ZXN0KGZpZWxkRGF0YS5kYXRhVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRldGltZUZpZWxkcy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Rm9ybWF0dGVyOiBmdW5jdGlvbiBnZXRGb3JtYXR0ZXIoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRlRm9ybWF0dGVyID09PSBudWxsKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEludGwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZUZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KERhdGVBbmRUaW1lLmdldExvY2FsZSgpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGVGb3JtYXR0ZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdChteURhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXlEYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUZvcm1hdHRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0RGF0ZUxvY2FsZTogZnVuY3Rpb24gZm9ybWF0RGF0ZUxvY2FsZShyYXdEYXRlKSB7XG4gICAgICAgICAgICB2YXIgbXlEYXRlLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlcjtcblxuICAgICAgICAgICAgaWYgKHJhd0RhdGUgPT09ICcwMDAwLTAwLTAwJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbXlEYXRlID0gbmV3IERhdGUocmF3RGF0ZSk7XG4gICAgICAgICAgICBmb3JtYXR0ZXIgPSBEYXRlQW5kVGltZS5nZXRGb3JtYXR0ZXIuYXBwbHkodGhpcyk7XG5cbiAgICAgICAgICAgIGlmICghRGF0ZUFuZFRpbWUuaXNWYWxpZERhdGUobXlEYXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQobXlEYXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0RGF0ZXRpbWVMb2NhbGU6IGZ1bmN0aW9uIGZvcm1hdERhdGV0aW1lTG9jYWxlKHJhd0RhdGUpIHtcbiAgICAgICAgICAgIHZhciBteURhdGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyO1xuXG4gICAgICAgICAgICBpZiAocmF3RGF0ZSA9PT0gJzAwMDAtMDAtMDAgMDA6MDA6MDAnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBteURhdGUgPSBuZXcgRGF0ZShyYXdEYXRlKTtcbiAgICAgICAgICAgIGZvcm1hdHRlciA9IERhdGVBbmRUaW1lLmdldEZvcm1hdHRlci5hcHBseSh0aGlzKTtcblxuICAgICAgICAgICAgaWYgKCFEYXRlQW5kVGltZS5pc1ZhbGlkRGF0ZShteURhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdChteURhdGUpICsgJyAnICsgbXlEYXRlLnRvTG9jYWxlVGltZVN0cmluZygpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRMb2NhbGU6IGZ1bmN0aW9uIGdldExvY2FsZSgpIHtcbiAgICAgICAgICAgIGlmIChuYXZpZ2F0b3IubGFuZ3VhZ2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLmxhbmd1YWdlc1swXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5sYW5ndWFnZTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNWYWxpZERhdGU6IGZ1bmN0aW9uIGlzVmFsaWREYXRlKG15RGF0ZSkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChteURhdGUpID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWlzTmFOKG15RGF0ZS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRGF0ZXRpbWU6IGZ1bmN0aW9uIGlzTnRvTihmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGV0aW1lRmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmRhdGV0aW1lRmllbGRzLmluZGV4T2YoZmllbGROYW1lKSA+IC0xKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNEYXRlOiBmdW5jdGlvbiBpc050b04oZmllbGROYW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRlRmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmRhdGVGaWVsZHMuaW5kZXhPZihmaWVsZE5hbWUpID4gLTEpO1xuICAgICAgICB9XG59KTtcblxuZXhwb3J0cy5EYXRlQW5kVGltZSA9IERhdGVBbmRUaW1lOyIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG52YXIgRHJvcGRvd24gPSBPYmplY3QuY3JlYXRlKHtcbiAgICBpbml0RGF0YTogZnVuY3Rpb24gaW5pdERhdGEoKSB7XG4gICAgICAgIF8uZWFjaCh0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmZpZWxkVHlwZXNDb2x1bW5zLCBmdW5jdGlvbiBmaWVsZFR5cGVzKGZpZWxkRGF0YSwgZmllbGROYW1lKSB7XG4gICAgICAgICAgICBpZiAoL15kcm9wZG93bihfc2VhcmNoKT8kLy50ZXN0KGZpZWxkRGF0YS5kYXRhVHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duRmllbGRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duRmllbGRzRGF0YVtmaWVsZE5hbWVdID0ge307XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duRmllbGRzRGF0YVtmaWVsZE5hbWVdID0gZmllbGREYXRhLnBlcm1pdHRlZFZhbHVlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuICAgIGlzRHJvcGRvd246IGZ1bmN0aW9uIGlzRHJvcGRvd24oZmllbGROYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmRyb3Bkb3duRmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZHJvcGRvd25GaWVsZHMuaW5kZXhPZihmaWVsZE5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgZm9ybWF0VmFsdWU6IGZ1bmN0aW9uIGZvcm1hdFZhbHVlKGZpZWxkTmFtZSwgZmllbGRWYWx1ZSkge1xuICAgICAgICB2YXIgZGF0YTtcblxuICAgICAgICBpZiAoIWZpZWxkVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEgPSB0aGlzLmRyb3Bkb3duRmllbGRzRGF0YVtmaWVsZE5hbWVdO1xuXG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChkYXRhW2ZpZWxkVmFsdWVdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFbZmllbGRWYWx1ZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICB9XG59KTtcblxuZXhwb3J0cy5Ecm9wZG93biA9IERyb3Bkb3duO1xuIiwiaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XG5cbnZhciBFbnVtID0gT2JqZWN0LmNyZWF0ZSh7XG4gICAgaW5pdERhdGE6IGZ1bmN0aW9uIGluaXREYXRhKCkge1xuICAgICAgICBfLmVhY2godGhpcy5jYWNoZWRJbml0aWFsRGF0YS5maWVsZFR5cGVzQ29sdW1ucywgZnVuY3Rpb24gZmllbGRUeXBlcyhmaWVsZERhdGEsIGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgaWYgKGZpZWxkRGF0YS5kYXRhVHlwZSA9PT0gJ2VudW0nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnVtRmllbGRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVudW1GaWVsZHNEYXRhW2ZpZWxkTmFtZV0gPSB7fTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZW51bUZpZWxkc0RhdGFbZmllbGROYW1lXSA9IGZpZWxkRGF0YS5wZXJtaXR0ZWRWYWx1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSxcbiAgICBpc0VudW06IGZ1bmN0aW9uIGlzRW51bShmaWVsZE5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZW51bUZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmVudW1GaWVsZHMuaW5kZXhPZihmaWVsZE5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0pO1xuXG5leHBvcnRzLkVudW0gPSBFbnVtO1xuIiwiaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XG5cbnZhciBNdWx0aXBsZVNlbGVjdCA9IE9iamVjdC5jcmVhdGUoe1xuICAgIGluaXREYXRhOiBmdW5jdGlvbiBpbml0RGF0YSgpIHtcbiAgICAgICAgXy5lYWNoKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuZmllbGRUeXBlc0NvbHVtbnMsIGZ1bmN0aW9uIGZpZWxkVHlwZXMoZmllbGREYXRhLCBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZERhdGEuZGF0YVR5cGUgPT09ICdtdWx0aXNlbGVjdF9zZWFyY2hhYmxlJyB8fFxuICAgICAgICAgICAgICAgIGZpZWxkRGF0YS5kYXRhVHlwZSA9PT0gJ211bHRpc2VsZWN0X25hdGl2ZScpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMubXVsdGlwbGVTZWxlY3RGaWVsZHNbZmllbGROYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBsZVNlbGVjdERhdGFbZmllbGROYW1lXSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgXy5lYWNoKGZpZWxkRGF0YS5wZXJtaXR0ZWRWYWx1ZXMsIGZ1bmN0aW9uIGZvcmVhY2hEYXRhKGRhdGFMYWJlbCwgZGF0YUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXVsdGlwbGVTZWxlY3REYXRhW2ZpZWxkTmFtZV1bZGF0YUluZGV4XSA9IGRhdGFMYWJlbDtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG4gICAgaXNUaGlzVHlwZTogZnVuY3Rpb24gaXNUaGlzVHlwZShmaWVsZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbGVTZWxlY3RGaWVsZHNbZmllbGROYW1lXTtcbiAgICB9LFxuICAgIHRyYW5zZm9ybURhdGE6IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZmllbGROYW1lLCBmaWVsZERhdGEpIHtcbiAgICAgICAgbGV0IGZpbmFsU3RyaW5nLFxuICAgICAgICAgICAgZmluYWxBcnJheSA9IFtdO1xuICAgICAgICBfLmVhY2goZmllbGREYXRhLnNwbGl0KCcsJyksIGZ1bmN0aW9uIGZvcmVhY2hUcmFuc2Zvcm1EYXRhKGRhdGFWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlwbGVTZWxlY3REYXRhW2ZpZWxkTmFtZV1bZGF0YVZhbHVlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmluYWxBcnJheS5wdXNoKHRoaXMubXVsdGlwbGVTZWxlY3REYXRhW2ZpZWxkTmFtZV1bZGF0YVZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgZmluYWxTdHJpbmcgPSBmaW5hbEFycmF5LmpvaW4oJywnKTtcblxuICAgICAgICByZXR1cm4gZmluYWxTdHJpbmc7XG4gICAgfVxufSk7XG5cbmV4cG9ydHMuTXVsdGlwbGVTZWxlY3QgPSBNdWx0aXBsZVNlbGVjdDtcbiIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuQ29uc3RhbnRzLFxuICAgIFJlbGF0aW9uTnRvTiA9IE9iamVjdC5jcmVhdGUoe1xuICAgICAgICBpbml0RGF0YTogZnVuY3Rpb24gaW5pdERhdGEoKSB7XG4gICAgICAgICAgICBfLmVhY2godGhpcy5jYWNoZWRJbml0aWFsRGF0YS5maWVsZFR5cGVzQ29sdW1ucywgZnVuY3Rpb24gZmllbGRUeXBlcyhmaWVsZERhdGEsIGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZERhdGEuZGF0YVR5cGUgPT09IENvbnN0YW50cy5GSUVMRF9UWVBFX1JFTEFUSU9OX05fVE9fTiB8fFxuICAgICAgICAgICAgICAgICAgICBmaWVsZERhdGEuZGF0YVR5cGUgPT09IENvbnN0YW50cy5GSUVMRF9UWVBFX05BVElWRV9SRUxBVElPTl9OX1RPX04gfHxcbiAgICAgICAgICAgICAgICAgICAgZmllbGREYXRhLmRhdGFUeXBlID09PSBDb25zdGFudHMuRklFTERfVFlQRV9TRUFSQ0hBQkxFX05fVE9fTikge1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpb25OdG9ORmllbGRzW2ZpZWxkTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aW9uTnRvTkRhdGFbZmllbGROYW1lXSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChmaWVsZERhdGEucGVybWl0dGVkVmFsdWVzLCBmdW5jdGlvbiBmb3JlYWNoRGF0YShkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aW9uTnRvTkRhdGFbZmllbGROYW1lXVtkYXRhLmlkXSA9IGRhdGEudGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNOdG9OOiBmdW5jdGlvbiBpc050b04oZmllbGROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxhdGlvbk50b05GaWVsZHNbZmllbGROYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmb3JtRGF0YTogZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShmaWVsZE5hbWUsIGZpZWxkRGF0YSkge1xuICAgICAgICAgICAgdmFyIGZpbmFsU3RyaW5nID0gJyc7XG4gICAgICAgICAgICBfLmVhY2goZmllbGREYXRhLCBmdW5jdGlvbiBmb3JlYWNoVHJhbnNmb3JtRGF0YShkYXRhVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWxhdGlvbk50b05EYXRhW2ZpZWxkTmFtZV1bZGF0YVZhbHVlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsU3RyaW5nICs9IHRoaXMucmVsYXRpb25OdG9ORGF0YVtmaWVsZE5hbWVdW2RhdGFWYWx1ZV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIGlmIChmaW5hbFN0cmluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgZmluYWxTdHJpbmcgPSBmaW5hbFN0cmluZy5zdWJzdHIoMCwgZmluYWxTdHJpbmcubGVuZ3RoIC0gMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmaW5hbFN0cmluZztcbiAgICAgICAgfVxuICAgIH0pO1xuXG5leHBvcnRzLlJlbGF0aW9uTnRvTiA9IFJlbGF0aW9uTnRvTjtcbiIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuQ29uc3RhbnRzLFxuICAgIFJlbGF0aW9uID0gT2JqZWN0LmNyZWF0ZSh7XG4gICAgICAgIGluaXREYXRhOiBmdW5jdGlvbiBpbml0RGF0YSgpIHtcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmZpZWxkVHlwZXNDb2x1bW5zLCBmdW5jdGlvbiBmaWVsZFR5cGVzKGZpZWxkRGF0YSwgZmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkRGF0YS5kYXRhVHlwZSA9PT0gQ29uc3RhbnRzLkZJRUxEX1RZUEVfUkVMQVRJT04gfHwgZmllbGREYXRhLmRhdGFUeXBlID09PSBDb25zdGFudHMuRklFTERfVFlQRV9SRUxBVElPTl9OQVRJVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGlvbkZpZWxkcy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpb25EYXRhW2ZpZWxkTmFtZV0gPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICBfLmVhY2goZmllbGREYXRhLnBlcm1pdHRlZFZhbHVlcywgZnVuY3Rpb24gZm9yZWFjaERhdGEoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGlvbkRhdGFbZmllbGROYW1lXVtkYXRhLmlkXSA9IGRhdGEudGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNSZWxhdGlvbmFsOiBmdW5jdGlvbiBpc1JlbGF0aW9uYWwoZmllbGROYW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWxhdGlvbkZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnJlbGF0aW9uRmllbGRzLmluZGV4T2YoZmllbGROYW1lKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmb3JtRGF0YTogZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShmaWVsZE5hbWUsIGZpZWxkRGF0YSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVsYXRpb25EYXRhW2ZpZWxkTmFtZV1bZmllbGREYXRhXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVsYXRpb25EYXRhW2ZpZWxkTmFtZV1bZmllbGREYXRhXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkRGF0YTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5leHBvcnRzLlJlbGF0aW9uID0gUmVsYXRpb247XG4iLCJpbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcblxudmFyIFRleHRlZGl0b3IgPSBPYmplY3QuY3JlYXRlKHtcbiAgICBpbml0RGF0YTogZnVuY3Rpb24gaW5pdERhdGEoKSB7XG4gICAgICAgIF8uZWFjaCh0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmZpZWxkVHlwZXNDb2x1bW5zLCBmdW5jdGlvbiBmaWVsZFR5cGVzKGZpZWxkRGF0YSwgZmllbGROYW1lKSB7XG4gICAgICAgICAgICBpZiAoZmllbGREYXRhLmRhdGFUeXBlID09PSAndGV4dGVkaXRvcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRlZGl0b3JGaWVsZHNbZmllbGROYW1lXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSxcbiAgICBpc1RoaXNUeXBlOiBmdW5jdGlvbiBpc1RoaXNUeXBlKGZpZWxkTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0ZWRpdG9yRmllbGRzW2ZpZWxkTmFtZV07XG4gICAgfVxufSk7XG5cbmV4cG9ydHMuVGV4dGVkaXRvciA9IFRleHRlZGl0b3I7IiwiaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XG5cbnZhciBVcGxvYWQgPSBPYmplY3QuY3JlYXRlKHtcbiAgICBpbml0RGF0YTogZnVuY3Rpb24gaW5pdERhdGEoKSB7XG4gICAgICAgIF8uZWFjaCh0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmZpZWxkVHlwZXNDb2x1bW5zLCBmdW5jdGlvbiBmaWVsZFR5cGVzKGZpZWxkRGF0YSwgZmllbGROYW1lKSB7XG4gICAgICAgICAgICBpZiAoZmllbGREYXRhLmRhdGFUeXBlID09PSAndXBsb2FkJykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBsb2FkRmllbGRzLnB1c2goZmllbGROYW1lKTtcblxuICAgICAgICAgICAgICAgIHRoaXMudXBsb2FkRmllbGRzRGF0YVtmaWVsZE5hbWVdID0gZmllbGREYXRhLm9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSxcbiAgICBpc1VwbG9hZFR5cGU6IGZ1bmN0aW9uIGlzVXBsb2FkVHlwZShmaWVsZE5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMudXBsb2FkRmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLnVwbG9hZEZpZWxkcy5pbmRleE9mKGZpZWxkTmFtZSkgPiAtMSk7XG4gICAgfSxcbiAgICBmb3JtYXRVcGxvYWQ6IGZ1bmN0aW9uIGZvcm1hdFVwbG9hZChmaWVsZE5hbWUsIGZpZWxkVmFsdWUpIHtcbiAgICAgICAgdmFyIHVybDtcblxuICAgICAgICBpZiAoIWZpZWxkVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHVybCA9IHRoaXMudXBsb2FkRmllbGRzRGF0YVtmaWVsZE5hbWVdLnB1YmxpY1BhdGggKyAnLycgKyBmaWVsZFZhbHVlO1xuXG4gICAgICAgIHJldHVybiAnPGEgaHJlZj1cIicgKyB1cmwgKyAnXCIgdGFyZ2V0PVwiX2JsYW5rXCI+JyArIGZpZWxkVmFsdWUgKyAnPC9hPic7XG4gICAgfVxufSk7XG5cbmV4cG9ydHMuVXBsb2FkID0gVXBsb2FkOyIsIi8qKiB2aW06IGV0OnRzPTQ6c3c9NDpzdHM9NFxuICogQGxpY2Vuc2UgYW1kZWZpbmUgMS4wLjEgQ29weXJpZ2h0IChjKSAyMDExLTIwMTYsIFRoZSBEb2pvIEZvdW5kYXRpb24gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIEF2YWlsYWJsZSB2aWEgdGhlIE1JVCBvciBuZXcgQlNEIGxpY2Vuc2UuXG4gKiBzZWU6IGh0dHA6Ly9naXRodWIuY29tL2pyYnVya2UvYW1kZWZpbmUgZm9yIGRldGFpbHNcbiAqL1xuXG4vKmpzbGludCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCBtb2R1bGUsIHByb2Nlc3MgKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVmaW5lIGZvciBub2RlLlxuICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSB0aGUgXCJtb2R1bGVcIiBvYmplY3QgdGhhdCBpcyBkZWZpbmVkIGJ5IE5vZGUgZm9yIHRoZVxuICogY3VycmVudCBtb2R1bGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVxdWlyZUZuXS4gTm9kZSdzIHJlcXVpcmUgZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50IG1vZHVsZS5cbiAqIEl0IG9ubHkgbmVlZHMgdG8gYmUgcGFzc2VkIGluIE5vZGUgdmVyc2lvbnMgYmVmb3JlIDAuNSwgd2hlbiBtb2R1bGUucmVxdWlyZVxuICogZGlkIG5vdCBleGlzdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBkZWZpbmUgZnVuY3Rpb24gdGhhdCBpcyB1c2FibGUgZm9yIHRoZSBjdXJyZW50IG5vZGVcbiAqIG1vZHVsZS5cbiAqL1xuZnVuY3Rpb24gYW1kZWZpbmUobW9kdWxlLCByZXF1aXJlRm4pIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGRlZmluZUNhY2hlID0ge30sXG4gICAgICAgIGxvYWRlckNhY2hlID0ge30sXG4gICAgICAgIGFscmVhZHlDYWxsZWQgPSBmYWxzZSxcbiAgICAgICAgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKSxcbiAgICAgICAgbWFrZVJlcXVpcmUsIHN0cmluZ1JlcXVpcmU7XG5cbiAgICAvKipcbiAgICAgKiBUcmltcyB0aGUgLiBhbmQgLi4gZnJvbSBhbiBhcnJheSBvZiBwYXRoIHNlZ21lbnRzLlxuICAgICAqIEl0IHdpbGwga2VlcCBhIGxlYWRpbmcgcGF0aCBzZWdtZW50IGlmIGEgLi4gd2lsbCBiZWNvbWVcbiAgICAgKiB0aGUgZmlyc3QgcGF0aCBzZWdtZW50LCB0byBoZWxwIHdpdGggbW9kdWxlIG5hbWUgbG9va3VwcyxcbiAgICAgKiB3aGljaCBhY3QgbGlrZSBwYXRocywgYnV0IGNhbiBiZSByZW1hcHBlZC4gQnV0IHRoZSBlbmQgcmVzdWx0LFxuICAgICAqIGFsbCBwYXRocyB0aGF0IHVzZSB0aGlzIGZ1bmN0aW9uIHNob3VsZCBsb29rIG5vcm1hbGl6ZWQuXG4gICAgICogTk9URTogdGhpcyBtZXRob2QgTU9ESUZJRVMgdGhlIGlucHV0IGFycmF5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyeSB0aGUgYXJyYXkgb2YgcGF0aCBzZWdtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltRG90cyhhcnkpIHtcbiAgICAgICAgdmFyIGksIHBhcnQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGFyeVtpXTsgaSs9IDEpIHtcbiAgICAgICAgICAgIHBhcnQgPSBhcnlbaV07XG4gICAgICAgICAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgYXJ5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiAoYXJ5WzJdID09PSAnLi4nIHx8IGFyeVswXSA9PT0gJy4uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9FbmQgb2YgdGhlIGxpbmUuIEtlZXAgYXQgbGVhc3Qgb25lIG5vbi1kb3RcbiAgICAgICAgICAgICAgICAgICAgLy9wYXRoIHNlZ21lbnQgYXQgdGhlIGZyb250IHNvIGl0IGNhbiBiZSBtYXBwZWRcbiAgICAgICAgICAgICAgICAgICAgLy9jb3JyZWN0bHkgdG8gZGlzay4gT3RoZXJ3aXNlLCB0aGVyZSBpcyBsaWtlbHlcbiAgICAgICAgICAgICAgICAgICAgLy9ubyBwYXRoIG1hcHBpbmcgZm9yIGEgcGF0aCBzdGFydGluZyB3aXRoICcuLicuXG4gICAgICAgICAgICAgICAgICAgIC8vVGhpcyBjYW4gc3RpbGwgZmFpbCwgYnV0IGNhdGNoZXMgdGhlIG1vc3QgcmVhc29uYWJsZVxuICAgICAgICAgICAgICAgICAgICAvL3VzZXMgb2YgLi5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhcnkuc3BsaWNlKGkgLSAxLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lLCBiYXNlTmFtZSkge1xuICAgICAgICB2YXIgYmFzZVBhcnRzO1xuXG4gICAgICAgIC8vQWRqdXN0IGFueSByZWxhdGl2ZSBwYXRocy5cbiAgICAgICAgaWYgKG5hbWUgJiYgbmFtZS5jaGFyQXQoMCkgPT09ICcuJykge1xuICAgICAgICAgICAgLy9JZiBoYXZlIGEgYmFzZSBuYW1lLCB0cnkgdG8gbm9ybWFsaXplIGFnYWluc3QgaXQsXG4gICAgICAgICAgICAvL290aGVyd2lzZSwgYXNzdW1lIGl0IGlzIGEgdG9wLWxldmVsIHJlcXVpcmUgdGhhdCB3aWxsXG4gICAgICAgICAgICAvL2JlIHJlbGF0aXZlIHRvIGJhc2VVcmwgaW4gdGhlIGVuZC5cbiAgICAgICAgICAgIGlmIChiYXNlTmFtZSkge1xuICAgICAgICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2VOYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgYmFzZVBhcnRzID0gYmFzZVBhcnRzLnNsaWNlKDAsIGJhc2VQYXJ0cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlUGFydHMuY29uY2F0KG5hbWUuc3BsaXQoJy8nKSk7XG4gICAgICAgICAgICAgICAgdHJpbURvdHMoYmFzZVBhcnRzKTtcbiAgICAgICAgICAgICAgICBuYW1lID0gYmFzZVBhcnRzLmpvaW4oJy8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgbm9ybWFsaXplKCkgZnVuY3Rpb24gcGFzc2VkIHRvIGEgbG9hZGVyIHBsdWdpbidzXG4gICAgICogbm9ybWFsaXplIG1ldGhvZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlTm9ybWFsaXplKHJlbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKG5hbWUsIHJlbE5hbWUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VMb2FkKGlkKSB7XG4gICAgICAgIGZ1bmN0aW9uIGxvYWQodmFsdWUpIHtcbiAgICAgICAgICAgIGxvYWRlckNhY2hlW2lkXSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9hZC5mcm9tVGV4dCA9IGZ1bmN0aW9uIChpZCwgdGV4dCkge1xuICAgICAgICAgICAgLy9UaGlzIG9uZSBpcyBkaWZmaWN1bHQgYmVjYXVzZSB0aGUgdGV4dCBjYW4vcHJvYmFibHkgdXNlc1xuICAgICAgICAgICAgLy9kZWZpbmUsIGFuZCBhbnkgcmVsYXRpdmUgcGF0aHMgYW5kIHJlcXVpcmVzIHNob3VsZCBiZSByZWxhdGl2ZVxuICAgICAgICAgICAgLy90byB0aGF0IGlkIHdhcyBpdCB3b3VsZCBiZSBmb3VuZCBvbiBkaXNrLiBCdXQgdGhpcyB3b3VsZCByZXF1aXJlXG4gICAgICAgICAgICAvL2Jvb3RzdHJhcHBpbmcgYSBtb2R1bGUvcmVxdWlyZSBmYWlybHkgZGVlcGx5IGZyb20gbm9kZSBjb3JlLlxuICAgICAgICAgICAgLy9Ob3Qgc3VyZSBob3cgYmVzdCB0byBnbyBhYm91dCB0aGF0IHlldC5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYW1kZWZpbmUgZG9lcyBub3QgaW1wbGVtZW50IGxvYWQuZnJvbVRleHQnKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbG9hZDtcbiAgICB9XG5cbiAgICBtYWtlUmVxdWlyZSA9IGZ1bmN0aW9uIChzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIHJlbElkKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFtZFJlcXVpcmUoZGVwcywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVwcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL1N5bmNocm9ub3VzLCBzaW5nbGUgbW9kdWxlIHJlcXVpcmUoJycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1JlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCBkZXBzLCByZWxJZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vQXJyYXkgb2YgZGVwZW5kZW5jaWVzIHdpdGggYSBjYWxsYmFjay5cblxuICAgICAgICAgICAgICAgIC8vQ29udmVydCB0aGUgZGVwZW5kZW5jaWVzIHRvIG1vZHVsZXMuXG4gICAgICAgICAgICAgICAgZGVwcyA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgZGVwTmFtZSwgcmVsSWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9XYWl0IGZvciBuZXh0IHRpY2sgdG8gY2FsbCBiYWNrIHRoZSByZXF1aXJlIGNhbGwuXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgZGVwcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFtZFJlcXVpcmUudG9VcmwgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgICAgIGlmIChmaWxlUGF0aC5pbmRleE9mKCcuJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKGZpbGVQYXRoLCBwYXRoLmRpcm5hbWUobW9kdWxlLmZpbGVuYW1lKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYW1kUmVxdWlyZTtcbiAgICB9O1xuXG4gICAgLy9GYXZvciBleHBsaWNpdCB2YWx1ZSwgcGFzc2VkIGluIGlmIHRoZSBtb2R1bGUgd2FudHMgdG8gc3VwcG9ydCBOb2RlIDAuNC5cbiAgICByZXF1aXJlRm4gPSByZXF1aXJlRm4gfHwgZnVuY3Rpb24gcmVxKCkge1xuICAgICAgICByZXR1cm4gbW9kdWxlLnJlcXVpcmUuYXBwbHkobW9kdWxlLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBydW5GYWN0b3J5KGlkLCBkZXBzLCBmYWN0b3J5KSB7XG4gICAgICAgIHZhciByLCBlLCBtLCByZXN1bHQ7XG5cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBlID0gbG9hZGVyQ2FjaGVbaWRdID0ge307XG4gICAgICAgICAgICBtID0ge1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICB1cmk6IF9fZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgZXhwb3J0czogZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHIgPSBtYWtlUmVxdWlyZShyZXF1aXJlRm4sIGUsIG0sIGlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vT25seSBzdXBwb3J0IG9uZSBkZWZpbmUgY2FsbCBwZXIgZmlsZVxuICAgICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FtZGVmaW5lIHdpdGggbm8gbW9kdWxlIElEIGNhbm5vdCBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGZpbGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy9Vc2UgdGhlIHJlYWwgdmFyaWFibGVzIGZyb20gbm9kZVxuICAgICAgICAgICAgLy9Vc2UgbW9kdWxlLmV4cG9ydHMgZm9yIGV4cG9ydHMsIHNpbmNlXG4gICAgICAgICAgICAvL3RoZSBleHBvcnRzIGluIGhlcmUgaXMgYW1kZWZpbmUgZXhwb3J0cy5cbiAgICAgICAgICAgIGUgPSBtb2R1bGUuZXhwb3J0cztcbiAgICAgICAgICAgIG0gPSBtb2R1bGU7XG4gICAgICAgICAgICByID0gbWFrZVJlcXVpcmUocmVxdWlyZUZuLCBlLCBtLCBtb2R1bGUuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9JZiB0aGVyZSBhcmUgZGVwZW5kZW5jaWVzLCB0aGV5IGFyZSBzdHJpbmdzLCBzbyBuZWVkXG4gICAgICAgIC8vdG8gY29udmVydCB0aGVtIHRvIGRlcGVuZGVuY3kgdmFsdWVzLlxuICAgICAgICBpZiAoZGVwcykge1xuICAgICAgICAgICAgZGVwcyA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIoZGVwTmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vQ2FsbCB0aGUgZmFjdG9yeSB3aXRoIHRoZSByaWdodCBkZXBlbmRlbmNpZXMuXG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFjdG9yeS5hcHBseShtLmV4cG9ydHMsIGRlcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFjdG9yeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbS5leHBvcnRzID0gcmVzdWx0O1xuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgbG9hZGVyQ2FjaGVbaWRdID0gbS5leHBvcnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RyaW5nUmVxdWlyZSA9IGZ1bmN0aW9uIChzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIGlkLCByZWxJZCkge1xuICAgICAgICAvL1NwbGl0IHRoZSBJRCBieSBhICEgc28gdGhhdFxuICAgICAgICB2YXIgaW5kZXggPSBpZC5pbmRleE9mKCchJyksXG4gICAgICAgICAgICBvcmlnaW5hbElkID0gaWQsXG4gICAgICAgICAgICBwcmVmaXgsIHBsdWdpbjtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpZCA9IG5vcm1hbGl6ZShpZCwgcmVsSWQpO1xuXG4gICAgICAgICAgICAvL1N0cmFpZ2h0IG1vZHVsZSBsb29rdXAuIElmIGl0IGlzIG9uZSBvZiB0aGUgc3BlY2lhbCBkZXBlbmRlbmNpZXMsXG4gICAgICAgICAgICAvL2RlYWwgd2l0aCBpdCwgb3RoZXJ3aXNlLCBkZWxlZ2F0ZSB0byBub2RlLlxuICAgICAgICAgICAgaWYgKGlkID09PSAncmVxdWlyZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZVJlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCByZWxJZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkID09PSAnZXhwb3J0cycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQgPT09ICdtb2R1bGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG9hZGVyQ2FjaGUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVmaW5lQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICAgICAgcnVuRmFjdG9yeS5hcHBseShudWxsLCBkZWZpbmVDYWNoZVtpZF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKHN5c3RlbVJlcXVpcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5c3RlbVJlcXVpcmUob3JpZ2luYWxJZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtb2R1bGUgd2l0aCBJRDogJyArIGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL1RoZXJlIGlzIGEgcGx1Z2luIGluIHBsYXkuXG4gICAgICAgICAgICBwcmVmaXggPSBpZC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICAgICAgaWQgPSBpZC5zdWJzdHJpbmcoaW5kZXggKyAxLCBpZC5sZW5ndGgpO1xuXG4gICAgICAgICAgICBwbHVnaW4gPSBzdHJpbmdSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcHJlZml4LCByZWxJZCk7XG5cbiAgICAgICAgICAgIGlmIChwbHVnaW4ubm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBwbHVnaW4ubm9ybWFsaXplKGlkLCBtYWtlTm9ybWFsaXplKHJlbElkKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vTm9ybWFsaXplIHRoZSBJRCBub3JtYWxseS5cbiAgICAgICAgICAgICAgICBpZCA9IG5vcm1hbGl6ZShpZCwgcmVsSWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobG9hZGVyQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luLmxvYWQoaWQsIG1ha2VSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcmVsSWQpLCBtYWtlTG9hZChpZCksIHt9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9DcmVhdGUgYSBkZWZpbmUgZnVuY3Rpb24gc3BlY2lmaWMgdG8gdGhlIG1vZHVsZSBhc2tpbmcgZm9yIGFtZGVmaW5lLlxuICAgIGZ1bmN0aW9uIGRlZmluZShpZCwgZGVwcywgZmFjdG9yeSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpZCkpIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBkZXBzO1xuICAgICAgICAgICAgZGVwcyA9IGlkO1xuICAgICAgICAgICAgaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZmFjdG9yeSA9IGlkO1xuICAgICAgICAgICAgaWQgPSBkZXBzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlcHMgJiYgIUFycmF5LmlzQXJyYXkoZGVwcykpIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBkZXBzO1xuICAgICAgICAgICAgZGVwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGVwcykge1xuICAgICAgICAgICAgZGVwcyA9IFsncmVxdWlyZScsICdleHBvcnRzJywgJ21vZHVsZSddO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9TZXQgdXAgcHJvcGVydGllcyBmb3IgdGhpcyBtb2R1bGUuIElmIGFuIElELCB0aGVuIHVzZVxuICAgICAgICAvL2ludGVybmFsIGNhY2hlLiBJZiBubyBJRCwgdGhlbiB1c2UgdGhlIGV4dGVybmFsIHZhcmlhYmxlc1xuICAgICAgICAvL2ZvciB0aGlzIG5vZGUgbW9kdWxlLlxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIC8vUHV0IHRoZSBtb2R1bGUgaW4gZGVlcCBmcmVlemUgdW50aWwgdGhlcmUgaXMgYVxuICAgICAgICAgICAgLy9yZXF1aXJlIGNhbGwgZm9yIGl0LlxuICAgICAgICAgICAgZGVmaW5lQ2FjaGVbaWRdID0gW2lkLCBkZXBzLCBmYWN0b3J5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJ1bkZhY3RvcnkoaWQsIGRlcHMsIGZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9kZWZpbmUucmVxdWlyZSwgd2hpY2ggaGFzIGFjY2VzcyB0byBhbGwgdGhlIHZhbHVlcyBpbiB0aGVcbiAgICAvL2NhY2hlLiBVc2VmdWwgZm9yIEFNRCBtb2R1bGVzIHRoYXQgYWxsIGhhdmUgSURzIGluIHRoZSBmaWxlLFxuICAgIC8vYnV0IG5lZWQgdG8gZmluYWxseSBleHBvcnQgYSB2YWx1ZSB0byBub2RlIGJhc2VkIG9uIG9uZSBvZiB0aG9zZVxuICAgIC8vSURzLlxuICAgIGRlZmluZS5yZXF1aXJlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChsb2FkZXJDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmaW5lQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICBydW5GYWN0b3J5LmFwcGx5KG51bGwsIGRlZmluZUNhY2hlW2lkXSk7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGRlZmluZS5hbWQgPSB7fTtcblxuICAgIHJldHVybiBkZWZpbmU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYW1kZWZpbmU7XG4iLCIiLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE2IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZykpO1xuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcbiIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcbiIsIi8qKiBAbGljZW5zZVxuICogY3Jvc3Nyb2FkcyA8aHR0cDovL21pbGxlcm1lZGVpcm9zLmdpdGh1Yi5jb20vY3Jvc3Nyb2Fkcy5qcy8+XG4gKiBBdXRob3I6IE1pbGxlciBNZWRlaXJvcyB8IE1JVCBMaWNlbnNlXG4gKiB2MC4xMi4yICgyMDE1LzA3LzMxIDE4OjM3KVxuICovXG5cbihmdW5jdGlvbiAoKSB7XG52YXIgZmFjdG9yeSA9IGZ1bmN0aW9uIChzaWduYWxzKSB7XG5cbiAgICB2YXIgY3Jvc3Nyb2FkcyxcbiAgICAgICAgX2hhc09wdGlvbmFsR3JvdXBCdWcsXG4gICAgICAgIFVOREVGO1xuXG4gICAgLy8gSGVscGVycyAtLS0tLS0tLS0tLVxuICAgIC8vPT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIElFIDctOCBjYXB0dXJlIG9wdGlvbmFsIGdyb3VwcyBhcyBlbXB0eSBzdHJpbmdzIHdoaWxlIG90aGVyIGJyb3dzZXJzXG4gICAgLy8gY2FwdHVyZSBhcyBgdW5kZWZpbmVkYFxuICAgIF9oYXNPcHRpb25hbEdyb3VwQnVnID0gKC90KC4rKT8vKS5leGVjKCd0JylbMV0gPT09ICcnO1xuXG4gICAgZnVuY3Rpb24gYXJyYXlJbmRleE9mKGFyciwgdmFsKSB7XG4gICAgICAgIGlmIChhcnIuaW5kZXhPZikge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5pbmRleE9mKHZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL0FycmF5LmluZGV4T2YgZG9lc24ndCB3b3JrIG9uIElFIDYtN1xuICAgICAgICAgICAgdmFyIG4gPSBhcnIubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKG4tLSkge1xuICAgICAgICAgICAgICAgIGlmIChhcnJbbl0gPT09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcnJheVJlbW92ZShhcnIsIGl0ZW0pIHtcbiAgICAgICAgdmFyIGkgPSBhcnJheUluZGV4T2YoYXJyLCBpdGVtKTtcbiAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICBhcnIuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNLaW5kKHZhbCwga2luZCkge1xuICAgICAgICByZXR1cm4gJ1tvYmplY3QgJysga2luZCArJ10nID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1JlZ0V4cCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIGlzS2luZCh2YWwsICdSZWdFeHAnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICAgICAgICByZXR1cm4gaXNLaW5kKHZhbCwgJ0FycmF5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgLy9ib3Jyb3dlZCBmcm9tIEFNRC11dGlsc1xuICAgIGZ1bmN0aW9uIHR5cGVjYXN0VmFsdWUodmFsKSB7XG4gICAgICAgIHZhciByO1xuICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICByID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgciA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICByID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsID09PSBVTkRFRiB8fCB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByID0gVU5ERUY7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsID09PSAnJyB8fCBpc05hTih2YWwpKSB7XG4gICAgICAgICAgICAvL2lzTmFOKCcnKSByZXR1cm5zIGZhbHNlXG4gICAgICAgICAgICByID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9wYXJzZUZsb2F0KG51bGwgfHwgJycpIHJldHVybnMgTmFOXG4gICAgICAgICAgICByID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHR5cGVjYXN0QXJyYXlWYWx1ZXModmFsdWVzKSB7XG4gICAgICAgIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICByZXN1bHRbbl0gPSB0eXBlY2FzdFZhbHVlKHZhbHVlc1tuXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBib3Jyb3dlZCBmcm9tIE1PVVRcbiAgICBmdW5jdGlvbiBkZWNvZGVRdWVyeVN0cmluZyhxdWVyeVN0ciwgc2hvdWxkVHlwZWNhc3QpIHtcbiAgICAgICAgdmFyIHF1ZXJ5QXJyID0gKHF1ZXJ5U3RyIHx8ICcnKS5yZXBsYWNlKCc/JywgJycpLnNwbGl0KCcmJyksXG4gICAgICAgICAgICByZWcgPSAvKFtePV0rKT0oLispLyxcbiAgICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICAgIG9iaiA9IHt9LFxuICAgICAgICAgICAgZXF1YWxJbmRleCwgY3VyLCBwVmFsdWUsIHBOYW1lO1xuXG4gICAgICAgIHdoaWxlICgoY3VyID0gcXVlcnlBcnJbKytpXSkpIHtcbiAgICAgICAgICAgIGVxdWFsSW5kZXggPSBjdXIuaW5kZXhPZignPScpO1xuICAgICAgICAgICAgcE5hbWUgPSBjdXIuc3Vic3RyaW5nKDAsIGVxdWFsSW5kZXgpO1xuICAgICAgICAgICAgcFZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KGN1ci5zdWJzdHJpbmcoZXF1YWxJbmRleCArIDEpKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRUeXBlY2FzdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwVmFsdWUgPSB0eXBlY2FzdFZhbHVlKHBWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocE5hbWUgaW4gb2JqKXtcbiAgICAgICAgICAgICAgICBpZihpc0FycmF5KG9ialtwTmFtZV0pKXtcbiAgICAgICAgICAgICAgICAgICAgb2JqW3BOYW1lXS5wdXNoKHBWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW3BOYW1lXSA9IFtvYmpbcE5hbWVdLCBwVmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqW3BOYW1lXSA9IHBWYWx1ZTtcbiAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG5cbiAgICAvLyBDcm9zc3JvYWRzIC0tLS0tLS0tXG4gICAgLy89PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ3Jvc3Nyb2FkcygpIHtcbiAgICAgICAgdGhpcy5ieXBhc3NlZCA9IG5ldyBzaWduYWxzLlNpZ25hbCgpO1xuICAgICAgICB0aGlzLnJvdXRlZCA9IG5ldyBzaWduYWxzLlNpZ25hbCgpO1xuICAgICAgICB0aGlzLl9yb3V0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJldlJvdXRlcyA9IFtdO1xuICAgICAgICB0aGlzLl9waXBlZCA9IFtdO1xuICAgICAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbiAgICB9XG5cbiAgICBDcm9zc3JvYWRzLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBncmVlZHkgOiBmYWxzZSxcblxuICAgICAgICBncmVlZHlFbmFibGVkIDogdHJ1ZSxcblxuICAgICAgICBpZ25vcmVDYXNlIDogdHJ1ZSxcblxuICAgICAgICBpZ25vcmVTdGF0ZSA6IGZhbHNlLFxuXG4gICAgICAgIHNob3VsZFR5cGVjYXN0IDogZmFsc2UsXG5cbiAgICAgICAgbm9ybWFsaXplRm4gOiBudWxsLFxuXG4gICAgICAgIHJlc2V0U3RhdGUgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5fcHJldlJvdXRlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5fcHJldk1hdGNoZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZCeXBhc3NlZFJlcXVlc3QgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3Jvc3Nyb2FkcygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZFJvdXRlIDogZnVuY3Rpb24gKHBhdHRlcm4sIGNhbGxiYWNrLCBwcmlvcml0eSkge1xuICAgICAgICAgICAgdmFyIHJvdXRlID0gbmV3IFJvdXRlKHBhdHRlcm4sIGNhbGxiYWNrLCBwcmlvcml0eSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9zb3J0ZWRJbnNlcnQocm91dGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZVJvdXRlIDogZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgICAgICBhcnJheVJlbW92ZSh0aGlzLl9yb3V0ZXMsIHJvdXRlKTtcbiAgICAgICAgICAgIHJvdXRlLl9kZXN0cm95KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlQWxsUm91dGVzIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLmdldE51bVJvdXRlcygpO1xuICAgICAgICAgICAgd2hpbGUgKG4tLSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JvdXRlc1tuXS5fZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcm91dGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2UgOiBmdW5jdGlvbiAocmVxdWVzdCwgZGVmYXVsdEFyZ3MpIHtcbiAgICAgICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0IHx8ICcnO1xuICAgICAgICAgICAgZGVmYXVsdEFyZ3MgPSBkZWZhdWx0QXJncyB8fCBbXTtcblxuICAgICAgICAgICAgLy8gc2hvdWxkIG9ubHkgY2FyZSBhYm91dCBkaWZmZXJlbnQgcmVxdWVzdHMgaWYgaWdub3JlU3RhdGUgaXNuJ3QgdHJ1ZVxuICAgICAgICAgICAgaWYgKCAhdGhpcy5pZ25vcmVTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIChyZXF1ZXN0ID09PSB0aGlzLl9wcmV2TWF0Y2hlZFJlcXVlc3QgfHxcbiAgICAgICAgICAgICAgICAgcmVxdWVzdCA9PT0gdGhpcy5fcHJldkJ5cGFzc2VkUmVxdWVzdCkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcm91dGVzID0gdGhpcy5fZ2V0TWF0Y2hlZFJvdXRlcyhyZXF1ZXN0KSxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBuID0gcm91dGVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjdXI7XG5cbiAgICAgICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldk1hdGNoZWRSZXF1ZXN0ID0gcmVxdWVzdDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX25vdGlmeVByZXZSb3V0ZXMocm91dGVzLCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2Um91dGVzID0gcm91dGVzO1xuICAgICAgICAgICAgICAgIC8vc2hvdWxkIGJlIGluY3JlbWVudGFsIGxvb3AsIGV4ZWN1dGUgcm91dGVzIGluIG9yZGVyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IHJvdXRlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY3VyLnJvdXRlLm1hdGNoZWQuZGlzcGF0Y2guYXBwbHkoY3VyLnJvdXRlLm1hdGNoZWQsIGRlZmF1bHRBcmdzLmNvbmNhdChjdXIucGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5pc0ZpcnN0ID0gIWk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm91dGVkLmRpc3BhdGNoLmFwcGx5KHRoaXMucm91dGVkLCBkZWZhdWx0QXJncy5jb25jYXQoW3JlcXVlc3QsIGN1cl0pKTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldkJ5cGFzc2VkUmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5ieXBhc3NlZC5kaXNwYXRjaC5hcHBseSh0aGlzLmJ5cGFzc2VkLCBkZWZhdWx0QXJncy5jb25jYXQoW3JlcXVlc3RdKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3BpcGVQYXJzZShyZXF1ZXN0LCBkZWZhdWx0QXJncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX25vdGlmeVByZXZSb3V0ZXMgOiBmdW5jdGlvbihtYXRjaGVkUm91dGVzLCByZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgaSA9IDAsIHByZXY7XG4gICAgICAgICAgICB3aGlsZSAocHJldiA9IHRoaXMuX3ByZXZSb3V0ZXNbaSsrXSkge1xuICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgc3dpdGNoZWQgZXhpc3Qgc2luY2Ugcm91dGUgbWF5IGJlIGRpc3Bvc2VkXG4gICAgICAgICAgICAgICAgaWYocHJldi5yb3V0ZS5zd2l0Y2hlZCAmJiB0aGlzLl9kaWRTd2l0Y2gocHJldi5yb3V0ZSwgbWF0Y2hlZFJvdXRlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5yb3V0ZS5zd2l0Y2hlZC5kaXNwYXRjaChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RpZFN3aXRjaCA6IGZ1bmN0aW9uIChyb3V0ZSwgbWF0Y2hlZFJvdXRlcyl7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZCxcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaGVkID0gbWF0Y2hlZFJvdXRlc1tpKytdKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBkaXNwYXRjaCBzd2l0Y2hlZCBpZiBpdCBpcyBnb2luZyB0byBhIGRpZmZlcmVudCByb3V0ZVxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkLnJvdXRlID09PSByb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3BpcGVQYXJzZSA6IGZ1bmN0aW9uKHJlcXVlc3QsIGRlZmF1bHRBcmdzKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDAsIHJvdXRlO1xuICAgICAgICAgICAgd2hpbGUgKHJvdXRlID0gdGhpcy5fcGlwZWRbaSsrXSkge1xuICAgICAgICAgICAgICAgIHJvdXRlLnBhcnNlKHJlcXVlc3QsIGRlZmF1bHRBcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXROdW1Sb3V0ZXMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm91dGVzLmxlbmd0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBfc29ydGVkSW5zZXJ0IDogZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgICAgICAvL3NpbXBsaWZpZWQgaW5zZXJ0aW9uIHNvcnRcbiAgICAgICAgICAgIHZhciByb3V0ZXMgPSB0aGlzLl9yb3V0ZXMsXG4gICAgICAgICAgICAgICAgbiA9IHJvdXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBkbyB7IC0tbjsgfSB3aGlsZSAocm91dGVzW25dICYmIHJvdXRlLl9wcmlvcml0eSA8PSByb3V0ZXNbbl0uX3ByaW9yaXR5KTtcbiAgICAgICAgICAgIHJvdXRlcy5zcGxpY2UobisxLCAwLCByb3V0ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldE1hdGNoZWRSb3V0ZXMgOiBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IFtdLFxuICAgICAgICAgICAgICAgIHJvdXRlcyA9IHRoaXMuX3JvdXRlcyxcbiAgICAgICAgICAgICAgICBuID0gcm91dGVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICByb3V0ZTtcbiAgICAgICAgICAgIC8vc2hvdWxkIGJlIGRlY3JlbWVudCBsb29wIHNpbmNlIGhpZ2hlciBwcmlvcml0aWVzIGFyZSBhZGRlZCBhdCB0aGUgZW5kIG9mIGFycmF5XG4gICAgICAgICAgICB3aGlsZSAocm91dGUgPSByb3V0ZXNbLS1uXSkge1xuICAgICAgICAgICAgICAgIGlmICgoIXJlcy5sZW5ndGggfHwgdGhpcy5ncmVlZHkgfHwgcm91dGUuZ3JlZWR5KSAmJiByb3V0ZS5tYXRjaChyZXF1ZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZSA6IHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zIDogcm91dGUuX2dldFBhcmFtc0FycmF5KHJlcXVlc3QpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZ3JlZWR5RW5hYmxlZCAmJiByZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGlwZSA6IGZ1bmN0aW9uIChvdGhlclJvdXRlcikge1xuICAgICAgICAgICAgdGhpcy5fcGlwZWQucHVzaChvdGhlclJvdXRlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5waXBlIDogZnVuY3Rpb24gKG90aGVyUm91dGVyKSB7XG4gICAgICAgICAgICBhcnJheVJlbW92ZSh0aGlzLl9waXBlZCwgb3RoZXJSb3V0ZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdbY3Jvc3Nyb2FkcyBudW1Sb3V0ZXM6JysgdGhpcy5nZXROdW1Sb3V0ZXMoKSArJ10nO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vXCJzdGF0aWNcIiBpbnN0YW5jZVxuICAgIGNyb3Nzcm9hZHMgPSBuZXcgQ3Jvc3Nyb2FkcygpO1xuICAgIGNyb3Nzcm9hZHMuVkVSU0lPTiA9ICcwLjEyLjInO1xuXG4gICAgY3Jvc3Nyb2Fkcy5OT1JNX0FTX0FSUkFZID0gZnVuY3Rpb24gKHJlcSwgdmFscykge1xuICAgICAgICByZXR1cm4gW3ZhbHMudmFsc19dO1xuICAgIH07XG5cbiAgICBjcm9zc3JvYWRzLk5PUk1fQVNfT0JKRUNUID0gZnVuY3Rpb24gKHJlcSwgdmFscykge1xuICAgICAgICByZXR1cm4gW3ZhbHNdO1xuICAgIH07XG5cblxuICAgIC8vIFJvdXRlIC0tLS0tLS0tLS0tLS0tXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJvdXRlKHBhdHRlcm4sIGNhbGxiYWNrLCBwcmlvcml0eSwgcm91dGVyKSB7XG4gICAgICAgIHZhciBpc1JlZ2V4UGF0dGVybiA9IGlzUmVnRXhwKHBhdHRlcm4pLFxuICAgICAgICAgICAgcGF0dGVybkxleGVyID0gcm91dGVyLnBhdHRlcm5MZXhlcjtcbiAgICAgICAgdGhpcy5fcm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLl9wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgICAgdGhpcy5fcGFyYW1zSWRzID0gaXNSZWdleFBhdHRlcm4/IG51bGwgOiBwYXR0ZXJuTGV4ZXIuZ2V0UGFyYW1JZHMocGF0dGVybik7XG4gICAgICAgIHRoaXMuX29wdGlvbmFsUGFyYW1zSWRzID0gaXNSZWdleFBhdHRlcm4/IG51bGwgOiBwYXR0ZXJuTGV4ZXIuZ2V0T3B0aW9uYWxQYXJhbXNJZHMocGF0dGVybik7XG4gICAgICAgIHRoaXMuX21hdGNoUmVnZXhwID0gaXNSZWdleFBhdHRlcm4/IHBhdHRlcm4gOiBwYXR0ZXJuTGV4ZXIuY29tcGlsZVBhdHRlcm4ocGF0dGVybiwgcm91dGVyLmlnbm9yZUNhc2UpO1xuICAgICAgICB0aGlzLm1hdGNoZWQgPSBuZXcgc2lnbmFscy5TaWduYWwoKTtcbiAgICAgICAgdGhpcy5zd2l0Y2hlZCA9IG5ldyBzaWduYWxzLlNpZ25hbCgpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlZC5hZGQoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMDtcbiAgICB9XG5cbiAgICBSb3V0ZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgZ3JlZWR5IDogZmFsc2UsXG5cbiAgICAgICAgcnVsZXMgOiB2b2lkKDApLFxuXG4gICAgICAgIG1hdGNoIDogZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0IHx8ICcnO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hdGNoUmVnZXhwLnRlc3QocmVxdWVzdCkgJiYgdGhpcy5fdmFsaWRhdGVQYXJhbXMocmVxdWVzdCk7IC8vdmFsaWRhdGUgcGFyYW1zIGV2ZW4gaWYgcmVnZXhwIGJlY2F1c2Ugb2YgYHJlcXVlc3RfYCBydWxlLlxuICAgICAgICB9LFxuXG4gICAgICAgIF92YWxpZGF0ZVBhcmFtcyA6IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzLFxuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHRoaXMuX2dldFBhcmFtc09iamVjdChyZXF1ZXN0KSxcbiAgICAgICAgICAgICAgICBrZXk7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBydWxlcykge1xuICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZV8gaXNuJ3QgYSB2YWxpZGF0aW9uIHJ1bGUuLi4gKCMzOSlcbiAgICAgICAgICAgICAgICBpZihrZXkgIT09ICdub3JtYWxpemVfJyAmJiBydWxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICEgdGhpcy5faXNWYWxpZFBhcmFtKHJlcXVlc3QsIGtleSwgdmFsdWVzKSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfaXNWYWxpZFBhcmFtIDogZnVuY3Rpb24gKHJlcXVlc3QsIHByb3AsIHZhbHVlcykge1xuICAgICAgICAgICAgdmFyIHZhbGlkYXRpb25SdWxlID0gdGhpcy5ydWxlc1twcm9wXSxcbiAgICAgICAgICAgICAgICB2YWwgPSB2YWx1ZXNbcHJvcF0sXG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzUXVlcnkgPSAocHJvcC5pbmRleE9mKCc/JykgPT09IDApO1xuXG4gICAgICAgICAgICBpZiAodmFsID09IG51bGwgJiYgdGhpcy5fb3B0aW9uYWxQYXJhbXNJZHMgJiYgYXJyYXlJbmRleE9mKHRoaXMuX29wdGlvbmFsUGFyYW1zSWRzLCBwcm9wKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVnRXhwKHZhbGlkYXRpb25SdWxlKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbHVlc1twcm9wICsnXyddOyAvL3VzZSByYXcgc3RyaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzVmFsaWQgPSB2YWxpZGF0aW9uUnVsZS50ZXN0KHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5KHZhbGlkYXRpb25SdWxlKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbHVlc1twcm9wICsnXyddOyAvL3VzZSByYXcgc3RyaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzVmFsaWQgPSB0aGlzLl9pc1ZhbGlkQXJyYXlSdWxlKHZhbGlkYXRpb25SdWxlLCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbih2YWxpZGF0aW9uUnVsZSkpIHtcbiAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdmFsaWRhdGlvblJ1bGUodmFsLCByZXF1ZXN0LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaXNWYWxpZDsgLy9mYWlsIHNpbGVudGx5IGlmIHZhbGlkYXRpb25SdWxlIGlzIGZyb20gYW4gdW5zdXBwb3J0ZWQgdHlwZVxuICAgICAgICB9LFxuXG4gICAgICAgIF9pc1ZhbGlkQXJyYXlSdWxlIDogZnVuY3Rpb24gKGFyciwgdmFsKSB7XG4gICAgICAgICAgICBpZiAoISB0aGlzLl9yb3V0ZXIuaWdub3JlQ2FzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheUluZGV4T2YoYXJyLCB2YWwpICE9PSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gdmFsLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuID0gYXJyLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgIGNvbXBhcmVWYWw7XG5cbiAgICAgICAgICAgIHdoaWxlIChuLS0pIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gYXJyW25dO1xuICAgICAgICAgICAgICAgIGNvbXBhcmVWYWwgPSAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKT8gaXRlbS50b0xvd2VyQ2FzZSgpIDogaXRlbTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZVZhbCA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0UGFyYW1zT2JqZWN0IDogZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGRUeXBlY2FzdCA9IHRoaXMuX3JvdXRlci5zaG91bGRUeXBlY2FzdCxcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSB0aGlzLl9yb3V0ZXIucGF0dGVybkxleGVyLmdldFBhcmFtVmFsdWVzKHJlcXVlc3QsIHRoaXMuX21hdGNoUmVnZXhwLCBzaG91bGRUeXBlY2FzdCksXG4gICAgICAgICAgICAgICAgbyA9IHt9LFxuICAgICAgICAgICAgICAgIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHBhcmFtLCB2YWw7XG4gICAgICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gdmFsdWVzW25dO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wYXJhbXNJZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0gPSB0aGlzLl9wYXJhbXNJZHNbbl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleE9mKCc/JykgPT09IDAgJiYgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL21ha2UgYSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBzdHJpbmcgc28gYXJyYXkgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1JlZ0V4cCB2YWxpZGF0aW9uIGNhbiBiZSBhcHBsaWVkIHByb3Blcmx5XG4gICAgICAgICAgICAgICAgICAgICAgICBvW3BhcmFtICsnXyddID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy91cGRhdGUgdmFsc18gYXJyYXkgYXMgd2VsbCBzaW5jZSBpdCB3aWxsIGJlIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZHVyaW5nIGRpc3BhdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBkZWNvZGVRdWVyeVN0cmluZyh2YWwsIHNob3VsZFR5cGVjYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1tuXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJRSB3aWxsIGNhcHR1cmUgb3B0aW9uYWwgZ3JvdXBzIGFzIGVtcHR5IHN0cmluZ3Mgd2hpbGUgb3RoZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gYnJvd3NlcnMgd2lsbCBjYXB0dXJlIGB1bmRlZmluZWRgIHNvIG5vcm1hbGl6ZSBiZWhhdmlvci5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2VlOiAjZ2gtNTgsICNnaC01OSwgI2doLTYwXG4gICAgICAgICAgICAgICAgICAgIGlmICggX2hhc09wdGlvbmFsR3JvdXBCdWcgJiYgdmFsID09PSAnJyAmJiBhcnJheUluZGV4T2YodGhpcy5fb3B0aW9uYWxQYXJhbXNJZHMsIHBhcmFtKSAhPT0gLTEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB2b2lkKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzW25dID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9bcGFyYW1dID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2FsaWFzIHRvIHBhdGhzIGFuZCBmb3IgUmVnRXhwIHBhdHRlcm5cbiAgICAgICAgICAgICAgICBvW25dID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgby5yZXF1ZXN0XyA9IHNob3VsZFR5cGVjYXN0PyB0eXBlY2FzdFZhbHVlKHJlcXVlc3QpIDogcmVxdWVzdDtcbiAgICAgICAgICAgIG8udmFsc18gPSB2YWx1ZXM7XG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0UGFyYW1zQXJyYXkgOiBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICAgICAgdmFyIG5vcm0gPSB0aGlzLnJ1bGVzPyB0aGlzLnJ1bGVzLm5vcm1hbGl6ZV8gOiBudWxsLFxuICAgICAgICAgICAgICAgIHBhcmFtcztcbiAgICAgICAgICAgIG5vcm0gPSBub3JtIHx8IHRoaXMuX3JvdXRlci5ub3JtYWxpemVGbjsgLy8gZGVmYXVsdCBub3JtYWxpemVcbiAgICAgICAgICAgIGlmIChub3JtICYmIGlzRnVuY3Rpb24obm9ybSkpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBub3JtKHJlcXVlc3QsIHRoaXMuX2dldFBhcmFtc09iamVjdChyZXF1ZXN0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHRoaXMuX2dldFBhcmFtc09iamVjdChyZXF1ZXN0KS52YWxzXztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW50ZXJwb2xhdGUgOiBmdW5jdGlvbihyZXBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSB0aGlzLl9yb3V0ZXIucGF0dGVybkxleGVyLmludGVycG9sYXRlKHRoaXMuX3BhdHRlcm4sIHJlcGxhY2VtZW50cyk7XG4gICAgICAgICAgICBpZiAoISB0aGlzLl92YWxpZGF0ZVBhcmFtcyhzdHIpICkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2VuZXJhdGVkIHN0cmluZyBkb2VzblxcJ3QgdmFsaWRhdGUgYWdhaW5zdCBgUm91dGUucnVsZXNgLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcm91dGVyLnJlbW92ZVJvdXRlKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kZXN0cm95IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5tYXRjaGVkLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3dpdGNoZWQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5tYXRjaGVkID0gdGhpcy5zd2l0Y2hlZCA9IHRoaXMuX3BhdHRlcm4gPSB0aGlzLl9tYXRjaFJlZ2V4cCA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9TdHJpbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tSb3V0ZSBwYXR0ZXJuOlwiJysgdGhpcy5fcGF0dGVybiArJ1wiLCBudW1MaXN0ZW5lcnM6JysgdGhpcy5tYXRjaGVkLmdldE51bUxpc3RlbmVycygpICsnXSc7XG4gICAgICAgIH1cblxuICAgIH07XG5cblxuXG4gICAgLy8gUGF0dGVybiBMZXhlciAtLS0tLS1cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgQ3Jvc3Nyb2Fkcy5wcm90b3R5cGUucGF0dGVybkxleGVyID0gKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXJcbiAgICAgICAgICAgIC8vbWF0Y2ggY2hhcnMgdGhhdCBzaG91bGQgYmUgZXNjYXBlZCBvbiBzdHJpbmcgcmVnZXhwXG4gICAgICAgICAgICBFU0NBUEVfQ0hBUlNfUkVHRVhQID0gL1tcXFxcLisqP1xcXiRcXFtcXF0oKXt9XFwvJyNdL2csXG5cbiAgICAgICAgICAgIC8vdHJhaWxpbmcgc2xhc2hlcyAoYmVnaW4vZW5kIG9mIHN0cmluZylcbiAgICAgICAgICAgIExPT1NFX1NMQVNIRVNfUkVHRVhQID0gL15cXC98XFwvJC9nLFxuICAgICAgICAgICAgTEVHQUNZX1NMQVNIRVNfUkVHRVhQID0gL1xcLyQvZyxcblxuICAgICAgICAgICAgLy9wYXJhbXMgLSBldmVyeXRoaW5nIGJldHdlZW4gYHsgfWAgb3IgYDogOmBcbiAgICAgICAgICAgIFBBUkFNU19SRUdFWFAgPSAvKD86XFx7fDopKFtefTpdKykoPzpcXH18OikvZyxcblxuICAgICAgICAgICAgLy91c2VkIHRvIHNhdmUgcGFyYW1zIGR1cmluZyBjb21waWxlIChhdm9pZCBlc2NhcGluZyB0aGluZ3MgdGhhdFxuICAgICAgICAgICAgLy9zaG91bGRuJ3QgYmUgZXNjYXBlZCkuXG4gICAgICAgICAgICBUT0tFTlMgPSB7XG4gICAgICAgICAgICAgICAgJ09TJyA6IHtcbiAgICAgICAgICAgICAgICAgICAgLy9vcHRpb25hbCBzbGFzaGVzXG4gICAgICAgICAgICAgICAgICAgIC8vc2xhc2ggYmV0d2VlbiBgOjpgIG9yIGB9OmAgb3IgYFxcdzpgIG9yIGA6ez9gIG9yIGB9ez9gIG9yIGBcXHd7P2BcbiAgICAgICAgICAgICAgICAgICAgcmd4IDogLyhbOn1dfFxcdyg/PVxcLykpXFwvPyg6fCg/Olxce1xcPykpL2csXG4gICAgICAgICAgICAgICAgICAgIHNhdmUgOiAnJDF7e2lkfX0kMicsXG4gICAgICAgICAgICAgICAgICAgIHJlcyA6ICdcXFxcLz8nXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnUlMnIDoge1xuICAgICAgICAgICAgICAgICAgICAvL3JlcXVpcmVkIHNsYXNoZXNcbiAgICAgICAgICAgICAgICAgICAgLy91c2VkIHRvIGluc2VydCBzbGFzaCBiZXR3ZWVuIGA6e2AgYW5kIGB9e2BcbiAgICAgICAgICAgICAgICAgICAgcmd4IDogLyhbOn1dKVxcLz8oXFx7KS9nLFxuICAgICAgICAgICAgICAgICAgICBzYXZlIDogJyQxe3tpZH19JDInLFxuICAgICAgICAgICAgICAgICAgICByZXMgOiAnXFxcXC8nXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnUlEnIDoge1xuICAgICAgICAgICAgICAgICAgICAvL3JlcXVpcmVkIHF1ZXJ5IHN0cmluZyAtIGV2ZXJ5dGhpbmcgaW4gYmV0d2VlbiBgez8gfWBcbiAgICAgICAgICAgICAgICAgICAgcmd4IDogL1xce1xcPyhbXn1dKylcXH0vZyxcbiAgICAgICAgICAgICAgICAgICAgLy9ldmVyeXRoaW5nIGZyb20gYD9gIHRpbGwgYCNgIG9yIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgcmVzIDogJ1xcXFw/KFteI10rKSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdPUScgOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vb3B0aW9uYWwgcXVlcnkgc3RyaW5nIC0gZXZlcnl0aGluZyBpbiBiZXR3ZWVuIGA6PyA6YFxuICAgICAgICAgICAgICAgICAgICByZ3ggOiAvOlxcPyhbXjpdKyk6L2csXG4gICAgICAgICAgICAgICAgICAgIC8vZXZlcnl0aGluZyBmcm9tIGA/YCB0aWxsIGAjYCBvciBlbmQgb2Ygc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIHJlcyA6ICcoPzpcXFxcPyhbXiNdKikpPydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdPUicgOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vb3B0aW9uYWwgcmVzdCAtIGV2ZXJ5dGhpbmcgaW4gYmV0d2VlbiBgOiAqOmBcbiAgICAgICAgICAgICAgICAgICAgcmd4IDogLzooW146XSspXFwqOi9nLFxuICAgICAgICAgICAgICAgICAgICByZXMgOiAnKC4qKT8nIC8vIG9wdGlvbmFsIGdyb3VwIHRvIGF2b2lkIHBhc3NpbmcgZW1wdHkgc3RyaW5nIGFzIGNhcHR1cmVkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnUlInIDoge1xuICAgICAgICAgICAgICAgICAgICAvL3Jlc3QgcGFyYW0gLSBldmVyeXRoaW5nIGluIGJldHdlZW4gYHsgKn1gXG4gICAgICAgICAgICAgICAgICAgIHJneCA6IC9cXHsoW159XSspXFwqXFx9L2csXG4gICAgICAgICAgICAgICAgICAgIHJlcyA6ICcoLispJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gcmVxdWlyZWQvb3B0aW9uYWwgcGFyYW1zIHNob3VsZCBjb21lIGFmdGVyIHJlc3Qgc2VnbWVudHNcbiAgICAgICAgICAgICAgICAnUlAnIDoge1xuICAgICAgICAgICAgICAgICAgICAvL3JlcXVpcmVkIHBhcmFtcyAtIGV2ZXJ5dGhpbmcgYmV0d2VlbiBgeyB9YFxuICAgICAgICAgICAgICAgICAgICByZ3ggOiAvXFx7KFtefV0rKVxcfS9nLFxuICAgICAgICAgICAgICAgICAgICByZXMgOiAnKFteXFxcXC8/XSspJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ09QJyA6IHtcbiAgICAgICAgICAgICAgICAgICAgLy9vcHRpb25hbCBwYXJhbXMgLSBldmVyeXRoaW5nIGJldHdlZW4gYDogOmBcbiAgICAgICAgICAgICAgICAgICAgcmd4IDogLzooW146XSspOi9nLFxuICAgICAgICAgICAgICAgICAgICByZXMgOiAnKFteXFxcXC8/XSspP1xcLz8nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgTE9PU0VfU0xBU0ggPSAxLFxuICAgICAgICAgICAgU1RSSUNUX1NMQVNIID0gMixcbiAgICAgICAgICAgIExFR0FDWV9TTEFTSCA9IDMsXG5cbiAgICAgICAgICAgIF9zbGFzaE1vZGUgPSBMT09TRV9TTEFTSDtcblxuXG4gICAgICAgIGZ1bmN0aW9uIHByZWNvbXBpbGVUb2tlbnMoKXtcbiAgICAgICAgICAgIHZhciBrZXksIGN1cjtcbiAgICAgICAgICAgIGZvciAoa2V5IGluIFRPS0VOUykge1xuICAgICAgICAgICAgICAgIGlmIChUT0tFTlMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBUT0tFTlNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgY3VyLmlkID0gJ19fQ1JfJysga2V5ICsnX18nO1xuICAgICAgICAgICAgICAgICAgICBjdXIuc2F2ZSA9ICgnc2F2ZScgaW4gY3VyKT8gY3VyLnNhdmUucmVwbGFjZSgne3tpZH19JywgY3VyLmlkKSA6IGN1ci5pZDtcbiAgICAgICAgICAgICAgICAgICAgY3VyLnJSZXN0b3JlID0gbmV3IFJlZ0V4cChjdXIuaWQsICdnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZWNvbXBpbGVUb2tlbnMoKTtcblxuXG4gICAgICAgIGZ1bmN0aW9uIGNhcHR1cmVWYWxzKHJlZ2V4LCBwYXR0ZXJuKSB7XG4gICAgICAgICAgICB2YXIgdmFscyA9IFtdLCBtYXRjaDtcbiAgICAgICAgICAgIC8vIHZlcnkgaW1wb3J0YW50IHRvIHJlc2V0IGxhc3RJbmRleCBzaW5jZSBSZWdFeHAgY2FuIGhhdmUgXCJnXCIgZmxhZ1xuICAgICAgICAgICAgLy8gYW5kIG11bHRpcGxlIHJ1bnMgbWlnaHQgYWZmZWN0IHRoZSByZXN1bHQsIHNwZWNpYWxseSBpZiBtYXRjaGluZ1xuICAgICAgICAgICAgLy8gc2FtZSBzdHJpbmcgbXVsdGlwbGUgdGltZXMgb24gSUUgNy04XG4gICAgICAgICAgICByZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgd2hpbGUgKG1hdGNoID0gcmVnZXguZXhlYyhwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIHZhbHMucHVzaChtYXRjaFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFscztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFBhcmFtSWRzKHBhdHRlcm4pIHtcbiAgICAgICAgICAgIHJldHVybiBjYXB0dXJlVmFscyhQQVJBTVNfUkVHRVhQLCBwYXR0ZXJuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldE9wdGlvbmFsUGFyYW1zSWRzKHBhdHRlcm4pIHtcbiAgICAgICAgICAgIHJldHVybiBjYXB0dXJlVmFscyhUT0tFTlMuT1Aucmd4LCBwYXR0ZXJuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4sIGlnbm9yZUNhc2UpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuIHx8ICcnO1xuXG4gICAgICAgICAgICBpZihwYXR0ZXJuKXtcbiAgICAgICAgICAgICAgICBpZiAoX3NsYXNoTW9kZSA9PT0gTE9PU0VfU0xBU0gpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZShMT09TRV9TTEFTSEVTX1JFR0VYUCwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfc2xhc2hNb2RlID09PSBMRUdBQ1lfU0xBU0gpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZShMRUdBQ1lfU0xBU0hFU19SRUdFWFAsICcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL3NhdmUgdG9rZW5zXG4gICAgICAgICAgICAgICAgcGF0dGVybiA9IHJlcGxhY2VUb2tlbnMocGF0dGVybiwgJ3JneCcsICdzYXZlJyk7XG4gICAgICAgICAgICAgICAgLy9yZWdleHAgZXNjYXBlXG4gICAgICAgICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZShFU0NBUEVfQ0hBUlNfUkVHRVhQLCAnXFxcXCQmJyk7XG4gICAgICAgICAgICAgICAgLy9yZXN0b3JlIHRva2Vuc1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gPSByZXBsYWNlVG9rZW5zKHBhdHRlcm4sICdyUmVzdG9yZScsICdyZXMnKTtcblxuICAgICAgICAgICAgICAgIGlmIChfc2xhc2hNb2RlID09PSBMT09TRV9TTEFTSCkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gJ1xcXFwvPycrIHBhdHRlcm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoX3NsYXNoTW9kZSAhPT0gU1RSSUNUX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgLy9zaW5nbGUgc2xhc2ggaXMgdHJlYXRlZCBhcyBlbXB0eSBhbmQgZW5kIHNsYXNoIGlzIG9wdGlvbmFsXG4gICAgICAgICAgICAgICAgcGF0dGVybiArPSAnXFxcXC8/JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKCdeJysgcGF0dGVybiArICckJywgaWdub3JlQ2FzZT8gJ2knIDogJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZVRva2VucyhwYXR0ZXJuLCByZWdleHBOYW1lLCByZXBsYWNlTmFtZSkge1xuICAgICAgICAgICAgdmFyIGN1ciwga2V5O1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gVE9LRU5TKSB7XG4gICAgICAgICAgICAgICAgaWYgKFRPS0VOUy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IFRPS0VOU1trZXldO1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKGN1cltyZWdleHBOYW1lXSwgY3VyW3JlcGxhY2VOYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRQYXJhbVZhbHVlcyhyZXF1ZXN0LCByZWdleHAsIHNob3VsZFR5cGVjYXN0KSB7XG4gICAgICAgICAgICB2YXIgdmFscyA9IHJlZ2V4cC5leGVjKHJlcXVlc3QpO1xuICAgICAgICAgICAgaWYgKHZhbHMpIHtcbiAgICAgICAgICAgICAgICB2YWxzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFR5cGVjYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHMgPSB0eXBlY2FzdEFycmF5VmFsdWVzKHZhbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWxzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJwb2xhdGUocGF0dGVybiwgcmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGFuIGVtcHR5IG9iamVjdCBiZWNhdXNlIHBhdHRlcm4gbWlnaHQgaGF2ZSBqdXN0XG4gICAgICAgICAgICAvLyBvcHRpb25hbCBhcmd1bWVudHNcbiAgICAgICAgICAgIHJlcGxhY2VtZW50cyA9IHJlcGxhY2VtZW50cyB8fCB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JvdXRlIHBhdHRlcm4gc2hvdWxkIGJlIGEgc3RyaW5nLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVwbGFjZUZuID0gZnVuY3Rpb24obWF0Y2gsIHByb3Ape1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsO1xuICAgICAgICAgICAgICAgICAgICBwcm9wID0gKHByb3Auc3Vic3RyKDAsIDEpID09PSAnPycpPyBwcm9wLnN1YnN0cigxKSA6IHByb3A7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudHNbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlbWVudHNbcHJvcF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5UGFydHMgPSBbXSwgcmVwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIga2V5IGluIHJlcGxhY2VtZW50c1twcm9wXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXAgPSByZXBsYWNlbWVudHNbcHJvcF1ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkocmVwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiByZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGtleS5zbGljZSgtMikgPT0gJ1tdJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJ0cy5wdXNoKGVuY29kZVVSSShrZXkuc2xpY2UoMCwgLTIpKSArICdbXT0nICsgZW5jb2RlVVJJKHJlcFtrXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFydHMucHVzaChlbmNvZGVVUkkoa2V5ICsgJz0nICsgcmVwW2tdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJ0cy5wdXNoKGVuY29kZVVSSShrZXkgKyAnPScgKyByZXApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSAnPycgKyBxdWVyeVBhcnRzLmpvaW4oJyYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHZhbHVlIGlzIGEgc3RyaW5nIHNlZSAjZ2gtNTRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBTdHJpbmcocmVwbGFjZW1lbnRzW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLmluZGV4T2YoJyonKSA9PT0gLTEgJiYgdmFsLmluZGV4T2YoJy8nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgXCInKyB2YWwgKydcIiBmb3Igc2VnbWVudCBcIicrIG1hdGNoICsnXCIuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2guaW5kZXhPZigneycpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VnbWVudCAnKyBtYXRjaCArJyBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCEgVE9LRU5TLk9TLnRyYWlsKSB7XG4gICAgICAgICAgICAgICAgVE9LRU5TLk9TLnRyYWlsID0gbmV3IFJlZ0V4cCgnKD86JysgVE9LRU5TLk9TLmlkICsnKSskJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShUT0tFTlMuT1Mucmd4LCBUT0tFTlMuT1Muc2F2ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKFBBUkFNU19SRUdFWFAsIHJlcGxhY2VGbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKFRPS0VOUy5PUy50cmFpbCwgJycpIC8vIHJlbW92ZSB0cmFpbGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoVE9LRU5TLk9TLnJSZXN0b3JlLCAnLycpOyAvLyBhZGQgc2xhc2ggYmV0d2VlbiBzZWdtZW50c1xuICAgICAgICB9XG5cbiAgICAgICAgLy9BUElcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0cmljdCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgX3NsYXNoTW9kZSA9IFNUUklDVF9TTEFTSDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb29zZSA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgX3NsYXNoTW9kZSA9IExPT1NFX1NMQVNIO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlZ2FjeSA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgX3NsYXNoTW9kZSA9IExFR0FDWV9TTEFTSDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRQYXJhbUlkcyA6IGdldFBhcmFtSWRzLFxuICAgICAgICAgICAgZ2V0T3B0aW9uYWxQYXJhbXNJZHMgOiBnZXRPcHRpb25hbFBhcmFtc0lkcyxcbiAgICAgICAgICAgIGdldFBhcmFtVmFsdWVzIDogZ2V0UGFyYW1WYWx1ZXMsXG4gICAgICAgICAgICBjb21waWxlUGF0dGVybiA6IGNvbXBpbGVQYXR0ZXJuLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGUgOiBpbnRlcnBvbGF0ZVxuICAgICAgICB9O1xuXG4gICAgfSgpKTtcblxuXG4gICAgcmV0dXJuIGNyb3Nzcm9hZHM7XG59O1xuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnc2lnbmFscyddLCBmYWN0b3J5KTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHsgLy9Ob2RlXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3NpZ25hbHMnKSk7XG59IGVsc2Uge1xuICAgIC8qanNoaW50IHN1Yjp0cnVlICovXG4gICAgd2luZG93Wydjcm9zc3JvYWRzJ10gPSBmYWN0b3J5KHdpbmRvd1snc2lnbmFscyddKTtcbn1cblxufSgpKTtcblxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50OyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7IiwiaW1wb3J0IHJ1bnRpbWUgZnJvbSAnLi9oYW5kbGViYXJzLnJ1bnRpbWUnO1xuXG4vLyBDb21waWxlciBpbXBvcnRzXG5pbXBvcnQgQVNUIGZyb20gJy4vaGFuZGxlYmFycy9jb21waWxlci9hc3QnO1xuaW1wb3J0IHsgcGFyc2VyIGFzIFBhcnNlciwgcGFyc2UgfSBmcm9tICcuL2hhbmRsZWJhcnMvY29tcGlsZXIvYmFzZSc7XG5pbXBvcnQgeyBDb21waWxlciwgY29tcGlsZSwgcHJlY29tcGlsZSB9IGZyb20gJy4vaGFuZGxlYmFycy9jb21waWxlci9jb21waWxlcic7XG5pbXBvcnQgSmF2YVNjcmlwdENvbXBpbGVyIGZyb20gJy4vaGFuZGxlYmFycy9jb21waWxlci9qYXZhc2NyaXB0LWNvbXBpbGVyJztcbmltcG9ydCBWaXNpdG9yIGZyb20gJy4vaGFuZGxlYmFycy9jb21waWxlci92aXNpdG9yJztcblxuaW1wb3J0IG5vQ29uZmxpY3QgZnJvbSAnLi9oYW5kbGViYXJzL25vLWNvbmZsaWN0JztcblxubGV0IF9jcmVhdGUgPSBydW50aW1lLmNyZWF0ZTtcbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IGhiID0gX2NyZWF0ZSgpO1xuXG4gIGhiLmNvbXBpbGUgPSBmdW5jdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBjb21waWxlKGlucHV0LCBvcHRpb25zLCBoYik7XG4gIH07XG4gIGhiLnByZWNvbXBpbGUgPSBmdW5jdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBwcmVjb21waWxlKGlucHV0LCBvcHRpb25zLCBoYik7XG4gIH07XG5cbiAgaGIuQVNUID0gQVNUO1xuICBoYi5Db21waWxlciA9IENvbXBpbGVyO1xuICBoYi5KYXZhU2NyaXB0Q29tcGlsZXIgPSBKYXZhU2NyaXB0Q29tcGlsZXI7XG4gIGhiLlBhcnNlciA9IFBhcnNlcjtcbiAgaGIucGFyc2UgPSBwYXJzZTtcblxuICByZXR1cm4gaGI7XG59XG5cbmxldCBpbnN0ID0gY3JlYXRlKCk7XG5pbnN0LmNyZWF0ZSA9IGNyZWF0ZTtcblxubm9Db25mbGljdChpbnN0KTtcblxuaW5zdC5WaXNpdG9yID0gVmlzaXRvcjtcblxuaW5zdFsnZGVmYXVsdCddID0gaW5zdDtcblxuZXhwb3J0IGRlZmF1bHQgaW5zdDtcbiIsImltcG9ydCAqIGFzIGJhc2UgZnJvbSAnLi9oYW5kbGViYXJzL2Jhc2UnO1xuXG4vLyBFYWNoIG9mIHRoZXNlIGF1Z21lbnQgdGhlIEhhbmRsZWJhcnMgb2JqZWN0LiBObyBuZWVkIHRvIHNldHVwIGhlcmUuXG4vLyAoVGhpcyBpcyBkb25lIHRvIGVhc2lseSBzaGFyZSBjb2RlIGJldHdlZW4gY29tbW9uanMgYW5kIGJyb3dzZSBlbnZzKVxuaW1wb3J0IFNhZmVTdHJpbmcgZnJvbSAnLi9oYW5kbGViYXJzL3NhZmUtc3RyaW5nJztcbmltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi9oYW5kbGViYXJzL2V4Y2VwdGlvbic7XG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tICcuL2hhbmRsZWJhcnMvdXRpbHMnO1xuaW1wb3J0ICogYXMgcnVudGltZSBmcm9tICcuL2hhbmRsZWJhcnMvcnVudGltZSc7XG5cbmltcG9ydCBub0NvbmZsaWN0IGZyb20gJy4vaGFuZGxlYmFycy9uby1jb25mbGljdCc7XG5cbi8vIEZvciBjb21wYXRpYmlsaXR5IGFuZCB1c2FnZSBvdXRzaWRlIG9mIG1vZHVsZSBzeXN0ZW1zLCBtYWtlIHRoZSBIYW5kbGViYXJzIG9iamVjdCBhIG5hbWVzcGFjZVxuZnVuY3Rpb24gY3JlYXRlKCkge1xuICBsZXQgaGIgPSBuZXcgYmFzZS5IYW5kbGViYXJzRW52aXJvbm1lbnQoKTtcblxuICBVdGlscy5leHRlbmQoaGIsIGJhc2UpO1xuICBoYi5TYWZlU3RyaW5nID0gU2FmZVN0cmluZztcbiAgaGIuRXhjZXB0aW9uID0gRXhjZXB0aW9uO1xuICBoYi5VdGlscyA9IFV0aWxzO1xuICBoYi5lc2NhcGVFeHByZXNzaW9uID0gVXRpbHMuZXNjYXBlRXhwcmVzc2lvbjtcblxuICBoYi5WTSA9IHJ1bnRpbWU7XG4gIGhiLnRlbXBsYXRlID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHJldHVybiBydW50aW1lLnRlbXBsYXRlKHNwZWMsIGhiKTtcbiAgfTtcblxuICByZXR1cm4gaGI7XG59XG5cbmxldCBpbnN0ID0gY3JlYXRlKCk7XG5pbnN0LmNyZWF0ZSA9IGNyZWF0ZTtcblxubm9Db25mbGljdChpbnN0KTtcblxuaW5zdFsnZGVmYXVsdCddID0gaW5zdDtcblxuZXhwb3J0IGRlZmF1bHQgaW5zdDtcbiIsImltcG9ydCB7Y3JlYXRlRnJhbWUsIGV4dGVuZCwgdG9TdHJpbmd9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuL2V4Y2VwdGlvbic7XG5pbXBvcnQge3JlZ2lzdGVyRGVmYXVsdEhlbHBlcnN9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQge3JlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnN9IGZyb20gJy4vZGVjb3JhdG9ycyc7XG5pbXBvcnQgbG9nZ2VyIGZyb20gJy4vbG9nZ2VyJztcblxuZXhwb3J0IGNvbnN0IFZFUlNJT04gPSAnNC4wLjExJztcbmV4cG9ydCBjb25zdCBDT01QSUxFUl9SRVZJU0lPTiA9IDc7XG5cbmV4cG9ydCBjb25zdCBSRVZJU0lPTl9DSEFOR0VTID0ge1xuICAxOiAnPD0gMS4wLnJjLjInLCAvLyAxLjAucmMuMiBpcyBhY3R1YWxseSByZXYyIGJ1dCBkb2Vzbid0IHJlcG9ydCBpdFxuICAyOiAnPT0gMS4wLjAtcmMuMycsXG4gIDM6ICc9PSAxLjAuMC1yYy40JyxcbiAgNDogJz09IDEueC54JyxcbiAgNTogJz09IDIuMC4wLWFscGhhLngnLFxuICA2OiAnPj0gMi4wLjAtYmV0YS4xJyxcbiAgNzogJz49IDQuMC4wJ1xufTtcblxuY29uc3Qgb2JqZWN0VHlwZSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG5leHBvcnQgZnVuY3Rpb24gSGFuZGxlYmFyc0Vudmlyb25tZW50KGhlbHBlcnMsIHBhcnRpYWxzLCBkZWNvcmF0b3JzKSB7XG4gIHRoaXMuaGVscGVycyA9IGhlbHBlcnMgfHwge307XG4gIHRoaXMucGFydGlhbHMgPSBwYXJ0aWFscyB8fCB7fTtcbiAgdGhpcy5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycyB8fCB7fTtcblxuICByZWdpc3RlckRlZmF1bHRIZWxwZXJzKHRoaXMpO1xuICByZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzKHRoaXMpO1xufVxuXG5IYW5kbGViYXJzRW52aXJvbm1lbnQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogSGFuZGxlYmFyc0Vudmlyb25tZW50LFxuXG4gIGxvZ2dlcjogbG9nZ2VyLFxuICBsb2c6IGxvZ2dlci5sb2csXG5cbiAgcmVnaXN0ZXJIZWxwZXI6IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobmFtZSkgPT09IG9iamVjdFR5cGUpIHtcbiAgICAgIGlmIChmbikgeyB0aHJvdyBuZXcgRXhjZXB0aW9uKCdBcmcgbm90IHN1cHBvcnRlZCB3aXRoIG11bHRpcGxlIGhlbHBlcnMnKTsgfVxuICAgICAgZXh0ZW5kKHRoaXMuaGVscGVycywgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVscGVyc1tuYW1lXSA9IGZuO1xuICAgIH1cbiAgfSxcbiAgdW5yZWdpc3RlckhlbHBlcjogZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLmhlbHBlcnNbbmFtZV07XG4gIH0sXG5cbiAgcmVnaXN0ZXJQYXJ0aWFsOiBmdW5jdGlvbihuYW1lLCBwYXJ0aWFsKSB7XG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobmFtZSkgPT09IG9iamVjdFR5cGUpIHtcbiAgICAgIGV4dGVuZCh0aGlzLnBhcnRpYWxzLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBwYXJ0aWFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKGBBdHRlbXB0aW5nIHRvIHJlZ2lzdGVyIGEgcGFydGlhbCBjYWxsZWQgXCIke25hbWV9XCIgYXMgdW5kZWZpbmVkYCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhcnRpYWxzW25hbWVdID0gcGFydGlhbDtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXJQYXJ0aWFsOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMucGFydGlhbHNbbmFtZV07XG4gIH0sXG5cbiAgcmVnaXN0ZXJEZWNvcmF0b3I6IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobmFtZSkgPT09IG9iamVjdFR5cGUpIHtcbiAgICAgIGlmIChmbikgeyB0aHJvdyBuZXcgRXhjZXB0aW9uKCdBcmcgbm90IHN1cHBvcnRlZCB3aXRoIG11bHRpcGxlIGRlY29yYXRvcnMnKTsgfVxuICAgICAgZXh0ZW5kKHRoaXMuZGVjb3JhdG9ycywgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVjb3JhdG9yc1tuYW1lXSA9IGZuO1xuICAgIH1cbiAgfSxcbiAgdW5yZWdpc3RlckRlY29yYXRvcjogZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLmRlY29yYXRvcnNbbmFtZV07XG4gIH1cbn07XG5cbmV4cG9ydCBsZXQgbG9nID0gbG9nZ2VyLmxvZztcblxuZXhwb3J0IHtjcmVhdGVGcmFtZSwgbG9nZ2VyfTtcbiIsImxldCBBU1QgPSB7XG4gIC8vIFB1YmxpYyBBUEkgdXNlZCB0byBldmFsdWF0ZSBkZXJpdmVkIGF0dHJpYnV0ZXMgcmVnYXJkaW5nIEFTVCBub2Rlc1xuICBoZWxwZXJzOiB7XG4gICAgLy8gYSBtdXN0YWNoZSBpcyBkZWZpbml0ZWx5IGEgaGVscGVyIGlmOlxuICAgIC8vICogaXQgaXMgYW4gZWxpZ2libGUgaGVscGVyLCBhbmRcbiAgICAvLyAqIGl0IGhhcyBhdCBsZWFzdCBvbmUgcGFyYW1ldGVyIG9yIGhhc2ggc2VnbWVudFxuICAgIGhlbHBlckV4cHJlc3Npb246IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiAobm9kZS50eXBlID09PSAnU3ViRXhwcmVzc2lvbicpXG4gICAgICAgICAgfHwgKChub2RlLnR5cGUgPT09ICdNdXN0YWNoZVN0YXRlbWVudCcgfHwgbm9kZS50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnKVxuICAgICAgICAgICAgJiYgISEoKG5vZGUucGFyYW1zICYmIG5vZGUucGFyYW1zLmxlbmd0aCkgfHwgbm9kZS5oYXNoKSk7XG4gICAgfSxcblxuICAgIHNjb3BlZElkOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICByZXR1cm4gKC9eXFwufHRoaXNcXGIvKS50ZXN0KHBhdGgub3JpZ2luYWwpO1xuICAgIH0sXG5cbiAgICAvLyBhbiBJRCBpcyBzaW1wbGUgaWYgaXQgb25seSBoYXMgb25lIHBhcnQsIGFuZCB0aGF0IHBhcnQgaXMgbm90XG4gICAgLy8gYC4uYCBvciBgdGhpc2AuXG4gICAgc2ltcGxlSWQ6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLnBhcnRzLmxlbmd0aCA9PT0gMSAmJiAhQVNULmhlbHBlcnMuc2NvcGVkSWQocGF0aCkgJiYgIXBhdGguZGVwdGg7XG4gICAgfVxuICB9XG59O1xuXG5cbi8vIE11c3QgYmUgZXhwb3J0ZWQgYXMgYW4gb2JqZWN0IHJhdGhlciB0aGFuIHRoZSByb290IG9mIHRoZSBtb2R1bGUgYXMgdGhlIGppc29uIGxleGVyXG4vLyBtdXN0IG1vZGlmeSB0aGUgb2JqZWN0IHRvIG9wZXJhdGUgcHJvcGVybHkuXG5leHBvcnQgZGVmYXVsdCBBU1Q7XG4iLCJpbXBvcnQgcGFyc2VyIGZyb20gJy4vcGFyc2VyJztcbmltcG9ydCBXaGl0ZXNwYWNlQ29udHJvbCBmcm9tICcuL3doaXRlc3BhY2UtY29udHJvbCc7XG5pbXBvcnQgKiBhcyBIZWxwZXJzIGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCB7IHBhcnNlciB9O1xuXG5sZXQgeXkgPSB7fTtcbmV4dGVuZCh5eSwgSGVscGVycyk7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICAvLyBKdXN0IHJldHVybiBpZiBhbiBhbHJlYWR5LWNvbXBpbGVkIEFTVCB3YXMgcGFzc2VkIGluLlxuICBpZiAoaW5wdXQudHlwZSA9PT0gJ1Byb2dyYW0nKSB7IHJldHVybiBpbnB1dDsgfVxuXG4gIHBhcnNlci55eSA9IHl5O1xuXG4gIC8vIEFsdGVyaW5nIHRoZSBzaGFyZWQgb2JqZWN0IGhlcmUsIGJ1dCB0aGlzIGlzIG9rIGFzIHBhcnNlciBpcyBhIHN5bmMgb3BlcmF0aW9uXG4gIHl5LmxvY0luZm8gPSBmdW5jdGlvbihsb2NJbmZvKSB7XG4gICAgcmV0dXJuIG5ldyB5eS5Tb3VyY2VMb2NhdGlvbihvcHRpb25zICYmIG9wdGlvbnMuc3JjTmFtZSwgbG9jSW5mbyk7XG4gIH07XG5cbiAgbGV0IHN0cmlwID0gbmV3IFdoaXRlc3BhY2VDb250cm9sKG9wdGlvbnMpO1xuICByZXR1cm4gc3RyaXAuYWNjZXB0KHBhcnNlci5wYXJzZShpbnB1dCkpO1xufVxuIiwiLyogZ2xvYmFsIGRlZmluZSAqL1xuaW1wb3J0IHtpc0FycmF5fSBmcm9tICcuLi91dGlscyc7XG5cbmxldCBTb3VyY2VOb2RlO1xuXG50cnkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJyB8fCAhZGVmaW5lLmFtZCkge1xuICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgdGhpcyBpbiBBTUQgZW52aXJvbm1lbnRzLiBGb3IgdGhlc2UgZW52aXJvbm1lbnRzLCB3ZSBhc3VzbWUgdGhhdFxuICAgIC8vIHRoZXkgYXJlIHJ1bm5pbmcgb24gdGhlIGJyb3dzZXIgYW5kIHRodXMgaGF2ZSBubyBuZWVkIGZvciB0aGUgc291cmNlLW1hcCBsaWJyYXJ5LlxuICAgIGxldCBTb3VyY2VNYXAgPSByZXF1aXJlKCdzb3VyY2UtbWFwJyk7XG4gICAgU291cmNlTm9kZSA9IFNvdXJjZU1hcC5Tb3VyY2VOb2RlO1xuICB9XG59IGNhdGNoIChlcnIpIHtcbiAgLyogTk9QICovXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZjogdGVzdGVkIGJ1dCBub3QgY292ZXJlZCBpbiBpc3RhbmJ1bCBkdWUgdG8gZGlzdCBidWlsZCAgKi9cbmlmICghU291cmNlTm9kZSkge1xuICBTb3VyY2VOb2RlID0gZnVuY3Rpb24obGluZSwgY29sdW1uLCBzcmNGaWxlLCBjaHVua3MpIHtcbiAgICB0aGlzLnNyYyA9ICcnO1xuICAgIGlmIChjaHVua3MpIHtcbiAgICAgIHRoaXMuYWRkKGNodW5rcyk7XG4gICAgfVxuICB9O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZSA9IHtcbiAgICBhZGQ6IGZ1bmN0aW9uKGNodW5rcykge1xuICAgICAgaWYgKGlzQXJyYXkoY2h1bmtzKSkge1xuICAgICAgICBjaHVua3MgPSBjaHVua3Muam9pbignJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnNyYyArPSBjaHVua3M7XG4gICAgfSxcbiAgICBwcmVwZW5kOiBmdW5jdGlvbihjaHVua3MpIHtcbiAgICAgIGlmIChpc0FycmF5KGNodW5rcykpIHtcbiAgICAgICAgY2h1bmtzID0gY2h1bmtzLmpvaW4oJycpO1xuICAgICAgfVxuICAgICAgdGhpcy5zcmMgPSBjaHVua3MgKyB0aGlzLnNyYztcbiAgICB9LFxuICAgIHRvU3RyaW5nV2l0aFNvdXJjZU1hcDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge2NvZGU6IHRoaXMudG9TdHJpbmcoKX07XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcmM7XG4gICAgfVxuICB9O1xufVxuXG5cbmZ1bmN0aW9uIGNhc3RDaHVuayhjaHVuaywgY29kZUdlbiwgbG9jKSB7XG4gIGlmIChpc0FycmF5KGNodW5rKSkge1xuICAgIGxldCByZXQgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjaHVuay5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmV0LnB1c2goY29kZUdlbi53cmFwKGNodW5rW2ldLCBsb2MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgY2h1bmsgPT09ICdudW1iZXInKSB7XG4gICAgLy8gSGFuZGxlIHByaW1pdGl2ZXMgdGhhdCB0aGUgU291cmNlTm9kZSB3aWxsIHRocm93IHVwIG9uXG4gICAgcmV0dXJuIGNodW5rICsgJyc7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5cbmZ1bmN0aW9uIENvZGVHZW4oc3JjRmlsZSkge1xuICB0aGlzLnNyY0ZpbGUgPSBzcmNGaWxlO1xuICB0aGlzLnNvdXJjZSA9IFtdO1xufVxuXG5Db2RlR2VuLnByb3RvdHlwZSA9IHtcbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gIXRoaXMuc291cmNlLmxlbmd0aDtcbiAgfSxcbiAgcHJlcGVuZDogZnVuY3Rpb24oc291cmNlLCBsb2MpIHtcbiAgICB0aGlzLnNvdXJjZS51bnNoaWZ0KHRoaXMud3JhcChzb3VyY2UsIGxvYykpO1xuICB9LFxuICBwdXNoOiBmdW5jdGlvbihzb3VyY2UsIGxvYykge1xuICAgIHRoaXMuc291cmNlLnB1c2godGhpcy53cmFwKHNvdXJjZSwgbG9jKSk7XG4gIH0sXG5cbiAgbWVyZ2U6IGZ1bmN0aW9uKCkge1xuICAgIGxldCBzb3VyY2UgPSB0aGlzLmVtcHR5KCk7XG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHNvdXJjZS5hZGQoWycgICcsIGxpbmUsICdcXG4nXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfSxcblxuICBlYWNoOiBmdW5jdGlvbihpdGVyKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuc291cmNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpdGVyKHRoaXMuc291cmNlW2ldKTtcbiAgICB9XG4gIH0sXG5cbiAgZW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgIGxldCBsb2MgPSB0aGlzLmN1cnJlbnRMb2NhdGlvbiB8fCB7c3RhcnQ6IHt9fTtcbiAgICByZXR1cm4gbmV3IFNvdXJjZU5vZGUobG9jLnN0YXJ0LmxpbmUsIGxvYy5zdGFydC5jb2x1bW4sIHRoaXMuc3JjRmlsZSk7XG4gIH0sXG4gIHdyYXA6IGZ1bmN0aW9uKGNodW5rLCBsb2MgPSB0aGlzLmN1cnJlbnRMb2NhdGlvbiB8fCB7c3RhcnQ6IHt9fSkge1xuICAgIGlmIChjaHVuayBpbnN0YW5jZW9mIFNvdXJjZU5vZGUpIHtcbiAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG5cbiAgICBjaHVuayA9IGNhc3RDaHVuayhjaHVuaywgdGhpcywgbG9jKTtcblxuICAgIHJldHVybiBuZXcgU291cmNlTm9kZShsb2Muc3RhcnQubGluZSwgbG9jLnN0YXJ0LmNvbHVtbiwgdGhpcy5zcmNGaWxlLCBjaHVuayk7XG4gIH0sXG5cbiAgZnVuY3Rpb25DYWxsOiBmdW5jdGlvbihmbiwgdHlwZSwgcGFyYW1zKSB7XG4gICAgcGFyYW1zID0gdGhpcy5nZW5lcmF0ZUxpc3QocGFyYW1zKTtcbiAgICByZXR1cm4gdGhpcy53cmFwKFtmbiwgdHlwZSA/ICcuJyArIHR5cGUgKyAnKCcgOiAnKCcsIHBhcmFtcywgJyknXSk7XG4gIH0sXG5cbiAgcXVvdGVkU3RyaW5nOiBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gJ1wiJyArIChzdHIgKyAnJylcbiAgICAgIC5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpXG4gICAgICAucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpXG4gICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpXG4gICAgICAucmVwbGFjZSgvXFxyL2csICdcXFxccicpXG4gICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JykgICAvLyBQZXIgRWNtYS0yNjIgNy4zICsgNy44LjRcbiAgICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKSArICdcIic7XG4gIH0sXG5cbiAgb2JqZWN0TGl0ZXJhbDogZnVuY3Rpb24ob2JqKSB7XG4gICAgbGV0IHBhaXJzID0gW107XG5cbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gY2FzdENodW5rKG9ialtrZXldLCB0aGlzKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHBhaXJzLnB1c2goW3RoaXMucXVvdGVkU3RyaW5nKGtleSksICc6JywgdmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCByZXQgPSB0aGlzLmdlbmVyYXRlTGlzdChwYWlycyk7XG4gICAgcmV0LnByZXBlbmQoJ3snKTtcbiAgICByZXQuYWRkKCd9Jyk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuXG4gIGdlbmVyYXRlTGlzdDogZnVuY3Rpb24oZW50cmllcykge1xuICAgIGxldCByZXQgPSB0aGlzLmVtcHR5KCk7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZW50cmllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGkpIHtcbiAgICAgICAgcmV0LmFkZCgnLCcpO1xuICAgICAgfVxuXG4gICAgICByZXQuYWRkKGNhc3RDaHVuayhlbnRyaWVzW2ldLCB0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBnZW5lcmF0ZUFycmF5OiBmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgbGV0IHJldCA9IHRoaXMuZ2VuZXJhdGVMaXN0KGVudHJpZXMpO1xuICAgIHJldC5wcmVwZW5kKCdbJyk7XG4gICAgcmV0LmFkZCgnXScpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQ29kZUdlbjtcblxuIiwiLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xuXG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4uL2V4Y2VwdGlvbic7XG5pbXBvcnQge2lzQXJyYXksIGluZGV4T2YsIGV4dGVuZH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IEFTVCBmcm9tICcuL2FzdCc7XG5cbmNvbnN0IHNsaWNlID0gW10uc2xpY2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBDb21waWxlcigpIHt9XG5cbi8vIHRoZSBmb3VuZEhlbHBlciByZWdpc3RlciB3aWxsIGRpc2FtYmlndWF0ZSBoZWxwZXIgbG9va3VwIGZyb20gZmluZGluZyBhXG4vLyBmdW5jdGlvbiBpbiBhIGNvbnRleHQuIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciBtdXN0YWNoZSBjb21wYXRpYmlsaXR5LCB3aGljaFxuLy8gcmVxdWlyZXMgdGhhdCBjb250ZXh0IGZ1bmN0aW9ucyBpbiBibG9ja3MgYXJlIGV2YWx1YXRlZCBieSBibG9ja0hlbHBlck1pc3NpbmcsXG4vLyBhbmQgdGhlbiBwcm9jZWVkIGFzIGlmIHRoZSByZXN1bHRpbmcgdmFsdWUgd2FzIHByb3ZpZGVkIHRvIGJsb2NrSGVscGVyTWlzc2luZy5cblxuQ29tcGlsZXIucHJvdG90eXBlID0ge1xuICBjb21waWxlcjogQ29tcGlsZXIsXG5cbiAgZXF1YWxzOiBmdW5jdGlvbihvdGhlcikge1xuICAgIGxldCBsZW4gPSB0aGlzLm9wY29kZXMubGVuZ3RoO1xuICAgIGlmIChvdGhlci5vcGNvZGVzLmxlbmd0aCAhPT0gbGVuKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGV0IG9wY29kZSA9IHRoaXMub3Bjb2Rlc1tpXSxcbiAgICAgICAgICBvdGhlck9wY29kZSA9IG90aGVyLm9wY29kZXNbaV07XG4gICAgICBpZiAob3Bjb2RlLm9wY29kZSAhPT0gb3RoZXJPcGNvZGUub3Bjb2RlIHx8ICFhcmdFcXVhbHMob3Bjb2RlLmFyZ3MsIG90aGVyT3Bjb2RlLmFyZ3MpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZSBrbm93IHRoYXQgbGVuZ3RoIGlzIHRoZSBzYW1lIGJldHdlZW4gdGhlIHR3byBhcnJheXMgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSB0aWVkXG4gICAgLy8gdG8gdGhlIG9wY29kZSBiZWhhdmlvciBhYm92ZS5cbiAgICBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuY2hpbGRyZW5baV0uZXF1YWxzKG90aGVyLmNoaWxkcmVuW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgZ3VpZDogMCxcblxuICBjb21waWxlOiBmdW5jdGlvbihwcm9ncmFtLCBvcHRpb25zKSB7XG4gICAgdGhpcy5zb3VyY2VOb2RlID0gW107XG4gICAgdGhpcy5vcGNvZGVzID0gW107XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zdHJpbmdQYXJhbXMgPSBvcHRpb25zLnN0cmluZ1BhcmFtcztcbiAgICB0aGlzLnRyYWNrSWRzID0gb3B0aW9ucy50cmFja0lkcztcblxuICAgIG9wdGlvbnMuYmxvY2tQYXJhbXMgPSBvcHRpb25zLmJsb2NrUGFyYW1zIHx8IFtdO1xuXG4gICAgLy8gVGhlc2UgY2hhbmdlcyB3aWxsIHByb3BhZ2F0ZSB0byB0aGUgb3RoZXIgY29tcGlsZXIgY29tcG9uZW50c1xuICAgIGxldCBrbm93bkhlbHBlcnMgPSBvcHRpb25zLmtub3duSGVscGVycztcbiAgICBvcHRpb25zLmtub3duSGVscGVycyA9IHtcbiAgICAgICdoZWxwZXJNaXNzaW5nJzogdHJ1ZSxcbiAgICAgICdibG9ja0hlbHBlck1pc3NpbmcnOiB0cnVlLFxuICAgICAgJ2VhY2gnOiB0cnVlLFxuICAgICAgJ2lmJzogdHJ1ZSxcbiAgICAgICd1bmxlc3MnOiB0cnVlLFxuICAgICAgJ3dpdGgnOiB0cnVlLFxuICAgICAgJ2xvZyc6IHRydWUsXG4gICAgICAnbG9va3VwJzogdHJ1ZVxuICAgIH07XG4gICAgaWYgKGtub3duSGVscGVycykge1xuICAgICAgZm9yIChsZXQgbmFtZSBpbiBrbm93bkhlbHBlcnMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKG5hbWUgaW4ga25vd25IZWxwZXJzKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmtub3duSGVscGVyc1tuYW1lXSA9IGtub3duSGVscGVyc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFjY2VwdChwcm9ncmFtKTtcbiAgfSxcblxuICBjb21waWxlUHJvZ3JhbTogZnVuY3Rpb24ocHJvZ3JhbSkge1xuICAgIGxldCBjaGlsZENvbXBpbGVyID0gbmV3IHRoaXMuY29tcGlsZXIoKSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgICAgIHJlc3VsdCA9IGNoaWxkQ29tcGlsZXIuY29tcGlsZShwcm9ncmFtLCB0aGlzLm9wdGlvbnMpLFxuICAgICAgICBndWlkID0gdGhpcy5ndWlkKys7XG5cbiAgICB0aGlzLnVzZVBhcnRpYWwgPSB0aGlzLnVzZVBhcnRpYWwgfHwgcmVzdWx0LnVzZVBhcnRpYWw7XG5cbiAgICB0aGlzLmNoaWxkcmVuW2d1aWRdID0gcmVzdWx0O1xuICAgIHRoaXMudXNlRGVwdGhzID0gdGhpcy51c2VEZXB0aHMgfHwgcmVzdWx0LnVzZURlcHRocztcblxuICAgIHJldHVybiBndWlkO1xuICB9LFxuXG4gIGFjY2VwdDogZnVuY3Rpb24obm9kZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBTYW5pdHkgY29kZSAqL1xuICAgIGlmICghdGhpc1tub2RlLnR5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdVbmtub3duIHR5cGU6ICcgKyBub2RlLnR5cGUsIG5vZGUpO1xuICAgIH1cblxuICAgIHRoaXMuc291cmNlTm9kZS51bnNoaWZ0KG5vZGUpO1xuICAgIGxldCByZXQgPSB0aGlzW25vZGUudHlwZV0obm9kZSk7XG4gICAgdGhpcy5zb3VyY2VOb2RlLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBQcm9ncmFtOiBmdW5jdGlvbihwcm9ncmFtKSB7XG4gICAgdGhpcy5vcHRpb25zLmJsb2NrUGFyYW1zLnVuc2hpZnQocHJvZ3JhbS5ibG9ja1BhcmFtcyk7XG5cbiAgICBsZXQgYm9keSA9IHByb2dyYW0uYm9keSxcbiAgICAgICAgYm9keUxlbmd0aCA9IGJvZHkubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9keUxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmFjY2VwdChib2R5W2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMuYmxvY2tQYXJhbXMuc2hpZnQoKTtcblxuICAgIHRoaXMuaXNTaW1wbGUgPSBib2R5TGVuZ3RoID09PSAxO1xuICAgIHRoaXMuYmxvY2tQYXJhbXMgPSBwcm9ncmFtLmJsb2NrUGFyYW1zID8gcHJvZ3JhbS5ibG9ja1BhcmFtcy5sZW5ndGggOiAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgQmxvY2tTdGF0ZW1lbnQ6IGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgdHJhbnNmb3JtTGl0ZXJhbFRvUGF0aChibG9jayk7XG5cbiAgICBsZXQgcHJvZ3JhbSA9IGJsb2NrLnByb2dyYW0sXG4gICAgICAgIGludmVyc2UgPSBibG9jay5pbnZlcnNlO1xuXG4gICAgcHJvZ3JhbSA9IHByb2dyYW0gJiYgdGhpcy5jb21waWxlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBpbnZlcnNlID0gaW52ZXJzZSAmJiB0aGlzLmNvbXBpbGVQcm9ncmFtKGludmVyc2UpO1xuXG4gICAgbGV0IHR5cGUgPSB0aGlzLmNsYXNzaWZ5U2V4cHIoYmxvY2spO1xuXG4gICAgaWYgKHR5cGUgPT09ICdoZWxwZXInKSB7XG4gICAgICB0aGlzLmhlbHBlclNleHByKGJsb2NrLCBwcm9ncmFtLCBpbnZlcnNlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzaW1wbGUnKSB7XG4gICAgICB0aGlzLnNpbXBsZVNleHByKGJsb2NrKTtcblxuICAgICAgLy8gbm93IHRoYXQgdGhlIHNpbXBsZSBtdXN0YWNoZSBpcyByZXNvbHZlZCwgd2UgbmVlZCB0b1xuICAgICAgLy8gZXZhbHVhdGUgaXQgYnkgZXhlY3V0aW5nIGBibG9ja0hlbHBlck1pc3NpbmdgXG4gICAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBwcm9ncmFtKTtcbiAgICAgIHRoaXMub3Bjb2RlKCdwdXNoUHJvZ3JhbScsIGludmVyc2UpO1xuICAgICAgdGhpcy5vcGNvZGUoJ2VtcHR5SGFzaCcpO1xuICAgICAgdGhpcy5vcGNvZGUoJ2Jsb2NrVmFsdWUnLCBibG9jay5wYXRoLm9yaWdpbmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hbWJpZ3VvdXNTZXhwcihibG9jaywgcHJvZ3JhbSwgaW52ZXJzZSk7XG5cbiAgICAgIC8vIG5vdyB0aGF0IHRoZSBzaW1wbGUgbXVzdGFjaGUgaXMgcmVzb2x2ZWQsIHdlIG5lZWQgdG9cbiAgICAgIC8vIGV2YWx1YXRlIGl0IGJ5IGV4ZWN1dGluZyBgYmxvY2tIZWxwZXJNaXNzaW5nYFxuICAgICAgdGhpcy5vcGNvZGUoJ3B1c2hQcm9ncmFtJywgcHJvZ3JhbSk7XG4gICAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBpbnZlcnNlKTtcbiAgICAgIHRoaXMub3Bjb2RlKCdlbXB0eUhhc2gnKTtcbiAgICAgIHRoaXMub3Bjb2RlKCdhbWJpZ3VvdXNCbG9ja1ZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5vcGNvZGUoJ2FwcGVuZCcpO1xuICB9LFxuXG4gIERlY29yYXRvckJsb2NrKGRlY29yYXRvcikge1xuICAgIGxldCBwcm9ncmFtID0gZGVjb3JhdG9yLnByb2dyYW0gJiYgdGhpcy5jb21waWxlUHJvZ3JhbShkZWNvcmF0b3IucHJvZ3JhbSk7XG4gICAgbGV0IHBhcmFtcyA9IHRoaXMuc2V0dXBGdWxsTXVzdGFjaGVQYXJhbXMoZGVjb3JhdG9yLCBwcm9ncmFtLCB1bmRlZmluZWQpLFxuICAgICAgICBwYXRoID0gZGVjb3JhdG9yLnBhdGg7XG5cbiAgICB0aGlzLnVzZURlY29yYXRvcnMgPSB0cnVlO1xuICAgIHRoaXMub3Bjb2RlKCdyZWdpc3RlckRlY29yYXRvcicsIHBhcmFtcy5sZW5ndGgsIHBhdGgub3JpZ2luYWwpO1xuICB9LFxuXG4gIFBhcnRpYWxTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHBhcnRpYWwpIHtcbiAgICB0aGlzLnVzZVBhcnRpYWwgPSB0cnVlO1xuXG4gICAgbGV0IHByb2dyYW0gPSBwYXJ0aWFsLnByb2dyYW07XG4gICAgaWYgKHByb2dyYW0pIHtcbiAgICAgIHByb2dyYW0gPSB0aGlzLmNvbXBpbGVQcm9ncmFtKHBhcnRpYWwucHJvZ3JhbSk7XG4gICAgfVxuXG4gICAgbGV0IHBhcmFtcyA9IHBhcnRpYWwucGFyYW1zO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgbnVtYmVyIG9mIHBhcnRpYWwgYXJndW1lbnRzOiAnICsgcGFyYW1zLmxlbmd0aCwgcGFydGlhbCk7XG4gICAgfSBlbHNlIGlmICghcGFyYW1zLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHBsaWNpdFBhcnRpYWxDb250ZXh0KSB7XG4gICAgICAgIHRoaXMub3Bjb2RlKCdwdXNoTGl0ZXJhbCcsICd1bmRlZmluZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKHt0eXBlOiAnUGF0aEV4cHJlc3Npb24nLCBwYXJ0czogW10sIGRlcHRoOiAwfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHBhcnRpYWxOYW1lID0gcGFydGlhbC5uYW1lLm9yaWdpbmFsLFxuICAgICAgICBpc0R5bmFtaWMgPSBwYXJ0aWFsLm5hbWUudHlwZSA9PT0gJ1N1YkV4cHJlc3Npb24nO1xuICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgIHRoaXMuYWNjZXB0KHBhcnRpYWwubmFtZSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXR1cEZ1bGxNdXN0YWNoZVBhcmFtcyhwYXJ0aWFsLCBwcm9ncmFtLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgbGV0IGluZGVudCA9IHBhcnRpYWwuaW5kZW50IHx8ICcnO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucHJldmVudEluZGVudCAmJiBpbmRlbnQpIHtcbiAgICAgIHRoaXMub3Bjb2RlKCdhcHBlbmRDb250ZW50JywgaW5kZW50KTtcbiAgICAgIGluZGVudCA9ICcnO1xuICAgIH1cblxuICAgIHRoaXMub3Bjb2RlKCdpbnZva2VQYXJ0aWFsJywgaXNEeW5hbWljLCBwYXJ0aWFsTmFtZSwgaW5kZW50KTtcbiAgICB0aGlzLm9wY29kZSgnYXBwZW5kJyk7XG4gIH0sXG4gIFBhcnRpYWxCbG9ja1N0YXRlbWVudDogZnVuY3Rpb24ocGFydGlhbEJsb2NrKSB7XG4gICAgdGhpcy5QYXJ0aWFsU3RhdGVtZW50KHBhcnRpYWxCbG9jayk7XG4gIH0sXG5cbiAgTXVzdGFjaGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uKG11c3RhY2hlKSB7XG4gICAgdGhpcy5TdWJFeHByZXNzaW9uKG11c3RhY2hlKTtcblxuICAgIGlmIChtdXN0YWNoZS5lc2NhcGVkICYmICF0aGlzLm9wdGlvbnMubm9Fc2NhcGUpIHtcbiAgICAgIHRoaXMub3Bjb2RlKCdhcHBlbmRFc2NhcGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3Bjb2RlKCdhcHBlbmQnKTtcbiAgICB9XG4gIH0sXG4gIERlY29yYXRvcihkZWNvcmF0b3IpIHtcbiAgICB0aGlzLkRlY29yYXRvckJsb2NrKGRlY29yYXRvcik7XG4gIH0sXG5cblxuICBDb250ZW50U3RhdGVtZW50OiBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgaWYgKGNvbnRlbnQudmFsdWUpIHtcbiAgICAgIHRoaXMub3Bjb2RlKCdhcHBlbmRDb250ZW50JywgY29udGVudC52YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIENvbW1lbnRTdGF0ZW1lbnQ6IGZ1bmN0aW9uKCkge30sXG5cbiAgU3ViRXhwcmVzc2lvbjogZnVuY3Rpb24oc2V4cHIpIHtcbiAgICB0cmFuc2Zvcm1MaXRlcmFsVG9QYXRoKHNleHByKTtcbiAgICBsZXQgdHlwZSA9IHRoaXMuY2xhc3NpZnlTZXhwcihzZXhwcik7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3NpbXBsZScpIHtcbiAgICAgIHRoaXMuc2ltcGxlU2V4cHIoc2V4cHIpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2hlbHBlcicpIHtcbiAgICAgIHRoaXMuaGVscGVyU2V4cHIoc2V4cHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFtYmlndW91c1NleHByKHNleHByKTtcbiAgICB9XG4gIH0sXG4gIGFtYmlndW91c1NleHByOiBmdW5jdGlvbihzZXhwciwgcHJvZ3JhbSwgaW52ZXJzZSkge1xuICAgIGxldCBwYXRoID0gc2V4cHIucGF0aCxcbiAgICAgICAgbmFtZSA9IHBhdGgucGFydHNbMF0sXG4gICAgICAgIGlzQmxvY2sgPSBwcm9ncmFtICE9IG51bGwgfHwgaW52ZXJzZSAhPSBudWxsO1xuXG4gICAgdGhpcy5vcGNvZGUoJ2dldENvbnRleHQnLCBwYXRoLmRlcHRoKTtcblxuICAgIHRoaXMub3Bjb2RlKCdwdXNoUHJvZ3JhbScsIHByb2dyYW0pO1xuICAgIHRoaXMub3Bjb2RlKCdwdXNoUHJvZ3JhbScsIGludmVyc2UpO1xuXG4gICAgcGF0aC5zdHJpY3QgPSB0cnVlO1xuICAgIHRoaXMuYWNjZXB0KHBhdGgpO1xuXG4gICAgdGhpcy5vcGNvZGUoJ2ludm9rZUFtYmlndW91cycsIG5hbWUsIGlzQmxvY2spO1xuICB9LFxuXG4gIHNpbXBsZVNleHByOiBmdW5jdGlvbihzZXhwcikge1xuICAgIGxldCBwYXRoID0gc2V4cHIucGF0aDtcbiAgICBwYXRoLnN0cmljdCA9IHRydWU7XG4gICAgdGhpcy5hY2NlcHQocGF0aCk7XG4gICAgdGhpcy5vcGNvZGUoJ3Jlc29sdmVQb3NzaWJsZUxhbWJkYScpO1xuICB9LFxuXG4gIGhlbHBlclNleHByOiBmdW5jdGlvbihzZXhwciwgcHJvZ3JhbSwgaW52ZXJzZSkge1xuICAgIGxldCBwYXJhbXMgPSB0aGlzLnNldHVwRnVsbE11c3RhY2hlUGFyYW1zKHNleHByLCBwcm9ncmFtLCBpbnZlcnNlKSxcbiAgICAgICAgcGF0aCA9IHNleHByLnBhdGgsXG4gICAgICAgIG5hbWUgPSBwYXRoLnBhcnRzWzBdO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5rbm93bkhlbHBlcnNbbmFtZV0pIHtcbiAgICAgIHRoaXMub3Bjb2RlKCdpbnZva2VLbm93bkhlbHBlcicsIHBhcmFtcy5sZW5ndGgsIG5hbWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmtub3duSGVscGVyc09ubHkpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1lvdSBzcGVjaWZpZWQga25vd25IZWxwZXJzT25seSwgYnV0IHVzZWQgdGhlIHVua25vd24gaGVscGVyICcgKyBuYW1lLCBzZXhwcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGguc3RyaWN0ID0gdHJ1ZTtcbiAgICAgIHBhdGguZmFsc3kgPSB0cnVlO1xuXG4gICAgICB0aGlzLmFjY2VwdChwYXRoKTtcbiAgICAgIHRoaXMub3Bjb2RlKCdpbnZva2VIZWxwZXInLCBwYXJhbXMubGVuZ3RoLCBwYXRoLm9yaWdpbmFsLCBBU1QuaGVscGVycy5zaW1wbGVJZChwYXRoKSk7XG4gICAgfVxuICB9LFxuXG4gIFBhdGhFeHByZXNzaW9uOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgdGhpcy5hZGREZXB0aChwYXRoLmRlcHRoKTtcbiAgICB0aGlzLm9wY29kZSgnZ2V0Q29udGV4dCcsIHBhdGguZGVwdGgpO1xuXG4gICAgbGV0IG5hbWUgPSBwYXRoLnBhcnRzWzBdLFxuICAgICAgICBzY29wZWQgPSBBU1QuaGVscGVycy5zY29wZWRJZChwYXRoKSxcbiAgICAgICAgYmxvY2tQYXJhbUlkID0gIXBhdGguZGVwdGggJiYgIXNjb3BlZCAmJiB0aGlzLmJsb2NrUGFyYW1JbmRleChuYW1lKTtcblxuICAgIGlmIChibG9ja1BhcmFtSWQpIHtcbiAgICAgIHRoaXMub3Bjb2RlKCdsb29rdXBCbG9ja1BhcmFtJywgYmxvY2tQYXJhbUlkLCBwYXRoLnBhcnRzKTtcbiAgICB9IGVsc2UgaWYgKCFuYW1lKSB7XG4gICAgICAvLyBDb250ZXh0IHJlZmVyZW5jZSwgaS5lLiBge3tmb28gLn19YCBvciBge3tmb28gLi59fWBcbiAgICAgIHRoaXMub3Bjb2RlKCdwdXNoQ29udGV4dCcpO1xuICAgIH0gZWxzZSBpZiAocGF0aC5kYXRhKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZGF0YSA9IHRydWU7XG4gICAgICB0aGlzLm9wY29kZSgnbG9va3VwRGF0YScsIHBhdGguZGVwdGgsIHBhdGgucGFydHMsIHBhdGguc3RyaWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcGNvZGUoJ2xvb2t1cE9uQ29udGV4dCcsIHBhdGgucGFydHMsIHBhdGguZmFsc3ksIHBhdGguc3RyaWN0LCBzY29wZWQpO1xuICAgIH1cbiAgfSxcblxuICBTdHJpbmdMaXRlcmFsOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB0aGlzLm9wY29kZSgncHVzaFN0cmluZycsIHN0cmluZy52YWx1ZSk7XG4gIH0sXG5cbiAgTnVtYmVyTGl0ZXJhbDogZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgdGhpcy5vcGNvZGUoJ3B1c2hMaXRlcmFsJywgbnVtYmVyLnZhbHVlKTtcbiAgfSxcblxuICBCb29sZWFuTGl0ZXJhbDogZnVuY3Rpb24oYm9vbCkge1xuICAgIHRoaXMub3Bjb2RlKCdwdXNoTGl0ZXJhbCcsIGJvb2wudmFsdWUpO1xuICB9LFxuXG4gIFVuZGVmaW5lZExpdGVyYWw6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub3Bjb2RlKCdwdXNoTGl0ZXJhbCcsICd1bmRlZmluZWQnKTtcbiAgfSxcblxuICBOdWxsTGl0ZXJhbDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vcGNvZGUoJ3B1c2hMaXRlcmFsJywgJ251bGwnKTtcbiAgfSxcblxuICBIYXNoOiBmdW5jdGlvbihoYXNoKSB7XG4gICAgbGV0IHBhaXJzID0gaGFzaC5wYWlycyxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGwgPSBwYWlycy5sZW5ndGg7XG5cbiAgICB0aGlzLm9wY29kZSgncHVzaEhhc2gnKTtcblxuICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLnB1c2hQYXJhbShwYWlyc1tpXS52YWx1ZSk7XG4gICAgfVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMub3Bjb2RlKCdhc3NpZ25Ub0hhc2gnLCBwYWlyc1tpXS5rZXkpO1xuICAgIH1cbiAgICB0aGlzLm9wY29kZSgncG9wSGFzaCcpO1xuICB9LFxuXG4gIC8vIEhFTFBFUlNcbiAgb3Bjb2RlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdGhpcy5vcGNvZGVzLnB1c2goeyBvcGNvZGU6IG5hbWUsIGFyZ3M6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgbG9jOiB0aGlzLnNvdXJjZU5vZGVbMF0ubG9jIH0pO1xuICB9LFxuXG4gIGFkZERlcHRoOiBmdW5jdGlvbihkZXB0aCkge1xuICAgIGlmICghZGVwdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnVzZURlcHRocyA9IHRydWU7XG4gIH0sXG5cbiAgY2xhc3NpZnlTZXhwcjogZnVuY3Rpb24oc2V4cHIpIHtcbiAgICBsZXQgaXNTaW1wbGUgPSBBU1QuaGVscGVycy5zaW1wbGVJZChzZXhwci5wYXRoKTtcblxuICAgIGxldCBpc0Jsb2NrUGFyYW0gPSBpc1NpbXBsZSAmJiAhIXRoaXMuYmxvY2tQYXJhbUluZGV4KHNleHByLnBhdGgucGFydHNbMF0pO1xuXG4gICAgLy8gYSBtdXN0YWNoZSBpcyBhbiBlbGlnaWJsZSBoZWxwZXIgaWY6XG4gICAgLy8gKiBpdHMgaWQgaXMgc2ltcGxlIChhIHNpbmdsZSBwYXJ0LCBub3QgYHRoaXNgIG9yIGAuLmApXG4gICAgbGV0IGlzSGVscGVyID0gIWlzQmxvY2tQYXJhbSAmJiBBU1QuaGVscGVycy5oZWxwZXJFeHByZXNzaW9uKHNleHByKTtcblxuICAgIC8vIGlmIGEgbXVzdGFjaGUgaXMgYW4gZWxpZ2libGUgaGVscGVyIGJ1dCBub3QgYSBkZWZpbml0ZVxuICAgIC8vIGhlbHBlciwgaXQgaXMgYW1iaWd1b3VzLCBhbmQgd2lsbCBiZSByZXNvbHZlZCBpbiBhIGxhdGVyXG4gICAgLy8gcGFzcyBvciBhdCBydW50aW1lLlxuICAgIGxldCBpc0VsaWdpYmxlID0gIWlzQmxvY2tQYXJhbSAmJiAoaXNIZWxwZXIgfHwgaXNTaW1wbGUpO1xuXG4gICAgLy8gaWYgYW1iaWd1b3VzLCB3ZSBjYW4gcG9zc2libHkgcmVzb2x2ZSB0aGUgYW1iaWd1aXR5IG5vd1xuICAgIC8vIEFuIGVsaWdpYmxlIGhlbHBlciBpcyBvbmUgdGhhdCBkb2VzIG5vdCBoYXZlIGEgY29tcGxleCBwYXRoLCBpLmUuIGB0aGlzLmZvb2AsIGAuLi9mb29gIGV0Yy5cbiAgICBpZiAoaXNFbGlnaWJsZSAmJiAhaXNIZWxwZXIpIHtcbiAgICAgIGxldCBuYW1lID0gc2V4cHIucGF0aC5wYXJ0c1swXSxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICBpZiAob3B0aW9ucy5rbm93bkhlbHBlcnNbbmFtZV0pIHtcbiAgICAgICAgaXNIZWxwZXIgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmtub3duSGVscGVyc09ubHkpIHtcbiAgICAgICAgaXNFbGlnaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0hlbHBlcikge1xuICAgICAgcmV0dXJuICdoZWxwZXInO1xuICAgIH0gZWxzZSBpZiAoaXNFbGlnaWJsZSkge1xuICAgICAgcmV0dXJuICdhbWJpZ3VvdXMnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ3NpbXBsZSc7XG4gICAgfVxuICB9LFxuXG4gIHB1c2hQYXJhbXM6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gcGFyYW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5wdXNoUGFyYW0ocGFyYW1zW2ldKTtcbiAgICB9XG4gIH0sXG5cbiAgcHVzaFBhcmFtOiBmdW5jdGlvbih2YWwpIHtcbiAgICBsZXQgdmFsdWUgPSB2YWwudmFsdWUgIT0gbnVsbCA/IHZhbC52YWx1ZSA6IHZhbC5vcmlnaW5hbCB8fCAnJztcblxuICAgIGlmICh0aGlzLnN0cmluZ1BhcmFtcykge1xuICAgICAgaWYgKHZhbHVlLnJlcGxhY2UpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVxuICAgICAgICAgICAgLnJlcGxhY2UoL14oXFwuP1xcLlxcLykqL2csICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcLy9nLCAnLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsLmRlcHRoKSB7XG4gICAgICAgIHRoaXMuYWRkRGVwdGgodmFsLmRlcHRoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3Bjb2RlKCdnZXRDb250ZXh0JywgdmFsLmRlcHRoIHx8IDApO1xuICAgICAgdGhpcy5vcGNvZGUoJ3B1c2hTdHJpbmdQYXJhbScsIHZhbHVlLCB2YWwudHlwZSk7XG5cbiAgICAgIGlmICh2YWwudHlwZSA9PT0gJ1N1YkV4cHJlc3Npb24nKSB7XG4gICAgICAgIC8vIFN1YkV4cHJlc3Npb25zIGdldCBldmFsdWF0ZWQgYW5kIHBhc3NlZCBpblxuICAgICAgICAvLyBpbiBzdHJpbmcgcGFyYW1zIG1vZGUuXG4gICAgICAgIHRoaXMuYWNjZXB0KHZhbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLnRyYWNrSWRzKSB7XG4gICAgICAgIGxldCBibG9ja1BhcmFtSW5kZXg7XG4gICAgICAgIGlmICh2YWwucGFydHMgJiYgIUFTVC5oZWxwZXJzLnNjb3BlZElkKHZhbCkgJiYgIXZhbC5kZXB0aCkge1xuICAgICAgICAgICBibG9ja1BhcmFtSW5kZXggPSB0aGlzLmJsb2NrUGFyYW1JbmRleCh2YWwucGFydHNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibG9ja1BhcmFtSW5kZXgpIHtcbiAgICAgICAgICBsZXQgYmxvY2tQYXJhbUNoaWxkID0gdmFsLnBhcnRzLnNsaWNlKDEpLmpvaW4oJy4nKTtcbiAgICAgICAgICB0aGlzLm9wY29kZSgncHVzaElkJywgJ0Jsb2NrUGFyYW0nLCBibG9ja1BhcmFtSW5kZXgsIGJsb2NrUGFyYW1DaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWwub3JpZ2luYWwgfHwgdmFsdWU7XG4gICAgICAgICAgaWYgKHZhbHVlLnJlcGxhY2UpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXnRoaXMoPzpcXC58JCkvLCAnJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXlxcLlxcLy8sICcnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eXFwuJC8sICcnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm9wY29kZSgncHVzaElkJywgdmFsLnR5cGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5hY2NlcHQodmFsKTtcbiAgICB9XG4gIH0sXG5cbiAgc2V0dXBGdWxsTXVzdGFjaGVQYXJhbXM6IGZ1bmN0aW9uKHNleHByLCBwcm9ncmFtLCBpbnZlcnNlLCBvbWl0RW1wdHkpIHtcbiAgICBsZXQgcGFyYW1zID0gc2V4cHIucGFyYW1zO1xuICAgIHRoaXMucHVzaFBhcmFtcyhwYXJhbXMpO1xuXG4gICAgdGhpcy5vcGNvZGUoJ3B1c2hQcm9ncmFtJywgcHJvZ3JhbSk7XG4gICAgdGhpcy5vcGNvZGUoJ3B1c2hQcm9ncmFtJywgaW52ZXJzZSk7XG5cbiAgICBpZiAoc2V4cHIuaGFzaCkge1xuICAgICAgdGhpcy5hY2NlcHQoc2V4cHIuaGFzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3Bjb2RlKCdlbXB0eUhhc2gnLCBvbWl0RW1wdHkpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH0sXG5cbiAgYmxvY2tQYXJhbUluZGV4OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgZm9yIChsZXQgZGVwdGggPSAwLCBsZW4gPSB0aGlzLm9wdGlvbnMuYmxvY2tQYXJhbXMubGVuZ3RoOyBkZXB0aCA8IGxlbjsgZGVwdGgrKykge1xuICAgICAgbGV0IGJsb2NrUGFyYW1zID0gdGhpcy5vcHRpb25zLmJsb2NrUGFyYW1zW2RlcHRoXSxcbiAgICAgICAgICBwYXJhbSA9IGJsb2NrUGFyYW1zICYmIGluZGV4T2YoYmxvY2tQYXJhbXMsIG5hbWUpO1xuICAgICAgaWYgKGJsb2NrUGFyYW1zICYmIHBhcmFtID49IDApIHtcbiAgICAgICAgcmV0dXJuIFtkZXB0aCwgcGFyYW1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHByZWNvbXBpbGUoaW5wdXQsIG9wdGlvbnMsIGVudikge1xuICBpZiAoaW5wdXQgPT0gbnVsbCB8fCAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJyAmJiBpbnB1dC50eXBlICE9PSAnUHJvZ3JhbScpKSB7XG4gICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignWW91IG11c3QgcGFzcyBhIHN0cmluZyBvciBIYW5kbGViYXJzIEFTVCB0byBIYW5kbGViYXJzLnByZWNvbXBpbGUuIFlvdSBwYXNzZWQgJyArIGlucHV0KTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoISgnZGF0YScgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmRhdGEgPSB0cnVlO1xuICB9XG4gIGlmIChvcHRpb25zLmNvbXBhdCkge1xuICAgIG9wdGlvbnMudXNlRGVwdGhzID0gdHJ1ZTtcbiAgfVxuXG4gIGxldCBhc3QgPSBlbnYucGFyc2UoaW5wdXQsIG9wdGlvbnMpLFxuICAgICAgZW52aXJvbm1lbnQgPSBuZXcgZW52LkNvbXBpbGVyKCkuY29tcGlsZShhc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gbmV3IGVudi5KYXZhU2NyaXB0Q29tcGlsZXIoKS5jb21waWxlKGVudmlyb25tZW50LCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGUoaW5wdXQsIG9wdGlvbnMgPSB7fSwgZW52KSB7XG4gIGlmIChpbnB1dCA9PSBudWxsIHx8ICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnICYmIGlucHV0LnR5cGUgIT09ICdQcm9ncmFtJykpIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdZb3UgbXVzdCBwYXNzIGEgc3RyaW5nIG9yIEhhbmRsZWJhcnMgQVNUIHRvIEhhbmRsZWJhcnMuY29tcGlsZS4gWW91IHBhc3NlZCAnICsgaW5wdXQpO1xuICB9XG5cbiAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gIGlmICghKCdkYXRhJyBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMuZGF0YSA9IHRydWU7XG4gIH1cbiAgaWYgKG9wdGlvbnMuY29tcGF0KSB7XG4gICAgb3B0aW9ucy51c2VEZXB0aHMgPSB0cnVlO1xuICB9XG5cbiAgbGV0IGNvbXBpbGVkO1xuXG4gIGZ1bmN0aW9uIGNvbXBpbGVJbnB1dCgpIHtcbiAgICBsZXQgYXN0ID0gZW52LnBhcnNlKGlucHV0LCBvcHRpb25zKSxcbiAgICAgICAgZW52aXJvbm1lbnQgPSBuZXcgZW52LkNvbXBpbGVyKCkuY29tcGlsZShhc3QsIG9wdGlvbnMpLFxuICAgICAgICB0ZW1wbGF0ZVNwZWMgPSBuZXcgZW52LkphdmFTY3JpcHRDb21waWxlcigpLmNvbXBpbGUoZW52aXJvbm1lbnQsIG9wdGlvbnMsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgcmV0dXJuIGVudi50ZW1wbGF0ZSh0ZW1wbGF0ZVNwZWMpO1xuICB9XG5cbiAgLy8gVGVtcGxhdGUgaXMgb25seSBjb21waWxlZCBvbiBmaXJzdCB1c2UgYW5kIGNhY2hlZCBhZnRlciB0aGF0IHBvaW50LlxuICBmdW5jdGlvbiByZXQoY29udGV4dCwgZXhlY09wdGlvbnMpIHtcbiAgICBpZiAoIWNvbXBpbGVkKSB7XG4gICAgICBjb21waWxlZCA9IGNvbXBpbGVJbnB1dCgpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGlsZWQuY2FsbCh0aGlzLCBjb250ZXh0LCBleGVjT3B0aW9ucyk7XG4gIH1cbiAgcmV0Ll9zZXR1cCA9IGZ1bmN0aW9uKHNldHVwT3B0aW9ucykge1xuICAgIGlmICghY29tcGlsZWQpIHtcbiAgICAgIGNvbXBpbGVkID0gY29tcGlsZUlucHV0KCk7XG4gICAgfVxuICAgIHJldHVybiBjb21waWxlZC5fc2V0dXAoc2V0dXBPcHRpb25zKTtcbiAgfTtcbiAgcmV0Ll9jaGlsZCA9IGZ1bmN0aW9uKGksIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcbiAgICBpZiAoIWNvbXBpbGVkKSB7XG4gICAgICBjb21waWxlZCA9IGNvbXBpbGVJbnB1dCgpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGlsZWQuX2NoaWxkKGksIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICB9O1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBhcmdFcXVhbHMoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkoYSkgJiYgaXNBcnJheShiKSAmJiBhLmxlbmd0aCA9PT0gYi5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghYXJnRXF1YWxzKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTGl0ZXJhbFRvUGF0aChzZXhwcikge1xuICBpZiAoIXNleHByLnBhdGgucGFydHMpIHtcbiAgICBsZXQgbGl0ZXJhbCA9IHNleHByLnBhdGg7XG4gICAgLy8gQ2FzdGluZyB0byBzdHJpbmcgaGVyZSB0byBtYWtlIGZhbHNlIGFuZCAwIGxpdGVyYWwgdmFsdWVzIHBsYXkgbmljZWx5IHdpdGggdGhlIHJlc3RcbiAgICAvLyBvZiB0aGUgc3lzdGVtLlxuICAgIHNleHByLnBhdGggPSB7XG4gICAgICB0eXBlOiAnUGF0aEV4cHJlc3Npb24nLFxuICAgICAgZGF0YTogZmFsc2UsXG4gICAgICBkZXB0aDogMCxcbiAgICAgIHBhcnRzOiBbbGl0ZXJhbC5vcmlnaW5hbCArICcnXSxcbiAgICAgIG9yaWdpbmFsOiBsaXRlcmFsLm9yaWdpbmFsICsgJycsXG4gICAgICBsb2M6IGxpdGVyYWwubG9jXG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuLi9leGNlcHRpb24nO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUNsb3NlKG9wZW4sIGNsb3NlKSB7XG4gIGNsb3NlID0gY2xvc2UucGF0aCA/IGNsb3NlLnBhdGgub3JpZ2luYWwgOiBjbG9zZTtcblxuICBpZiAob3Blbi5wYXRoLm9yaWdpbmFsICE9PSBjbG9zZSkge1xuICAgIGxldCBlcnJvck5vZGUgPSB7bG9jOiBvcGVuLnBhdGgubG9jfTtcblxuICAgIHRocm93IG5ldyBFeGNlcHRpb24ob3Blbi5wYXRoLm9yaWdpbmFsICsgXCIgZG9lc24ndCBtYXRjaCBcIiArIGNsb3NlLCBlcnJvck5vZGUpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTb3VyY2VMb2NhdGlvbihzb3VyY2UsIGxvY0luZm8pIHtcbiAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gIHRoaXMuc3RhcnQgPSB7XG4gICAgbGluZTogbG9jSW5mby5maXJzdF9saW5lLFxuICAgIGNvbHVtbjogbG9jSW5mby5maXJzdF9jb2x1bW5cbiAgfTtcbiAgdGhpcy5lbmQgPSB7XG4gICAgbGluZTogbG9jSW5mby5sYXN0X2xpbmUsXG4gICAgY29sdW1uOiBsb2NJbmZvLmxhc3RfY29sdW1uXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpZCh0b2tlbikge1xuICBpZiAoL15cXFsuKlxcXSQvLnRlc3QodG9rZW4pKSB7XG4gICAgcmV0dXJuIHRva2VuLnN1YnN0cigxLCB0b2tlbi5sZW5ndGggLSAyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdG9rZW47XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwRmxhZ3Mob3BlbiwgY2xvc2UpIHtcbiAgcmV0dXJuIHtcbiAgICBvcGVuOiBvcGVuLmNoYXJBdCgyKSA9PT0gJ34nLFxuICAgIGNsb3NlOiBjbG9zZS5jaGFyQXQoY2xvc2UubGVuZ3RoIC0gMykgPT09ICd+J1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBDb21tZW50KGNvbW1lbnQpIHtcbiAgcmV0dXJuIGNvbW1lbnQucmVwbGFjZSgvXlxce1xce34/XFwhLT8tPy8sICcnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8tPy0/fj9cXH1cXH0kLywgJycpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZVBhdGgoZGF0YSwgcGFydHMsIGxvYykge1xuICBsb2MgPSB0aGlzLmxvY0luZm8obG9jKTtcblxuICBsZXQgb3JpZ2luYWwgPSBkYXRhID8gJ0AnIDogJycsXG4gICAgICBkaWcgPSBbXSxcbiAgICAgIGRlcHRoID0gMCxcbiAgICAgIGRlcHRoU3RyaW5nID0gJyc7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsZXQgcGFydCA9IHBhcnRzW2ldLnBhcnQsXG4gICAgICAgIC8vIElmIHdlIGhhdmUgW10gc3ludGF4IHRoZW4gd2UgZG8gbm90IHRyZWF0IHBhdGggcmVmZXJlbmNlcyBhcyBvcGVyYXRvcnMsXG4gICAgICAgIC8vIGkuZS4gZm9vLlt0aGlzXSByZXNvbHZlcyB0byBhcHByb3hpbWF0ZWx5IGNvbnRleHQuZm9vWyd0aGlzJ11cbiAgICAgICAgaXNMaXRlcmFsID0gcGFydHNbaV0ub3JpZ2luYWwgIT09IHBhcnQ7XG4gICAgb3JpZ2luYWwgKz0gKHBhcnRzW2ldLnNlcGFyYXRvciB8fCAnJykgKyBwYXJ0O1xuXG4gICAgaWYgKCFpc0xpdGVyYWwgJiYgKHBhcnQgPT09ICcuLicgfHwgcGFydCA9PT0gJy4nIHx8IHBhcnQgPT09ICd0aGlzJykpIHtcbiAgICAgIGlmIChkaWcubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdJbnZhbGlkIHBhdGg6ICcgKyBvcmlnaW5hbCwge2xvY30pO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICAgIGRlcHRoU3RyaW5nICs9ICcuLi8nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkaWcucHVzaChwYXJ0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdQYXRoRXhwcmVzc2lvbicsXG4gICAgZGF0YSxcbiAgICBkZXB0aCxcbiAgICBwYXJ0czogZGlnLFxuICAgIG9yaWdpbmFsLFxuICAgIGxvY1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZU11c3RhY2hlKHBhdGgsIHBhcmFtcywgaGFzaCwgb3Blbiwgc3RyaXAsIGxvY0luZm8pIHtcbiAgLy8gTXVzdCB1c2UgY2hhckF0IHRvIHN1cHBvcnQgSUUgcHJlLTEwXG4gIGxldCBlc2NhcGVGbGFnID0gb3Blbi5jaGFyQXQoMykgfHwgb3Blbi5jaGFyQXQoMiksXG4gICAgICBlc2NhcGVkID0gZXNjYXBlRmxhZyAhPT0gJ3snICYmIGVzY2FwZUZsYWcgIT09ICcmJztcblxuICBsZXQgZGVjb3JhdG9yID0gKC9cXCovLnRlc3Qob3BlbikpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGRlY29yYXRvciA/ICdEZWNvcmF0b3InIDogJ011c3RhY2hlU3RhdGVtZW50JyxcbiAgICBwYXRoLFxuICAgIHBhcmFtcyxcbiAgICBoYXNoLFxuICAgIGVzY2FwZWQsXG4gICAgc3RyaXAsXG4gICAgbG9jOiB0aGlzLmxvY0luZm8obG9jSW5mbylcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVSYXdCbG9jayhvcGVuUmF3QmxvY2ssIGNvbnRlbnRzLCBjbG9zZSwgbG9jSW5mbykge1xuICB2YWxpZGF0ZUNsb3NlKG9wZW5SYXdCbG9jaywgY2xvc2UpO1xuXG4gIGxvY0luZm8gPSB0aGlzLmxvY0luZm8obG9jSW5mbyk7XG4gIGxldCBwcm9ncmFtID0ge1xuICAgIHR5cGU6ICdQcm9ncmFtJyxcbiAgICBib2R5OiBjb250ZW50cyxcbiAgICBzdHJpcDoge30sXG4gICAgbG9jOiBsb2NJbmZvXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQmxvY2tTdGF0ZW1lbnQnLFxuICAgIHBhdGg6IG9wZW5SYXdCbG9jay5wYXRoLFxuICAgIHBhcmFtczogb3BlblJhd0Jsb2NrLnBhcmFtcyxcbiAgICBoYXNoOiBvcGVuUmF3QmxvY2suaGFzaCxcbiAgICBwcm9ncmFtLFxuICAgIG9wZW5TdHJpcDoge30sXG4gICAgaW52ZXJzZVN0cmlwOiB7fSxcbiAgICBjbG9zZVN0cmlwOiB7fSxcbiAgICBsb2M6IGxvY0luZm9cbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVCbG9jayhvcGVuQmxvY2ssIHByb2dyYW0sIGludmVyc2VBbmRQcm9ncmFtLCBjbG9zZSwgaW52ZXJ0ZWQsIGxvY0luZm8pIHtcbiAgaWYgKGNsb3NlICYmIGNsb3NlLnBhdGgpIHtcbiAgICB2YWxpZGF0ZUNsb3NlKG9wZW5CbG9jaywgY2xvc2UpO1xuICB9XG5cbiAgbGV0IGRlY29yYXRvciA9ICgvXFwqLy50ZXN0KG9wZW5CbG9jay5vcGVuKSk7XG5cbiAgcHJvZ3JhbS5ibG9ja1BhcmFtcyA9IG9wZW5CbG9jay5ibG9ja1BhcmFtcztcblxuICBsZXQgaW52ZXJzZSxcbiAgICAgIGludmVyc2VTdHJpcDtcblxuICBpZiAoaW52ZXJzZUFuZFByb2dyYW0pIHtcbiAgICBpZiAoZGVjb3JhdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdVbmV4cGVjdGVkIGludmVyc2UgYmxvY2sgb24gZGVjb3JhdG9yJywgaW52ZXJzZUFuZFByb2dyYW0pO1xuICAgIH1cblxuICAgIGlmIChpbnZlcnNlQW5kUHJvZ3JhbS5jaGFpbikge1xuICAgICAgaW52ZXJzZUFuZFByb2dyYW0ucHJvZ3JhbS5ib2R5WzBdLmNsb3NlU3RyaXAgPSBjbG9zZS5zdHJpcDtcbiAgICB9XG5cbiAgICBpbnZlcnNlU3RyaXAgPSBpbnZlcnNlQW5kUHJvZ3JhbS5zdHJpcDtcbiAgICBpbnZlcnNlID0gaW52ZXJzZUFuZFByb2dyYW0ucHJvZ3JhbTtcbiAgfVxuXG4gIGlmIChpbnZlcnRlZCkge1xuICAgIGludmVydGVkID0gaW52ZXJzZTtcbiAgICBpbnZlcnNlID0gcHJvZ3JhbTtcbiAgICBwcm9ncmFtID0gaW52ZXJ0ZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IGRlY29yYXRvciA/ICdEZWNvcmF0b3JCbG9jaycgOiAnQmxvY2tTdGF0ZW1lbnQnLFxuICAgIHBhdGg6IG9wZW5CbG9jay5wYXRoLFxuICAgIHBhcmFtczogb3BlbkJsb2NrLnBhcmFtcyxcbiAgICBoYXNoOiBvcGVuQmxvY2suaGFzaCxcbiAgICBwcm9ncmFtLFxuICAgIGludmVyc2UsXG4gICAgb3BlblN0cmlwOiBvcGVuQmxvY2suc3RyaXAsXG4gICAgaW52ZXJzZVN0cmlwLFxuICAgIGNsb3NlU3RyaXA6IGNsb3NlICYmIGNsb3NlLnN0cmlwLFxuICAgIGxvYzogdGhpcy5sb2NJbmZvKGxvY0luZm8pXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlUHJvZ3JhbShzdGF0ZW1lbnRzLCBsb2MpIHtcbiAgaWYgKCFsb2MgJiYgc3RhdGVtZW50cy5sZW5ndGgpIHtcbiAgICBjb25zdCBmaXJzdExvYyA9IHN0YXRlbWVudHNbMF0ubG9jLFxuICAgICAgICAgIGxhc3RMb2MgPSBzdGF0ZW1lbnRzW3N0YXRlbWVudHMubGVuZ3RoIC0gMV0ubG9jO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZmlyc3RMb2MgJiYgbGFzdExvYykge1xuICAgICAgbG9jID0ge1xuICAgICAgICBzb3VyY2U6IGZpcnN0TG9jLnNvdXJjZSxcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICBsaW5lOiBmaXJzdExvYy5zdGFydC5saW5lLFxuICAgICAgICAgIGNvbHVtbjogZmlyc3RMb2Muc3RhcnQuY29sdW1uXG4gICAgICAgIH0sXG4gICAgICAgIGVuZDoge1xuICAgICAgICAgIGxpbmU6IGxhc3RMb2MuZW5kLmxpbmUsXG4gICAgICAgICAgY29sdW1uOiBsYXN0TG9jLmVuZC5jb2x1bW5cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdQcm9ncmFtJyxcbiAgICBib2R5OiBzdGF0ZW1lbnRzLFxuICAgIHN0cmlwOiB7fSxcbiAgICBsb2M6IGxvY1xuICB9O1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlUGFydGlhbEJsb2NrKG9wZW4sIHByb2dyYW0sIGNsb3NlLCBsb2NJbmZvKSB7XG4gIHZhbGlkYXRlQ2xvc2Uob3BlbiwgY2xvc2UpO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1BhcnRpYWxCbG9ja1N0YXRlbWVudCcsXG4gICAgbmFtZTogb3Blbi5wYXRoLFxuICAgIHBhcmFtczogb3Blbi5wYXJhbXMsXG4gICAgaGFzaDogb3Blbi5oYXNoLFxuICAgIHByb2dyYW0sXG4gICAgb3BlblN0cmlwOiBvcGVuLnN0cmlwLFxuICAgIGNsb3NlU3RyaXA6IGNsb3NlICYmIGNsb3NlLnN0cmlwLFxuICAgIGxvYzogdGhpcy5sb2NJbmZvKGxvY0luZm8pXG4gIH07XG59XG5cbiIsImltcG9ydCB7IENPTVBJTEVSX1JFVklTSU9OLCBSRVZJU0lPTl9DSEFOR0VTIH0gZnJvbSAnLi4vYmFzZSc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4uL2V4Y2VwdGlvbic7XG5pbXBvcnQge2lzQXJyYXl9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBDb2RlR2VuIGZyb20gJy4vY29kZS1nZW4nO1xuXG5mdW5jdGlvbiBMaXRlcmFsKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gSmF2YVNjcmlwdENvbXBpbGVyKCkge31cblxuSmF2YVNjcmlwdENvbXBpbGVyLnByb3RvdHlwZSA9IHtcbiAgLy8gUFVCTElDIEFQSTogWW91IGNhbiBvdmVycmlkZSB0aGVzZSBtZXRob2RzIGluIGEgc3ViY2xhc3MgdG8gcHJvdmlkZVxuICAvLyBhbHRlcm5hdGl2ZSBjb21waWxlZCBmb3JtcyBmb3IgbmFtZSBsb29rdXAgYW5kIGJ1ZmZlcmluZyBzZW1hbnRpY3NcbiAgbmFtZUxvb2t1cDogZnVuY3Rpb24ocGFyZW50LCBuYW1lLyogLCB0eXBlKi8pIHtcbiAgICBpZiAoSmF2YVNjcmlwdENvbXBpbGVyLmlzVmFsaWRKYXZhU2NyaXB0VmFyaWFibGVOYW1lKG5hbWUpKSB7XG4gICAgICByZXR1cm4gW3BhcmVudCwgJy4nLCBuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtwYXJlbnQsICdbJywgSlNPTi5zdHJpbmdpZnkobmFtZSksICddJ107XG4gICAgfVxuICB9LFxuICBkZXB0aGVkTG9va3VwOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIFt0aGlzLmFsaWFzYWJsZSgnY29udGFpbmVyLmxvb2t1cCcpLCAnKGRlcHRocywgXCInLCBuYW1lLCAnXCIpJ107XG4gIH0sXG5cbiAgY29tcGlsZXJJbmZvOiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCByZXZpc2lvbiA9IENPTVBJTEVSX1JFVklTSU9OLFxuICAgICAgICAgIHZlcnNpb25zID0gUkVWSVNJT05fQ0hBTkdFU1tyZXZpc2lvbl07XG4gICAgcmV0dXJuIFtyZXZpc2lvbiwgdmVyc2lvbnNdO1xuICB9LFxuXG4gIGFwcGVuZFRvQnVmZmVyOiBmdW5jdGlvbihzb3VyY2UsIGxvY2F0aW9uLCBleHBsaWNpdCkge1xuICAgIC8vIEZvcmNlIGEgc291cmNlIGFzIHRoaXMgc2ltcGxpZmllcyB0aGUgbWVyZ2UgbG9naWMuXG4gICAgaWYgKCFpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IFtzb3VyY2VdO1xuICAgIH1cbiAgICBzb3VyY2UgPSB0aGlzLnNvdXJjZS53cmFwKHNvdXJjZSwgbG9jYXRpb24pO1xuXG4gICAgaWYgKHRoaXMuZW52aXJvbm1lbnQuaXNTaW1wbGUpIHtcbiAgICAgIHJldHVybiBbJ3JldHVybiAnLCBzb3VyY2UsICc7J107XG4gICAgfSBlbHNlIGlmIChleHBsaWNpdCkge1xuICAgICAgLy8gVGhpcyBpcyBhIGNhc2Ugd2hlcmUgdGhlIGJ1ZmZlciBvcGVyYXRpb24gb2NjdXJzIGFzIGEgY2hpbGQgb2YgYW5vdGhlclxuICAgICAgLy8gY29uc3RydWN0LCBnZW5lcmFsbHkgYnJhY2VzLiBXZSBoYXZlIHRvIGV4cGxpY2l0bHkgb3V0cHV0IHRoZXNlIGJ1ZmZlclxuICAgICAgLy8gb3BlcmF0aW9ucyB0byBlbnN1cmUgdGhhdCB0aGUgZW1pdHRlZCBjb2RlIGdvZXMgaW4gdGhlIGNvcnJlY3QgbG9jYXRpb24uXG4gICAgICByZXR1cm4gWydidWZmZXIgKz0gJywgc291cmNlLCAnOyddO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2UuYXBwZW5kVG9CdWZmZXIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUJ1ZmZlcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVvdGVkU3RyaW5nKCcnKTtcbiAgfSxcbiAgLy8gRU5EIFBVQkxJQyBBUElcblxuICBjb21waWxlOiBmdW5jdGlvbihlbnZpcm9ubWVudCwgb3B0aW9ucywgY29udGV4dCwgYXNPYmplY3QpIHtcbiAgICB0aGlzLmVudmlyb25tZW50ID0gZW52aXJvbm1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnN0cmluZ1BhcmFtcyA9IHRoaXMub3B0aW9ucy5zdHJpbmdQYXJhbXM7XG4gICAgdGhpcy50cmFja0lkcyA9IHRoaXMub3B0aW9ucy50cmFja0lkcztcbiAgICB0aGlzLnByZWNvbXBpbGUgPSAhYXNPYmplY3Q7XG5cbiAgICB0aGlzLm5hbWUgPSB0aGlzLmVudmlyb25tZW50Lm5hbWU7XG4gICAgdGhpcy5pc0NoaWxkID0gISFjb250ZXh0O1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQgfHwge1xuICAgICAgZGVjb3JhdG9yczogW10sXG4gICAgICBwcm9ncmFtczogW10sXG4gICAgICBlbnZpcm9ubWVudHM6IFtdXG4gICAgfTtcblxuICAgIHRoaXMucHJlYW1ibGUoKTtcblxuICAgIHRoaXMuc3RhY2tTbG90ID0gMDtcbiAgICB0aGlzLnN0YWNrVmFycyA9IFtdO1xuICAgIHRoaXMuYWxpYXNlcyA9IHt9O1xuICAgIHRoaXMucmVnaXN0ZXJzID0geyBsaXN0OiBbXSB9O1xuICAgIHRoaXMuaGFzaGVzID0gW107XG4gICAgdGhpcy5jb21waWxlU3RhY2sgPSBbXTtcbiAgICB0aGlzLmlubGluZVN0YWNrID0gW107XG4gICAgdGhpcy5ibG9ja1BhcmFtcyA9IFtdO1xuXG4gICAgdGhpcy5jb21waWxlQ2hpbGRyZW4oZW52aXJvbm1lbnQsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy51c2VEZXB0aHMgPSB0aGlzLnVzZURlcHRocyB8fCBlbnZpcm9ubWVudC51c2VEZXB0aHMgfHwgZW52aXJvbm1lbnQudXNlRGVjb3JhdG9ycyB8fCB0aGlzLm9wdGlvbnMuY29tcGF0O1xuICAgIHRoaXMudXNlQmxvY2tQYXJhbXMgPSB0aGlzLnVzZUJsb2NrUGFyYW1zIHx8IGVudmlyb25tZW50LnVzZUJsb2NrUGFyYW1zO1xuXG4gICAgbGV0IG9wY29kZXMgPSBlbnZpcm9ubWVudC5vcGNvZGVzLFxuICAgICAgICBvcGNvZGUsXG4gICAgICAgIGZpcnN0TG9jLFxuICAgICAgICBpLFxuICAgICAgICBsO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IG9wY29kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBvcGNvZGUgPSBvcGNvZGVzW2ldO1xuXG4gICAgICB0aGlzLnNvdXJjZS5jdXJyZW50TG9jYXRpb24gPSBvcGNvZGUubG9jO1xuICAgICAgZmlyc3RMb2MgPSBmaXJzdExvYyB8fCBvcGNvZGUubG9jO1xuICAgICAgdGhpc1tvcGNvZGUub3Bjb2RlXS5hcHBseSh0aGlzLCBvcGNvZGUuYXJncyk7XG4gICAgfVxuXG4gICAgLy8gRmx1c2ggYW55IHRyYWlsaW5nIGNvbnRlbnQgdGhhdCBtaWdodCBiZSBwZW5kaW5nLlxuICAgIHRoaXMuc291cmNlLmN1cnJlbnRMb2NhdGlvbiA9IGZpcnN0TG9jO1xuICAgIHRoaXMucHVzaFNvdXJjZSgnJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0aGlzLnN0YWNrU2xvdCB8fCB0aGlzLmlubGluZVN0YWNrLmxlbmd0aCB8fCB0aGlzLmNvbXBpbGVTdGFjay5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ0NvbXBpbGUgY29tcGxldGVkIHdpdGggY29udGVudCBsZWZ0IG9uIHN0YWNrJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmRlY29yYXRvcnMuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLnVzZURlY29yYXRvcnMgPSB0cnVlO1xuXG4gICAgICB0aGlzLmRlY29yYXRvcnMucHJlcGVuZCgndmFyIGRlY29yYXRvcnMgPSBjb250YWluZXIuZGVjb3JhdG9ycztcXG4nKTtcbiAgICAgIHRoaXMuZGVjb3JhdG9ycy5wdXNoKCdyZXR1cm4gZm47Jyk7XG5cbiAgICAgIGlmIChhc09iamVjdCkge1xuICAgICAgICB0aGlzLmRlY29yYXRvcnMgPSBGdW5jdGlvbi5hcHBseSh0aGlzLCBbJ2ZuJywgJ3Byb3BzJywgJ2NvbnRhaW5lcicsICdkZXB0aDAnLCAnZGF0YScsICdibG9ja1BhcmFtcycsICdkZXB0aHMnLCB0aGlzLmRlY29yYXRvcnMubWVyZ2UoKV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWNvcmF0b3JzLnByZXBlbmQoJ2Z1bmN0aW9uKGZuLCBwcm9wcywgY29udGFpbmVyLCBkZXB0aDAsIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcXG4nKTtcbiAgICAgICAgdGhpcy5kZWNvcmF0b3JzLnB1c2goJ31cXG4nKTtcbiAgICAgICAgdGhpcy5kZWNvcmF0b3JzID0gdGhpcy5kZWNvcmF0b3JzLm1lcmdlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVjb3JhdG9ycyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBsZXQgZm4gPSB0aGlzLmNyZWF0ZUZ1bmN0aW9uQ29udGV4dChhc09iamVjdCk7XG4gICAgaWYgKCF0aGlzLmlzQ2hpbGQpIHtcbiAgICAgIGxldCByZXQgPSB7XG4gICAgICAgIGNvbXBpbGVyOiB0aGlzLmNvbXBpbGVySW5mbygpLFxuICAgICAgICBtYWluOiBmblxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuZGVjb3JhdG9ycykge1xuICAgICAgICByZXQubWFpbl9kID0gdGhpcy5kZWNvcmF0b3JzOyAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG4gICAgICAgIHJldC51c2VEZWNvcmF0b3JzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IHtwcm9ncmFtcywgZGVjb3JhdG9yc30gPSB0aGlzLmNvbnRleHQ7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gcHJvZ3JhbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChwcm9ncmFtc1tpXSkge1xuICAgICAgICAgIHJldFtpXSA9IHByb2dyYW1zW2ldO1xuICAgICAgICAgIGlmIChkZWNvcmF0b3JzW2ldKSB7XG4gICAgICAgICAgICByZXRbaSArICdfZCddID0gZGVjb3JhdG9yc1tpXTtcbiAgICAgICAgICAgIHJldC51c2VEZWNvcmF0b3JzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZW52aXJvbm1lbnQudXNlUGFydGlhbCkge1xuICAgICAgICByZXQudXNlUGFydGlhbCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRhdGEpIHtcbiAgICAgICAgcmV0LnVzZURhdGEgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudXNlRGVwdGhzKSB7XG4gICAgICAgIHJldC51c2VEZXB0aHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudXNlQmxvY2tQYXJhbXMpIHtcbiAgICAgICAgcmV0LnVzZUJsb2NrUGFyYW1zID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0KSB7XG4gICAgICAgIHJldC5jb21wYXQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFzT2JqZWN0KSB7XG4gICAgICAgIHJldC5jb21waWxlciA9IEpTT04uc3RyaW5naWZ5KHJldC5jb21waWxlcik7XG5cbiAgICAgICAgdGhpcy5zb3VyY2UuY3VycmVudExvY2F0aW9uID0ge3N0YXJ0OiB7bGluZTogMSwgY29sdW1uOiAwfX07XG4gICAgICAgIHJldCA9IHRoaXMub2JqZWN0TGl0ZXJhbChyZXQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNyY05hbWUpIHtcbiAgICAgICAgICByZXQgPSByZXQudG9TdHJpbmdXaXRoU291cmNlTWFwKHtmaWxlOiBvcHRpb25zLmRlc3ROYW1lfSk7XG4gICAgICAgICAgcmV0Lm1hcCA9IHJldC5tYXAgJiYgcmV0Lm1hcC50b1N0cmluZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IHJldC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQuY29tcGlsZXJPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZm47XG4gICAgfVxuICB9LFxuXG4gIHByZWFtYmxlOiBmdW5jdGlvbigpIHtcbiAgICAvLyB0cmFjayB0aGUgbGFzdCBjb250ZXh0IHB1c2hlZCBpbnRvIHBsYWNlIHRvIGFsbG93IHNraXBwaW5nIHRoZVxuICAgIC8vIGdldENvbnRleHQgb3Bjb2RlIHdoZW4gaXQgd291bGQgYmUgYSBub29wXG4gICAgdGhpcy5sYXN0Q29udGV4dCA9IDA7XG4gICAgdGhpcy5zb3VyY2UgPSBuZXcgQ29kZUdlbih0aGlzLm9wdGlvbnMuc3JjTmFtZSk7XG4gICAgdGhpcy5kZWNvcmF0b3JzID0gbmV3IENvZGVHZW4odGhpcy5vcHRpb25zLnNyY05hbWUpO1xuICB9LFxuXG4gIGNyZWF0ZUZ1bmN0aW9uQ29udGV4dDogZnVuY3Rpb24oYXNPYmplY3QpIHtcbiAgICBsZXQgdmFyRGVjbGFyYXRpb25zID0gJyc7XG5cbiAgICBsZXQgbG9jYWxzID0gdGhpcy5zdGFja1ZhcnMuY29uY2F0KHRoaXMucmVnaXN0ZXJzLmxpc3QpO1xuICAgIGlmIChsb2NhbHMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyRGVjbGFyYXRpb25zICs9ICcsICcgKyBsb2NhbHMuam9pbignLCAnKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBtaW5pbWl6ZXIgYWxpYXMgbWFwcGluZ3NcbiAgICAvL1xuICAgIC8vIFdoZW4gdXNpbmcgdHJ1ZSBTb3VyY2VOb2RlcywgdGhpcyB3aWxsIHVwZGF0ZSBhbGwgcmVmZXJlbmNlcyB0byB0aGUgZ2l2ZW4gYWxpYXNcbiAgICAvLyBhcyB0aGUgc291cmNlIG5vZGVzIGFyZSByZXVzZWQgaW4gc2l0dS4gRm9yIHRoZSBub24tc291cmNlIG5vZGUgY29tcGlsYXRpb24gbW9kZSxcbiAgICAvLyBhbGlhc2VzIHdpbGwgbm90IGJlIHVzZWQsIGJ1dCB0aGlzIGNhc2UgaXMgYWxyZWFkeSBiZWluZyBydW4gb24gdGhlIGNsaWVudCBhbmRcbiAgICAvLyB3ZSBhcmVuJ3QgY29uY2VybiBhYm91dCBtaW5pbWl6aW5nIHRoZSB0ZW1wbGF0ZSBzaXplLlxuICAgIGxldCBhbGlhc0NvdW50ID0gMDtcbiAgICBmb3IgKGxldCBhbGlhcyBpbiB0aGlzLmFsaWFzZXMpIHsgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBndWFyZC1mb3ItaW5cbiAgICAgIGxldCBub2RlID0gdGhpcy5hbGlhc2VzW2FsaWFzXTtcblxuICAgICAgaWYgKHRoaXMuYWxpYXNlcy5oYXNPd25Qcm9wZXJ0eShhbGlhcykgJiYgbm9kZS5jaGlsZHJlbiAmJiBub2RlLnJlZmVyZW5jZUNvdW50ID4gMSkge1xuICAgICAgICB2YXJEZWNsYXJhdGlvbnMgKz0gJywgYWxpYXMnICsgKCsrYWxpYXNDb3VudCkgKyAnPScgKyBhbGlhcztcbiAgICAgICAgbm9kZS5jaGlsZHJlblswXSA9ICdhbGlhcycgKyBhbGlhc0NvdW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBwYXJhbXMgPSBbJ2NvbnRhaW5lcicsICdkZXB0aDAnLCAnaGVscGVycycsICdwYXJ0aWFscycsICdkYXRhJ107XG5cbiAgICBpZiAodGhpcy51c2VCbG9ja1BhcmFtcyB8fCB0aGlzLnVzZURlcHRocykge1xuICAgICAgcGFyYW1zLnB1c2goJ2Jsb2NrUGFyYW1zJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnVzZURlcHRocykge1xuICAgICAgcGFyYW1zLnB1c2goJ2RlcHRocycpO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYSBzZWNvbmQgcGFzcyBvdmVyIHRoZSBvdXRwdXQgdG8gbWVyZ2UgY29udGVudCB3aGVuIHBvc3NpYmxlXG4gICAgbGV0IHNvdXJjZSA9IHRoaXMubWVyZ2VTb3VyY2UodmFyRGVjbGFyYXRpb25zKTtcblxuICAgIGlmIChhc09iamVjdCkge1xuICAgICAgcGFyYW1zLnB1c2goc291cmNlKTtcblxuICAgICAgcmV0dXJuIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIHBhcmFtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS53cmFwKFsnZnVuY3Rpb24oJywgcGFyYW1zLmpvaW4oJywnKSwgJykge1xcbiAgJywgc291cmNlLCAnfSddKTtcbiAgICB9XG4gIH0sXG4gIG1lcmdlU291cmNlOiBmdW5jdGlvbih2YXJEZWNsYXJhdGlvbnMpIHtcbiAgICBsZXQgaXNTaW1wbGUgPSB0aGlzLmVudmlyb25tZW50LmlzU2ltcGxlLFxuICAgICAgICBhcHBlbmRPbmx5ID0gIXRoaXMuZm9yY2VCdWZmZXIsXG4gICAgICAgIGFwcGVuZEZpcnN0LFxuXG4gICAgICAgIHNvdXJjZVNlZW4sXG4gICAgICAgIGJ1ZmZlclN0YXJ0LFxuICAgICAgICBidWZmZXJFbmQ7XG4gICAgdGhpcy5zb3VyY2UuZWFjaCgobGluZSkgPT4ge1xuICAgICAgaWYgKGxpbmUuYXBwZW5kVG9CdWZmZXIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlclN0YXJ0KSB7XG4gICAgICAgICAgbGluZS5wcmVwZW5kKCcgICsgJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmZmVyU3RhcnQgPSBsaW5lO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlckVuZCA9IGxpbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYnVmZmVyU3RhcnQpIHtcbiAgICAgICAgICBpZiAoIXNvdXJjZVNlZW4pIHtcbiAgICAgICAgICAgIGFwcGVuZEZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyU3RhcnQucHJlcGVuZCgnYnVmZmVyICs9ICcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWZmZXJFbmQuYWRkKCc7Jyk7XG4gICAgICAgICAgYnVmZmVyU3RhcnQgPSBidWZmZXJFbmQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBzb3VyY2VTZWVuID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFpc1NpbXBsZSkge1xuICAgICAgICAgIGFwcGVuZE9ubHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBpZiAoYXBwZW5kT25seSkge1xuICAgICAgaWYgKGJ1ZmZlclN0YXJ0KSB7XG4gICAgICAgIGJ1ZmZlclN0YXJ0LnByZXBlbmQoJ3JldHVybiAnKTtcbiAgICAgICAgYnVmZmVyRW5kLmFkZCgnOycpO1xuICAgICAgfSBlbHNlIGlmICghc291cmNlU2Vlbikge1xuICAgICAgICB0aGlzLnNvdXJjZS5wdXNoKCdyZXR1cm4gXCJcIjsnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyRGVjbGFyYXRpb25zICs9ICcsIGJ1ZmZlciA9ICcgKyAoYXBwZW5kRmlyc3QgPyAnJyA6IHRoaXMuaW5pdGlhbGl6ZUJ1ZmZlcigpKTtcblxuICAgICAgaWYgKGJ1ZmZlclN0YXJ0KSB7XG4gICAgICAgIGJ1ZmZlclN0YXJ0LnByZXBlbmQoJ3JldHVybiBidWZmZXIgKyAnKTtcbiAgICAgICAgYnVmZmVyRW5kLmFkZCgnOycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zb3VyY2UucHVzaCgncmV0dXJuIGJ1ZmZlcjsnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFyRGVjbGFyYXRpb25zKSB7XG4gICAgICB0aGlzLnNvdXJjZS5wcmVwZW5kKCd2YXIgJyArIHZhckRlY2xhcmF0aW9ucy5zdWJzdHJpbmcoMikgKyAoYXBwZW5kRmlyc3QgPyAnJyA6ICc7XFxuJykpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNvdXJjZS5tZXJnZSgpO1xuICB9LFxuXG4gIC8vIFtibG9ja1ZhbHVlXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiBoYXNoLCBpbnZlcnNlLCBwcm9ncmFtLCB2YWx1ZVxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHJldHVybiB2YWx1ZSBvZiBibG9ja0hlbHBlck1pc3NpbmdcbiAgLy9cbiAgLy8gVGhlIHB1cnBvc2Ugb2YgdGhpcyBvcGNvZGUgaXMgdG8gdGFrZSBhIGJsb2NrIG9mIHRoZSBmb3JtXG4gIC8vIGB7eyN0aGlzLmZvb319Li4ue3svdGhpcy5mb299fWAsIHJlc29sdmUgdGhlIHZhbHVlIG9mIGBmb29gLCBhbmRcbiAgLy8gcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgd2l0aCB0aGUgcmVzdWx0IG9mIHByb3Blcmx5XG4gIC8vIGludm9raW5nIGJsb2NrSGVscGVyTWlzc2luZy5cbiAgYmxvY2tWYWx1ZTogZnVuY3Rpb24obmFtZSkge1xuICAgIGxldCBibG9ja0hlbHBlck1pc3NpbmcgPSB0aGlzLmFsaWFzYWJsZSgnaGVscGVycy5ibG9ja0hlbHBlck1pc3NpbmcnKSxcbiAgICAgICAgcGFyYW1zID0gW3RoaXMuY29udGV4dE5hbWUoMCldO1xuICAgIHRoaXMuc2V0dXBIZWxwZXJBcmdzKG5hbWUsIDAsIHBhcmFtcyk7XG5cbiAgICBsZXQgYmxvY2tOYW1lID0gdGhpcy5wb3BTdGFjaygpO1xuICAgIHBhcmFtcy5zcGxpY2UoMSwgMCwgYmxvY2tOYW1lKTtcblxuICAgIHRoaXMucHVzaCh0aGlzLnNvdXJjZS5mdW5jdGlvbkNhbGwoYmxvY2tIZWxwZXJNaXNzaW5nLCAnY2FsbCcsIHBhcmFtcykpO1xuICB9LFxuXG4gIC8vIFthbWJpZ3VvdXNCbG9ja1ZhbHVlXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiBoYXNoLCBpbnZlcnNlLCBwcm9ncmFtLCB2YWx1ZVxuICAvLyBDb21waWxlciB2YWx1ZSwgYmVmb3JlOiBsYXN0SGVscGVyPXZhbHVlIG9mIGxhc3QgZm91bmQgaGVscGVyLCBpZiBhbnlcbiAgLy8gT24gc3RhY2ssIGFmdGVyLCBpZiBubyBsYXN0SGVscGVyOiBzYW1lIGFzIFtibG9ja1ZhbHVlXVxuICAvLyBPbiBzdGFjaywgYWZ0ZXIsIGlmIGxhc3RIZWxwZXI6IHZhbHVlXG4gIGFtYmlndW91c0Jsb2NrVmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFdlJ3JlIGJlaW5nIGEgYml0IGNoZWVreSBhbmQgcmV1c2luZyB0aGUgb3B0aW9ucyB2YWx1ZSBmcm9tIHRoZSBwcmlvciBleGVjXG4gICAgbGV0IGJsb2NrSGVscGVyTWlzc2luZyA9IHRoaXMuYWxpYXNhYmxlKCdoZWxwZXJzLmJsb2NrSGVscGVyTWlzc2luZycpLFxuICAgICAgICBwYXJhbXMgPSBbdGhpcy5jb250ZXh0TmFtZSgwKV07XG4gICAgdGhpcy5zZXR1cEhlbHBlckFyZ3MoJycsIDAsIHBhcmFtcywgdHJ1ZSk7XG5cbiAgICB0aGlzLmZsdXNoSW5saW5lKCk7XG5cbiAgICBsZXQgY3VycmVudCA9IHRoaXMudG9wU3RhY2soKTtcbiAgICBwYXJhbXMuc3BsaWNlKDEsIDAsIGN1cnJlbnQpO1xuXG4gICAgdGhpcy5wdXNoU291cmNlKFtcbiAgICAgICAgJ2lmICghJywgdGhpcy5sYXN0SGVscGVyLCAnKSB7ICcsXG4gICAgICAgICAgY3VycmVudCwgJyA9ICcsIHRoaXMuc291cmNlLmZ1bmN0aW9uQ2FsbChibG9ja0hlbHBlck1pc3NpbmcsICdjYWxsJywgcGFyYW1zKSxcbiAgICAgICAgJ30nXSk7XG4gIH0sXG5cbiAgLy8gW2FwcGVuZENvbnRlbnRdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IC4uLlxuICAvL1xuICAvLyBBcHBlbmRzIHRoZSBzdHJpbmcgdmFsdWUgb2YgYGNvbnRlbnRgIHRvIHRoZSBjdXJyZW50IGJ1ZmZlclxuICBhcHBlbmRDb250ZW50OiBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NvbnRlbnQpIHtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLnBlbmRpbmdDb250ZW50ICsgY29udGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wZW5kaW5nTG9jYXRpb24gPSB0aGlzLnNvdXJjZS5jdXJyZW50TG9jYXRpb247XG4gICAgfVxuXG4gICAgdGhpcy5wZW5kaW5nQ29udGVudCA9IGNvbnRlbnQ7XG4gIH0sXG5cbiAgLy8gW2FwcGVuZF1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogdmFsdWUsIC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IC4uLlxuICAvL1xuICAvLyBDb2VyY2VzIGB2YWx1ZWAgdG8gYSBTdHJpbmcgYW5kIGFwcGVuZHMgaXQgdG8gdGhlIGN1cnJlbnQgYnVmZmVyLlxuICAvL1xuICAvLyBJZiBgdmFsdWVgIGlzIHRydXRoeSwgb3IgMCwgaXQgaXMgY29lcmNlZCBpbnRvIGEgc3RyaW5nIGFuZCBhcHBlbmRlZFxuICAvLyBPdGhlcndpc2UsIHRoZSBlbXB0eSBzdHJpbmcgaXMgYXBwZW5kZWRcbiAgYXBwZW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc0lubGluZSgpKSB7XG4gICAgICB0aGlzLnJlcGxhY2VTdGFjaygoY3VycmVudCkgPT4gWycgIT0gbnVsbCA/ICcsIGN1cnJlbnQsICcgOiBcIlwiJ10pO1xuXG4gICAgICB0aGlzLnB1c2hTb3VyY2UodGhpcy5hcHBlbmRUb0J1ZmZlcih0aGlzLnBvcFN0YWNrKCkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGxvY2FsID0gdGhpcy5wb3BTdGFjaygpO1xuICAgICAgdGhpcy5wdXNoU291cmNlKFsnaWYgKCcsIGxvY2FsLCAnICE9IG51bGwpIHsgJywgdGhpcy5hcHBlbmRUb0J1ZmZlcihsb2NhbCwgdW5kZWZpbmVkLCB0cnVlKSwgJyB9J10pO1xuICAgICAgaWYgKHRoaXMuZW52aXJvbm1lbnQuaXNTaW1wbGUpIHtcbiAgICAgICAgdGhpcy5wdXNoU291cmNlKFsnZWxzZSB7ICcsIHRoaXMuYXBwZW5kVG9CdWZmZXIoXCInJ1wiLCB1bmRlZmluZWQsIHRydWUpLCAnIH0nXSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8vIFthcHBlbmRFc2NhcGVkXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiB2YWx1ZSwgLi4uXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogLi4uXG4gIC8vXG4gIC8vIEVzY2FwZSBgdmFsdWVgIGFuZCBhcHBlbmQgaXQgdG8gdGhlIGJ1ZmZlclxuICBhcHBlbmRFc2NhcGVkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnB1c2hTb3VyY2UodGhpcy5hcHBlbmRUb0J1ZmZlcihcbiAgICAgICAgW3RoaXMuYWxpYXNhYmxlKCdjb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbicpLCAnKCcsIHRoaXMucG9wU3RhY2soKSwgJyknXSkpO1xuICB9LFxuXG4gIC8vIFtnZXRDb250ZXh0XVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiAuLi5cbiAgLy8gQ29tcGlsZXIgdmFsdWUsIGFmdGVyOiBsYXN0Q29udGV4dD1kZXB0aFxuICAvL1xuICAvLyBTZXQgdGhlIHZhbHVlIG9mIHRoZSBgbGFzdENvbnRleHRgIGNvbXBpbGVyIHZhbHVlIHRvIHRoZSBkZXB0aFxuICBnZXRDb250ZXh0OiBmdW5jdGlvbihkZXB0aCkge1xuICAgIHRoaXMubGFzdENvbnRleHQgPSBkZXB0aDtcbiAgfSxcblxuICAvLyBbcHVzaENvbnRleHRdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IGN1cnJlbnRDb250ZXh0LCAuLi5cbiAgLy9cbiAgLy8gUHVzaGVzIHRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCBjb250ZXh0IG9udG8gdGhlIHN0YWNrLlxuICBwdXNoQ29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKHRoaXMuY29udGV4dE5hbWUodGhpcy5sYXN0Q29udGV4dCkpO1xuICB9LFxuXG4gIC8vIFtsb29rdXBPbkNvbnRleHRdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IGN1cnJlbnRDb250ZXh0W25hbWVdLCAuLi5cbiAgLy9cbiAgLy8gTG9va3MgdXAgdGhlIHZhbHVlIG9mIGBuYW1lYCBvbiB0aGUgY3VycmVudCBjb250ZXh0IGFuZCBwdXNoZXNcbiAgLy8gaXQgb250byB0aGUgc3RhY2suXG4gIGxvb2t1cE9uQ29udGV4dDogZnVuY3Rpb24ocGFydHMsIGZhbHN5LCBzdHJpY3QsIHNjb3BlZCkge1xuICAgIGxldCBpID0gMDtcblxuICAgIGlmICghc2NvcGVkICYmIHRoaXMub3B0aW9ucy5jb21wYXQgJiYgIXRoaXMubGFzdENvbnRleHQpIHtcbiAgICAgIC8vIFRoZSBkZXB0aGVkIHF1ZXJ5IGlzIGV4cGVjdGVkIHRvIGhhbmRsZSB0aGUgdW5kZWZpbmVkIGxvZ2ljIGZvciB0aGUgcm9vdCBsZXZlbCB0aGF0XG4gICAgICAvLyBpcyBpbXBsZW1lbnRlZCBiZWxvdywgc28gd2UgZXZhbHVhdGUgdGhhdCBkaXJlY3RseSBpbiBjb21wYXQgbW9kZVxuICAgICAgdGhpcy5wdXNoKHRoaXMuZGVwdGhlZExvb2t1cChwYXJ0c1tpKytdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaENvbnRleHQoKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlc29sdmVQYXRoKCdjb250ZXh0JywgcGFydHMsIGksIGZhbHN5LCBzdHJpY3QpO1xuICB9LFxuXG4gIC8vIFtsb29rdXBCbG9ja1BhcmFtXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiBibG9ja1BhcmFtW25hbWVdLCAuLi5cbiAgLy9cbiAgLy8gTG9va3MgdXAgdGhlIHZhbHVlIG9mIGBwYXJ0c2Agb24gdGhlIGdpdmVuIGJsb2NrIHBhcmFtIGFuZCBwdXNoZXNcbiAgLy8gaXQgb250byB0aGUgc3RhY2suXG4gIGxvb2t1cEJsb2NrUGFyYW06IGZ1bmN0aW9uKGJsb2NrUGFyYW1JZCwgcGFydHMpIHtcbiAgICB0aGlzLnVzZUJsb2NrUGFyYW1zID0gdHJ1ZTtcblxuICAgIHRoaXMucHVzaChbJ2Jsb2NrUGFyYW1zWycsIGJsb2NrUGFyYW1JZFswXSwgJ11bJywgYmxvY2tQYXJhbUlkWzFdLCAnXSddKTtcbiAgICB0aGlzLnJlc29sdmVQYXRoKCdjb250ZXh0JywgcGFydHMsIDEpO1xuICB9LFxuXG4gIC8vIFtsb29rdXBEYXRhXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiBkYXRhLCAuLi5cbiAgLy9cbiAgLy8gUHVzaCB0aGUgZGF0YSBsb29rdXAgb3BlcmF0b3JcbiAgbG9va3VwRGF0YTogZnVuY3Rpb24oZGVwdGgsIHBhcnRzLCBzdHJpY3QpIHtcbiAgICBpZiAoIWRlcHRoKSB7XG4gICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwoJ2RhdGEnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKCdjb250YWluZXIuZGF0YShkYXRhLCAnICsgZGVwdGggKyAnKScpO1xuICAgIH1cblxuICAgIHRoaXMucmVzb2x2ZVBhdGgoJ2RhdGEnLCBwYXJ0cywgMCwgdHJ1ZSwgc3RyaWN0KTtcbiAgfSxcblxuICByZXNvbHZlUGF0aDogZnVuY3Rpb24odHlwZSwgcGFydHMsIGksIGZhbHN5LCBzdHJpY3QpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnN0cmljdCB8fCB0aGlzLm9wdGlvbnMuYXNzdW1lT2JqZWN0cykge1xuICAgICAgdGhpcy5wdXNoKHN0cmljdExvb2t1cCh0aGlzLm9wdGlvbnMuc3RyaWN0ICYmIHN0cmljdCwgdGhpcywgcGFydHMsIHR5cGUpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgbGVuID0gcGFydHMubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuICAgICAgdGhpcy5yZXBsYWNlU3RhY2soKGN1cnJlbnQpID0+IHtcbiAgICAgICAgbGV0IGxvb2t1cCA9IHRoaXMubmFtZUxvb2t1cChjdXJyZW50LCBwYXJ0c1tpXSwgdHlwZSk7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgemVybyBhbmQgZmFsc2UgYXJlIGhhbmRsZWQgcHJvcGVybHkgaWYgdGhlIGNvbnRleHQgKGZhbHN5IGZsYWcpXG4gICAgICAgIC8vIG5lZWRzIHRvIGhhdmUgdGhlIHNwZWNpYWwgaGFuZGxpbmcgZm9yIHRoZXNlIHZhbHVlcy5cbiAgICAgICAgaWYgKCFmYWxzeSkge1xuICAgICAgICAgIHJldHVybiBbJyAhPSBudWxsID8gJywgbG9va3VwLCAnIDogJywgY3VycmVudF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGNhbiB1c2UgZ2VuZXJpYyBmYWxzeSBoYW5kbGluZ1xuICAgICAgICAgIHJldHVybiBbJyAmJiAnLCBsb29rdXBdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG4gICAgfVxuICB9LFxuXG4gIC8vIFtyZXNvbHZlUG9zc2libGVMYW1iZGFdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IHZhbHVlLCAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiByZXNvbHZlZCB2YWx1ZSwgLi4uXG4gIC8vXG4gIC8vIElmIHRoZSBgdmFsdWVgIGlzIGEgbGFtYmRhLCByZXBsYWNlIGl0IG9uIHRoZSBzdGFjayBieVxuICAvLyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBsYW1iZGFcbiAgcmVzb2x2ZVBvc3NpYmxlTGFtYmRhOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnB1c2goW3RoaXMuYWxpYXNhYmxlKCdjb250YWluZXIubGFtYmRhJyksICcoJywgdGhpcy5wb3BTdGFjaygpLCAnLCAnLCB0aGlzLmNvbnRleHROYW1lKDApLCAnKSddKTtcbiAgfSxcblxuICAvLyBbcHVzaFN0cmluZ1BhcmFtXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiBzdHJpbmcsIGN1cnJlbnRDb250ZXh0LCAuLi5cbiAgLy9cbiAgLy8gVGhpcyBvcGNvZGUgaXMgZGVzaWduZWQgZm9yIHVzZSBpbiBzdHJpbmcgbW9kZSwgd2hpY2hcbiAgLy8gcHJvdmlkZXMgdGhlIHN0cmluZyB2YWx1ZSBvZiBhIHBhcmFtZXRlciBhbG9uZyB3aXRoIGl0c1xuICAvLyBkZXB0aCByYXRoZXIgdGhhbiByZXNvbHZpbmcgaXQgaW1tZWRpYXRlbHkuXG4gIHB1c2hTdHJpbmdQYXJhbTogZnVuY3Rpb24oc3RyaW5nLCB0eXBlKSB7XG4gICAgdGhpcy5wdXNoQ29udGV4dCgpO1xuICAgIHRoaXMucHVzaFN0cmluZyh0eXBlKTtcblxuICAgIC8vIElmIGl0J3MgYSBzdWJleHByZXNzaW9uLCB0aGUgc3RyaW5nIHJlc3VsdFxuICAgIC8vIHdpbGwgYmUgcHVzaGVkIGFmdGVyIHRoaXMgb3Bjb2RlLlxuICAgIGlmICh0eXBlICE9PSAnU3ViRXhwcmVzc2lvbicpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLnB1c2hTdHJpbmcoc3RyaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbChzdHJpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBlbXB0eUhhc2g6IGZ1bmN0aW9uKG9taXRFbXB0eSkge1xuICAgIGlmICh0aGlzLnRyYWNrSWRzKSB7XG4gICAgICB0aGlzLnB1c2goJ3t9Jyk7IC8vIGhhc2hJZHNcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RyaW5nUGFyYW1zKSB7XG4gICAgICB0aGlzLnB1c2goJ3t9Jyk7IC8vIGhhc2hDb250ZXh0c1xuICAgICAgdGhpcy5wdXNoKCd7fScpOyAvLyBoYXNoVHlwZXNcbiAgICB9XG4gICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKG9taXRFbXB0eSA/ICd1bmRlZmluZWQnIDogJ3t9Jyk7XG4gIH0sXG4gIHB1c2hIYXNoOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5oYXNoKSB7XG4gICAgICB0aGlzLmhhc2hlcy5wdXNoKHRoaXMuaGFzaCk7XG4gICAgfVxuICAgIHRoaXMuaGFzaCA9IHt2YWx1ZXM6IFtdLCB0eXBlczogW10sIGNvbnRleHRzOiBbXSwgaWRzOiBbXX07XG4gIH0sXG4gIHBvcEhhc2g6IGZ1bmN0aW9uKCkge1xuICAgIGxldCBoYXNoID0gdGhpcy5oYXNoO1xuICAgIHRoaXMuaGFzaCA9IHRoaXMuaGFzaGVzLnBvcCgpO1xuXG4gICAgaWYgKHRoaXMudHJhY2tJZHMpIHtcbiAgICAgIHRoaXMucHVzaCh0aGlzLm9iamVjdExpdGVyYWwoaGFzaC5pZHMpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RyaW5nUGFyYW1zKSB7XG4gICAgICB0aGlzLnB1c2godGhpcy5vYmplY3RMaXRlcmFsKGhhc2guY29udGV4dHMpKTtcbiAgICAgIHRoaXMucHVzaCh0aGlzLm9iamVjdExpdGVyYWwoaGFzaC50eXBlcykpO1xuICAgIH1cblxuICAgIHRoaXMucHVzaCh0aGlzLm9iamVjdExpdGVyYWwoaGFzaC52YWx1ZXMpKTtcbiAgfSxcblxuICAvLyBbcHVzaFN0cmluZ11cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogcXVvdGVkU3RyaW5nKHN0cmluZyksIC4uLlxuICAvL1xuICAvLyBQdXNoIGEgcXVvdGVkIHZlcnNpb24gb2YgYHN0cmluZ2Agb250byB0aGUgc3RhY2tcbiAgcHVzaFN0cmluZzogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKHRoaXMucXVvdGVkU3RyaW5nKHN0cmluZykpO1xuICB9LFxuXG4gIC8vIFtwdXNoTGl0ZXJhbF1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogdmFsdWUsIC4uLlxuICAvL1xuICAvLyBQdXNoZXMgYSB2YWx1ZSBvbnRvIHRoZSBzdGFjay4gVGhpcyBvcGVyYXRpb24gcHJldmVudHNcbiAgLy8gdGhlIGNvbXBpbGVyIGZyb20gY3JlYXRpbmcgYSB0ZW1wb3JhcnkgdmFyaWFibGUgdG8gaG9sZFxuICAvLyBpdC5cbiAgcHVzaExpdGVyYWw6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKHZhbHVlKTtcbiAgfSxcblxuICAvLyBbcHVzaFByb2dyYW1dXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHByb2dyYW0oZ3VpZCksIC4uLlxuICAvL1xuICAvLyBQdXNoIGEgcHJvZ3JhbSBleHByZXNzaW9uIG9udG8gdGhlIHN0YWNrLiBUaGlzIHRha2VzXG4gIC8vIGEgY29tcGlsZS10aW1lIGd1aWQgYW5kIGNvbnZlcnRzIGl0IGludG8gYSBydW50aW1lLWFjY2Vzc2libGVcbiAgLy8gZXhwcmVzc2lvbi5cbiAgcHVzaFByb2dyYW06IGZ1bmN0aW9uKGd1aWQpIHtcbiAgICBpZiAoZ3VpZCAhPSBudWxsKSB7XG4gICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwodGhpcy5wcm9ncmFtRXhwcmVzc2lvbihndWlkKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbChudWxsKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gW3JlZ2lzdGVyRGVjb3JhdG9yXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiBoYXNoLCBwcm9ncmFtLCBwYXJhbXMuLi4sIC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IC4uLlxuICAvL1xuICAvLyBQb3BzIG9mZiB0aGUgZGVjb3JhdG9yJ3MgcGFyYW1ldGVycywgaW52b2tlcyB0aGUgZGVjb3JhdG9yLFxuICAvLyBhbmQgaW5zZXJ0cyB0aGUgZGVjb3JhdG9yIGludG8gdGhlIGRlY29yYXRvcnMgbGlzdC5cbiAgcmVnaXN0ZXJEZWNvcmF0b3IocGFyYW1TaXplLCBuYW1lKSB7XG4gICAgbGV0IGZvdW5kRGVjb3JhdG9yID0gdGhpcy5uYW1lTG9va3VwKCdkZWNvcmF0b3JzJywgbmFtZSwgJ2RlY29yYXRvcicpLFxuICAgICAgICBvcHRpb25zID0gdGhpcy5zZXR1cEhlbHBlckFyZ3MobmFtZSwgcGFyYW1TaXplKTtcblxuICAgIHRoaXMuZGVjb3JhdG9ycy5wdXNoKFtcbiAgICAgICdmbiA9ICcsXG4gICAgICB0aGlzLmRlY29yYXRvcnMuZnVuY3Rpb25DYWxsKGZvdW5kRGVjb3JhdG9yLCAnJywgWydmbicsICdwcm9wcycsICdjb250YWluZXInLCBvcHRpb25zXSksXG4gICAgICAnIHx8IGZuOydcbiAgICBdKTtcbiAgfSxcblxuICAvLyBbaW52b2tlSGVscGVyXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiBoYXNoLCBpbnZlcnNlLCBwcm9ncmFtLCBwYXJhbXMuLi4sIC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHJlc3VsdCBvZiBoZWxwZXIgaW52b2NhdGlvblxuICAvL1xuICAvLyBQb3BzIG9mZiB0aGUgaGVscGVyJ3MgcGFyYW1ldGVycywgaW52b2tlcyB0aGUgaGVscGVyLFxuICAvLyBhbmQgcHVzaGVzIHRoZSBoZWxwZXIncyByZXR1cm4gdmFsdWUgb250byB0aGUgc3RhY2suXG4gIC8vXG4gIC8vIElmIHRoZSBoZWxwZXIgaXMgbm90IGZvdW5kLCBgaGVscGVyTWlzc2luZ2AgaXMgY2FsbGVkLlxuICBpbnZva2VIZWxwZXI6IGZ1bmN0aW9uKHBhcmFtU2l6ZSwgbmFtZSwgaXNTaW1wbGUpIHtcbiAgICBsZXQgbm9uSGVscGVyID0gdGhpcy5wb3BTdGFjaygpLFxuICAgICAgICBoZWxwZXIgPSB0aGlzLnNldHVwSGVscGVyKHBhcmFtU2l6ZSwgbmFtZSksXG4gICAgICAgIHNpbXBsZSA9IGlzU2ltcGxlID8gW2hlbHBlci5uYW1lLCAnIHx8ICddIDogJyc7XG5cbiAgICBsZXQgbG9va3VwID0gWycoJ10uY29uY2F0KHNpbXBsZSwgbm9uSGVscGVyKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgIGxvb2t1cC5wdXNoKCcgfHwgJywgdGhpcy5hbGlhc2FibGUoJ2hlbHBlcnMuaGVscGVyTWlzc2luZycpKTtcbiAgICB9XG4gICAgbG9va3VwLnB1c2goJyknKTtcblxuICAgIHRoaXMucHVzaCh0aGlzLnNvdXJjZS5mdW5jdGlvbkNhbGwobG9va3VwLCAnY2FsbCcsIGhlbHBlci5jYWxsUGFyYW1zKSk7XG4gIH0sXG5cbiAgLy8gW2ludm9rZUtub3duSGVscGVyXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiBoYXNoLCBpbnZlcnNlLCBwcm9ncmFtLCBwYXJhbXMuLi4sIC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHJlc3VsdCBvZiBoZWxwZXIgaW52b2NhdGlvblxuICAvL1xuICAvLyBUaGlzIG9wZXJhdGlvbiBpcyB1c2VkIHdoZW4gdGhlIGhlbHBlciBpcyBrbm93biB0byBleGlzdCxcbiAgLy8gc28gYSBgaGVscGVyTWlzc2luZ2AgZmFsbGJhY2sgaXMgbm90IHJlcXVpcmVkLlxuICBpbnZva2VLbm93bkhlbHBlcjogZnVuY3Rpb24ocGFyYW1TaXplLCBuYW1lKSB7XG4gICAgbGV0IGhlbHBlciA9IHRoaXMuc2V0dXBIZWxwZXIocGFyYW1TaXplLCBuYW1lKTtcbiAgICB0aGlzLnB1c2godGhpcy5zb3VyY2UuZnVuY3Rpb25DYWxsKGhlbHBlci5uYW1lLCAnY2FsbCcsIGhlbHBlci5jYWxsUGFyYW1zKSk7XG4gIH0sXG5cbiAgLy8gW2ludm9rZUFtYmlndW91c11cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogaGFzaCwgaW52ZXJzZSwgcHJvZ3JhbSwgcGFyYW1zLi4uLCAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiByZXN1bHQgb2YgZGlzYW1iaWd1YXRpb25cbiAgLy9cbiAgLy8gVGhpcyBvcGVyYXRpb24gaXMgdXNlZCB3aGVuIGFuIGV4cHJlc3Npb24gbGlrZSBge3tmb299fWBcbiAgLy8gaXMgcHJvdmlkZWQsIGJ1dCB3ZSBkb24ndCBrbm93IGF0IGNvbXBpbGUtdGltZSB3aGV0aGVyIGl0XG4gIC8vIGlzIGEgaGVscGVyIG9yIGEgcGF0aC5cbiAgLy9cbiAgLy8gVGhpcyBvcGVyYXRpb24gZW1pdHMgbW9yZSBjb2RlIHRoYW4gdGhlIG90aGVyIG9wdGlvbnMsXG4gIC8vIGFuZCBjYW4gYmUgYXZvaWRlZCBieSBwYXNzaW5nIHRoZSBga25vd25IZWxwZXJzYCBhbmRcbiAgLy8gYGtub3duSGVscGVyc09ubHlgIGZsYWdzIGF0IGNvbXBpbGUtdGltZS5cbiAgaW52b2tlQW1iaWd1b3VzOiBmdW5jdGlvbihuYW1lLCBoZWxwZXJDYWxsKSB7XG4gICAgdGhpcy51c2VSZWdpc3RlcignaGVscGVyJyk7XG5cbiAgICBsZXQgbm9uSGVscGVyID0gdGhpcy5wb3BTdGFjaygpO1xuXG4gICAgdGhpcy5lbXB0eUhhc2goKTtcbiAgICBsZXQgaGVscGVyID0gdGhpcy5zZXR1cEhlbHBlcigwLCBuYW1lLCBoZWxwZXJDYWxsKTtcblxuICAgIGxldCBoZWxwZXJOYW1lID0gdGhpcy5sYXN0SGVscGVyID0gdGhpcy5uYW1lTG9va3VwKCdoZWxwZXJzJywgbmFtZSwgJ2hlbHBlcicpO1xuXG4gICAgbGV0IGxvb2t1cCA9IFsnKCcsICcoaGVscGVyID0gJywgaGVscGVyTmFtZSwgJyB8fCAnLCBub25IZWxwZXIsICcpJ107XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICBsb29rdXBbMF0gPSAnKGhlbHBlciA9ICc7XG4gICAgICBsb29rdXAucHVzaChcbiAgICAgICAgJyAhPSBudWxsID8gaGVscGVyIDogJyxcbiAgICAgICAgdGhpcy5hbGlhc2FibGUoJ2hlbHBlcnMuaGVscGVyTWlzc2luZycpXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMucHVzaChbXG4gICAgICAgICcoJywgbG9va3VwLFxuICAgICAgICAoaGVscGVyLnBhcmFtc0luaXQgPyBbJyksKCcsIGhlbHBlci5wYXJhbXNJbml0XSA6IFtdKSwgJyksJyxcbiAgICAgICAgJyh0eXBlb2YgaGVscGVyID09PSAnLCB0aGlzLmFsaWFzYWJsZSgnXCJmdW5jdGlvblwiJyksICcgPyAnLFxuICAgICAgICB0aGlzLnNvdXJjZS5mdW5jdGlvbkNhbGwoJ2hlbHBlcicsICdjYWxsJywgaGVscGVyLmNhbGxQYXJhbXMpLCAnIDogaGVscGVyKSknXG4gICAgXSk7XG4gIH0sXG5cbiAgLy8gW2ludm9rZVBhcnRpYWxdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IGNvbnRleHQsIC4uLlxuICAvLyBPbiBzdGFjayBhZnRlcjogcmVzdWx0IG9mIHBhcnRpYWwgaW52b2NhdGlvblxuICAvL1xuICAvLyBUaGlzIG9wZXJhdGlvbiBwb3BzIG9mZiBhIGNvbnRleHQsIGludm9rZXMgYSBwYXJ0aWFsIHdpdGggdGhhdCBjb250ZXh0LFxuICAvLyBhbmQgcHVzaGVzIHRoZSByZXN1bHQgb2YgdGhlIGludm9jYXRpb24gYmFjay5cbiAgaW52b2tlUGFydGlhbDogZnVuY3Rpb24oaXNEeW5hbWljLCBuYW1lLCBpbmRlbnQpIHtcbiAgICBsZXQgcGFyYW1zID0gW10sXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLnNldHVwUGFyYW1zKG5hbWUsIDEsIHBhcmFtcyk7XG5cbiAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICBuYW1lID0gdGhpcy5wb3BTdGFjaygpO1xuICAgICAgZGVsZXRlIG9wdGlvbnMubmFtZTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZW50KSB7XG4gICAgICBvcHRpb25zLmluZGVudCA9IEpTT04uc3RyaW5naWZ5KGluZGVudCk7XG4gICAgfVxuICAgIG9wdGlvbnMuaGVscGVycyA9ICdoZWxwZXJzJztcbiAgICBvcHRpb25zLnBhcnRpYWxzID0gJ3BhcnRpYWxzJztcbiAgICBvcHRpb25zLmRlY29yYXRvcnMgPSAnY29udGFpbmVyLmRlY29yYXRvcnMnO1xuXG4gICAgaWYgKCFpc0R5bmFtaWMpIHtcbiAgICAgIHBhcmFtcy51bnNoaWZ0KHRoaXMubmFtZUxvb2t1cCgncGFydGlhbHMnLCBuYW1lLCAncGFydGlhbCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zLnVuc2hpZnQobmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb21wYXQpIHtcbiAgICAgIG9wdGlvbnMuZGVwdGhzID0gJ2RlcHRocyc7XG4gICAgfVxuICAgIG9wdGlvbnMgPSB0aGlzLm9iamVjdExpdGVyYWwob3B0aW9ucyk7XG4gICAgcGFyYW1zLnB1c2gob3B0aW9ucyk7XG5cbiAgICB0aGlzLnB1c2godGhpcy5zb3VyY2UuZnVuY3Rpb25DYWxsKCdjb250YWluZXIuaW52b2tlUGFydGlhbCcsICcnLCBwYXJhbXMpKTtcbiAgfSxcblxuICAvLyBbYXNzaWduVG9IYXNoXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiB2YWx1ZSwgLi4uLCBoYXNoLCAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiAuLi4sIGhhc2gsIC4uLlxuICAvL1xuICAvLyBQb3BzIGEgdmFsdWUgb2ZmIHRoZSBzdGFjayBhbmQgYXNzaWducyBpdCB0byB0aGUgY3VycmVudCBoYXNoXG4gIGFzc2lnblRvSGFzaDogZnVuY3Rpb24oa2V5KSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5wb3BTdGFjaygpLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICB0eXBlLFxuICAgICAgICBpZDtcblxuICAgIGlmICh0aGlzLnRyYWNrSWRzKSB7XG4gICAgICBpZCA9IHRoaXMucG9wU3RhY2soKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RyaW5nUGFyYW1zKSB7XG4gICAgICB0eXBlID0gdGhpcy5wb3BTdGFjaygpO1xuICAgICAgY29udGV4dCA9IHRoaXMucG9wU3RhY2soKTtcbiAgICB9XG5cbiAgICBsZXQgaGFzaCA9IHRoaXMuaGFzaDtcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgaGFzaC5jb250ZXh0c1trZXldID0gY29udGV4dDtcbiAgICB9XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGhhc2gudHlwZXNba2V5XSA9IHR5cGU7XG4gICAgfVxuICAgIGlmIChpZCkge1xuICAgICAgaGFzaC5pZHNba2V5XSA9IGlkO1xuICAgIH1cbiAgICBoYXNoLnZhbHVlc1trZXldID0gdmFsdWU7XG4gIH0sXG5cbiAgcHVzaElkOiBmdW5jdGlvbih0eXBlLCBuYW1lLCBjaGlsZCkge1xuICAgIGlmICh0eXBlID09PSAnQmxvY2tQYXJhbScpIHtcbiAgICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbChcbiAgICAgICAgICAnYmxvY2tQYXJhbXNbJyArIG5hbWVbMF0gKyAnXS5wYXRoWycgKyBuYW1lWzFdICsgJ10nXG4gICAgICAgICAgKyAoY2hpbGQgPyAnICsgJyArIEpTT04uc3RyaW5naWZ5KCcuJyArIGNoaWxkKSA6ICcnKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnUGF0aEV4cHJlc3Npb24nKSB7XG4gICAgICB0aGlzLnB1c2hTdHJpbmcobmFtZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnU3ViRXhwcmVzc2lvbicpIHtcbiAgICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbCgndHJ1ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwoJ251bGwnKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gSEVMUEVSU1xuXG4gIGNvbXBpbGVyOiBKYXZhU2NyaXB0Q29tcGlsZXIsXG5cbiAgY29tcGlsZUNoaWxkcmVuOiBmdW5jdGlvbihlbnZpcm9ubWVudCwgb3B0aW9ucykge1xuICAgIGxldCBjaGlsZHJlbiA9IGVudmlyb25tZW50LmNoaWxkcmVuLCBjaGlsZCwgY29tcGlsZXI7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGNvbXBpbGVyID0gbmV3IHRoaXMuY29tcGlsZXIoKTsgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG5cbiAgICAgIGxldCBleGlzdGluZyA9IHRoaXMubWF0Y2hFeGlzdGluZ1Byb2dyYW0oY2hpbGQpO1xuXG4gICAgICBpZiAoZXhpc3RpbmcgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNvbnRleHQucHJvZ3JhbXMucHVzaCgnJyk7ICAgICAvLyBQbGFjZWhvbGRlciB0byBwcmV2ZW50IG5hbWUgY29uZmxpY3RzIGZvciBuZXN0ZWQgY2hpbGRyZW5cbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5jb250ZXh0LnByb2dyYW1zLmxlbmd0aDtcbiAgICAgICAgY2hpbGQuaW5kZXggPSBpbmRleDtcbiAgICAgICAgY2hpbGQubmFtZSA9ICdwcm9ncmFtJyArIGluZGV4O1xuICAgICAgICB0aGlzLmNvbnRleHQucHJvZ3JhbXNbaW5kZXhdID0gY29tcGlsZXIuY29tcGlsZShjaGlsZCwgb3B0aW9ucywgdGhpcy5jb250ZXh0LCAhdGhpcy5wcmVjb21waWxlKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmRlY29yYXRvcnNbaW5kZXhdID0gY29tcGlsZXIuZGVjb3JhdG9ycztcbiAgICAgICAgdGhpcy5jb250ZXh0LmVudmlyb25tZW50c1tpbmRleF0gPSBjaGlsZDtcblxuICAgICAgICB0aGlzLnVzZURlcHRocyA9IHRoaXMudXNlRGVwdGhzIHx8IGNvbXBpbGVyLnVzZURlcHRocztcbiAgICAgICAgdGhpcy51c2VCbG9ja1BhcmFtcyA9IHRoaXMudXNlQmxvY2tQYXJhbXMgfHwgY29tcGlsZXIudXNlQmxvY2tQYXJhbXM7XG4gICAgICAgIGNoaWxkLnVzZURlcHRocyA9IHRoaXMudXNlRGVwdGhzO1xuICAgICAgICBjaGlsZC51c2VCbG9ja1BhcmFtcyA9IHRoaXMudXNlQmxvY2tQYXJhbXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZC5pbmRleCA9IGV4aXN0aW5nLmluZGV4O1xuICAgICAgICBjaGlsZC5uYW1lID0gJ3Byb2dyYW0nICsgZXhpc3RpbmcuaW5kZXg7XG5cbiAgICAgICAgdGhpcy51c2VEZXB0aHMgPSB0aGlzLnVzZURlcHRocyB8fCBleGlzdGluZy51c2VEZXB0aHM7XG4gICAgICAgIHRoaXMudXNlQmxvY2tQYXJhbXMgPSB0aGlzLnVzZUJsb2NrUGFyYW1zIHx8IGV4aXN0aW5nLnVzZUJsb2NrUGFyYW1zO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbWF0Y2hFeGlzdGluZ1Byb2dyYW06IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuY29udGV4dC5lbnZpcm9ubWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxldCBlbnZpcm9ubWVudCA9IHRoaXMuY29udGV4dC5lbnZpcm9ubWVudHNbaV07XG4gICAgICBpZiAoZW52aXJvbm1lbnQgJiYgZW52aXJvbm1lbnQuZXF1YWxzKGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHByb2dyYW1FeHByZXNzaW9uOiBmdW5jdGlvbihndWlkKSB7XG4gICAgbGV0IGNoaWxkID0gdGhpcy5lbnZpcm9ubWVudC5jaGlsZHJlbltndWlkXSxcbiAgICAgICAgcHJvZ3JhbVBhcmFtcyA9IFtjaGlsZC5pbmRleCwgJ2RhdGEnLCBjaGlsZC5ibG9ja1BhcmFtc107XG5cbiAgICBpZiAodGhpcy51c2VCbG9ja1BhcmFtcyB8fCB0aGlzLnVzZURlcHRocykge1xuICAgICAgcHJvZ3JhbVBhcmFtcy5wdXNoKCdibG9ja1BhcmFtcycpO1xuICAgIH1cbiAgICBpZiAodGhpcy51c2VEZXB0aHMpIHtcbiAgICAgIHByb2dyYW1QYXJhbXMucHVzaCgnZGVwdGhzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICdjb250YWluZXIucHJvZ3JhbSgnICsgcHJvZ3JhbVBhcmFtcy5qb2luKCcsICcpICsgJyknO1xuICB9LFxuXG4gIHVzZVJlZ2lzdGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLnJlZ2lzdGVyc1tuYW1lXSkge1xuICAgICAgdGhpcy5yZWdpc3RlcnNbbmFtZV0gPSB0cnVlO1xuICAgICAgdGhpcy5yZWdpc3RlcnMubGlzdC5wdXNoKG5hbWUpO1xuICAgIH1cbiAgfSxcblxuICBwdXNoOiBmdW5jdGlvbihleHByKSB7XG4gICAgaWYgKCEoZXhwciBpbnN0YW5jZW9mIExpdGVyYWwpKSB7XG4gICAgICBleHByID0gdGhpcy5zb3VyY2Uud3JhcChleHByKTtcbiAgICB9XG5cbiAgICB0aGlzLmlubGluZVN0YWNrLnB1c2goZXhwcik7XG4gICAgcmV0dXJuIGV4cHI7XG4gIH0sXG5cbiAgcHVzaFN0YWNrTGl0ZXJhbDogZnVuY3Rpb24oaXRlbSkge1xuICAgIHRoaXMucHVzaChuZXcgTGl0ZXJhbChpdGVtKSk7XG4gIH0sXG5cbiAgcHVzaFNvdXJjZTogZnVuY3Rpb24oc291cmNlKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NvbnRlbnQpIHtcbiAgICAgIHRoaXMuc291cmNlLnB1c2goXG4gICAgICAgICAgdGhpcy5hcHBlbmRUb0J1ZmZlcih0aGlzLnNvdXJjZS5xdW90ZWRTdHJpbmcodGhpcy5wZW5kaW5nQ29udGVudCksIHRoaXMucGVuZGluZ0xvY2F0aW9uKSk7XG4gICAgICB0aGlzLnBlbmRpbmdDb250ZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlLnB1c2goc291cmNlKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVwbGFjZVN0YWNrOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGxldCBwcmVmaXggPSBbJygnXSxcbiAgICAgICAgc3RhY2ssXG4gICAgICAgIGNyZWF0ZWRTdGFjayxcbiAgICAgICAgdXNlZExpdGVyYWw7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICghdGhpcy5pc0lubGluZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdyZXBsYWNlU3RhY2sgb24gbm9uLWlubGluZScpO1xuICAgIH1cblxuICAgIC8vIFdlIHdhbnQgdG8gbWVyZ2UgdGhlIGlubGluZSBzdGF0ZW1lbnQgaW50byB0aGUgcmVwbGFjZW1lbnQgc3RhdGVtZW50IHZpYSAnLCdcbiAgICBsZXQgdG9wID0gdGhpcy5wb3BTdGFjayh0cnVlKTtcblxuICAgIGlmICh0b3AgaW5zdGFuY2VvZiBMaXRlcmFsKSB7XG4gICAgICAvLyBMaXRlcmFscyBkbyBub3QgbmVlZCB0byBiZSBpbmxpbmVkXG4gICAgICBzdGFjayA9IFt0b3AudmFsdWVdO1xuICAgICAgcHJlZml4ID0gWycoJywgc3RhY2tdO1xuICAgICAgdXNlZExpdGVyYWwgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBHZXQgb3IgY3JlYXRlIHRoZSBjdXJyZW50IHN0YWNrIG5hbWUgZm9yIHVzZSBieSB0aGUgaW5saW5lXG4gICAgICBjcmVhdGVkU3RhY2sgPSB0cnVlO1xuICAgICAgbGV0IG5hbWUgPSB0aGlzLmluY3JTdGFjaygpO1xuXG4gICAgICBwcmVmaXggPSBbJygoJywgdGhpcy5wdXNoKG5hbWUpLCAnID0gJywgdG9wLCAnKSddO1xuICAgICAgc3RhY2sgPSB0aGlzLnRvcFN0YWNrKCk7XG4gICAgfVxuXG4gICAgbGV0IGl0ZW0gPSBjYWxsYmFjay5jYWxsKHRoaXMsIHN0YWNrKTtcblxuICAgIGlmICghdXNlZExpdGVyYWwpIHtcbiAgICAgIHRoaXMucG9wU3RhY2soKTtcbiAgICB9XG4gICAgaWYgKGNyZWF0ZWRTdGFjaykge1xuICAgICAgdGhpcy5zdGFja1Nsb3QtLTtcbiAgICB9XG4gICAgdGhpcy5wdXNoKHByZWZpeC5jb25jYXQoaXRlbSwgJyknKSk7XG4gIH0sXG5cbiAgaW5jclN0YWNrOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0YWNrU2xvdCsrO1xuICAgIGlmICh0aGlzLnN0YWNrU2xvdCA+IHRoaXMuc3RhY2tWYXJzLmxlbmd0aCkgeyB0aGlzLnN0YWNrVmFycy5wdXNoKCdzdGFjaycgKyB0aGlzLnN0YWNrU2xvdCk7IH1cbiAgICByZXR1cm4gdGhpcy50b3BTdGFja05hbWUoKTtcbiAgfSxcbiAgdG9wU3RhY2tOYW1lOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ3N0YWNrJyArIHRoaXMuc3RhY2tTbG90O1xuICB9LFxuICBmbHVzaElubGluZTogZnVuY3Rpb24oKSB7XG4gICAgbGV0IGlubGluZVN0YWNrID0gdGhpcy5pbmxpbmVTdGFjaztcbiAgICB0aGlzLmlubGluZVN0YWNrID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGlubGluZVN0YWNrLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsZXQgZW50cnkgPSBpbmxpbmVTdGFja1tpXTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGVudHJ5IGluc3RhbmNlb2YgTGl0ZXJhbCkge1xuICAgICAgICB0aGlzLmNvbXBpbGVTdGFjay5wdXNoKGVudHJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBzdGFjayA9IHRoaXMuaW5jclN0YWNrKCk7XG4gICAgICAgIHRoaXMucHVzaFNvdXJjZShbc3RhY2ssICcgPSAnLCBlbnRyeSwgJzsnXSk7XG4gICAgICAgIHRoaXMuY29tcGlsZVN0YWNrLnB1c2goc3RhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgaXNJbmxpbmU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlubGluZVN0YWNrLmxlbmd0aDtcbiAgfSxcblxuICBwb3BTdGFjazogZnVuY3Rpb24od3JhcHBlZCkge1xuICAgIGxldCBpbmxpbmUgPSB0aGlzLmlzSW5saW5lKCksXG4gICAgICAgIGl0ZW0gPSAoaW5saW5lID8gdGhpcy5pbmxpbmVTdGFjayA6IHRoaXMuY29tcGlsZVN0YWNrKS5wb3AoKTtcblxuICAgIGlmICghd3JhcHBlZCAmJiAoaXRlbSBpbnN0YW5jZW9mIExpdGVyYWwpKSB7XG4gICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFpbmxpbmUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKCF0aGlzLnN0YWNrU2xvdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ0ludmFsaWQgc3RhY2sgcG9wJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFja1Nsb3QtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgfSxcblxuICB0b3BTdGFjazogZnVuY3Rpb24oKSB7XG4gICAgbGV0IHN0YWNrID0gKHRoaXMuaXNJbmxpbmUoKSA/IHRoaXMuaW5saW5lU3RhY2sgOiB0aGlzLmNvbXBpbGVTdGFjayksXG4gICAgICAgIGl0ZW0gPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgTGl0ZXJhbCkge1xuICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgfSxcblxuICBjb250ZXh0TmFtZTogZnVuY3Rpb24oY29udGV4dCkge1xuICAgIGlmICh0aGlzLnVzZURlcHRocyAmJiBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gJ2RlcHRoc1snICsgY29udGV4dCArICddJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdkZXB0aCcgKyBjb250ZXh0O1xuICAgIH1cbiAgfSxcblxuICBxdW90ZWRTdHJpbmc6IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5xdW90ZWRTdHJpbmcoc3RyKTtcbiAgfSxcblxuICBvYmplY3RMaXRlcmFsOiBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2Uub2JqZWN0TGl0ZXJhbChvYmopO1xuICB9LFxuXG4gIGFsaWFzYWJsZTogZnVuY3Rpb24obmFtZSkge1xuICAgIGxldCByZXQgPSB0aGlzLmFsaWFzZXNbbmFtZV07XG4gICAgaWYgKHJldCkge1xuICAgICAgcmV0LnJlZmVyZW5jZUNvdW50Kys7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHJldCA9IHRoaXMuYWxpYXNlc1tuYW1lXSA9IHRoaXMuc291cmNlLndyYXAobmFtZSk7XG4gICAgcmV0LmFsaWFzYWJsZSA9IHRydWU7XG4gICAgcmV0LnJlZmVyZW5jZUNvdW50ID0gMTtcblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgc2V0dXBIZWxwZXI6IGZ1bmN0aW9uKHBhcmFtU2l6ZSwgbmFtZSwgYmxvY2tIZWxwZXIpIHtcbiAgICBsZXQgcGFyYW1zID0gW10sXG4gICAgICAgIHBhcmFtc0luaXQgPSB0aGlzLnNldHVwSGVscGVyQXJncyhuYW1lLCBwYXJhbVNpemUsIHBhcmFtcywgYmxvY2tIZWxwZXIpO1xuICAgIGxldCBmb3VuZEhlbHBlciA9IHRoaXMubmFtZUxvb2t1cCgnaGVscGVycycsIG5hbWUsICdoZWxwZXInKSxcbiAgICAgICAgY2FsbENvbnRleHQgPSB0aGlzLmFsaWFzYWJsZShgJHt0aGlzLmNvbnRleHROYW1lKDApfSAhPSBudWxsID8gJHt0aGlzLmNvbnRleHROYW1lKDApfSA6IChjb250YWluZXIubnVsbENvbnRleHQgfHwge30pYCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICBwYXJhbXNJbml0OiBwYXJhbXNJbml0LFxuICAgICAgbmFtZTogZm91bmRIZWxwZXIsXG4gICAgICBjYWxsUGFyYW1zOiBbY2FsbENvbnRleHRdLmNvbmNhdChwYXJhbXMpXG4gICAgfTtcbiAgfSxcblxuICBzZXR1cFBhcmFtczogZnVuY3Rpb24oaGVscGVyLCBwYXJhbVNpemUsIHBhcmFtcykge1xuICAgIGxldCBvcHRpb25zID0ge30sXG4gICAgICAgIGNvbnRleHRzID0gW10sXG4gICAgICAgIHR5cGVzID0gW10sXG4gICAgICAgIGlkcyA9IFtdLFxuICAgICAgICBvYmplY3RBcmdzID0gIXBhcmFtcyxcbiAgICAgICAgcGFyYW07XG5cbiAgICBpZiAob2JqZWN0QXJncykge1xuICAgICAgcGFyYW1zID0gW107XG4gICAgfVxuXG4gICAgb3B0aW9ucy5uYW1lID0gdGhpcy5xdW90ZWRTdHJpbmcoaGVscGVyKTtcbiAgICBvcHRpb25zLmhhc2ggPSB0aGlzLnBvcFN0YWNrKCk7XG5cbiAgICBpZiAodGhpcy50cmFja0lkcykge1xuICAgICAgb3B0aW9ucy5oYXNoSWRzID0gdGhpcy5wb3BTdGFjaygpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdHJpbmdQYXJhbXMpIHtcbiAgICAgIG9wdGlvbnMuaGFzaFR5cGVzID0gdGhpcy5wb3BTdGFjaygpO1xuICAgICAgb3B0aW9ucy5oYXNoQ29udGV4dHMgPSB0aGlzLnBvcFN0YWNrKCk7XG4gICAgfVxuXG4gICAgbGV0IGludmVyc2UgPSB0aGlzLnBvcFN0YWNrKCksXG4gICAgICAgIHByb2dyYW0gPSB0aGlzLnBvcFN0YWNrKCk7XG5cbiAgICAvLyBBdm9pZCBzZXR0aW5nIGZuIGFuZCBpbnZlcnNlIGlmIG5laXRoZXIgYXJlIHNldC4gVGhpcyBhbGxvd3NcbiAgICAvLyBoZWxwZXJzIHRvIGRvIGEgY2hlY2sgZm9yIGBpZiAob3B0aW9ucy5mbilgXG4gICAgaWYgKHByb2dyYW0gfHwgaW52ZXJzZSkge1xuICAgICAgb3B0aW9ucy5mbiA9IHByb2dyYW0gfHwgJ2NvbnRhaW5lci5ub29wJztcbiAgICAgIG9wdGlvbnMuaW52ZXJzZSA9IGludmVyc2UgfHwgJ2NvbnRhaW5lci5ub29wJztcbiAgICB9XG5cbiAgICAvLyBUaGUgcGFyYW1ldGVycyBnbyBvbiB0byB0aGUgc3RhY2sgaW4gb3JkZXIgKG1ha2luZyBzdXJlIHRoYXQgdGhleSBhcmUgZXZhbHVhdGVkIGluIG9yZGVyKVxuICAgIC8vIHNvIHdlIG5lZWQgdG8gcG9wIHRoZW0gb2ZmIHRoZSBzdGFjayBpbiByZXZlcnNlIG9yZGVyXG4gICAgbGV0IGkgPSBwYXJhbVNpemU7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcGFyYW0gPSB0aGlzLnBvcFN0YWNrKCk7XG4gICAgICBwYXJhbXNbaV0gPSBwYXJhbTtcblxuICAgICAgaWYgKHRoaXMudHJhY2tJZHMpIHtcbiAgICAgICAgaWRzW2ldID0gdGhpcy5wb3BTdGFjaygpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RyaW5nUGFyYW1zKSB7XG4gICAgICAgIHR5cGVzW2ldID0gdGhpcy5wb3BTdGFjaygpO1xuICAgICAgICBjb250ZXh0c1tpXSA9IHRoaXMucG9wU3RhY2soKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2JqZWN0QXJncykge1xuICAgICAgb3B0aW9ucy5hcmdzID0gdGhpcy5zb3VyY2UuZ2VuZXJhdGVBcnJheShwYXJhbXMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRyYWNrSWRzKSB7XG4gICAgICBvcHRpb25zLmlkcyA9IHRoaXMuc291cmNlLmdlbmVyYXRlQXJyYXkoaWRzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RyaW5nUGFyYW1zKSB7XG4gICAgICBvcHRpb25zLnR5cGVzID0gdGhpcy5zb3VyY2UuZ2VuZXJhdGVBcnJheSh0eXBlcyk7XG4gICAgICBvcHRpb25zLmNvbnRleHRzID0gdGhpcy5zb3VyY2UuZ2VuZXJhdGVBcnJheShjb250ZXh0cyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kYXRhKSB7XG4gICAgICBvcHRpb25zLmRhdGEgPSAnZGF0YSc7XG4gICAgfVxuICAgIGlmICh0aGlzLnVzZUJsb2NrUGFyYW1zKSB7XG4gICAgICBvcHRpb25zLmJsb2NrUGFyYW1zID0gJ2Jsb2NrUGFyYW1zJztcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH0sXG5cbiAgc2V0dXBIZWxwZXJBcmdzOiBmdW5jdGlvbihoZWxwZXIsIHBhcmFtU2l6ZSwgcGFyYW1zLCB1c2VSZWdpc3Rlcikge1xuICAgIGxldCBvcHRpb25zID0gdGhpcy5zZXR1cFBhcmFtcyhoZWxwZXIsIHBhcmFtU2l6ZSwgcGFyYW1zKTtcbiAgICBvcHRpb25zID0gdGhpcy5vYmplY3RMaXRlcmFsKG9wdGlvbnMpO1xuICAgIGlmICh1c2VSZWdpc3Rlcikge1xuICAgICAgdGhpcy51c2VSZWdpc3Rlcignb3B0aW9ucycpO1xuICAgICAgcGFyYW1zLnB1c2goJ29wdGlvbnMnKTtcbiAgICAgIHJldHVybiBbJ29wdGlvbnM9Jywgb3B0aW9uc107XG4gICAgfSBlbHNlIGlmIChwYXJhbXMpIHtcbiAgICAgIHBhcmFtcy5wdXNoKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH1cbn07XG5cblxuKGZ1bmN0aW9uKCkge1xuICBjb25zdCByZXNlcnZlZFdvcmRzID0gKFxuICAgICdicmVhayBlbHNlIG5ldyB2YXInICtcbiAgICAnIGNhc2UgZmluYWxseSByZXR1cm4gdm9pZCcgK1xuICAgICcgY2F0Y2ggZm9yIHN3aXRjaCB3aGlsZScgK1xuICAgICcgY29udGludWUgZnVuY3Rpb24gdGhpcyB3aXRoJyArXG4gICAgJyBkZWZhdWx0IGlmIHRocm93JyArXG4gICAgJyBkZWxldGUgaW4gdHJ5JyArXG4gICAgJyBkbyBpbnN0YW5jZW9mIHR5cGVvZicgK1xuICAgICcgYWJzdHJhY3QgZW51bSBpbnQgc2hvcnQnICtcbiAgICAnIGJvb2xlYW4gZXhwb3J0IGludGVyZmFjZSBzdGF0aWMnICtcbiAgICAnIGJ5dGUgZXh0ZW5kcyBsb25nIHN1cGVyJyArXG4gICAgJyBjaGFyIGZpbmFsIG5hdGl2ZSBzeW5jaHJvbml6ZWQnICtcbiAgICAnIGNsYXNzIGZsb2F0IHBhY2thZ2UgdGhyb3dzJyArXG4gICAgJyBjb25zdCBnb3RvIHByaXZhdGUgdHJhbnNpZW50JyArXG4gICAgJyBkZWJ1Z2dlciBpbXBsZW1lbnRzIHByb3RlY3RlZCB2b2xhdGlsZScgK1xuICAgICcgZG91YmxlIGltcG9ydCBwdWJsaWMgbGV0IHlpZWxkIGF3YWl0JyArXG4gICAgJyBudWxsIHRydWUgZmFsc2UnXG4gICkuc3BsaXQoJyAnKTtcblxuICBjb25zdCBjb21waWxlcldvcmRzID0gSmF2YVNjcmlwdENvbXBpbGVyLlJFU0VSVkVEX1dPUkRTID0ge307XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSByZXNlcnZlZFdvcmRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbXBpbGVyV29yZHNbcmVzZXJ2ZWRXb3Jkc1tpXV0gPSB0cnVlO1xuICB9XG59KCkpO1xuXG5KYXZhU2NyaXB0Q29tcGlsZXIuaXNWYWxpZEphdmFTY3JpcHRWYXJpYWJsZU5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiAhSmF2YVNjcmlwdENvbXBpbGVyLlJFU0VSVkVEX1dPUkRTW25hbWVdICYmICgvXlthLXpBLVpfJF1bMC05YS16QS1aXyRdKiQvKS50ZXN0KG5hbWUpO1xufTtcblxuZnVuY3Rpb24gc3RyaWN0TG9va3VwKHJlcXVpcmVUZXJtaW5hbCwgY29tcGlsZXIsIHBhcnRzLCB0eXBlKSB7XG4gIGxldCBzdGFjayA9IGNvbXBpbGVyLnBvcFN0YWNrKCksXG4gICAgICBpID0gMCxcbiAgICAgIGxlbiA9IHBhcnRzLmxlbmd0aDtcbiAgaWYgKHJlcXVpcmVUZXJtaW5hbCkge1xuICAgIGxlbi0tO1xuICB9XG5cbiAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgIHN0YWNrID0gY29tcGlsZXIubmFtZUxvb2t1cChzdGFjaywgcGFydHNbaV0sIHR5cGUpO1xuICB9XG5cbiAgaWYgKHJlcXVpcmVUZXJtaW5hbCkge1xuICAgIHJldHVybiBbY29tcGlsZXIuYWxpYXNhYmxlKCdjb250YWluZXIuc3RyaWN0JyksICcoJywgc3RhY2ssICcsICcsIGNvbXBpbGVyLnF1b3RlZFN0cmluZyhwYXJ0c1tpXSksICcpJ107XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEphdmFTY3JpcHRDb21waWxlcjtcbiIsIi8vIEZpbGUgaWdub3JlZCBpbiBjb3ZlcmFnZSB0ZXN0cyB2aWEgc2V0dGluZyBpbiAuaXN0YW5idWwueW1sXG4vKiBKaXNvbiBnZW5lcmF0ZWQgcGFyc2VyICovXG52YXIgaGFuZGxlYmFycyA9IChmdW5jdGlvbigpe1xudmFyIHBhcnNlciA9IHt0cmFjZTogZnVuY3Rpb24gdHJhY2UoKSB7IH0sXG55eToge30sXG5zeW1ib2xzXzoge1wiZXJyb3JcIjoyLFwicm9vdFwiOjMsXCJwcm9ncmFtXCI6NCxcIkVPRlwiOjUsXCJwcm9ncmFtX3JlcGV0aXRpb24wXCI6NixcInN0YXRlbWVudFwiOjcsXCJtdXN0YWNoZVwiOjgsXCJibG9ja1wiOjksXCJyYXdCbG9ja1wiOjEwLFwicGFydGlhbFwiOjExLFwicGFydGlhbEJsb2NrXCI6MTIsXCJjb250ZW50XCI6MTMsXCJDT01NRU5UXCI6MTQsXCJDT05URU5UXCI6MTUsXCJvcGVuUmF3QmxvY2tcIjoxNixcInJhd0Jsb2NrX3JlcGV0aXRpb25fcGx1czBcIjoxNyxcIkVORF9SQVdfQkxPQ0tcIjoxOCxcIk9QRU5fUkFXX0JMT0NLXCI6MTksXCJoZWxwZXJOYW1lXCI6MjAsXCJvcGVuUmF3QmxvY2tfcmVwZXRpdGlvbjBcIjoyMSxcIm9wZW5SYXdCbG9ja19vcHRpb24wXCI6MjIsXCJDTE9TRV9SQVdfQkxPQ0tcIjoyMyxcIm9wZW5CbG9ja1wiOjI0LFwiYmxvY2tfb3B0aW9uMFwiOjI1LFwiY2xvc2VCbG9ja1wiOjI2LFwib3BlbkludmVyc2VcIjoyNyxcImJsb2NrX29wdGlvbjFcIjoyOCxcIk9QRU5fQkxPQ0tcIjoyOSxcIm9wZW5CbG9ja19yZXBldGl0aW9uMFwiOjMwLFwib3BlbkJsb2NrX29wdGlvbjBcIjozMSxcIm9wZW5CbG9ja19vcHRpb24xXCI6MzIsXCJDTE9TRVwiOjMzLFwiT1BFTl9JTlZFUlNFXCI6MzQsXCJvcGVuSW52ZXJzZV9yZXBldGl0aW9uMFwiOjM1LFwib3BlbkludmVyc2Vfb3B0aW9uMFwiOjM2LFwib3BlbkludmVyc2Vfb3B0aW9uMVwiOjM3LFwib3BlbkludmVyc2VDaGFpblwiOjM4LFwiT1BFTl9JTlZFUlNFX0NIQUlOXCI6MzksXCJvcGVuSW52ZXJzZUNoYWluX3JlcGV0aXRpb24wXCI6NDAsXCJvcGVuSW52ZXJzZUNoYWluX29wdGlvbjBcIjo0MSxcIm9wZW5JbnZlcnNlQ2hhaW5fb3B0aW9uMVwiOjQyLFwiaW52ZXJzZUFuZFByb2dyYW1cIjo0MyxcIklOVkVSU0VcIjo0NCxcImludmVyc2VDaGFpblwiOjQ1LFwiaW52ZXJzZUNoYWluX29wdGlvbjBcIjo0NixcIk9QRU5fRU5EQkxPQ0tcIjo0NyxcIk9QRU5cIjo0OCxcIm11c3RhY2hlX3JlcGV0aXRpb24wXCI6NDksXCJtdXN0YWNoZV9vcHRpb24wXCI6NTAsXCJPUEVOX1VORVNDQVBFRFwiOjUxLFwibXVzdGFjaGVfcmVwZXRpdGlvbjFcIjo1MixcIm11c3RhY2hlX29wdGlvbjFcIjo1MyxcIkNMT1NFX1VORVNDQVBFRFwiOjU0LFwiT1BFTl9QQVJUSUFMXCI6NTUsXCJwYXJ0aWFsTmFtZVwiOjU2LFwicGFydGlhbF9yZXBldGl0aW9uMFwiOjU3LFwicGFydGlhbF9vcHRpb24wXCI6NTgsXCJvcGVuUGFydGlhbEJsb2NrXCI6NTksXCJPUEVOX1BBUlRJQUxfQkxPQ0tcIjo2MCxcIm9wZW5QYXJ0aWFsQmxvY2tfcmVwZXRpdGlvbjBcIjo2MSxcIm9wZW5QYXJ0aWFsQmxvY2tfb3B0aW9uMFwiOjYyLFwicGFyYW1cIjo2MyxcInNleHByXCI6NjQsXCJPUEVOX1NFWFBSXCI6NjUsXCJzZXhwcl9yZXBldGl0aW9uMFwiOjY2LFwic2V4cHJfb3B0aW9uMFwiOjY3LFwiQ0xPU0VfU0VYUFJcIjo2OCxcImhhc2hcIjo2OSxcImhhc2hfcmVwZXRpdGlvbl9wbHVzMFwiOjcwLFwiaGFzaFNlZ21lbnRcIjo3MSxcIklEXCI6NzIsXCJFUVVBTFNcIjo3MyxcImJsb2NrUGFyYW1zXCI6NzQsXCJPUEVOX0JMT0NLX1BBUkFNU1wiOjc1LFwiYmxvY2tQYXJhbXNfcmVwZXRpdGlvbl9wbHVzMFwiOjc2LFwiQ0xPU0VfQkxPQ0tfUEFSQU1TXCI6NzcsXCJwYXRoXCI6NzgsXCJkYXRhTmFtZVwiOjc5LFwiU1RSSU5HXCI6ODAsXCJOVU1CRVJcIjo4MSxcIkJPT0xFQU5cIjo4MixcIlVOREVGSU5FRFwiOjgzLFwiTlVMTFwiOjg0LFwiREFUQVwiOjg1LFwicGF0aFNlZ21lbnRzXCI6ODYsXCJTRVBcIjo4NyxcIiRhY2NlcHRcIjowLFwiJGVuZFwiOjF9LFxudGVybWluYWxzXzogezI6XCJlcnJvclwiLDU6XCJFT0ZcIiwxNDpcIkNPTU1FTlRcIiwxNTpcIkNPTlRFTlRcIiwxODpcIkVORF9SQVdfQkxPQ0tcIiwxOTpcIk9QRU5fUkFXX0JMT0NLXCIsMjM6XCJDTE9TRV9SQVdfQkxPQ0tcIiwyOTpcIk9QRU5fQkxPQ0tcIiwzMzpcIkNMT1NFXCIsMzQ6XCJPUEVOX0lOVkVSU0VcIiwzOTpcIk9QRU5fSU5WRVJTRV9DSEFJTlwiLDQ0OlwiSU5WRVJTRVwiLDQ3OlwiT1BFTl9FTkRCTE9DS1wiLDQ4OlwiT1BFTlwiLDUxOlwiT1BFTl9VTkVTQ0FQRURcIiw1NDpcIkNMT1NFX1VORVNDQVBFRFwiLDU1OlwiT1BFTl9QQVJUSUFMXCIsNjA6XCJPUEVOX1BBUlRJQUxfQkxPQ0tcIiw2NTpcIk9QRU5fU0VYUFJcIiw2ODpcIkNMT1NFX1NFWFBSXCIsNzI6XCJJRFwiLDczOlwiRVFVQUxTXCIsNzU6XCJPUEVOX0JMT0NLX1BBUkFNU1wiLDc3OlwiQ0xPU0VfQkxPQ0tfUEFSQU1TXCIsODA6XCJTVFJJTkdcIiw4MTpcIk5VTUJFUlwiLDgyOlwiQk9PTEVBTlwiLDgzOlwiVU5ERUZJTkVEXCIsODQ6XCJOVUxMXCIsODU6XCJEQVRBXCIsODc6XCJTRVBcIn0sXG5wcm9kdWN0aW9uc186IFswLFszLDJdLFs0LDFdLFs3LDFdLFs3LDFdLFs3LDFdLFs3LDFdLFs3LDFdLFs3LDFdLFs3LDFdLFsxMywxXSxbMTAsM10sWzE2LDVdLFs5LDRdLFs5LDRdLFsyNCw2XSxbMjcsNl0sWzM4LDZdLFs0MywyXSxbNDUsM10sWzQ1LDFdLFsyNiwzXSxbOCw1XSxbOCw1XSxbMTEsNV0sWzEyLDNdLFs1OSw1XSxbNjMsMV0sWzYzLDFdLFs2NCw1XSxbNjksMV0sWzcxLDNdLFs3NCwzXSxbMjAsMV0sWzIwLDFdLFsyMCwxXSxbMjAsMV0sWzIwLDFdLFsyMCwxXSxbMjAsMV0sWzU2LDFdLFs1NiwxXSxbNzksMl0sWzc4LDFdLFs4NiwzXSxbODYsMV0sWzYsMF0sWzYsMl0sWzE3LDFdLFsxNywyXSxbMjEsMF0sWzIxLDJdLFsyMiwwXSxbMjIsMV0sWzI1LDBdLFsyNSwxXSxbMjgsMF0sWzI4LDFdLFszMCwwXSxbMzAsMl0sWzMxLDBdLFszMSwxXSxbMzIsMF0sWzMyLDFdLFszNSwwXSxbMzUsMl0sWzM2LDBdLFszNiwxXSxbMzcsMF0sWzM3LDFdLFs0MCwwXSxbNDAsMl0sWzQxLDBdLFs0MSwxXSxbNDIsMF0sWzQyLDFdLFs0NiwwXSxbNDYsMV0sWzQ5LDBdLFs0OSwyXSxbNTAsMF0sWzUwLDFdLFs1MiwwXSxbNTIsMl0sWzUzLDBdLFs1MywxXSxbNTcsMF0sWzU3LDJdLFs1OCwwXSxbNTgsMV0sWzYxLDBdLFs2MSwyXSxbNjIsMF0sWzYyLDFdLFs2NiwwXSxbNjYsMl0sWzY3LDBdLFs2NywxXSxbNzAsMV0sWzcwLDJdLFs3NiwxXSxbNzYsMl1dLFxucGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5dGV4dCx5eWxlbmcseXlsaW5lbm8seXkseXlzdGF0ZSwkJCxfJFxuLyoqLykge1xuXG52YXIgJDAgPSAkJC5sZW5ndGggLSAxO1xuc3dpdGNoICh5eXN0YXRlKSB7XG5jYXNlIDE6IHJldHVybiAkJFskMC0xXTsgXG5icmVhaztcbmNhc2UgMjp0aGlzLiQgPSB5eS5wcmVwYXJlUHJvZ3JhbSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDM6dGhpcy4kID0gJCRbJDBdO1xuYnJlYWs7XG5jYXNlIDQ6dGhpcy4kID0gJCRbJDBdO1xuYnJlYWs7XG5jYXNlIDU6dGhpcy4kID0gJCRbJDBdO1xuYnJlYWs7XG5jYXNlIDY6dGhpcy4kID0gJCRbJDBdO1xuYnJlYWs7XG5jYXNlIDc6dGhpcy4kID0gJCRbJDBdO1xuYnJlYWs7XG5jYXNlIDg6dGhpcy4kID0gJCRbJDBdO1xuYnJlYWs7XG5jYXNlIDk6XG4gICAgdGhpcy4kID0ge1xuICAgICAgdHlwZTogJ0NvbW1lbnRTdGF0ZW1lbnQnLFxuICAgICAgdmFsdWU6IHl5LnN0cmlwQ29tbWVudCgkJFskMF0pLFxuICAgICAgc3RyaXA6IHl5LnN0cmlwRmxhZ3MoJCRbJDBdLCAkJFskMF0pLFxuICAgICAgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpXG4gICAgfTtcbiAgXG5icmVhaztcbmNhc2UgMTA6XG4gICAgdGhpcy4kID0ge1xuICAgICAgdHlwZTogJ0NvbnRlbnRTdGF0ZW1lbnQnLFxuICAgICAgb3JpZ2luYWw6ICQkWyQwXSxcbiAgICAgIHZhbHVlOiAkJFskMF0sXG4gICAgICBsb2M6IHl5LmxvY0luZm8odGhpcy5fJClcbiAgICB9O1xuICBcbmJyZWFrO1xuY2FzZSAxMTp0aGlzLiQgPSB5eS5wcmVwYXJlUmF3QmxvY2soJCRbJDAtMl0sICQkWyQwLTFdLCAkJFskMF0sIHRoaXMuXyQpO1xuYnJlYWs7XG5jYXNlIDEyOnRoaXMuJCA9IHsgcGF0aDogJCRbJDAtM10sIHBhcmFtczogJCRbJDAtMl0sIGhhc2g6ICQkWyQwLTFdIH07XG5icmVhaztcbmNhc2UgMTM6dGhpcy4kID0geXkucHJlcGFyZUJsb2NrKCQkWyQwLTNdLCAkJFskMC0yXSwgJCRbJDAtMV0sICQkWyQwXSwgZmFsc2UsIHRoaXMuXyQpO1xuYnJlYWs7XG5jYXNlIDE0OnRoaXMuJCA9IHl5LnByZXBhcmVCbG9jaygkJFskMC0zXSwgJCRbJDAtMl0sICQkWyQwLTFdLCAkJFskMF0sIHRydWUsIHRoaXMuXyQpO1xuYnJlYWs7XG5jYXNlIDE1OnRoaXMuJCA9IHsgb3BlbjogJCRbJDAtNV0sIHBhdGg6ICQkWyQwLTRdLCBwYXJhbXM6ICQkWyQwLTNdLCBoYXNoOiAkJFskMC0yXSwgYmxvY2tQYXJhbXM6ICQkWyQwLTFdLCBzdHJpcDogeXkuc3RyaXBGbGFncygkJFskMC01XSwgJCRbJDBdKSB9O1xuYnJlYWs7XG5jYXNlIDE2OnRoaXMuJCA9IHsgcGF0aDogJCRbJDAtNF0sIHBhcmFtczogJCRbJDAtM10sIGhhc2g6ICQkWyQwLTJdLCBibG9ja1BhcmFtczogJCRbJDAtMV0sIHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwLTVdLCAkJFskMF0pIH07XG5icmVhaztcbmNhc2UgMTc6dGhpcy4kID0geyBwYXRoOiAkJFskMC00XSwgcGFyYW1zOiAkJFskMC0zXSwgaGFzaDogJCRbJDAtMl0sIGJsb2NrUGFyYW1zOiAkJFskMC0xXSwgc3RyaXA6IHl5LnN0cmlwRmxhZ3MoJCRbJDAtNV0sICQkWyQwXSkgfTtcbmJyZWFrO1xuY2FzZSAxODp0aGlzLiQgPSB7IHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwLTFdLCAkJFskMC0xXSksIHByb2dyYW06ICQkWyQwXSB9O1xuYnJlYWs7XG5jYXNlIDE5OlxuICAgIHZhciBpbnZlcnNlID0geXkucHJlcGFyZUJsb2NrKCQkWyQwLTJdLCAkJFskMC0xXSwgJCRbJDBdLCAkJFskMF0sIGZhbHNlLCB0aGlzLl8kKSxcbiAgICAgICAgcHJvZ3JhbSA9IHl5LnByZXBhcmVQcm9ncmFtKFtpbnZlcnNlXSwgJCRbJDAtMV0ubG9jKTtcbiAgICBwcm9ncmFtLmNoYWluZWQgPSB0cnVlO1xuXG4gICAgdGhpcy4kID0geyBzdHJpcDogJCRbJDAtMl0uc3RyaXAsIHByb2dyYW06IHByb2dyYW0sIGNoYWluOiB0cnVlIH07XG4gIFxuYnJlYWs7XG5jYXNlIDIwOnRoaXMuJCA9ICQkWyQwXTtcbmJyZWFrO1xuY2FzZSAyMTp0aGlzLiQgPSB7cGF0aDogJCRbJDAtMV0sIHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwLTJdLCAkJFskMF0pfTtcbmJyZWFrO1xuY2FzZSAyMjp0aGlzLiQgPSB5eS5wcmVwYXJlTXVzdGFjaGUoJCRbJDAtM10sICQkWyQwLTJdLCAkJFskMC0xXSwgJCRbJDAtNF0sIHl5LnN0cmlwRmxhZ3MoJCRbJDAtNF0sICQkWyQwXSksIHRoaXMuXyQpO1xuYnJlYWs7XG5jYXNlIDIzOnRoaXMuJCA9IHl5LnByZXBhcmVNdXN0YWNoZSgkJFskMC0zXSwgJCRbJDAtMl0sICQkWyQwLTFdLCAkJFskMC00XSwgeXkuc3RyaXBGbGFncygkJFskMC00XSwgJCRbJDBdKSwgdGhpcy5fJCk7XG5icmVhaztcbmNhc2UgMjQ6XG4gICAgdGhpcy4kID0ge1xuICAgICAgdHlwZTogJ1BhcnRpYWxTdGF0ZW1lbnQnLFxuICAgICAgbmFtZTogJCRbJDAtM10sXG4gICAgICBwYXJhbXM6ICQkWyQwLTJdLFxuICAgICAgaGFzaDogJCRbJDAtMV0sXG4gICAgICBpbmRlbnQ6ICcnLFxuICAgICAgc3RyaXA6IHl5LnN0cmlwRmxhZ3MoJCRbJDAtNF0sICQkWyQwXSksXG4gICAgICBsb2M6IHl5LmxvY0luZm8odGhpcy5fJClcbiAgICB9O1xuICBcbmJyZWFrO1xuY2FzZSAyNTp0aGlzLiQgPSB5eS5wcmVwYXJlUGFydGlhbEJsb2NrKCQkWyQwLTJdLCAkJFskMC0xXSwgJCRbJDBdLCB0aGlzLl8kKTtcbmJyZWFrO1xuY2FzZSAyNjp0aGlzLiQgPSB7IHBhdGg6ICQkWyQwLTNdLCBwYXJhbXM6ICQkWyQwLTJdLCBoYXNoOiAkJFskMC0xXSwgc3RyaXA6IHl5LnN0cmlwRmxhZ3MoJCRbJDAtNF0sICQkWyQwXSkgfTtcbmJyZWFrO1xuY2FzZSAyNzp0aGlzLiQgPSAkJFskMF07XG5icmVhaztcbmNhc2UgMjg6dGhpcy4kID0gJCRbJDBdO1xuYnJlYWs7XG5jYXNlIDI5OlxuICAgIHRoaXMuJCA9IHtcbiAgICAgIHR5cGU6ICdTdWJFeHByZXNzaW9uJyxcbiAgICAgIHBhdGg6ICQkWyQwLTNdLFxuICAgICAgcGFyYW1zOiAkJFskMC0yXSxcbiAgICAgIGhhc2g6ICQkWyQwLTFdLFxuICAgICAgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpXG4gICAgfTtcbiAgXG5icmVhaztcbmNhc2UgMzA6dGhpcy4kID0ge3R5cGU6ICdIYXNoJywgcGFpcnM6ICQkWyQwXSwgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpfTtcbmJyZWFrO1xuY2FzZSAzMTp0aGlzLiQgPSB7dHlwZTogJ0hhc2hQYWlyJywga2V5OiB5eS5pZCgkJFskMC0yXSksIHZhbHVlOiAkJFskMF0sIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKX07XG5icmVhaztcbmNhc2UgMzI6dGhpcy4kID0geXkuaWQoJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDMzOnRoaXMuJCA9ICQkWyQwXTtcbmJyZWFrO1xuY2FzZSAzNDp0aGlzLiQgPSAkJFskMF07XG5icmVhaztcbmNhc2UgMzU6dGhpcy4kID0ge3R5cGU6ICdTdHJpbmdMaXRlcmFsJywgdmFsdWU6ICQkWyQwXSwgb3JpZ2luYWw6ICQkWyQwXSwgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpfTtcbmJyZWFrO1xuY2FzZSAzNjp0aGlzLiQgPSB7dHlwZTogJ051bWJlckxpdGVyYWwnLCB2YWx1ZTogTnVtYmVyKCQkWyQwXSksIG9yaWdpbmFsOiBOdW1iZXIoJCRbJDBdKSwgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpfTtcbmJyZWFrO1xuY2FzZSAzNzp0aGlzLiQgPSB7dHlwZTogJ0Jvb2xlYW5MaXRlcmFsJywgdmFsdWU6ICQkWyQwXSA9PT0gJ3RydWUnLCBvcmlnaW5hbDogJCRbJDBdID09PSAndHJ1ZScsIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKX07XG5icmVhaztcbmNhc2UgMzg6dGhpcy4kID0ge3R5cGU6ICdVbmRlZmluZWRMaXRlcmFsJywgb3JpZ2luYWw6IHVuZGVmaW5lZCwgdmFsdWU6IHVuZGVmaW5lZCwgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpfTtcbmJyZWFrO1xuY2FzZSAzOTp0aGlzLiQgPSB7dHlwZTogJ051bGxMaXRlcmFsJywgb3JpZ2luYWw6IG51bGwsIHZhbHVlOiBudWxsLCBsb2M6IHl5LmxvY0luZm8odGhpcy5fJCl9O1xuYnJlYWs7XG5jYXNlIDQwOnRoaXMuJCA9ICQkWyQwXTtcbmJyZWFrO1xuY2FzZSA0MTp0aGlzLiQgPSAkJFskMF07XG5icmVhaztcbmNhc2UgNDI6dGhpcy4kID0geXkucHJlcGFyZVBhdGgodHJ1ZSwgJCRbJDBdLCB0aGlzLl8kKTtcbmJyZWFrO1xuY2FzZSA0Mzp0aGlzLiQgPSB5eS5wcmVwYXJlUGF0aChmYWxzZSwgJCRbJDBdLCB0aGlzLl8kKTtcbmJyZWFrO1xuY2FzZSA0NDogJCRbJDAtMl0ucHVzaCh7cGFydDogeXkuaWQoJCRbJDBdKSwgb3JpZ2luYWw6ICQkWyQwXSwgc2VwYXJhdG9yOiAkJFskMC0xXX0pOyB0aGlzLiQgPSAkJFskMC0yXTsgXG5icmVhaztcbmNhc2UgNDU6dGhpcy4kID0gW3twYXJ0OiB5eS5pZCgkJFskMF0pLCBvcmlnaW5hbDogJCRbJDBdfV07XG5icmVhaztcbmNhc2UgNDY6dGhpcy4kID0gW107XG5icmVhaztcbmNhc2UgNDc6JCRbJDAtMV0ucHVzaCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDQ4OnRoaXMuJCA9IFskJFskMF1dO1xuYnJlYWs7XG5jYXNlIDQ5OiQkWyQwLTFdLnB1c2goJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA1MDp0aGlzLiQgPSBbXTtcbmJyZWFrO1xuY2FzZSA1MTokJFskMC0xXS5wdXNoKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNTg6dGhpcy4kID0gW107XG5icmVhaztcbmNhc2UgNTk6JCRbJDAtMV0ucHVzaCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDY0OnRoaXMuJCA9IFtdO1xuYnJlYWs7XG5jYXNlIDY1OiQkWyQwLTFdLnB1c2goJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA3MDp0aGlzLiQgPSBbXTtcbmJyZWFrO1xuY2FzZSA3MTokJFskMC0xXS5wdXNoKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNzg6dGhpcy4kID0gW107XG5icmVhaztcbmNhc2UgNzk6JCRbJDAtMV0ucHVzaCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDgyOnRoaXMuJCA9IFtdO1xuYnJlYWs7XG5jYXNlIDgzOiQkWyQwLTFdLnB1c2goJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA4Njp0aGlzLiQgPSBbXTtcbmJyZWFrO1xuY2FzZSA4NzokJFskMC0xXS5wdXNoKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgOTA6dGhpcy4kID0gW107XG5icmVhaztcbmNhc2UgOTE6JCRbJDAtMV0ucHVzaCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDk0OnRoaXMuJCA9IFtdO1xuYnJlYWs7XG5jYXNlIDk1OiQkWyQwLTFdLnB1c2goJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA5ODp0aGlzLiQgPSBbJCRbJDBdXTtcbmJyZWFrO1xuY2FzZSA5OTokJFskMC0xXS5wdXNoKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTAwOnRoaXMuJCA9IFskJFskMF1dO1xuYnJlYWs7XG5jYXNlIDEwMTokJFskMC0xXS5wdXNoKCQkWyQwXSk7XG5icmVhaztcbn1cbn0sXG50YWJsZTogW3szOjEsNDoyLDU6WzIsNDZdLDY6MywxNDpbMiw0Nl0sMTU6WzIsNDZdLDE5OlsyLDQ2XSwyOTpbMiw0Nl0sMzQ6WzIsNDZdLDQ4OlsyLDQ2XSw1MTpbMiw0Nl0sNTU6WzIsNDZdLDYwOlsyLDQ2XX0sezE6WzNdfSx7NTpbMSw0XX0sezU6WzIsMl0sNzo1LDg6Niw5OjcsMTA6OCwxMTo5LDEyOjEwLDEzOjExLDE0OlsxLDEyXSwxNTpbMSwyMF0sMTY6MTcsMTk6WzEsMjNdLDI0OjE1LDI3OjE2LDI5OlsxLDIxXSwzNDpbMSwyMl0sMzk6WzIsMl0sNDQ6WzIsMl0sNDc6WzIsMl0sNDg6WzEsMTNdLDUxOlsxLDE0XSw1NTpbMSwxOF0sNTk6MTksNjA6WzEsMjRdfSx7MTpbMiwxXX0sezU6WzIsNDddLDE0OlsyLDQ3XSwxNTpbMiw0N10sMTk6WzIsNDddLDI5OlsyLDQ3XSwzNDpbMiw0N10sMzk6WzIsNDddLDQ0OlsyLDQ3XSw0NzpbMiw0N10sNDg6WzIsNDddLDUxOlsyLDQ3XSw1NTpbMiw0N10sNjA6WzIsNDddfSx7NTpbMiwzXSwxNDpbMiwzXSwxNTpbMiwzXSwxOTpbMiwzXSwyOTpbMiwzXSwzNDpbMiwzXSwzOTpbMiwzXSw0NDpbMiwzXSw0NzpbMiwzXSw0ODpbMiwzXSw1MTpbMiwzXSw1NTpbMiwzXSw2MDpbMiwzXX0sezU6WzIsNF0sMTQ6WzIsNF0sMTU6WzIsNF0sMTk6WzIsNF0sMjk6WzIsNF0sMzQ6WzIsNF0sMzk6WzIsNF0sNDQ6WzIsNF0sNDc6WzIsNF0sNDg6WzIsNF0sNTE6WzIsNF0sNTU6WzIsNF0sNjA6WzIsNF19LHs1OlsyLDVdLDE0OlsyLDVdLDE1OlsyLDVdLDE5OlsyLDVdLDI5OlsyLDVdLDM0OlsyLDVdLDM5OlsyLDVdLDQ0OlsyLDVdLDQ3OlsyLDVdLDQ4OlsyLDVdLDUxOlsyLDVdLDU1OlsyLDVdLDYwOlsyLDVdfSx7NTpbMiw2XSwxNDpbMiw2XSwxNTpbMiw2XSwxOTpbMiw2XSwyOTpbMiw2XSwzNDpbMiw2XSwzOTpbMiw2XSw0NDpbMiw2XSw0NzpbMiw2XSw0ODpbMiw2XSw1MTpbMiw2XSw1NTpbMiw2XSw2MDpbMiw2XX0sezU6WzIsN10sMTQ6WzIsN10sMTU6WzIsN10sMTk6WzIsN10sMjk6WzIsN10sMzQ6WzIsN10sMzk6WzIsN10sNDQ6WzIsN10sNDc6WzIsN10sNDg6WzIsN10sNTE6WzIsN10sNTU6WzIsN10sNjA6WzIsN119LHs1OlsyLDhdLDE0OlsyLDhdLDE1OlsyLDhdLDE5OlsyLDhdLDI5OlsyLDhdLDM0OlsyLDhdLDM5OlsyLDhdLDQ0OlsyLDhdLDQ3OlsyLDhdLDQ4OlsyLDhdLDUxOlsyLDhdLDU1OlsyLDhdLDYwOlsyLDhdfSx7NTpbMiw5XSwxNDpbMiw5XSwxNTpbMiw5XSwxOTpbMiw5XSwyOTpbMiw5XSwzNDpbMiw5XSwzOTpbMiw5XSw0NDpbMiw5XSw0NzpbMiw5XSw0ODpbMiw5XSw1MTpbMiw5XSw1NTpbMiw5XSw2MDpbMiw5XX0sezIwOjI1LDcyOlsxLDM1XSw3ODoyNiw3OToyNyw4MDpbMSwyOF0sODE6WzEsMjldLDgyOlsxLDMwXSw4MzpbMSwzMV0sODQ6WzEsMzJdLDg1OlsxLDM0XSw4NjozM30sezIwOjM2LDcyOlsxLDM1XSw3ODoyNiw3OToyNyw4MDpbMSwyOF0sODE6WzEsMjldLDgyOlsxLDMwXSw4MzpbMSwzMV0sODQ6WzEsMzJdLDg1OlsxLDM0XSw4NjozM30sezQ6MzcsNjozLDE0OlsyLDQ2XSwxNTpbMiw0Nl0sMTk6WzIsNDZdLDI5OlsyLDQ2XSwzNDpbMiw0Nl0sMzk6WzIsNDZdLDQ0OlsyLDQ2XSw0NzpbMiw0Nl0sNDg6WzIsNDZdLDUxOlsyLDQ2XSw1NTpbMiw0Nl0sNjA6WzIsNDZdfSx7NDozOCw2OjMsMTQ6WzIsNDZdLDE1OlsyLDQ2XSwxOTpbMiw0Nl0sMjk6WzIsNDZdLDM0OlsyLDQ2XSw0NDpbMiw0Nl0sNDc6WzIsNDZdLDQ4OlsyLDQ2XSw1MTpbMiw0Nl0sNTU6WzIsNDZdLDYwOlsyLDQ2XX0sezEzOjQwLDE1OlsxLDIwXSwxNzozOX0sezIwOjQyLDU2OjQxLDY0OjQzLDY1OlsxLDQ0XSw3MjpbMSwzNV0sNzg6MjYsNzk6MjcsODA6WzEsMjhdLDgxOlsxLDI5XSw4MjpbMSwzMF0sODM6WzEsMzFdLDg0OlsxLDMyXSw4NTpbMSwzNF0sODY6MzN9LHs0OjQ1LDY6MywxNDpbMiw0Nl0sMTU6WzIsNDZdLDE5OlsyLDQ2XSwyOTpbMiw0Nl0sMzQ6WzIsNDZdLDQ3OlsyLDQ2XSw0ODpbMiw0Nl0sNTE6WzIsNDZdLDU1OlsyLDQ2XSw2MDpbMiw0Nl19LHs1OlsyLDEwXSwxNDpbMiwxMF0sMTU6WzIsMTBdLDE4OlsyLDEwXSwxOTpbMiwxMF0sMjk6WzIsMTBdLDM0OlsyLDEwXSwzOTpbMiwxMF0sNDQ6WzIsMTBdLDQ3OlsyLDEwXSw0ODpbMiwxMF0sNTE6WzIsMTBdLDU1OlsyLDEwXSw2MDpbMiwxMF19LHsyMDo0Niw3MjpbMSwzNV0sNzg6MjYsNzk6MjcsODA6WzEsMjhdLDgxOlsxLDI5XSw4MjpbMSwzMF0sODM6WzEsMzFdLDg0OlsxLDMyXSw4NTpbMSwzNF0sODY6MzN9LHsyMDo0Nyw3MjpbMSwzNV0sNzg6MjYsNzk6MjcsODA6WzEsMjhdLDgxOlsxLDI5XSw4MjpbMSwzMF0sODM6WzEsMzFdLDg0OlsxLDMyXSw4NTpbMSwzNF0sODY6MzN9LHsyMDo0OCw3MjpbMSwzNV0sNzg6MjYsNzk6MjcsODA6WzEsMjhdLDgxOlsxLDI5XSw4MjpbMSwzMF0sODM6WzEsMzFdLDg0OlsxLDMyXSw4NTpbMSwzNF0sODY6MzN9LHsyMDo0Miw1Njo0OSw2NDo0Myw2NTpbMSw0NF0sNzI6WzEsMzVdLDc4OjI2LDc5OjI3LDgwOlsxLDI4XSw4MTpbMSwyOV0sODI6WzEsMzBdLDgzOlsxLDMxXSw4NDpbMSwzMl0sODU6WzEsMzRdLDg2OjMzfSx7MzM6WzIsNzhdLDQ5OjUwLDY1OlsyLDc4XSw3MjpbMiw3OF0sODA6WzIsNzhdLDgxOlsyLDc4XSw4MjpbMiw3OF0sODM6WzIsNzhdLDg0OlsyLDc4XSw4NTpbMiw3OF19LHsyMzpbMiwzM10sMzM6WzIsMzNdLDU0OlsyLDMzXSw2NTpbMiwzM10sNjg6WzIsMzNdLDcyOlsyLDMzXSw3NTpbMiwzM10sODA6WzIsMzNdLDgxOlsyLDMzXSw4MjpbMiwzM10sODM6WzIsMzNdLDg0OlsyLDMzXSw4NTpbMiwzM119LHsyMzpbMiwzNF0sMzM6WzIsMzRdLDU0OlsyLDM0XSw2NTpbMiwzNF0sNjg6WzIsMzRdLDcyOlsyLDM0XSw3NTpbMiwzNF0sODA6WzIsMzRdLDgxOlsyLDM0XSw4MjpbMiwzNF0sODM6WzIsMzRdLDg0OlsyLDM0XSw4NTpbMiwzNF19LHsyMzpbMiwzNV0sMzM6WzIsMzVdLDU0OlsyLDM1XSw2NTpbMiwzNV0sNjg6WzIsMzVdLDcyOlsyLDM1XSw3NTpbMiwzNV0sODA6WzIsMzVdLDgxOlsyLDM1XSw4MjpbMiwzNV0sODM6WzIsMzVdLDg0OlsyLDM1XSw4NTpbMiwzNV19LHsyMzpbMiwzNl0sMzM6WzIsMzZdLDU0OlsyLDM2XSw2NTpbMiwzNl0sNjg6WzIsMzZdLDcyOlsyLDM2XSw3NTpbMiwzNl0sODA6WzIsMzZdLDgxOlsyLDM2XSw4MjpbMiwzNl0sODM6WzIsMzZdLDg0OlsyLDM2XSw4NTpbMiwzNl19LHsyMzpbMiwzN10sMzM6WzIsMzddLDU0OlsyLDM3XSw2NTpbMiwzN10sNjg6WzIsMzddLDcyOlsyLDM3XSw3NTpbMiwzN10sODA6WzIsMzddLDgxOlsyLDM3XSw4MjpbMiwzN10sODM6WzIsMzddLDg0OlsyLDM3XSw4NTpbMiwzN119LHsyMzpbMiwzOF0sMzM6WzIsMzhdLDU0OlsyLDM4XSw2NTpbMiwzOF0sNjg6WzIsMzhdLDcyOlsyLDM4XSw3NTpbMiwzOF0sODA6WzIsMzhdLDgxOlsyLDM4XSw4MjpbMiwzOF0sODM6WzIsMzhdLDg0OlsyLDM4XSw4NTpbMiwzOF19LHsyMzpbMiwzOV0sMzM6WzIsMzldLDU0OlsyLDM5XSw2NTpbMiwzOV0sNjg6WzIsMzldLDcyOlsyLDM5XSw3NTpbMiwzOV0sODA6WzIsMzldLDgxOlsyLDM5XSw4MjpbMiwzOV0sODM6WzIsMzldLDg0OlsyLDM5XSw4NTpbMiwzOV19LHsyMzpbMiw0M10sMzM6WzIsNDNdLDU0OlsyLDQzXSw2NTpbMiw0M10sNjg6WzIsNDNdLDcyOlsyLDQzXSw3NTpbMiw0M10sODA6WzIsNDNdLDgxOlsyLDQzXSw4MjpbMiw0M10sODM6WzIsNDNdLDg0OlsyLDQzXSw4NTpbMiw0M10sODc6WzEsNTFdfSx7NzI6WzEsMzVdLDg2OjUyfSx7MjM6WzIsNDVdLDMzOlsyLDQ1XSw1NDpbMiw0NV0sNjU6WzIsNDVdLDY4OlsyLDQ1XSw3MjpbMiw0NV0sNzU6WzIsNDVdLDgwOlsyLDQ1XSw4MTpbMiw0NV0sODI6WzIsNDVdLDgzOlsyLDQ1XSw4NDpbMiw0NV0sODU6WzIsNDVdLDg3OlsyLDQ1XX0sezUyOjUzLDU0OlsyLDgyXSw2NTpbMiw4Ml0sNzI6WzIsODJdLDgwOlsyLDgyXSw4MTpbMiw4Ml0sODI6WzIsODJdLDgzOlsyLDgyXSw4NDpbMiw4Ml0sODU6WzIsODJdfSx7MjU6NTQsMzg6NTYsMzk6WzEsNThdLDQzOjU3LDQ0OlsxLDU5XSw0NTo1NSw0NzpbMiw1NF19LHsyODo2MCw0Mzo2MSw0NDpbMSw1OV0sNDc6WzIsNTZdfSx7MTM6NjMsMTU6WzEsMjBdLDE4OlsxLDYyXX0sezE1OlsyLDQ4XSwxODpbMiw0OF19LHszMzpbMiw4Nl0sNTc6NjQsNjU6WzIsODZdLDcyOlsyLDg2XSw4MDpbMiw4Nl0sODE6WzIsODZdLDgyOlsyLDg2XSw4MzpbMiw4Nl0sODQ6WzIsODZdLDg1OlsyLDg2XX0sezMzOlsyLDQwXSw2NTpbMiw0MF0sNzI6WzIsNDBdLDgwOlsyLDQwXSw4MTpbMiw0MF0sODI6WzIsNDBdLDgzOlsyLDQwXSw4NDpbMiw0MF0sODU6WzIsNDBdfSx7MzM6WzIsNDFdLDY1OlsyLDQxXSw3MjpbMiw0MV0sODA6WzIsNDFdLDgxOlsyLDQxXSw4MjpbMiw0MV0sODM6WzIsNDFdLDg0OlsyLDQxXSw4NTpbMiw0MV19LHsyMDo2NSw3MjpbMSwzNV0sNzg6MjYsNzk6MjcsODA6WzEsMjhdLDgxOlsxLDI5XSw4MjpbMSwzMF0sODM6WzEsMzFdLDg0OlsxLDMyXSw4NTpbMSwzNF0sODY6MzN9LHsyNjo2Niw0NzpbMSw2N119LHszMDo2OCwzMzpbMiw1OF0sNjU6WzIsNThdLDcyOlsyLDU4XSw3NTpbMiw1OF0sODA6WzIsNThdLDgxOlsyLDU4XSw4MjpbMiw1OF0sODM6WzIsNThdLDg0OlsyLDU4XSw4NTpbMiw1OF19LHszMzpbMiw2NF0sMzU6NjksNjU6WzIsNjRdLDcyOlsyLDY0XSw3NTpbMiw2NF0sODA6WzIsNjRdLDgxOlsyLDY0XSw4MjpbMiw2NF0sODM6WzIsNjRdLDg0OlsyLDY0XSw4NTpbMiw2NF19LHsyMTo3MCwyMzpbMiw1MF0sNjU6WzIsNTBdLDcyOlsyLDUwXSw4MDpbMiw1MF0sODE6WzIsNTBdLDgyOlsyLDUwXSw4MzpbMiw1MF0sODQ6WzIsNTBdLDg1OlsyLDUwXX0sezMzOlsyLDkwXSw2MTo3MSw2NTpbMiw5MF0sNzI6WzIsOTBdLDgwOlsyLDkwXSw4MTpbMiw5MF0sODI6WzIsOTBdLDgzOlsyLDkwXSw4NDpbMiw5MF0sODU6WzIsOTBdfSx7MjA6NzUsMzM6WzIsODBdLDUwOjcyLDYzOjczLDY0Ojc2LDY1OlsxLDQ0XSw2OTo3NCw3MDo3Nyw3MTo3OCw3MjpbMSw3OV0sNzg6MjYsNzk6MjcsODA6WzEsMjhdLDgxOlsxLDI5XSw4MjpbMSwzMF0sODM6WzEsMzFdLDg0OlsxLDMyXSw4NTpbMSwzNF0sODY6MzN9LHs3MjpbMSw4MF19LHsyMzpbMiw0Ml0sMzM6WzIsNDJdLDU0OlsyLDQyXSw2NTpbMiw0Ml0sNjg6WzIsNDJdLDcyOlsyLDQyXSw3NTpbMiw0Ml0sODA6WzIsNDJdLDgxOlsyLDQyXSw4MjpbMiw0Ml0sODM6WzIsNDJdLDg0OlsyLDQyXSw4NTpbMiw0Ml0sODc6WzEsNTFdfSx7MjA6NzUsNTM6ODEsNTQ6WzIsODRdLDYzOjgyLDY0Ojc2LDY1OlsxLDQ0XSw2OTo4Myw3MDo3Nyw3MTo3OCw3MjpbMSw3OV0sNzg6MjYsNzk6MjcsODA6WzEsMjhdLDgxOlsxLDI5XSw4MjpbMSwzMF0sODM6WzEsMzFdLDg0OlsxLDMyXSw4NTpbMSwzNF0sODY6MzN9LHsyNjo4NCw0NzpbMSw2N119LHs0NzpbMiw1NV19LHs0Ojg1LDY6MywxNDpbMiw0Nl0sMTU6WzIsNDZdLDE5OlsyLDQ2XSwyOTpbMiw0Nl0sMzQ6WzIsNDZdLDM5OlsyLDQ2XSw0NDpbMiw0Nl0sNDc6WzIsNDZdLDQ4OlsyLDQ2XSw1MTpbMiw0Nl0sNTU6WzIsNDZdLDYwOlsyLDQ2XX0sezQ3OlsyLDIwXX0sezIwOjg2LDcyOlsxLDM1XSw3ODoyNiw3OToyNyw4MDpbMSwyOF0sODE6WzEsMjldLDgyOlsxLDMwXSw4MzpbMSwzMV0sODQ6WzEsMzJdLDg1OlsxLDM0XSw4NjozM30sezQ6ODcsNjozLDE0OlsyLDQ2XSwxNTpbMiw0Nl0sMTk6WzIsNDZdLDI5OlsyLDQ2XSwzNDpbMiw0Nl0sNDc6WzIsNDZdLDQ4OlsyLDQ2XSw1MTpbMiw0Nl0sNTU6WzIsNDZdLDYwOlsyLDQ2XX0sezI2Ojg4LDQ3OlsxLDY3XX0sezQ3OlsyLDU3XX0sezU6WzIsMTFdLDE0OlsyLDExXSwxNTpbMiwxMV0sMTk6WzIsMTFdLDI5OlsyLDExXSwzNDpbMiwxMV0sMzk6WzIsMTFdLDQ0OlsyLDExXSw0NzpbMiwxMV0sNDg6WzIsMTFdLDUxOlsyLDExXSw1NTpbMiwxMV0sNjA6WzIsMTFdfSx7MTU6WzIsNDldLDE4OlsyLDQ5XX0sezIwOjc1LDMzOlsyLDg4XSw1ODo4OSw2Mzo5MCw2NDo3Niw2NTpbMSw0NF0sNjk6OTEsNzA6NzcsNzE6NzgsNzI6WzEsNzldLDc4OjI2LDc5OjI3LDgwOlsxLDI4XSw4MTpbMSwyOV0sODI6WzEsMzBdLDgzOlsxLDMxXSw4NDpbMSwzMl0sODU6WzEsMzRdLDg2OjMzfSx7NjU6WzIsOTRdLDY2OjkyLDY4OlsyLDk0XSw3MjpbMiw5NF0sODA6WzIsOTRdLDgxOlsyLDk0XSw4MjpbMiw5NF0sODM6WzIsOTRdLDg0OlsyLDk0XSw4NTpbMiw5NF19LHs1OlsyLDI1XSwxNDpbMiwyNV0sMTU6WzIsMjVdLDE5OlsyLDI1XSwyOTpbMiwyNV0sMzQ6WzIsMjVdLDM5OlsyLDI1XSw0NDpbMiwyNV0sNDc6WzIsMjVdLDQ4OlsyLDI1XSw1MTpbMiwyNV0sNTU6WzIsMjVdLDYwOlsyLDI1XX0sezIwOjkzLDcyOlsxLDM1XSw3ODoyNiw3OToyNyw4MDpbMSwyOF0sODE6WzEsMjldLDgyOlsxLDMwXSw4MzpbMSwzMV0sODQ6WzEsMzJdLDg1OlsxLDM0XSw4NjozM30sezIwOjc1LDMxOjk0LDMzOlsyLDYwXSw2Mzo5NSw2NDo3Niw2NTpbMSw0NF0sNjk6OTYsNzA6NzcsNzE6NzgsNzI6WzEsNzldLDc1OlsyLDYwXSw3ODoyNiw3OToyNyw4MDpbMSwyOF0sODE6WzEsMjldLDgyOlsxLDMwXSw4MzpbMSwzMV0sODQ6WzEsMzJdLDg1OlsxLDM0XSw4NjozM30sezIwOjc1LDMzOlsyLDY2XSwzNjo5Nyw2Mzo5OCw2NDo3Niw2NTpbMSw0NF0sNjk6OTksNzA6NzcsNzE6NzgsNzI6WzEsNzldLDc1OlsyLDY2XSw3ODoyNiw3OToyNyw4MDpbMSwyOF0sODE6WzEsMjldLDgyOlsxLDMwXSw4MzpbMSwzMV0sODQ6WzEsMzJdLDg1OlsxLDM0XSw4NjozM30sezIwOjc1LDIyOjEwMCwyMzpbMiw1Ml0sNjM6MTAxLDY0Ojc2LDY1OlsxLDQ0XSw2OToxMDIsNzA6NzcsNzE6NzgsNzI6WzEsNzldLDc4OjI2LDc5OjI3LDgwOlsxLDI4XSw4MTpbMSwyOV0sODI6WzEsMzBdLDgzOlsxLDMxXSw4NDpbMSwzMl0sODU6WzEsMzRdLDg2OjMzfSx7MjA6NzUsMzM6WzIsOTJdLDYyOjEwMyw2MzoxMDQsNjQ6NzYsNjU6WzEsNDRdLDY5OjEwNSw3MDo3Nyw3MTo3OCw3MjpbMSw3OV0sNzg6MjYsNzk6MjcsODA6WzEsMjhdLDgxOlsxLDI5XSw4MjpbMSwzMF0sODM6WzEsMzFdLDg0OlsxLDMyXSw4NTpbMSwzNF0sODY6MzN9LHszMzpbMSwxMDZdfSx7MzM6WzIsNzldLDY1OlsyLDc5XSw3MjpbMiw3OV0sODA6WzIsNzldLDgxOlsyLDc5XSw4MjpbMiw3OV0sODM6WzIsNzldLDg0OlsyLDc5XSw4NTpbMiw3OV19LHszMzpbMiw4MV19LHsyMzpbMiwyN10sMzM6WzIsMjddLDU0OlsyLDI3XSw2NTpbMiwyN10sNjg6WzIsMjddLDcyOlsyLDI3XSw3NTpbMiwyN10sODA6WzIsMjddLDgxOlsyLDI3XSw4MjpbMiwyN10sODM6WzIsMjddLDg0OlsyLDI3XSw4NTpbMiwyN119LHsyMzpbMiwyOF0sMzM6WzIsMjhdLDU0OlsyLDI4XSw2NTpbMiwyOF0sNjg6WzIsMjhdLDcyOlsyLDI4XSw3NTpbMiwyOF0sODA6WzIsMjhdLDgxOlsyLDI4XSw4MjpbMiwyOF0sODM6WzIsMjhdLDg0OlsyLDI4XSw4NTpbMiwyOF19LHsyMzpbMiwzMF0sMzM6WzIsMzBdLDU0OlsyLDMwXSw2ODpbMiwzMF0sNzE6MTA3LDcyOlsxLDEwOF0sNzU6WzIsMzBdfSx7MjM6WzIsOThdLDMzOlsyLDk4XSw1NDpbMiw5OF0sNjg6WzIsOThdLDcyOlsyLDk4XSw3NTpbMiw5OF19LHsyMzpbMiw0NV0sMzM6WzIsNDVdLDU0OlsyLDQ1XSw2NTpbMiw0NV0sNjg6WzIsNDVdLDcyOlsyLDQ1XSw3MzpbMSwxMDldLDc1OlsyLDQ1XSw4MDpbMiw0NV0sODE6WzIsNDVdLDgyOlsyLDQ1XSw4MzpbMiw0NV0sODQ6WzIsNDVdLDg1OlsyLDQ1XSw4NzpbMiw0NV19LHsyMzpbMiw0NF0sMzM6WzIsNDRdLDU0OlsyLDQ0XSw2NTpbMiw0NF0sNjg6WzIsNDRdLDcyOlsyLDQ0XSw3NTpbMiw0NF0sODA6WzIsNDRdLDgxOlsyLDQ0XSw4MjpbMiw0NF0sODM6WzIsNDRdLDg0OlsyLDQ0XSw4NTpbMiw0NF0sODc6WzIsNDRdfSx7NTQ6WzEsMTEwXX0sezU0OlsyLDgzXSw2NTpbMiw4M10sNzI6WzIsODNdLDgwOlsyLDgzXSw4MTpbMiw4M10sODI6WzIsODNdLDgzOlsyLDgzXSw4NDpbMiw4M10sODU6WzIsODNdfSx7NTQ6WzIsODVdfSx7NTpbMiwxM10sMTQ6WzIsMTNdLDE1OlsyLDEzXSwxOTpbMiwxM10sMjk6WzIsMTNdLDM0OlsyLDEzXSwzOTpbMiwxM10sNDQ6WzIsMTNdLDQ3OlsyLDEzXSw0ODpbMiwxM10sNTE6WzIsMTNdLDU1OlsyLDEzXSw2MDpbMiwxM119LHszODo1NiwzOTpbMSw1OF0sNDM6NTcsNDQ6WzEsNTldLDQ1OjExMiw0NjoxMTEsNDc6WzIsNzZdfSx7MzM6WzIsNzBdLDQwOjExMyw2NTpbMiw3MF0sNzI6WzIsNzBdLDc1OlsyLDcwXSw4MDpbMiw3MF0sODE6WzIsNzBdLDgyOlsyLDcwXSw4MzpbMiw3MF0sODQ6WzIsNzBdLDg1OlsyLDcwXX0sezQ3OlsyLDE4XX0sezU6WzIsMTRdLDE0OlsyLDE0XSwxNTpbMiwxNF0sMTk6WzIsMTRdLDI5OlsyLDE0XSwzNDpbMiwxNF0sMzk6WzIsMTRdLDQ0OlsyLDE0XSw0NzpbMiwxNF0sNDg6WzIsMTRdLDUxOlsyLDE0XSw1NTpbMiwxNF0sNjA6WzIsMTRdfSx7MzM6WzEsMTE0XX0sezMzOlsyLDg3XSw2NTpbMiw4N10sNzI6WzIsODddLDgwOlsyLDg3XSw4MTpbMiw4N10sODI6WzIsODddLDgzOlsyLDg3XSw4NDpbMiw4N10sODU6WzIsODddfSx7MzM6WzIsODldfSx7MjA6NzUsNjM6MTE2LDY0Ojc2LDY1OlsxLDQ0XSw2NzoxMTUsNjg6WzIsOTZdLDY5OjExNyw3MDo3Nyw3MTo3OCw3MjpbMSw3OV0sNzg6MjYsNzk6MjcsODA6WzEsMjhdLDgxOlsxLDI5XSw4MjpbMSwzMF0sODM6WzEsMzFdLDg0OlsxLDMyXSw4NTpbMSwzNF0sODY6MzN9LHszMzpbMSwxMThdfSx7MzI6MTE5LDMzOlsyLDYyXSw3NDoxMjAsNzU6WzEsMTIxXX0sezMzOlsyLDU5XSw2NTpbMiw1OV0sNzI6WzIsNTldLDc1OlsyLDU5XSw4MDpbMiw1OV0sODE6WzIsNTldLDgyOlsyLDU5XSw4MzpbMiw1OV0sODQ6WzIsNTldLDg1OlsyLDU5XX0sezMzOlsyLDYxXSw3NTpbMiw2MV19LHszMzpbMiw2OF0sMzc6MTIyLDc0OjEyMyw3NTpbMSwxMjFdfSx7MzM6WzIsNjVdLDY1OlsyLDY1XSw3MjpbMiw2NV0sNzU6WzIsNjVdLDgwOlsyLDY1XSw4MTpbMiw2NV0sODI6WzIsNjVdLDgzOlsyLDY1XSw4NDpbMiw2NV0sODU6WzIsNjVdfSx7MzM6WzIsNjddLDc1OlsyLDY3XX0sezIzOlsxLDEyNF19LHsyMzpbMiw1MV0sNjU6WzIsNTFdLDcyOlsyLDUxXSw4MDpbMiw1MV0sODE6WzIsNTFdLDgyOlsyLDUxXSw4MzpbMiw1MV0sODQ6WzIsNTFdLDg1OlsyLDUxXX0sezIzOlsyLDUzXX0sezMzOlsxLDEyNV19LHszMzpbMiw5MV0sNjU6WzIsOTFdLDcyOlsyLDkxXSw4MDpbMiw5MV0sODE6WzIsOTFdLDgyOlsyLDkxXSw4MzpbMiw5MV0sODQ6WzIsOTFdLDg1OlsyLDkxXX0sezMzOlsyLDkzXX0sezU6WzIsMjJdLDE0OlsyLDIyXSwxNTpbMiwyMl0sMTk6WzIsMjJdLDI5OlsyLDIyXSwzNDpbMiwyMl0sMzk6WzIsMjJdLDQ0OlsyLDIyXSw0NzpbMiwyMl0sNDg6WzIsMjJdLDUxOlsyLDIyXSw1NTpbMiwyMl0sNjA6WzIsMjJdfSx7MjM6WzIsOTldLDMzOlsyLDk5XSw1NDpbMiw5OV0sNjg6WzIsOTldLDcyOlsyLDk5XSw3NTpbMiw5OV19LHs3MzpbMSwxMDldfSx7MjA6NzUsNjM6MTI2LDY0Ojc2LDY1OlsxLDQ0XSw3MjpbMSwzNV0sNzg6MjYsNzk6MjcsODA6WzEsMjhdLDgxOlsxLDI5XSw4MjpbMSwzMF0sODM6WzEsMzFdLDg0OlsxLDMyXSw4NTpbMSwzNF0sODY6MzN9LHs1OlsyLDIzXSwxNDpbMiwyM10sMTU6WzIsMjNdLDE5OlsyLDIzXSwyOTpbMiwyM10sMzQ6WzIsMjNdLDM5OlsyLDIzXSw0NDpbMiwyM10sNDc6WzIsMjNdLDQ4OlsyLDIzXSw1MTpbMiwyM10sNTU6WzIsMjNdLDYwOlsyLDIzXX0sezQ3OlsyLDE5XX0sezQ3OlsyLDc3XX0sezIwOjc1LDMzOlsyLDcyXSw0MToxMjcsNjM6MTI4LDY0Ojc2LDY1OlsxLDQ0XSw2OToxMjksNzA6NzcsNzE6NzgsNzI6WzEsNzldLDc1OlsyLDcyXSw3ODoyNiw3OToyNyw4MDpbMSwyOF0sODE6WzEsMjldLDgyOlsxLDMwXSw4MzpbMSwzMV0sODQ6WzEsMzJdLDg1OlsxLDM0XSw4NjozM30sezU6WzIsMjRdLDE0OlsyLDI0XSwxNTpbMiwyNF0sMTk6WzIsMjRdLDI5OlsyLDI0XSwzNDpbMiwyNF0sMzk6WzIsMjRdLDQ0OlsyLDI0XSw0NzpbMiwyNF0sNDg6WzIsMjRdLDUxOlsyLDI0XSw1NTpbMiwyNF0sNjA6WzIsMjRdfSx7Njg6WzEsMTMwXX0sezY1OlsyLDk1XSw2ODpbMiw5NV0sNzI6WzIsOTVdLDgwOlsyLDk1XSw4MTpbMiw5NV0sODI6WzIsOTVdLDgzOlsyLDk1XSw4NDpbMiw5NV0sODU6WzIsOTVdfSx7Njg6WzIsOTddfSx7NTpbMiwyMV0sMTQ6WzIsMjFdLDE1OlsyLDIxXSwxOTpbMiwyMV0sMjk6WzIsMjFdLDM0OlsyLDIxXSwzOTpbMiwyMV0sNDQ6WzIsMjFdLDQ3OlsyLDIxXSw0ODpbMiwyMV0sNTE6WzIsMjFdLDU1OlsyLDIxXSw2MDpbMiwyMV19LHszMzpbMSwxMzFdfSx7MzM6WzIsNjNdfSx7NzI6WzEsMTMzXSw3NjoxMzJ9LHszMzpbMSwxMzRdfSx7MzM6WzIsNjldfSx7MTU6WzIsMTJdfSx7MTQ6WzIsMjZdLDE1OlsyLDI2XSwxOTpbMiwyNl0sMjk6WzIsMjZdLDM0OlsyLDI2XSw0NzpbMiwyNl0sNDg6WzIsMjZdLDUxOlsyLDI2XSw1NTpbMiwyNl0sNjA6WzIsMjZdfSx7MjM6WzIsMzFdLDMzOlsyLDMxXSw1NDpbMiwzMV0sNjg6WzIsMzFdLDcyOlsyLDMxXSw3NTpbMiwzMV19LHszMzpbMiw3NF0sNDI6MTM1LDc0OjEzNiw3NTpbMSwxMjFdfSx7MzM6WzIsNzFdLDY1OlsyLDcxXSw3MjpbMiw3MV0sNzU6WzIsNzFdLDgwOlsyLDcxXSw4MTpbMiw3MV0sODI6WzIsNzFdLDgzOlsyLDcxXSw4NDpbMiw3MV0sODU6WzIsNzFdfSx7MzM6WzIsNzNdLDc1OlsyLDczXX0sezIzOlsyLDI5XSwzMzpbMiwyOV0sNTQ6WzIsMjldLDY1OlsyLDI5XSw2ODpbMiwyOV0sNzI6WzIsMjldLDc1OlsyLDI5XSw4MDpbMiwyOV0sODE6WzIsMjldLDgyOlsyLDI5XSw4MzpbMiwyOV0sODQ6WzIsMjldLDg1OlsyLDI5XX0sezE0OlsyLDE1XSwxNTpbMiwxNV0sMTk6WzIsMTVdLDI5OlsyLDE1XSwzNDpbMiwxNV0sMzk6WzIsMTVdLDQ0OlsyLDE1XSw0NzpbMiwxNV0sNDg6WzIsMTVdLDUxOlsyLDE1XSw1NTpbMiwxNV0sNjA6WzIsMTVdfSx7NzI6WzEsMTM4XSw3NzpbMSwxMzddfSx7NzI6WzIsMTAwXSw3NzpbMiwxMDBdfSx7MTQ6WzIsMTZdLDE1OlsyLDE2XSwxOTpbMiwxNl0sMjk6WzIsMTZdLDM0OlsyLDE2XSw0NDpbMiwxNl0sNDc6WzIsMTZdLDQ4OlsyLDE2XSw1MTpbMiwxNl0sNTU6WzIsMTZdLDYwOlsyLDE2XX0sezMzOlsxLDEzOV19LHszMzpbMiw3NV19LHszMzpbMiwzMl19LHs3MjpbMiwxMDFdLDc3OlsyLDEwMV19LHsxNDpbMiwxN10sMTU6WzIsMTddLDE5OlsyLDE3XSwyOTpbMiwxN10sMzQ6WzIsMTddLDM5OlsyLDE3XSw0NDpbMiwxN10sNDc6WzIsMTddLDQ4OlsyLDE3XSw1MTpbMiwxN10sNTU6WzIsMTddLDYwOlsyLDE3XX1dLFxuZGVmYXVsdEFjdGlvbnM6IHs0OlsyLDFdLDU1OlsyLDU1XSw1NzpbMiwyMF0sNjE6WzIsNTddLDc0OlsyLDgxXSw4MzpbMiw4NV0sODc6WzIsMThdLDkxOlsyLDg5XSwxMDI6WzIsNTNdLDEwNTpbMiw5M10sMTExOlsyLDE5XSwxMTI6WzIsNzddLDExNzpbMiw5N10sMTIwOlsyLDYzXSwxMjM6WzIsNjldLDEyNDpbMiwxMl0sMTM2OlsyLDc1XSwxMzc6WzIsMzJdfSxcbnBhcnNlRXJyb3I6IGZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XG59LFxucGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLCBzdGFjayA9IFswXSwgdnN0YWNrID0gW251bGxdLCBsc3RhY2sgPSBbXSwgdGFibGUgPSB0aGlzLnRhYmxlLCB5eXRleHQgPSBcIlwiLCB5eWxpbmVubyA9IDAsIHl5bGVuZyA9IDAsIHJlY292ZXJpbmcgPSAwLCBURVJST1IgPSAyLCBFT0YgPSAxO1xuICAgIHRoaXMubGV4ZXIuc2V0SW5wdXQoaW5wdXQpO1xuICAgIHRoaXMubGV4ZXIueXkgPSB0aGlzLnl5O1xuICAgIHRoaXMueXkubGV4ZXIgPSB0aGlzLmxleGVyO1xuICAgIHRoaXMueXkucGFyc2VyID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRoaXMubGV4ZXIueXlsbG9jID09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRoaXMubGV4ZXIueXlsbG9jID0ge307XG4gICAgdmFyIHl5bG9jID0gdGhpcy5sZXhlci55eWxsb2M7XG4gICAgbHN0YWNrLnB1c2goeXlsb2MpO1xuICAgIHZhciByYW5nZXMgPSB0aGlzLmxleGVyLm9wdGlvbnMgJiYgdGhpcy5sZXhlci5vcHRpb25zLnJhbmdlcztcbiAgICBpZiAodHlwZW9mIHRoaXMueXkucGFyc2VFcnJvciA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSB0aGlzLnl5LnBhcnNlRXJyb3I7XG4gICAgZnVuY3Rpb24gcG9wU3RhY2sobikge1xuICAgICAgICBzdGFjay5sZW5ndGggPSBzdGFjay5sZW5ndGggLSAyICogbjtcbiAgICAgICAgdnN0YWNrLmxlbmd0aCA9IHZzdGFjay5sZW5ndGggLSBuO1xuICAgICAgICBsc3RhY2subGVuZ3RoID0gbHN0YWNrLmxlbmd0aCAtIG47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxleCgpIHtcbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICB0b2tlbiA9IHNlbGYubGV4ZXIubGV4KCkgfHwgMTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdG9rZW4gPSBzZWxmLnN5bWJvbHNfW3Rva2VuXSB8fCB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIHZhciBzeW1ib2wsIHByZUVycm9yU3ltYm9sLCBzdGF0ZSwgYWN0aW9uLCBhLCByLCB5eXZhbCA9IHt9LCBwLCBsZW4sIG5ld1N0YXRlLCBleHBlY3RlZDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV0pIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN5bWJvbCA9PT0gbnVsbCB8fCB0eXBlb2Ygc3ltYm9sID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBsZXgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjdGlvbiA9IHRhYmxlW3N0YXRlXSAmJiB0YWJsZVtzdGF0ZV1bc3ltYm9sXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhYWN0aW9uLmxlbmd0aCB8fCAhYWN0aW9uWzBdKSB7XG4gICAgICAgICAgICB2YXIgZXJyU3RyID0gXCJcIjtcbiAgICAgICAgICAgIGlmICghcmVjb3ZlcmluZykge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChwIGluIHRhYmxlW3N0YXRlXSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGVybWluYWxzX1twXSAmJiBwID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQucHVzaChcIidcIiArIHRoaXMudGVybWluYWxzX1twXSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxleGVyLnNob3dQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSBcIlBhcnNlIGVycm9yIG9uIGxpbmUgXCIgKyAoeXlsaW5lbm8gKyAxKSArIFwiOlxcblwiICsgdGhpcy5sZXhlci5zaG93UG9zaXRpb24oKSArIFwiXFxuRXhwZWN0aW5nIFwiICsgZXhwZWN0ZWQuam9pbihcIiwgXCIpICsgXCIsIGdvdCAnXCIgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArIFwiJ1wiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVyclN0ciA9IFwiUGFyc2UgZXJyb3Igb24gbGluZSBcIiArICh5eWxpbmVubyArIDEpICsgXCI6IFVuZXhwZWN0ZWQgXCIgKyAoc3ltYm9sID09IDE/XCJlbmQgb2YgaW5wdXRcIjpcIidcIiArICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpICsgXCInXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRXJyb3IoZXJyU3RyLCB7dGV4dDogdGhpcy5sZXhlci5tYXRjaCwgdG9rZW46IHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCwgbGluZTogdGhpcy5sZXhlci55eWxpbmVubywgbG9jOiB5eWxvYywgZXhwZWN0ZWQ6IGV4cGVjdGVkfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvblswXSBpbnN0YW5jZW9mIEFycmF5ICYmIGFjdGlvbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJzZSBFcnJvcjogbXVsdGlwbGUgYWN0aW9ucyBwb3NzaWJsZSBhdCBzdGF0ZTogXCIgKyBzdGF0ZSArIFwiLCB0b2tlbjogXCIgKyBzeW1ib2wpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uWzBdKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHN0YWNrLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgIHZzdGFjay5wdXNoKHRoaXMubGV4ZXIueXl0ZXh0KTtcbiAgICAgICAgICAgIGxzdGFjay5wdXNoKHRoaXMubGV4ZXIueXlsbG9jKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goYWN0aW9uWzFdKTtcbiAgICAgICAgICAgIHN5bWJvbCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIXByZUVycm9yU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgeXlsZW5nID0gdGhpcy5sZXhlci55eWxlbmc7XG4gICAgICAgICAgICAgICAgeXl0ZXh0ID0gdGhpcy5sZXhlci55eXRleHQ7XG4gICAgICAgICAgICAgICAgeXlsaW5lbm8gPSB0aGlzLmxleGVyLnl5bGluZW5vO1xuICAgICAgICAgICAgICAgIHl5bG9jID0gdGhpcy5sZXhlci55eWxsb2M7XG4gICAgICAgICAgICAgICAgaWYgKHJlY292ZXJpbmcgPiAwKVxuICAgICAgICAgICAgICAgICAgICByZWNvdmVyaW5nLS07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IHByZUVycm9yU3ltYm9sO1xuICAgICAgICAgICAgICAgIHByZUVycm9yU3ltYm9sID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBsZW4gPSB0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzFdO1xuICAgICAgICAgICAgeXl2YWwuJCA9IHZzdGFja1t2c3RhY2subGVuZ3RoIC0gbGVuXTtcbiAgICAgICAgICAgIHl5dmFsLl8kID0ge2ZpcnN0X2xpbmU6IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0uZmlyc3RfbGluZSwgbGFzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfbGluZSwgZmlyc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2NvbHVtbiwgbGFzdF9jb2x1bW46IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ubGFzdF9jb2x1bW59O1xuICAgICAgICAgICAgaWYgKHJhbmdlcykge1xuICAgICAgICAgICAgICAgIHl5dmFsLl8kLnJhbmdlID0gW2xzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0ucmFuZ2VbMF0sIGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ucmFuZ2VbMV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgciA9IHRoaXMucGVyZm9ybUFjdGlvbi5jYWxsKHl5dmFsLCB5eXRleHQsIHl5bGVuZywgeXlsaW5lbm8sIHRoaXMueXksIGFjdGlvblsxXSwgdnN0YWNrLCBsc3RhY2spO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZSgwLCAtMSAqIGxlbiAqIDIpO1xuICAgICAgICAgICAgICAgIHZzdGFjayA9IHZzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XG4gICAgICAgICAgICAgICAgbHN0YWNrID0gbHN0YWNrLnNsaWNlKDAsIC0xICogbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVswXSk7XG4gICAgICAgICAgICB2c3RhY2sucHVzaCh5eXZhbC4kKTtcbiAgICAgICAgICAgIGxzdGFjay5wdXNoKHl5dmFsLl8kKTtcbiAgICAgICAgICAgIG5ld1N0YXRlID0gdGFibGVbc3RhY2tbc3RhY2subGVuZ3RoIC0gMl1dW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobmV3U3RhdGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxufTtcbi8qIEppc29uIGdlbmVyYXRlZCBsZXhlciAqL1xudmFyIGxleGVyID0gKGZ1bmN0aW9uKCl7XG52YXIgbGV4ZXIgPSAoe0VPRjoxLFxucGFyc2VFcnJvcjpmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xuICAgICAgICBpZiAodGhpcy55eS5wYXJzZXIpIHtcbiAgICAgICAgICAgIHRoaXMueXkucGFyc2VyLnBhcnNlRXJyb3Ioc3RyLCBoYXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xuICAgICAgICB9XG4gICAgfSxcbnNldElucHV0OmZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLl9tb3JlID0gdGhpcy5fbGVzcyA9IHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnl5bGluZW5vID0gdGhpcy55eWxlbmcgPSAwO1xuICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2ggPSAnJztcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjayA9IFsnSU5JVElBTCddO1xuICAgICAgICB0aGlzLnl5bGxvYyA9IHtmaXJzdF9saW5lOjEsZmlyc3RfY29sdW1uOjAsbGFzdF9saW5lOjEsbGFzdF9jb2x1bW46MH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB0aGlzLnl5bGxvYy5yYW5nZSA9IFswLDBdO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5pbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaCA9IHRoaXMuX2lucHV0WzBdO1xuICAgICAgICB0aGlzLnl5dGV4dCArPSBjaDtcbiAgICAgICAgdGhpcy55eWxlbmcrKztcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgdGhpcy5tYXRjaCArPSBjaDtcbiAgICAgICAgdGhpcy5tYXRjaGVkICs9IGNoO1xuICAgICAgICB2YXIgbGluZXMgPSBjaC5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XG4gICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubysrO1xuICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbisrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB0aGlzLnl5bGxvYy5yYW5nZVsxXSsrO1xuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9LFxudW5wdXQ6ZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIHZhciBsZW4gPSBjaC5sZW5ndGg7XG4gICAgICAgIHZhciBsaW5lcyA9IGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSBjaCArIHRoaXMuX2lucHV0O1xuICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMueXl0ZXh0LnN1YnN0cigwLCB0aGlzLnl5dGV4dC5sZW5ndGgtbGVuLTEpO1xuICAgICAgICAvL3RoaXMueXlsZW5nIC09IGxlbjtcbiAgICAgICAgdGhpcy5vZmZzZXQgLT0gbGVuO1xuICAgICAgICB2YXIgb2xkTGluZXMgPSB0aGlzLm1hdGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gICAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLm1hdGNoLnN1YnN0cigwLCB0aGlzLm1hdGNoLmxlbmd0aC0xKTtcbiAgICAgICAgdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoLTEpO1xuXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGgtMSkgdGhpcy55eWxpbmVubyAtPSBsaW5lcy5sZW5ndGgtMTtcbiAgICAgICAgdmFyIHIgPSB0aGlzLnl5bGxvYy5yYW5nZTtcblxuICAgICAgICB0aGlzLnl5bGxvYyA9IHtmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubysxLFxuICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/XG4gICAgICAgICAgICAgIChsaW5lcy5sZW5ndGggPT09IG9sZExpbmVzLmxlbmd0aCA/IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiA6IDApICsgb2xkTGluZXNbb2xkTGluZXMubGVuZ3RoIC0gbGluZXMubGVuZ3RoXS5sZW5ndGggLSBsaW5lc1swXS5sZW5ndGg6XG4gICAgICAgICAgICAgIHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiAtIGxlblxuICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gW3JbMF0sIHJbMF0gKyB0aGlzLnl5bGVuZyAtIGxlbl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbm1vcmU6ZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tb3JlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbmxlc3M6ZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdGhpcy51bnB1dCh0aGlzLm1hdGNoLnNsaWNlKG4pKTtcbiAgICB9LFxucGFzdElucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhc3QgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSB0aGlzLm1hdGNoLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiAocGFzdC5sZW5ndGggPiAyMCA/ICcuLi4nOicnKSArIHBhc3Quc3Vic3RyKC0yMCkucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgIH0sXG51cGNvbWluZ0lucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLm1hdGNoO1xuICAgICAgICBpZiAobmV4dC5sZW5ndGggPCAyMCkge1xuICAgICAgICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5zdWJzdHIoMCwgMjAtbmV4dC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobmV4dC5zdWJzdHIoMCwyMCkrKG5leHQubGVuZ3RoID4gMjAgPyAnLi4uJzonJykpLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICB9LFxuc2hvd1Bvc2l0aW9uOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZSA9IHRoaXMucGFzdElucHV0KCk7XG4gICAgICAgIHZhciBjID0gbmV3IEFycmF5KHByZS5sZW5ndGggKyAxKS5qb2luKFwiLVwiKTtcbiAgICAgICAgcmV0dXJuIHByZSArIHRoaXMudXBjb21pbmdJbnB1dCgpICsgXCJcXG5cIiArIGMrXCJeXCI7XG4gICAgfSxcbm5leHQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pbnB1dCkgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgICB2YXIgdG9rZW4sXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIHRlbXBNYXRjaCxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgbGluZXM7XG4gICAgICAgIGlmICghdGhpcy5fbW9yZSkge1xuICAgICAgICAgICAgdGhpcy55eXRleHQgPSAnJztcbiAgICAgICAgICAgIHRoaXMubWF0Y2ggPSAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLl9jdXJyZW50UnVsZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaT0wO2kgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcE1hdGNoID0gdGhpcy5faW5wdXQubWF0Y2godGhpcy5ydWxlc1tydWxlc1tpXV0pO1xuICAgICAgICAgICAgaWYgKHRlbXBNYXRjaCAmJiAoIW1hdGNoIHx8IHRlbXBNYXRjaFswXS5sZW5ndGggPiBtYXRjaFswXS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSB0ZW1wTWF0Y2g7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmZsZXgpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGluZXMgPSBtYXRjaFswXS5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XG4gICAgICAgICAgICBpZiAobGluZXMpIHRoaXMueXlsaW5lbm8gKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy55eWxsb2MgPSB7Zmlyc3RfbGluZTogdGhpcy55eWxsb2MubGFzdF9saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vKzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID8gbGluZXNbbGluZXMubGVuZ3RoLTFdLmxlbmd0aC1saW5lc1tsaW5lcy5sZW5ndGgtMV0ubWF0Y2goL1xccj9cXG4/LylbMF0ubGVuZ3RoIDogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gKyBtYXRjaFswXS5sZW5ndGh9O1xuICAgICAgICAgICAgdGhpcy55eXRleHQgKz0gbWF0Y2hbMF07XG4gICAgICAgICAgICB0aGlzLm1hdGNoICs9IG1hdGNoWzBdO1xuICAgICAgICAgICAgdGhpcy5tYXRjaGVzID0gbWF0Y2g7XG4gICAgICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbdGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICs9IHRoaXMueXlsZW5nXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21vcmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlZCArPSBtYXRjaFswXTtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwodGhpcywgdGhpcy55eSwgdGhpcywgcnVsZXNbaW5kZXhdLHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGgtMV0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9uZSAmJiB0aGlzLl9pbnB1dCkgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodG9rZW4pIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcrKHRoaXMueXlsaW5lbm8rMSkrJy4gVW5yZWNvZ25pemVkIHRleHQuXFxuJyt0aGlzLnNob3dQb3NpdGlvbigpLFxuICAgICAgICAgICAgICAgICAgICB7dGV4dDogXCJcIiwgdG9rZW46IG51bGwsIGxpbmU6IHRoaXMueXlsaW5lbm99KTtcbiAgICAgICAgfVxuICAgIH0sXG5sZXg6ZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICB2YXIgciA9IHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAodHlwZW9mIHIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxleCgpO1xuICAgICAgICB9XG4gICAgfSxcbmJlZ2luOmZ1bmN0aW9uIGJlZ2luKGNvbmRpdGlvbikge1xuICAgICAgICB0aGlzLmNvbmRpdGlvblN0YWNrLnB1c2goY29uZGl0aW9uKTtcbiAgICB9LFxucG9wU3RhdGU6ZnVuY3Rpb24gcG9wU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLnBvcCgpO1xuICAgIH0sXG5fY3VycmVudFJ1bGVzOmZ1bmN0aW9uIF9jdXJyZW50UnVsZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aC0xXV0ucnVsZXM7XG4gICAgfSxcbnRvcFN0YXRlOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGgtMl07XG4gICAgfSxcbnB1c2hTdGF0ZTpmdW5jdGlvbiBiZWdpbihjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5iZWdpbihjb25kaXRpb24pO1xuICAgIH19KTtcbmxleGVyLm9wdGlvbnMgPSB7fTtcbmxleGVyLnBlcmZvcm1BY3Rpb24gPSBmdW5jdGlvbiBhbm9ueW1vdXMoeXkseXlfLCRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsWVlfU1RBUlRcbi8qKi8pIHtcblxuXG5mdW5jdGlvbiBzdHJpcChzdGFydCwgZW5kKSB7XG4gIHJldHVybiB5eV8ueXl0ZXh0ID0geXlfLnl5dGV4dC5zdWJzdHIoc3RhcnQsIHl5Xy55eWxlbmctZW5kKTtcbn1cblxuXG52YXIgWVlTVEFURT1ZWV9TVEFSVFxuc3dpdGNoKCRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMpIHtcbmNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoeXlfLnl5dGV4dC5zbGljZSgtMikgPT09IFwiXFxcXFxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmlwKDAsMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpbihcIm11XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoeXlfLnl5dGV4dC5zbGljZSgtMSkgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaXAoMCwxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJlZ2luKFwiZW11XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJtdVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih5eV8ueXl0ZXh0KSByZXR1cm4gMTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbmJyZWFrO1xuY2FzZSAxOnJldHVybiAxNTtcbmJyZWFrO1xuY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuYnJlYWs7XG5jYXNlIDM6dGhpcy5iZWdpbigncmF3Jyk7IHJldHVybiAxNTtcbmJyZWFrO1xuY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQgYmUgdXNpbmcgYHRoaXMudG9wU3RhdGUoKWAgYmVsb3csIGJ1dCBpdCBjdXJyZW50bHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIHRoZSBzZWNvbmQgdG9wIGluc3RlYWQgb2YgdGhlIGZpcnN0IHRvcC4gT3BlbmVkIGFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXNzdWUgYWJvdXQgaXQgYXQgaHR0cHM6Ly9naXRodWIuY29tL3phYWNoL2ppc29uL2lzc3Vlcy8yOTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aC0xXSA9PT0gJ3JhdycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeXlfLnl5dGV4dCA9IHl5Xy55eXRleHQuc3Vic3RyKDUsIHl5Xy55eWxlbmctOSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ0VORF9SQVdfQkxPQ0snO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuYnJlYWs7XG5jYXNlIDU6IHJldHVybiAxNTsgXG5icmVhaztcbmNhc2UgNjpcbiAgdGhpcy5wb3BTdGF0ZSgpO1xuICByZXR1cm4gMTQ7XG5cbmJyZWFrO1xuY2FzZSA3OnJldHVybiA2NTtcbmJyZWFrO1xuY2FzZSA4OnJldHVybiA2ODtcbmJyZWFrO1xuY2FzZSA5OiByZXR1cm4gMTk7IFxuYnJlYWs7XG5jYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJlZ2luKCdyYXcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbmJyZWFrO1xuY2FzZSAxMTpyZXR1cm4gNTU7XG5icmVhaztcbmNhc2UgMTI6cmV0dXJuIDYwO1xuYnJlYWs7XG5jYXNlIDEzOnJldHVybiAyOTtcbmJyZWFrO1xuY2FzZSAxNDpyZXR1cm4gNDc7XG5icmVhaztcbmNhc2UgMTU6dGhpcy5wb3BTdGF0ZSgpOyByZXR1cm4gNDQ7XG5icmVhaztcbmNhc2UgMTY6dGhpcy5wb3BTdGF0ZSgpOyByZXR1cm4gNDQ7XG5icmVhaztcbmNhc2UgMTc6cmV0dXJuIDM0O1xuYnJlYWs7XG5jYXNlIDE4OnJldHVybiAzOTtcbmJyZWFrO1xuY2FzZSAxOTpyZXR1cm4gNTE7XG5icmVhaztcbmNhc2UgMjA6cmV0dXJuIDQ4O1xuYnJlYWs7XG5jYXNlIDIxOlxuICB0aGlzLnVucHV0KHl5Xy55eXRleHQpO1xuICB0aGlzLnBvcFN0YXRlKCk7XG4gIHRoaXMuYmVnaW4oJ2NvbScpO1xuXG5icmVhaztcbmNhc2UgMjI6XG4gIHRoaXMucG9wU3RhdGUoKTtcbiAgcmV0dXJuIDE0O1xuXG5icmVhaztcbmNhc2UgMjM6cmV0dXJuIDQ4O1xuYnJlYWs7XG5jYXNlIDI0OnJldHVybiA3MztcbmJyZWFrO1xuY2FzZSAyNTpyZXR1cm4gNzI7XG5icmVhaztcbmNhc2UgMjY6cmV0dXJuIDcyO1xuYnJlYWs7XG5jYXNlIDI3OnJldHVybiA4NztcbmJyZWFrO1xuY2FzZSAyODovLyBpZ25vcmUgd2hpdGVzcGFjZVxuYnJlYWs7XG5jYXNlIDI5OnRoaXMucG9wU3RhdGUoKTsgcmV0dXJuIDU0O1xuYnJlYWs7XG5jYXNlIDMwOnRoaXMucG9wU3RhdGUoKTsgcmV0dXJuIDMzO1xuYnJlYWs7XG5jYXNlIDMxOnl5Xy55eXRleHQgPSBzdHJpcCgxLDIpLnJlcGxhY2UoL1xcXFxcIi9nLCdcIicpOyByZXR1cm4gODA7XG5icmVhaztcbmNhc2UgMzI6eXlfLnl5dGV4dCA9IHN0cmlwKDEsMikucmVwbGFjZSgvXFxcXCcvZyxcIidcIik7IHJldHVybiA4MDtcbmJyZWFrO1xuY2FzZSAzMzpyZXR1cm4gODU7XG5icmVhaztcbmNhc2UgMzQ6cmV0dXJuIDgyO1xuYnJlYWs7XG5jYXNlIDM1OnJldHVybiA4MjtcbmJyZWFrO1xuY2FzZSAzNjpyZXR1cm4gODM7XG5icmVhaztcbmNhc2UgMzc6cmV0dXJuIDg0O1xuYnJlYWs7XG5jYXNlIDM4OnJldHVybiA4MTtcbmJyZWFrO1xuY2FzZSAzOTpyZXR1cm4gNzU7XG5icmVhaztcbmNhc2UgNDA6cmV0dXJuIDc3O1xuYnJlYWs7XG5jYXNlIDQxOnJldHVybiA3MjtcbmJyZWFrO1xuY2FzZSA0Mjp5eV8ueXl0ZXh0ID0geXlfLnl5dGV4dC5yZXBsYWNlKC9cXFxcKFtcXFxcXFxdXSkvZywnJDEnKTsgcmV0dXJuIDcyO1xuYnJlYWs7XG5jYXNlIDQzOnJldHVybiAnSU5WQUxJRCc7XG5icmVhaztcbmNhc2UgNDQ6cmV0dXJuIDU7XG5icmVhaztcbn1cbn07XG5sZXhlci5ydWxlcyA9IFsvXig/OlteXFx4MDBdKj8oPz0oXFx7XFx7KSkpLywvXig/OlteXFx4MDBdKykvLC9eKD86W15cXHgwMF17Mix9Pyg/PShcXHtcXHt8XFxcXFxce1xce3xcXFxcXFxcXFxce1xce3wkKSkpLywvXig/Olxce1xce1xce1xceyg/PVteXFwvXSkpLywvXig/Olxce1xce1xce1xce1xcL1teXFxzIVwiIyUtLFxcLlxcLzstPkBcXFstXFxeYFxcey1+XSsoPz1bPX1cXHNcXC8uXSlcXH1cXH1cXH1cXH0pLywvXig/OlteXFx4MDBdKj8oPz0oXFx7XFx7XFx7XFx7KSkpLywvXig/OltcXHNcXFNdKj8tLSh+KT9cXH1cXH0pLywvXig/OlxcKCkvLC9eKD86XFwpKS8sL14oPzpcXHtcXHtcXHtcXHspLywvXig/OlxcfVxcfVxcfVxcfSkvLC9eKD86XFx7XFx7KH4pPz4pLywvXig/Olxce1xceyh+KT8jPikvLC9eKD86XFx7XFx7KH4pPyNcXCo/KS8sL14oPzpcXHtcXHsofik/XFwvKS8sL14oPzpcXHtcXHsofik/XFxeXFxzKih+KT9cXH1cXH0pLywvXig/Olxce1xceyh+KT9cXHMqZWxzZVxccyoofik/XFx9XFx9KS8sL14oPzpcXHtcXHsofik/XFxeKS8sL14oPzpcXHtcXHsofik/XFxzKmVsc2VcXGIpLywvXig/Olxce1xceyh+KT9cXHspLywvXig/Olxce1xceyh+KT8mKS8sL14oPzpcXHtcXHsofik/IS0tKS8sL14oPzpcXHtcXHsofik/IVtcXHNcXFNdKj9cXH1cXH0pLywvXig/Olxce1xceyh+KT9cXCo/KS8sL14oPzo9KS8sL14oPzpcXC5cXC4pLywvXig/OlxcLig/PShbPX59XFxzXFwvLil8XSkpKS8sL14oPzpbXFwvLl0pLywvXig/OlxccyspLywvXig/OlxcfSh+KT9cXH1cXH0pLywvXig/Oih+KT9cXH1cXH0pLywvXig/OlwiKFxcXFxbXCJdfFteXCJdKSpcIikvLC9eKD86JyhcXFxcWyddfFteJ10pKicpLywvXig/OkApLywvXig/OnRydWUoPz0oW359XFxzKV0pKSkvLC9eKD86ZmFsc2UoPz0oW359XFxzKV0pKSkvLC9eKD86dW5kZWZpbmVkKD89KFt+fVxccyldKSkpLywvXig/Om51bGwoPz0oW359XFxzKV0pKSkvLC9eKD86LT9bMC05XSsoPzpcXC5bMC05XSspPyg/PShbfn1cXHMpXSkpKS8sL14oPzphc1xccytcXHwpLywvXig/OlxcfCkvLC9eKD86KFteXFxzIVwiIyUtLFxcLlxcLzstPkBcXFstXFxeYFxcey1+XSsoPz0oWz1+fVxcc1xcLy4pfF0pKSkpLywvXig/OlxcWyhcXFxcXFxdfFteXFxdXSkqXFxdKS8sL14oPzouKS8sL14oPzokKS9dO1xubGV4ZXIuY29uZGl0aW9ucyA9IHtcIm11XCI6e1wicnVsZXNcIjpbNyw4LDksMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksMzAsMzEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzksNDAsNDEsNDIsNDMsNDRdLFwiaW5jbHVzaXZlXCI6ZmFsc2V9LFwiZW11XCI6e1wicnVsZXNcIjpbMl0sXCJpbmNsdXNpdmVcIjpmYWxzZX0sXCJjb21cIjp7XCJydWxlc1wiOls2XSxcImluY2x1c2l2ZVwiOmZhbHNlfSxcInJhd1wiOntcInJ1bGVzXCI6WzMsNCw1XSxcImluY2x1c2l2ZVwiOmZhbHNlfSxcIklOSVRJQUxcIjp7XCJydWxlc1wiOlswLDEsNDRdLFwiaW5jbHVzaXZlXCI6dHJ1ZX19O1xucmV0dXJuIGxleGVyO30pKClcbnBhcnNlci5sZXhlciA9IGxleGVyO1xuZnVuY3Rpb24gUGFyc2VyICgpIHsgdGhpcy55eSA9IHt9OyB9UGFyc2VyLnByb3RvdHlwZSA9IHBhcnNlcjtwYXJzZXIuUGFyc2VyID0gUGFyc2VyO1xucmV0dXJuIG5ldyBQYXJzZXI7XG59KSgpO2V4cG9ydCBkZWZhdWx0IGhhbmRsZWJhcnM7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG5pbXBvcnQgVmlzaXRvciBmcm9tICcuL3Zpc2l0b3InO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJpbnQoYXN0KSB7XG4gIHJldHVybiBuZXcgUHJpbnRWaXNpdG9yKCkuYWNjZXB0KGFzdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBQcmludFZpc2l0b3IoKSB7XG4gIHRoaXMucGFkZGluZyA9IDA7XG59XG5cblByaW50VmlzaXRvci5wcm90b3R5cGUgPSBuZXcgVmlzaXRvcigpO1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLnBhZCA9IGZ1bmN0aW9uKHN0cmluZykge1xuICBsZXQgb3V0ID0gJyc7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLnBhZGRpbmc7IGkgPCBsOyBpKyspIHtcbiAgICBvdXQgKz0gJyAgJztcbiAgfVxuXG4gIG91dCArPSBzdHJpbmcgKyAnXFxuJztcbiAgcmV0dXJuIG91dDtcbn07XG5cblByaW50VmlzaXRvci5wcm90b3R5cGUuUHJvZ3JhbSA9IGZ1bmN0aW9uKHByb2dyYW0pIHtcbiAgbGV0IG91dCA9ICcnLFxuICAgICAgYm9keSA9IHByb2dyYW0uYm9keSxcbiAgICAgIGksIGw7XG5cbiAgaWYgKHByb2dyYW0uYmxvY2tQYXJhbXMpIHtcbiAgICBsZXQgYmxvY2tQYXJhbXMgPSAnQkxPQ0sgUEFSQU1TOiBbJztcbiAgICBmb3IgKGkgPSAwLCBsID0gcHJvZ3JhbS5ibG9ja1BhcmFtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICBibG9ja1BhcmFtcyArPSAnICcgKyBwcm9ncmFtLmJsb2NrUGFyYW1zW2ldO1xuICAgIH1cbiAgICBibG9ja1BhcmFtcyArPSAnIF0nO1xuICAgIG91dCArPSB0aGlzLnBhZChibG9ja1BhcmFtcyk7XG4gIH1cblxuICBmb3IgKGkgPSAwLCBsID0gYm9keS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvdXQgKz0gdGhpcy5hY2NlcHQoYm9keVtpXSk7XG4gIH1cblxuICB0aGlzLnBhZGRpbmctLTtcblxuICByZXR1cm4gb3V0O1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5NdXN0YWNoZVN0YXRlbWVudCA9IGZ1bmN0aW9uKG11c3RhY2hlKSB7XG4gIHJldHVybiB0aGlzLnBhZCgne3sgJyArIHRoaXMuU3ViRXhwcmVzc2lvbihtdXN0YWNoZSkgKyAnIH19Jyk7XG59O1xuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5EZWNvcmF0b3IgPSBmdW5jdGlvbihtdXN0YWNoZSkge1xuICByZXR1cm4gdGhpcy5wYWQoJ3t7IERJUkVDVElWRSAnICsgdGhpcy5TdWJFeHByZXNzaW9uKG11c3RhY2hlKSArICcgfX0nKTtcbn07XG5cblByaW50VmlzaXRvci5wcm90b3R5cGUuQmxvY2tTdGF0ZW1lbnQgPVxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5EZWNvcmF0b3JCbG9jayA9IGZ1bmN0aW9uKGJsb2NrKSB7XG4gIGxldCBvdXQgPSAnJztcblxuICBvdXQgKz0gdGhpcy5wYWQoKGJsb2NrLnR5cGUgPT09ICdEZWNvcmF0b3JCbG9jaycgPyAnRElSRUNUSVZFICcgOiAnJykgKyAnQkxPQ0s6Jyk7XG4gIHRoaXMucGFkZGluZysrO1xuICBvdXQgKz0gdGhpcy5wYWQodGhpcy5TdWJFeHByZXNzaW9uKGJsb2NrKSk7XG4gIGlmIChibG9jay5wcm9ncmFtKSB7XG4gICAgb3V0ICs9IHRoaXMucGFkKCdQUk9HUkFNOicpO1xuICAgIHRoaXMucGFkZGluZysrO1xuICAgIG91dCArPSB0aGlzLmFjY2VwdChibG9jay5wcm9ncmFtKTtcbiAgICB0aGlzLnBhZGRpbmctLTtcbiAgfVxuICBpZiAoYmxvY2suaW52ZXJzZSkge1xuICAgIGlmIChibG9jay5wcm9ncmFtKSB7IHRoaXMucGFkZGluZysrOyB9XG4gICAgb3V0ICs9IHRoaXMucGFkKCd7e159fScpO1xuICAgIHRoaXMucGFkZGluZysrO1xuICAgIG91dCArPSB0aGlzLmFjY2VwdChibG9jay5pbnZlcnNlKTtcbiAgICB0aGlzLnBhZGRpbmctLTtcbiAgICBpZiAoYmxvY2sucHJvZ3JhbSkgeyB0aGlzLnBhZGRpbmctLTsgfVxuICB9XG4gIHRoaXMucGFkZGluZy0tO1xuXG4gIHJldHVybiBvdXQ7XG59O1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLlBhcnRpYWxTdGF0ZW1lbnQgPSBmdW5jdGlvbihwYXJ0aWFsKSB7XG4gIGxldCBjb250ZW50ID0gJ1BBUlRJQUw6JyArIHBhcnRpYWwubmFtZS5vcmlnaW5hbDtcbiAgaWYgKHBhcnRpYWwucGFyYW1zWzBdKSB7XG4gICAgY29udGVudCArPSAnICcgKyB0aGlzLmFjY2VwdChwYXJ0aWFsLnBhcmFtc1swXSk7XG4gIH1cbiAgaWYgKHBhcnRpYWwuaGFzaCkge1xuICAgIGNvbnRlbnQgKz0gJyAnICsgdGhpcy5hY2NlcHQocGFydGlhbC5oYXNoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5wYWQoJ3t7PiAnICsgY29udGVudCArICcgfX0nKTtcbn07XG5QcmludFZpc2l0b3IucHJvdG90eXBlLlBhcnRpYWxCbG9ja1N0YXRlbWVudCA9IGZ1bmN0aW9uKHBhcnRpYWwpIHtcbiAgbGV0IGNvbnRlbnQgPSAnUEFSVElBTCBCTE9DSzonICsgcGFydGlhbC5uYW1lLm9yaWdpbmFsO1xuICBpZiAocGFydGlhbC5wYXJhbXNbMF0pIHtcbiAgICBjb250ZW50ICs9ICcgJyArIHRoaXMuYWNjZXB0KHBhcnRpYWwucGFyYW1zWzBdKTtcbiAgfVxuICBpZiAocGFydGlhbC5oYXNoKSB7XG4gICAgY29udGVudCArPSAnICcgKyB0aGlzLmFjY2VwdChwYXJ0aWFsLmhhc2gpO1xuICB9XG5cbiAgY29udGVudCArPSAnICcgKyB0aGlzLnBhZCgnUFJPR1JBTTonKTtcbiAgdGhpcy5wYWRkaW5nKys7XG4gIGNvbnRlbnQgKz0gdGhpcy5hY2NlcHQocGFydGlhbC5wcm9ncmFtKTtcbiAgdGhpcy5wYWRkaW5nLS07XG5cbiAgcmV0dXJuIHRoaXMucGFkKCd7ez4gJyArIGNvbnRlbnQgKyAnIH19Jyk7XG59O1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLkNvbnRlbnRTdGF0ZW1lbnQgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gIHJldHVybiB0aGlzLnBhZChcIkNPTlRFTlRbICdcIiArIGNvbnRlbnQudmFsdWUgKyBcIicgXVwiKTtcbn07XG5cblByaW50VmlzaXRvci5wcm90b3R5cGUuQ29tbWVudFN0YXRlbWVudCA9IGZ1bmN0aW9uKGNvbW1lbnQpIHtcbiAgcmV0dXJuIHRoaXMucGFkKFwie3shICdcIiArIGNvbW1lbnQudmFsdWUgKyBcIicgfX1cIik7XG59O1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLlN1YkV4cHJlc3Npb24gPSBmdW5jdGlvbihzZXhwcikge1xuICBsZXQgcGFyYW1zID0gc2V4cHIucGFyYW1zLFxuICAgICAgcGFyYW1TdHJpbmdzID0gW10sXG4gICAgICBoYXNoO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gcGFyYW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHBhcmFtU3RyaW5ncy5wdXNoKHRoaXMuYWNjZXB0KHBhcmFtc1tpXSkpO1xuICB9XG5cbiAgcGFyYW1zID0gJ1snICsgcGFyYW1TdHJpbmdzLmpvaW4oJywgJykgKyAnXSc7XG5cbiAgaGFzaCA9IHNleHByLmhhc2ggPyAnICcgKyB0aGlzLmFjY2VwdChzZXhwci5oYXNoKSA6ICcnO1xuXG4gIHJldHVybiB0aGlzLmFjY2VwdChzZXhwci5wYXRoKSArICcgJyArIHBhcmFtcyArIGhhc2g7XG59O1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLlBhdGhFeHByZXNzaW9uID0gZnVuY3Rpb24oaWQpIHtcbiAgbGV0IHBhdGggPSBpZC5wYXJ0cy5qb2luKCcvJyk7XG4gIHJldHVybiAoaWQuZGF0YSA/ICdAJyA6ICcnKSArICdQQVRIOicgKyBwYXRoO1xufTtcblxuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLlN0cmluZ0xpdGVyYWwgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgcmV0dXJuICdcIicgKyBzdHJpbmcudmFsdWUgKyAnXCInO1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5OdW1iZXJMaXRlcmFsID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gIHJldHVybiAnTlVNQkVSeycgKyBudW1iZXIudmFsdWUgKyAnfSc7XG59O1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLkJvb2xlYW5MaXRlcmFsID0gZnVuY3Rpb24oYm9vbCkge1xuICByZXR1cm4gJ0JPT0xFQU57JyArIGJvb2wudmFsdWUgKyAnfSc7XG59O1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLlVuZGVmaW5lZExpdGVyYWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdVTkRFRklORUQnO1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5OdWxsTGl0ZXJhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ05VTEwnO1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5IYXNoID0gZnVuY3Rpb24oaGFzaCkge1xuICBsZXQgcGFpcnMgPSBoYXNoLnBhaXJzLFxuICAgICAgam9pbmVkUGFpcnMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGpvaW5lZFBhaXJzLnB1c2godGhpcy5hY2NlcHQocGFpcnNbaV0pKTtcbiAgfVxuXG4gIHJldHVybiAnSEFTSHsnICsgam9pbmVkUGFpcnMuam9pbignLCAnKSArICd9Jztcbn07XG5QcmludFZpc2l0b3IucHJvdG90eXBlLkhhc2hQYWlyID0gZnVuY3Rpb24ocGFpcikge1xuICByZXR1cm4gcGFpci5rZXkgKyAnPScgKyB0aGlzLmFjY2VwdChwYWlyLnZhbHVlKTtcbn07XG4vKiBlc2xpbnQtZW5hYmxlIG5ldy1jYXAgKi9cbiIsImltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi4vZXhjZXB0aW9uJztcblxuZnVuY3Rpb24gVmlzaXRvcigpIHtcbiAgdGhpcy5wYXJlbnRzID0gW107XG59XG5cblZpc2l0b3IucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVmlzaXRvcixcbiAgbXV0YXRpbmc6IGZhbHNlLFxuXG4gIC8vIFZpc2l0cyBhIGdpdmVuIHZhbHVlLiBJZiBtdXRhdGluZywgd2lsbCByZXBsYWNlIHRoZSB2YWx1ZSBpZiBuZWNlc3NhcnkuXG4gIGFjY2VwdEtleTogZnVuY3Rpb24obm9kZSwgbmFtZSkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuYWNjZXB0KG5vZGVbbmFtZV0pO1xuICAgIGlmICh0aGlzLm11dGF0aW5nKSB7XG4gICAgICAvLyBIYWNreSBzYW5pdHkgY2hlY2s6IFRoaXMgbWF5IGhhdmUgYSBmZXcgZmFsc2UgcG9zaXRpdmVzIGZvciB0eXBlIGZvciB0aGUgaGVscGVyXG4gICAgICAvLyBtZXRob2RzIGJ1dCB3aWxsIGdlbmVyYWxseSBkbyB0aGUgcmlnaHQgdGhpbmcgd2l0aG91dCBhIGxvdCBvZiBvdmVyaGVhZC5cbiAgICAgIGlmICh2YWx1ZSAmJiAhVmlzaXRvci5wcm90b3R5cGVbdmFsdWUudHlwZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVW5leHBlY3RlZCBub2RlIHR5cGUgXCInICsgdmFsdWUudHlwZSArICdcIiBmb3VuZCB3aGVuIGFjY2VwdGluZyAnICsgbmFtZSArICcgb24gJyArIG5vZGUudHlwZSk7XG4gICAgICB9XG4gICAgICBub2RlW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIC8vIFBlcmZvcm1zIGFuIGFjY2VwdCBvcGVyYXRpb24gd2l0aCBhZGRlZCBzYW5pdHkgY2hlY2sgdG8gZW5zdXJlXG4gIC8vIHJlcXVpcmVkIGtleXMgYXJlIG5vdCByZW1vdmVkLlxuICBhY2NlcHRSZXF1aXJlZDogZnVuY3Rpb24obm9kZSwgbmFtZSkge1xuICAgIHRoaXMuYWNjZXB0S2V5KG5vZGUsIG5hbWUpO1xuXG4gICAgaWYgKCFub2RlW25hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKG5vZGUudHlwZSArICcgcmVxdWlyZXMgJyArIG5hbWUpO1xuICAgIH1cbiAgfSxcblxuICAvLyBUcmF2ZXJzZXMgYSBnaXZlbiBhcnJheS4gSWYgbXV0YXRpbmcsIGVtcHR5IHJlc3Buc2VzIHdpbGwgYmUgcmVtb3ZlZFxuICAvLyBmb3IgY2hpbGQgZWxlbWVudHMuXG4gIGFjY2VwdEFycmF5OiBmdW5jdGlvbihhcnJheSkge1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLmFjY2VwdEtleShhcnJheSwgaSk7XG5cbiAgICAgIGlmICghYXJyYXlbaV0pIHtcbiAgICAgICAgYXJyYXkuc3BsaWNlKGksIDEpO1xuICAgICAgICBpLS07XG4gICAgICAgIGwtLTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYWNjZXB0OiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAoIW9iamVjdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBTYW5pdHkgY29kZSAqL1xuICAgIGlmICghdGhpc1tvYmplY3QudHlwZV0pIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1Vua25vd24gdHlwZTogJyArIG9iamVjdC50eXBlLCBvYmplY3QpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmN1cnJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50cy51bnNoaWZ0KHRoaXMuY3VycmVudCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudCA9IG9iamVjdDtcblxuICAgIGxldCByZXQgPSB0aGlzW29iamVjdC50eXBlXShvYmplY3QpO1xuXG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5wYXJlbnRzLnNoaWZ0KCk7XG5cbiAgICBpZiAoIXRoaXMubXV0YXRpbmcgfHwgcmV0KSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gZWxzZSBpZiAocmV0ICE9PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gIH0sXG5cbiAgUHJvZ3JhbTogZnVuY3Rpb24ocHJvZ3JhbSkge1xuICAgIHRoaXMuYWNjZXB0QXJyYXkocHJvZ3JhbS5ib2R5KTtcbiAgfSxcblxuICBNdXN0YWNoZVN0YXRlbWVudDogdmlzaXRTdWJFeHByZXNzaW9uLFxuICBEZWNvcmF0b3I6IHZpc2l0U3ViRXhwcmVzc2lvbixcblxuICBCbG9ja1N0YXRlbWVudDogdmlzaXRCbG9jayxcbiAgRGVjb3JhdG9yQmxvY2s6IHZpc2l0QmxvY2ssXG5cbiAgUGFydGlhbFN0YXRlbWVudDogdmlzaXRQYXJ0aWFsLFxuICBQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHBhcnRpYWwpIHtcbiAgICB2aXNpdFBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsKTtcblxuICAgIHRoaXMuYWNjZXB0S2V5KHBhcnRpYWwsICdwcm9ncmFtJyk7XG4gIH0sXG5cbiAgQ29udGVudFN0YXRlbWVudDogZnVuY3Rpb24oLyogY29udGVudCAqLykge30sXG4gIENvbW1lbnRTdGF0ZW1lbnQ6IGZ1bmN0aW9uKC8qIGNvbW1lbnQgKi8pIHt9LFxuXG4gIFN1YkV4cHJlc3Npb246IHZpc2l0U3ViRXhwcmVzc2lvbixcblxuICBQYXRoRXhwcmVzc2lvbjogZnVuY3Rpb24oLyogcGF0aCAqLykge30sXG5cbiAgU3RyaW5nTGl0ZXJhbDogZnVuY3Rpb24oLyogc3RyaW5nICovKSB7fSxcbiAgTnVtYmVyTGl0ZXJhbDogZnVuY3Rpb24oLyogbnVtYmVyICovKSB7fSxcbiAgQm9vbGVhbkxpdGVyYWw6IGZ1bmN0aW9uKC8qIGJvb2wgKi8pIHt9LFxuICBVbmRlZmluZWRMaXRlcmFsOiBmdW5jdGlvbigvKiBsaXRlcmFsICovKSB7fSxcbiAgTnVsbExpdGVyYWw6IGZ1bmN0aW9uKC8qIGxpdGVyYWwgKi8pIHt9LFxuXG4gIEhhc2g6IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICB0aGlzLmFjY2VwdEFycmF5KGhhc2gucGFpcnMpO1xuICB9LFxuICBIYXNoUGFpcjogZnVuY3Rpb24ocGFpcikge1xuICAgIHRoaXMuYWNjZXB0UmVxdWlyZWQocGFpciwgJ3ZhbHVlJyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZpc2l0U3ViRXhwcmVzc2lvbihtdXN0YWNoZSkge1xuICB0aGlzLmFjY2VwdFJlcXVpcmVkKG11c3RhY2hlLCAncGF0aCcpO1xuICB0aGlzLmFjY2VwdEFycmF5KG11c3RhY2hlLnBhcmFtcyk7XG4gIHRoaXMuYWNjZXB0S2V5KG11c3RhY2hlLCAnaGFzaCcpO1xufVxuZnVuY3Rpb24gdmlzaXRCbG9jayhibG9jaykge1xuICB2aXNpdFN1YkV4cHJlc3Npb24uY2FsbCh0aGlzLCBibG9jayk7XG5cbiAgdGhpcy5hY2NlcHRLZXkoYmxvY2ssICdwcm9ncmFtJyk7XG4gIHRoaXMuYWNjZXB0S2V5KGJsb2NrLCAnaW52ZXJzZScpO1xufVxuZnVuY3Rpb24gdmlzaXRQYXJ0aWFsKHBhcnRpYWwpIHtcbiAgdGhpcy5hY2NlcHRSZXF1aXJlZChwYXJ0aWFsLCAnbmFtZScpO1xuICB0aGlzLmFjY2VwdEFycmF5KHBhcnRpYWwucGFyYW1zKTtcbiAgdGhpcy5hY2NlcHRLZXkocGFydGlhbCwgJ2hhc2gnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVmlzaXRvcjtcbiIsImltcG9ydCBWaXNpdG9yIGZyb20gJy4vdmlzaXRvcic7XG5cbmZ1bmN0aW9uIFdoaXRlc3BhY2VDb250cm9sKG9wdGlvbnMgPSB7fSkge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xufVxuV2hpdGVzcGFjZUNvbnRyb2wucHJvdG90eXBlID0gbmV3IFZpc2l0b3IoKTtcblxuV2hpdGVzcGFjZUNvbnRyb2wucHJvdG90eXBlLlByb2dyYW0gPSBmdW5jdGlvbihwcm9ncmFtKSB7XG4gIGNvbnN0IGRvU3RhbmRhbG9uZSA9ICF0aGlzLm9wdGlvbnMuaWdub3JlU3RhbmRhbG9uZTtcblxuICBsZXQgaXNSb290ID0gIXRoaXMuaXNSb290U2VlbjtcbiAgdGhpcy5pc1Jvb3RTZWVuID0gdHJ1ZTtcblxuICBsZXQgYm9keSA9IHByb2dyYW0uYm9keTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBib2R5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxldCBjdXJyZW50ID0gYm9keVtpXSxcbiAgICAgICAgc3RyaXAgPSB0aGlzLmFjY2VwdChjdXJyZW50KTtcblxuICAgIGlmICghc3RyaXApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCBfaXNQcmV2V2hpdGVzcGFjZSA9IGlzUHJldldoaXRlc3BhY2UoYm9keSwgaSwgaXNSb290KSxcbiAgICAgICAgX2lzTmV4dFdoaXRlc3BhY2UgPSBpc05leHRXaGl0ZXNwYWNlKGJvZHksIGksIGlzUm9vdCksXG5cbiAgICAgICAgb3BlblN0YW5kYWxvbmUgPSBzdHJpcC5vcGVuU3RhbmRhbG9uZSAmJiBfaXNQcmV2V2hpdGVzcGFjZSxcbiAgICAgICAgY2xvc2VTdGFuZGFsb25lID0gc3RyaXAuY2xvc2VTdGFuZGFsb25lICYmIF9pc05leHRXaGl0ZXNwYWNlLFxuICAgICAgICBpbmxpbmVTdGFuZGFsb25lID0gc3RyaXAuaW5saW5lU3RhbmRhbG9uZSAmJiBfaXNQcmV2V2hpdGVzcGFjZSAmJiBfaXNOZXh0V2hpdGVzcGFjZTtcblxuICAgIGlmIChzdHJpcC5jbG9zZSkge1xuICAgICAgb21pdFJpZ2h0KGJvZHksIGksIHRydWUpO1xuICAgIH1cbiAgICBpZiAoc3RyaXAub3Blbikge1xuICAgICAgb21pdExlZnQoYm9keSwgaSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGRvU3RhbmRhbG9uZSAmJiBpbmxpbmVTdGFuZGFsb25lKSB7XG4gICAgICBvbWl0UmlnaHQoYm9keSwgaSk7XG5cbiAgICAgIGlmIChvbWl0TGVmdChib2R5LCBpKSkge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgb24gYSBzdGFuZGFsb25lIG5vZGUsIHNhdmUgdGhlIGluZGVudCBpbmZvIGZvciBwYXJ0aWFsc1xuICAgICAgICBpZiAoY3VycmVudC50eXBlID09PSAnUGFydGlhbFN0YXRlbWVudCcpIHtcbiAgICAgICAgICAvLyBQdWxsIG91dCB0aGUgd2hpdGVzcGFjZSBmcm9tIHRoZSBmaW5hbCBsaW5lXG4gICAgICAgICAgY3VycmVudC5pbmRlbnQgPSAoLyhbIFxcdF0rJCkvKS5leGVjKGJvZHlbaSAtIDFdLm9yaWdpbmFsKVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZG9TdGFuZGFsb25lICYmIG9wZW5TdGFuZGFsb25lKSB7XG4gICAgICBvbWl0UmlnaHQoKGN1cnJlbnQucHJvZ3JhbSB8fCBjdXJyZW50LmludmVyc2UpLmJvZHkpO1xuXG4gICAgICAvLyBTdHJpcCBvdXQgdGhlIHByZXZpb3VzIGNvbnRlbnQgbm9kZSBpZiBpdCdzIHdoaXRlc3BhY2Ugb25seVxuICAgICAgb21pdExlZnQoYm9keSwgaSk7XG4gICAgfVxuICAgIGlmIChkb1N0YW5kYWxvbmUgJiYgY2xvc2VTdGFuZGFsb25lKSB7XG4gICAgICAvLyBBbHdheXMgc3RyaXAgdGhlIG5leHQgbm9kZVxuICAgICAgb21pdFJpZ2h0KGJvZHksIGkpO1xuXG4gICAgICBvbWl0TGVmdCgoY3VycmVudC5pbnZlcnNlIHx8IGN1cnJlbnQucHJvZ3JhbSkuYm9keSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb2dyYW07XG59O1xuXG5XaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuQmxvY2tTdGF0ZW1lbnQgPVxuV2hpdGVzcGFjZUNvbnRyb2wucHJvdG90eXBlLkRlY29yYXRvckJsb2NrID1cbldoaXRlc3BhY2VDb250cm9sLnByb3RvdHlwZS5QYXJ0aWFsQmxvY2tTdGF0ZW1lbnQgPSBmdW5jdGlvbihibG9jaykge1xuICB0aGlzLmFjY2VwdChibG9jay5wcm9ncmFtKTtcbiAgdGhpcy5hY2NlcHQoYmxvY2suaW52ZXJzZSk7XG5cbiAgLy8gRmluZCB0aGUgaW52ZXJzZSBwcm9ncmFtIHRoYXQgaXMgaW52b2xlZCB3aXRoIHdoaXRlc3BhY2Ugc3RyaXBwaW5nLlxuICBsZXQgcHJvZ3JhbSA9IGJsb2NrLnByb2dyYW0gfHwgYmxvY2suaW52ZXJzZSxcbiAgICAgIGludmVyc2UgPSBibG9jay5wcm9ncmFtICYmIGJsb2NrLmludmVyc2UsXG4gICAgICBmaXJzdEludmVyc2UgPSBpbnZlcnNlLFxuICAgICAgbGFzdEludmVyc2UgPSBpbnZlcnNlO1xuXG4gIGlmIChpbnZlcnNlICYmIGludmVyc2UuY2hhaW5lZCkge1xuICAgIGZpcnN0SW52ZXJzZSA9IGludmVyc2UuYm9keVswXS5wcm9ncmFtO1xuXG4gICAgLy8gV2FsayB0aGUgaW52ZXJzZSBjaGFpbiB0byBmaW5kIHRoZSBsYXN0IGludmVyc2UgdGhhdCBpcyBhY3R1YWxseSBpbiB0aGUgY2hhaW4uXG4gICAgd2hpbGUgKGxhc3RJbnZlcnNlLmNoYWluZWQpIHtcbiAgICAgIGxhc3RJbnZlcnNlID0gbGFzdEludmVyc2UuYm9keVtsYXN0SW52ZXJzZS5ib2R5Lmxlbmd0aCAtIDFdLnByb2dyYW07XG4gICAgfVxuICB9XG5cbiAgbGV0IHN0cmlwID0ge1xuICAgIG9wZW46IGJsb2NrLm9wZW5TdHJpcC5vcGVuLFxuICAgIGNsb3NlOiBibG9jay5jbG9zZVN0cmlwLmNsb3NlLFxuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBzdGFuZGFsb25lIGNhbmRpYWN5LiBCYXNpY2FsbHkgZmxhZyBvdXIgY29udGVudCBhcyBiZWluZyBwb3NzaWJseSBzdGFuZGFsb25lXG4gICAgLy8gc28gb3VyIHBhcmVudCBjYW4gZGV0ZXJtaW5lIGlmIHdlIGFjdHVhbGx5IGFyZSBzdGFuZGFsb25lXG4gICAgb3BlblN0YW5kYWxvbmU6IGlzTmV4dFdoaXRlc3BhY2UocHJvZ3JhbS5ib2R5KSxcbiAgICBjbG9zZVN0YW5kYWxvbmU6IGlzUHJldldoaXRlc3BhY2UoKGZpcnN0SW52ZXJzZSB8fCBwcm9ncmFtKS5ib2R5KVxuICB9O1xuXG4gIGlmIChibG9jay5vcGVuU3RyaXAuY2xvc2UpIHtcbiAgICBvbWl0UmlnaHQocHJvZ3JhbS5ib2R5LCBudWxsLCB0cnVlKTtcbiAgfVxuXG4gIGlmIChpbnZlcnNlKSB7XG4gICAgbGV0IGludmVyc2VTdHJpcCA9IGJsb2NrLmludmVyc2VTdHJpcDtcblxuICAgIGlmIChpbnZlcnNlU3RyaXAub3Blbikge1xuICAgICAgb21pdExlZnQocHJvZ3JhbS5ib2R5LCBudWxsLCB0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAoaW52ZXJzZVN0cmlwLmNsb3NlKSB7XG4gICAgICBvbWl0UmlnaHQoZmlyc3RJbnZlcnNlLmJvZHksIG51bGwsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoYmxvY2suY2xvc2VTdHJpcC5vcGVuKSB7XG4gICAgICBvbWl0TGVmdChsYXN0SW52ZXJzZS5ib2R5LCBudWxsLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHN0YW5kYWxvbmUgZWxzZSBzdGF0bWVudHNcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5pZ25vcmVTdGFuZGFsb25lXG4gICAgICAgICYmIGlzUHJldldoaXRlc3BhY2UocHJvZ3JhbS5ib2R5KVxuICAgICAgICAmJiBpc05leHRXaGl0ZXNwYWNlKGZpcnN0SW52ZXJzZS5ib2R5KSkge1xuICAgICAgb21pdExlZnQocHJvZ3JhbS5ib2R5KTtcbiAgICAgIG9taXRSaWdodChmaXJzdEludmVyc2UuYm9keSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGJsb2NrLmNsb3NlU3RyaXAub3Blbikge1xuICAgIG9taXRMZWZ0KHByb2dyYW0uYm9keSwgbnVsbCwgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gc3RyaXA7XG59O1xuXG5XaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuRGVjb3JhdG9yID1cbldoaXRlc3BhY2VDb250cm9sLnByb3RvdHlwZS5NdXN0YWNoZVN0YXRlbWVudCA9IGZ1bmN0aW9uKG11c3RhY2hlKSB7XG4gIHJldHVybiBtdXN0YWNoZS5zdHJpcDtcbn07XG5cbldoaXRlc3BhY2VDb250cm9sLnByb3RvdHlwZS5QYXJ0aWFsU3RhdGVtZW50ID1cbiAgICBXaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuQ29tbWVudFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgbGV0IHN0cmlwID0gbm9kZS5zdHJpcCB8fCB7fTtcbiAgcmV0dXJuIHtcbiAgICBpbmxpbmVTdGFuZGFsb25lOiB0cnVlLFxuICAgIG9wZW46IHN0cmlwLm9wZW4sXG4gICAgY2xvc2U6IHN0cmlwLmNsb3NlXG4gIH07XG59O1xuXG5cbmZ1bmN0aW9uIGlzUHJldldoaXRlc3BhY2UoYm9keSwgaSwgaXNSb290KSB7XG4gIGlmIChpID09PSB1bmRlZmluZWQpIHtcbiAgICBpID0gYm9keS5sZW5ndGg7XG4gIH1cblxuICAvLyBOb2RlcyB0aGF0IGVuZCB3aXRoIG5ld2xpbmVzIGFyZSBjb25zaWRlcmVkIHdoaXRlc3BhY2UgKGJ1dCBhcmUgc3BlY2lhbFxuICAvLyBjYXNlZCBmb3Igc3RyaXAgb3BlcmF0aW9ucylcbiAgbGV0IHByZXYgPSBib2R5W2kgLSAxXSxcbiAgICAgIHNpYmxpbmcgPSBib2R5W2kgLSAyXTtcbiAgaWYgKCFwcmV2KSB7XG4gICAgcmV0dXJuIGlzUm9vdDtcbiAgfVxuXG4gIGlmIChwcmV2LnR5cGUgPT09ICdDb250ZW50U3RhdGVtZW50Jykge1xuICAgIHJldHVybiAoc2libGluZyB8fCAhaXNSb290ID8gKC9cXHI/XFxuXFxzKj8kLykgOiAoLyhefFxccj9cXG4pXFxzKj8kLykpLnRlc3QocHJldi5vcmlnaW5hbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTmV4dFdoaXRlc3BhY2UoYm9keSwgaSwgaXNSb290KSB7XG4gIGlmIChpID09PSB1bmRlZmluZWQpIHtcbiAgICBpID0gLTE7XG4gIH1cblxuICBsZXQgbmV4dCA9IGJvZHlbaSArIDFdLFxuICAgICAgc2libGluZyA9IGJvZHlbaSArIDJdO1xuICBpZiAoIW5leHQpIHtcbiAgICByZXR1cm4gaXNSb290O1xuICB9XG5cbiAgaWYgKG5leHQudHlwZSA9PT0gJ0NvbnRlbnRTdGF0ZW1lbnQnKSB7XG4gICAgcmV0dXJuIChzaWJsaW5nIHx8ICFpc1Jvb3QgPyAoL15cXHMqP1xccj9cXG4vKSA6ICgvXlxccyo/KFxccj9cXG58JCkvKSkudGVzdChuZXh0Lm9yaWdpbmFsKTtcbiAgfVxufVxuXG4vLyBNYXJrcyB0aGUgbm9kZSB0byB0aGUgcmlnaHQgb2YgdGhlIHBvc2l0aW9uIGFzIG9taXR0ZWQuXG4vLyBJLmUuIHt7Zm9vfX0nICcgd2lsbCBtYXJrIHRoZSAnICcgbm9kZSBhcyBvbWl0dGVkLlxuLy9cbi8vIElmIGkgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIG1hcmtlZCBhcyBzdWNoLlxuLy9cbi8vIElmIG11bGl0cGxlIGlzIHRydXRoeSB0aGVuIGFsbCB3aGl0ZXNwYWNlIHdpbGwgYmUgc3RyaXBwZWQgb3V0IHVudGlsIG5vbi13aGl0ZXNwYWNlXG4vLyBjb250ZW50IGlzIG1ldC5cbmZ1bmN0aW9uIG9taXRSaWdodChib2R5LCBpLCBtdWx0aXBsZSkge1xuICBsZXQgY3VycmVudCA9IGJvZHlbaSA9PSBudWxsID8gMCA6IGkgKyAxXTtcbiAgaWYgKCFjdXJyZW50IHx8IGN1cnJlbnQudHlwZSAhPT0gJ0NvbnRlbnRTdGF0ZW1lbnQnIHx8ICghbXVsdGlwbGUgJiYgY3VycmVudC5yaWdodFN0cmlwcGVkKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBvcmlnaW5hbCA9IGN1cnJlbnQudmFsdWU7XG4gIGN1cnJlbnQudmFsdWUgPSBjdXJyZW50LnZhbHVlLnJlcGxhY2UobXVsdGlwbGUgPyAoL15cXHMrLykgOiAoL15bIFxcdF0qXFxyP1xcbj8vKSwgJycpO1xuICBjdXJyZW50LnJpZ2h0U3RyaXBwZWQgPSBjdXJyZW50LnZhbHVlICE9PSBvcmlnaW5hbDtcbn1cblxuLy8gTWFya3MgdGhlIG5vZGUgdG8gdGhlIGxlZnQgb2YgdGhlIHBvc2l0aW9uIGFzIG9taXR0ZWQuXG4vLyBJLmUuICcgJ3t7Zm9vfX0gd2lsbCBtYXJrIHRoZSAnICcgbm9kZSBhcyBvbWl0dGVkLlxuLy9cbi8vIElmIGkgaXMgdW5kZWZpbmVkIHRoZW4gdGhlIGxhc3QgY2hpbGQgd2lsbCBiZSBtYXJrZWQgYXMgc3VjaC5cbi8vXG4vLyBJZiBtdWxpdHBsZSBpcyB0cnV0aHkgdGhlbiBhbGwgd2hpdGVzcGFjZSB3aWxsIGJlIHN0cmlwcGVkIG91dCB1bnRpbCBub24td2hpdGVzcGFjZVxuLy8gY29udGVudCBpcyBtZXQuXG5mdW5jdGlvbiBvbWl0TGVmdChib2R5LCBpLCBtdWx0aXBsZSkge1xuICBsZXQgY3VycmVudCA9IGJvZHlbaSA9PSBudWxsID8gYm9keS5sZW5ndGggLSAxIDogaSAtIDFdO1xuICBpZiAoIWN1cnJlbnQgfHwgY3VycmVudC50eXBlICE9PSAnQ29udGVudFN0YXRlbWVudCcgfHwgKCFtdWx0aXBsZSAmJiBjdXJyZW50LmxlZnRTdHJpcHBlZCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBXZSBvbWl0IHRoZSBsYXN0IG5vZGUgaWYgaXQncyB3aGl0ZXNwYWNlIG9ubHkgYW5kIG5vdCBwcmVjZWVkZWQgYnkgYSBub24tY29udGVudCBub2RlLlxuICBsZXQgb3JpZ2luYWwgPSBjdXJyZW50LnZhbHVlO1xuICBjdXJyZW50LnZhbHVlID0gY3VycmVudC52YWx1ZS5yZXBsYWNlKG11bHRpcGxlID8gKC9cXHMrJC8pIDogKC9bIFxcdF0rJC8pLCAnJyk7XG4gIGN1cnJlbnQubGVmdFN0cmlwcGVkID0gY3VycmVudC52YWx1ZSAhPT0gb3JpZ2luYWw7XG4gIHJldHVybiBjdXJyZW50LmxlZnRTdHJpcHBlZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgV2hpdGVzcGFjZUNvbnRyb2w7XG4iLCJpbXBvcnQgcmVnaXN0ZXJJbmxpbmUgZnJvbSAnLi9kZWNvcmF0b3JzL2lubGluZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzKGluc3RhbmNlKSB7XG4gIHJlZ2lzdGVySW5saW5lKGluc3RhbmNlKTtcbn1cblxuIiwiaW1wb3J0IHtleHRlbmR9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJEZWNvcmF0b3IoJ2lubGluZScsIGZ1bmN0aW9uKGZuLCBwcm9wcywgY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgbGV0IHJldCA9IGZuO1xuICAgIGlmICghcHJvcHMucGFydGlhbHMpIHtcbiAgICAgIHByb3BzLnBhcnRpYWxzID0ge307XG4gICAgICByZXQgPSBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwYXJ0aWFscyBzdGFjayBmcmFtZSBwcmlvciB0byBleGVjLlxuICAgICAgICBsZXQgb3JpZ2luYWwgPSBjb250YWluZXIucGFydGlhbHM7XG4gICAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IGV4dGVuZCh7fSwgb3JpZ2luYWwsIHByb3BzLnBhcnRpYWxzKTtcbiAgICAgICAgbGV0IHJldCA9IGZuKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBvcmlnaW5hbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcHJvcHMucGFydGlhbHNbb3B0aW9ucy5hcmdzWzBdXSA9IG9wdGlvbnMuZm47XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cbiIsIlxuY29uc3QgZXJyb3JQcm9wcyA9IFsnZGVzY3JpcHRpb24nLCAnZmlsZU5hbWUnLCAnbGluZU51bWJlcicsICdtZXNzYWdlJywgJ25hbWUnLCAnbnVtYmVyJywgJ3N0YWNrJ107XG5cbmZ1bmN0aW9uIEV4Y2VwdGlvbihtZXNzYWdlLCBub2RlKSB7XG4gIGxldCBsb2MgPSBub2RlICYmIG5vZGUubG9jLFxuICAgICAgbGluZSxcbiAgICAgIGNvbHVtbjtcbiAgaWYgKGxvYykge1xuICAgIGxpbmUgPSBsb2Muc3RhcnQubGluZTtcbiAgICBjb2x1bW4gPSBsb2Muc3RhcnQuY29sdW1uO1xuXG4gICAgbWVzc2FnZSArPSAnIC0gJyArIGxpbmUgKyAnOicgKyBjb2x1bW47XG4gIH1cblxuICBsZXQgdG1wID0gRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG5cbiAgLy8gVW5mb3J0dW5hdGVseSBlcnJvcnMgYXJlIG5vdCBlbnVtZXJhYmxlIGluIENocm9tZSAoYXQgbGVhc3QpLCBzbyBgZm9yIHByb3AgaW4gdG1wYCBkb2Vzbid0IHdvcmsuXG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGVycm9yUHJvcHMubGVuZ3RoOyBpZHgrKykge1xuICAgIHRoaXNbZXJyb3JQcm9wc1tpZHhdXSA9IHRtcFtlcnJvclByb3BzW2lkeF1dO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRXhjZXB0aW9uKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGxvYykge1xuICAgICAgdGhpcy5saW5lTnVtYmVyID0gbGluZTtcblxuICAgICAgLy8gV29yayBhcm91bmQgaXNzdWUgdW5kZXIgc2FmYXJpIHdoZXJlIHdlIGNhbid0IGRpcmVjdGx5IHNldCB0aGUgY29sdW1uIHZhbHVlXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvbHVtbicsIHtcbiAgICAgICAgICB2YWx1ZTogY29sdW1uLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKG5vcCkge1xuICAgIC8qIElnbm9yZSBpZiB0aGUgYnJvd3NlciBpcyB2ZXJ5IHBhcnRpY3VsYXIgKi9cbiAgfVxufVxuXG5FeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbmV4cG9ydCBkZWZhdWx0IEV4Y2VwdGlvbjtcbiIsImltcG9ydCByZWdpc3RlckJsb2NrSGVscGVyTWlzc2luZyBmcm9tICcuL2hlbHBlcnMvYmxvY2staGVscGVyLW1pc3NpbmcnO1xuaW1wb3J0IHJlZ2lzdGVyRWFjaCBmcm9tICcuL2hlbHBlcnMvZWFjaCc7XG5pbXBvcnQgcmVnaXN0ZXJIZWxwZXJNaXNzaW5nIGZyb20gJy4vaGVscGVycy9oZWxwZXItbWlzc2luZyc7XG5pbXBvcnQgcmVnaXN0ZXJJZiBmcm9tICcuL2hlbHBlcnMvaWYnO1xuaW1wb3J0IHJlZ2lzdGVyTG9nIGZyb20gJy4vaGVscGVycy9sb2cnO1xuaW1wb3J0IHJlZ2lzdGVyTG9va3VwIGZyb20gJy4vaGVscGVycy9sb29rdXAnO1xuaW1wb3J0IHJlZ2lzdGVyV2l0aCBmcm9tICcuL2hlbHBlcnMvd2l0aCc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHRIZWxwZXJzKGluc3RhbmNlKSB7XG4gIHJlZ2lzdGVyQmxvY2tIZWxwZXJNaXNzaW5nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJFYWNoKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJIZWxwZXJNaXNzaW5nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJJZihpbnN0YW5jZSk7XG4gIHJlZ2lzdGVyTG9nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJMb29rdXAoaW5zdGFuY2UpO1xuICByZWdpc3RlcldpdGgoaW5zdGFuY2UpO1xufVxuIiwiaW1wb3J0IHthcHBlbmRDb250ZXh0UGF0aCwgY3JlYXRlRnJhbWUsIGlzQXJyYXl9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2Jsb2NrSGVscGVyTWlzc2luZycsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBsZXQgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZSxcbiAgICAgICAgZm4gPSBvcHRpb25zLmZuO1xuXG4gICAgaWYgKGNvbnRleHQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBmbih0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRleHQgPT09IGZhbHNlIHx8IGNvbnRleHQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGludmVyc2UodGhpcyk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGNvbnRleHQpKSB7XG4gICAgICBpZiAoY29udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmlkcykge1xuICAgICAgICAgIG9wdGlvbnMuaWRzID0gW29wdGlvbnMubmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5zdGFuY2UuaGVscGVycy5lYWNoKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGludmVyc2UodGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLm5hbWUpO1xuICAgICAgICBvcHRpb25zID0ge2RhdGE6IGRhdGF9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbn1cbiIsImltcG9ydCB7YXBwZW5kQ29udGV4dFBhdGgsIGJsb2NrUGFyYW1zLCBjcmVhdGVGcmFtZSwgaXNBcnJheSwgaXNGdW5jdGlvbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuLi9leGNlcHRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignZWFjaCcsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ011c3QgcGFzcyBpdGVyYXRvciB0byAjZWFjaCcpO1xuICAgIH1cblxuICAgIGxldCBmbiA9IG9wdGlvbnMuZm4sXG4gICAgICAgIGludmVyc2UgPSBvcHRpb25zLmludmVyc2UsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICByZXQgPSAnJyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dFBhdGg7XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG4gICAgICBjb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pICsgJy4nO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRleHQpKSB7IGNvbnRleHQgPSBjb250ZXh0LmNhbGwodGhpcyk7IH1cblxuICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4ZWNJdGVyYXRpb24oZmllbGQsIGluZGV4LCBsYXN0KSB7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBkYXRhLmtleSA9IGZpZWxkO1xuICAgICAgICBkYXRhLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGRhdGEuZmlyc3QgPSBpbmRleCA9PT0gMDtcbiAgICAgICAgZGF0YS5sYXN0ID0gISFsYXN0O1xuXG4gICAgICAgIGlmIChjb250ZXh0UGF0aCkge1xuICAgICAgICAgIGRhdGEuY29udGV4dFBhdGggPSBjb250ZXh0UGF0aCArIGZpZWxkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldCA9IHJldCArIGZuKGNvbnRleHRbZmllbGRdLCB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyhbY29udGV4dFtmaWVsZF0sIGZpZWxkXSwgW2NvbnRleHRQYXRoICsgZmllbGQsIG51bGxdKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoaXNBcnJheShjb250ZXh0KSkge1xuICAgICAgICBmb3IgKGxldCBqID0gY29udGV4dC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICBpZiAoaSBpbiBjb250ZXh0KSB7XG4gICAgICAgICAgICBleGVjSXRlcmF0aW9uKGksIGksIGkgPT09IGNvbnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcHJpb3JLZXk7XG5cbiAgICAgICAgZm9yIChsZXQga2V5IGluIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBydW5uaW5nIHRoZSBpdGVyYXRpb25zIG9uZSBzdGVwIG91dCBvZiBzeW5jIHNvIHdlIGNhbiBkZXRlY3RcbiAgICAgICAgICAgIC8vIHRoZSBsYXN0IGl0ZXJhdGlvbiB3aXRob3V0IGhhdmUgdG8gc2NhbiB0aGUgb2JqZWN0IHR3aWNlIGFuZCBjcmVhdGVcbiAgICAgICAgICAgIC8vIGFuIGl0ZXJtZWRpYXRlIGtleXMgYXJyYXkuXG4gICAgICAgICAgICBpZiAocHJpb3JLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBleGVjSXRlcmF0aW9uKHByaW9yS2V5LCBpIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmlvcktleSA9IGtleTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaW9yS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBleGVjSXRlcmF0aW9uKHByaW9yS2V5LCBpIC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgcmV0ID0gaW52ZXJzZSh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cbiIsImltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi4vZXhjZXB0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbigvKiBbYXJncywgXW9wdGlvbnMgKi8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gQSBtaXNzaW5nIGZpZWxkIGluIGEge3tmb299fSBjb25zdHJ1Y3QuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTb21lb25lIGlzIGFjdHVhbGx5IHRyeWluZyB0byBjYWxsIHNvbWV0aGluZywgYmxvdyB1cC5cbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ01pc3NpbmcgaGVscGVyOiBcIicgKyBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdLm5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH0pO1xufVxuIiwiaW1wb3J0IHtpc0VtcHR5LCBpc0Z1bmN0aW9ufSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdpZicsIGZ1bmN0aW9uKGNvbmRpdGlvbmFsLCBvcHRpb25zKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oY29uZGl0aW9uYWwpKSB7IGNvbmRpdGlvbmFsID0gY29uZGl0aW9uYWwuY2FsbCh0aGlzKTsgfVxuXG4gICAgLy8gRGVmYXVsdCBiZWhhdmlvciBpcyB0byByZW5kZXIgdGhlIHBvc2l0aXZlIHBhdGggaWYgdGhlIHZhbHVlIGlzIHRydXRoeSBhbmQgbm90IGVtcHR5LlxuICAgIC8vIFRoZSBgaW5jbHVkZVplcm9gIG9wdGlvbiBtYXkgYmUgc2V0IHRvIHRyZWF0IHRoZSBjb25kdGlvbmFsIGFzIHB1cmVseSBub3QgZW1wdHkgYmFzZWQgb24gdGhlXG4gICAgLy8gYmVoYXZpb3Igb2YgaXNFbXB0eS4gRWZmZWN0aXZlbHkgdGhpcyBkZXRlcm1pbmVzIGlmIDAgaXMgaGFuZGxlZCBieSB0aGUgcG9zaXRpdmUgcGF0aCBvciBuZWdhdGl2ZS5cbiAgICBpZiAoKCFvcHRpb25zLmhhc2guaW5jbHVkZVplcm8gJiYgIWNvbmRpdGlvbmFsKSB8fCBpc0VtcHR5KGNvbmRpdGlvbmFsKSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuZm4odGhpcyk7XG4gICAgfVxuICB9KTtcblxuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcigndW5sZXNzJywgZnVuY3Rpb24oY29uZGl0aW9uYWwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuaGVscGVyc1snaWYnXS5jYWxsKHRoaXMsIGNvbmRpdGlvbmFsLCB7Zm46IG9wdGlvbnMuaW52ZXJzZSwgaW52ZXJzZTogb3B0aW9ucy5mbiwgaGFzaDogb3B0aW9ucy5oYXNofSk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvZycsIGZ1bmN0aW9uKC8qIG1lc3NhZ2UsIG9wdGlvbnMgKi8pIHtcbiAgICBsZXQgYXJncyA9IFt1bmRlZmluZWRdLFxuICAgICAgICBvcHRpb25zID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIGxldCBsZXZlbCA9IDE7XG4gICAgaWYgKG9wdGlvbnMuaGFzaC5sZXZlbCAhPSBudWxsKSB7XG4gICAgICBsZXZlbCA9IG9wdGlvbnMuaGFzaC5sZXZlbDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmRhdGEubGV2ZWwgIT0gbnVsbCkge1xuICAgICAgbGV2ZWwgPSBvcHRpb25zLmRhdGEubGV2ZWw7XG4gICAgfVxuICAgIGFyZ3NbMF0gPSBsZXZlbDtcblxuICAgIGluc3RhbmNlLmxvZyguLi4gYXJncyk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvb2t1cCcsIGZ1bmN0aW9uKG9iaiwgZmllbGQpIHtcbiAgICByZXR1cm4gb2JqICYmIG9ialtmaWVsZF07XG4gIH0pO1xufVxuIiwiaW1wb3J0IHthcHBlbmRDb250ZXh0UGF0aCwgYmxvY2tQYXJhbXMsIGNyZWF0ZUZyYW1lLCBpc0VtcHR5LCBpc0Z1bmN0aW9ufSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCd3aXRoJywgZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRleHQpKSB7IGNvbnRleHQgPSBjb250ZXh0LmNhbGwodGhpcyk7IH1cblxuICAgIGxldCBmbiA9IG9wdGlvbnMuZm47XG5cbiAgICBpZiAoIWlzRW1wdHkoY29udGV4dCkpIHtcbiAgICAgIGxldCBkYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlkcykge1xuICAgICAgICBkYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4oY29udGV4dCwge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBibG9ja1BhcmFtczogYmxvY2tQYXJhbXMoW2NvbnRleHRdLCBbZGF0YSAmJiBkYXRhLmNvbnRleHRQYXRoXSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgIH1cbiAgfSk7XG59XG4iLCJpbXBvcnQge2luZGV4T2Z9IGZyb20gJy4vdXRpbHMnO1xuXG5sZXQgbG9nZ2VyID0ge1xuICBtZXRob2RNYXA6IFsnZGVidWcnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJ10sXG4gIGxldmVsOiAnaW5mbycsXG5cbiAgLy8gTWFwcyBhIGdpdmVuIGxldmVsIHZhbHVlIHRvIHRoZSBgbWV0aG9kTWFwYCBpbmRleGVzIGFib3ZlLlxuICBsb29rdXBMZXZlbDogZnVuY3Rpb24obGV2ZWwpIHtcbiAgICBpZiAodHlwZW9mIGxldmVsID09PSAnc3RyaW5nJykge1xuICAgICAgbGV0IGxldmVsTWFwID0gaW5kZXhPZihsb2dnZXIubWV0aG9kTWFwLCBsZXZlbC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIGlmIChsZXZlbE1hcCA+PSAwKSB7XG4gICAgICAgIGxldmVsID0gbGV2ZWxNYXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbCA9IHBhcnNlSW50KGxldmVsLCAxMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxldmVsO1xuICB9LFxuXG4gIC8vIENhbiBiZSBvdmVycmlkZGVuIGluIHRoZSBob3N0IGVudmlyb25tZW50XG4gIGxvZzogZnVuY3Rpb24obGV2ZWwsIC4uLm1lc3NhZ2UpIHtcbiAgICBsZXZlbCA9IGxvZ2dlci5sb29rdXBMZXZlbChsZXZlbCk7XG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGxvZ2dlci5sb29rdXBMZXZlbChsb2dnZXIubGV2ZWwpIDw9IGxldmVsKSB7XG4gICAgICBsZXQgbWV0aG9kID0gbG9nZ2VyLm1ldGhvZE1hcFtsZXZlbF07XG4gICAgICBpZiAoIWNvbnNvbGVbbWV0aG9kXSkgeyAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICBtZXRob2QgPSAnbG9nJztcbiAgICAgIH1cbiAgICAgIGNvbnNvbGVbbWV0aG9kXSguLi5tZXNzYWdlKTsgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBsb2dnZXI7XG4iLCIvKiBnbG9iYWwgd2luZG93ICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihIYW5kbGViYXJzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGxldCByb290ID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3csXG4gICAgICAkSGFuZGxlYmFycyA9IHJvb3QuSGFuZGxlYmFycztcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgSGFuZGxlYmFycy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHJvb3QuSGFuZGxlYmFycyA9PT0gSGFuZGxlYmFycykge1xuICAgICAgcm9vdC5IYW5kbGViYXJzID0gJEhhbmRsZWJhcnM7XG4gICAgfVxuICAgIHJldHVybiBIYW5kbGViYXJzO1xuICB9O1xufVxuIiwiaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4vZXhjZXB0aW9uJztcbmltcG9ydCB7IENPTVBJTEVSX1JFVklTSU9OLCBSRVZJU0lPTl9DSEFOR0VTLCBjcmVhdGVGcmFtZSB9IGZyb20gJy4vYmFzZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1JldmlzaW9uKGNvbXBpbGVySW5mbykge1xuICBjb25zdCBjb21waWxlclJldmlzaW9uID0gY29tcGlsZXJJbmZvICYmIGNvbXBpbGVySW5mb1swXSB8fCAxLFxuICAgICAgICBjdXJyZW50UmV2aXNpb24gPSBDT01QSUxFUl9SRVZJU0lPTjtcblxuICBpZiAoY29tcGlsZXJSZXZpc2lvbiAhPT0gY3VycmVudFJldmlzaW9uKSB7XG4gICAgaWYgKGNvbXBpbGVyUmV2aXNpb24gPCBjdXJyZW50UmV2aXNpb24pIHtcbiAgICAgIGNvbnN0IHJ1bnRpbWVWZXJzaW9ucyA9IFJFVklTSU9OX0NIQU5HRVNbY3VycmVudFJldmlzaW9uXSxcbiAgICAgICAgICAgIGNvbXBpbGVyVmVyc2lvbnMgPSBSRVZJU0lPTl9DSEFOR0VTW2NvbXBpbGVyUmV2aXNpb25dO1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVGVtcGxhdGUgd2FzIHByZWNvbXBpbGVkIHdpdGggYW4gb2xkZXIgdmVyc2lvbiBvZiBIYW5kbGViYXJzIHRoYW4gdGhlIGN1cnJlbnQgcnVudGltZS4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIHVwZGF0ZSB5b3VyIHByZWNvbXBpbGVyIHRvIGEgbmV3ZXIgdmVyc2lvbiAoJyArIHJ1bnRpbWVWZXJzaW9ucyArICcpIG9yIGRvd25ncmFkZSB5b3VyIHJ1bnRpbWUgdG8gYW4gb2xkZXIgdmVyc2lvbiAoJyArIGNvbXBpbGVyVmVyc2lvbnMgKyAnKS4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXNlIHRoZSBlbWJlZGRlZCB2ZXJzaW9uIGluZm8gc2luY2UgdGhlIHJ1bnRpbWUgZG9lc24ndCBrbm93IGFib3V0IHRoaXMgcmV2aXNpb24geWV0XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdUZW1wbGF0ZSB3YXMgcHJlY29tcGlsZWQgd2l0aCBhIG5ld2VyIHZlcnNpb24gb2YgSGFuZGxlYmFycyB0aGFuIHRoZSBjdXJyZW50IHJ1bnRpbWUuICcgK1xuICAgICAgICAgICAgJ1BsZWFzZSB1cGRhdGUgeW91ciBydW50aW1lIHRvIGEgbmV3ZXIgdmVyc2lvbiAoJyArIGNvbXBpbGVySW5mb1sxXSArICcpLicpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGUodGVtcGxhdGVTcGVjLCBlbnYpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKCFlbnYpIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdObyBlbnZpcm9ubWVudCBwYXNzZWQgdG8gdGVtcGxhdGUnKTtcbiAgfVxuICBpZiAoIXRlbXBsYXRlU3BlYyB8fCAhdGVtcGxhdGVTcGVjLm1haW4pIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdVbmtub3duIHRlbXBsYXRlIG9iamVjdDogJyArIHR5cGVvZiB0ZW1wbGF0ZVNwZWMpO1xuICB9XG5cbiAgdGVtcGxhdGVTcGVjLm1haW4uZGVjb3JhdG9yID0gdGVtcGxhdGVTcGVjLm1haW5fZDtcblxuICAvLyBOb3RlOiBVc2luZyBlbnYuVk0gcmVmZXJlbmNlcyByYXRoZXIgdGhhbiBsb2NhbCB2YXIgcmVmZXJlbmNlcyB0aHJvdWdob3V0IHRoaXMgc2VjdGlvbiB0byBhbGxvd1xuICAvLyBmb3IgZXh0ZXJuYWwgdXNlcnMgdG8gb3ZlcnJpZGUgdGhlc2UgYXMgcHN1ZWRvLXN1cHBvcnRlZCBBUElzLlxuICBlbnYuVk0uY2hlY2tSZXZpc2lvbih0ZW1wbGF0ZVNwZWMuY29tcGlsZXIpO1xuXG4gIGZ1bmN0aW9uIGludm9rZVBhcnRpYWxXcmFwcGVyKHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNoKSB7XG4gICAgICBjb250ZXh0ID0gVXRpbHMuZXh0ZW5kKHt9LCBjb250ZXh0LCBvcHRpb25zLmhhc2gpO1xuICAgICAgaWYgKG9wdGlvbnMuaWRzKSB7XG4gICAgICAgIG9wdGlvbnMuaWRzWzBdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJ0aWFsID0gZW52LlZNLnJlc29sdmVQYXJ0aWFsLmNhbGwodGhpcywgcGFydGlhbCwgY29udGV4dCwgb3B0aW9ucyk7XG4gICAgbGV0IHJlc3VsdCA9IGVudi5WTS5pbnZva2VQYXJ0aWFsLmNhbGwodGhpcywgcGFydGlhbCwgY29udGV4dCwgb3B0aW9ucyk7XG5cbiAgICBpZiAocmVzdWx0ID09IG51bGwgJiYgZW52LmNvbXBpbGUpIHtcbiAgICAgIG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXSA9IGVudi5jb21waWxlKHBhcnRpYWwsIHRlbXBsYXRlU3BlYy5jb21waWxlck9wdGlvbnMsIGVudik7XG4gICAgICByZXN1bHQgPSBvcHRpb25zLnBhcnRpYWxzW29wdGlvbnMubmFtZV0oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgaWYgKG9wdGlvbnMuaW5kZW50KSB7XG4gICAgICAgIGxldCBsaW5lcyA9IHJlc3VsdC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFsaW5lc1tpXSAmJiBpICsgMSA9PT0gbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGluZXNbaV0gPSBvcHRpb25zLmluZGVudCArIGxpbmVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVGhlIHBhcnRpYWwgJyArIG9wdGlvbnMubmFtZSArICcgY291bGQgbm90IGJlIGNvbXBpbGVkIHdoZW4gcnVubmluZyBpbiBydW50aW1lLW9ubHkgbW9kZScpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEp1c3QgYWRkIHdhdGVyXG4gIGxldCBjb250YWluZXIgPSB7XG4gICAgc3RyaWN0OiBmdW5jdGlvbihvYmosIG5hbWUpIHtcbiAgICAgIGlmICghKG5hbWUgaW4gb2JqKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdcIicgKyBuYW1lICsgJ1wiIG5vdCBkZWZpbmVkIGluICcgKyBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialtuYW1lXTtcbiAgICB9LFxuICAgIGxvb2t1cDogZnVuY3Rpb24oZGVwdGhzLCBuYW1lKSB7XG4gICAgICBjb25zdCBsZW4gPSBkZXB0aHMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoZGVwdGhzW2ldICYmIGRlcHRoc1tpXVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGRlcHRoc1tpXVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbGFtYmRhOiBmdW5jdGlvbihjdXJyZW50LCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGN1cnJlbnQgPT09ICdmdW5jdGlvbicgPyBjdXJyZW50LmNhbGwoY29udGV4dCkgOiBjdXJyZW50O1xuICAgIH0sXG5cbiAgICBlc2NhcGVFeHByZXNzaW9uOiBVdGlscy5lc2NhcGVFeHByZXNzaW9uLFxuICAgIGludm9rZVBhcnRpYWw6IGludm9rZVBhcnRpYWxXcmFwcGVyLFxuXG4gICAgZm46IGZ1bmN0aW9uKGkpIHtcbiAgICAgIGxldCByZXQgPSB0ZW1wbGF0ZVNwZWNbaV07XG4gICAgICByZXQuZGVjb3JhdG9yID0gdGVtcGxhdGVTcGVjW2kgKyAnX2QnXTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIHByb2dyYW1zOiBbXSxcbiAgICBwcm9ncmFtOiBmdW5jdGlvbihpLCBkYXRhLCBkZWNsYXJlZEJsb2NrUGFyYW1zLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XG4gICAgICBsZXQgcHJvZ3JhbVdyYXBwZXIgPSB0aGlzLnByb2dyYW1zW2ldLFxuICAgICAgICAgIGZuID0gdGhpcy5mbihpKTtcbiAgICAgIGlmIChkYXRhIHx8IGRlcHRocyB8fCBibG9ja1BhcmFtcyB8fCBkZWNsYXJlZEJsb2NrUGFyYW1zKSB7XG4gICAgICAgIHByb2dyYW1XcmFwcGVyID0gd3JhcFByb2dyYW0odGhpcywgaSwgZm4sIGRhdGEsIGRlY2xhcmVkQmxvY2tQYXJhbXMsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICAgICAgfSBlbHNlIGlmICghcHJvZ3JhbVdyYXBwZXIpIHtcbiAgICAgICAgcHJvZ3JhbVdyYXBwZXIgPSB0aGlzLnByb2dyYW1zW2ldID0gd3JhcFByb2dyYW0odGhpcywgaSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb2dyYW1XcmFwcGVyO1xuICAgIH0sXG5cbiAgICBkYXRhOiBmdW5jdGlvbih2YWx1ZSwgZGVwdGgpIHtcbiAgICAgIHdoaWxlICh2YWx1ZSAmJiBkZXB0aC0tKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuX3BhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIG1lcmdlOiBmdW5jdGlvbihwYXJhbSwgY29tbW9uKSB7XG4gICAgICBsZXQgb2JqID0gcGFyYW0gfHwgY29tbW9uO1xuXG4gICAgICBpZiAocGFyYW0gJiYgY29tbW9uICYmIChwYXJhbSAhPT0gY29tbW9uKSkge1xuICAgICAgICBvYmogPSBVdGlscy5leHRlbmQoe30sIGNvbW1vbiwgcGFyYW0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgLy8gQW4gZW1wdHkgb2JqZWN0IHRvIHVzZSBhcyByZXBsYWNlbWVudCBmb3IgbnVsbC1jb250ZXh0c1xuICAgIG51bGxDb250ZXh0OiBPYmplY3Quc2VhbCh7fSksXG5cbiAgICBub29wOiBlbnYuVk0ubm9vcCxcbiAgICBjb21waWxlckluZm86IHRlbXBsYXRlU3BlYy5jb21waWxlclxuICB9O1xuXG4gIGZ1bmN0aW9uIHJldChjb250ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgZGF0YSA9IG9wdGlvbnMuZGF0YTtcblxuICAgIHJldC5fc2V0dXAob3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zLnBhcnRpYWwgJiYgdGVtcGxhdGVTcGVjLnVzZURhdGEpIHtcbiAgICAgIGRhdGEgPSBpbml0RGF0YShjb250ZXh0LCBkYXRhKTtcbiAgICB9XG4gICAgbGV0IGRlcHRocyxcbiAgICAgICAgYmxvY2tQYXJhbXMgPSB0ZW1wbGF0ZVNwZWMudXNlQmxvY2tQYXJhbXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICBpZiAodGVtcGxhdGVTcGVjLnVzZURlcHRocykge1xuICAgICAgaWYgKG9wdGlvbnMuZGVwdGhzKSB7XG4gICAgICAgIGRlcHRocyA9IGNvbnRleHQgIT0gb3B0aW9ucy5kZXB0aHNbMF0gPyBbY29udGV4dF0uY29uY2F0KG9wdGlvbnMuZGVwdGhzKSA6IG9wdGlvbnMuZGVwdGhzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVwdGhzID0gW2NvbnRleHRdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1haW4oY29udGV4dC8qLCBvcHRpb25zKi8pIHtcbiAgICAgIHJldHVybiAnJyArIHRlbXBsYXRlU3BlYy5tYWluKGNvbnRhaW5lciwgY29udGV4dCwgY29udGFpbmVyLmhlbHBlcnMsIGNvbnRhaW5lci5wYXJ0aWFscywgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocyk7XG4gICAgfVxuICAgIG1haW4gPSBleGVjdXRlRGVjb3JhdG9ycyh0ZW1wbGF0ZVNwZWMubWFpbiwgbWFpbiwgY29udGFpbmVyLCBvcHRpb25zLmRlcHRocyB8fCBbXSwgZGF0YSwgYmxvY2tQYXJhbXMpO1xuICAgIHJldHVybiBtYWluKGNvbnRleHQsIG9wdGlvbnMpO1xuICB9XG4gIHJldC5pc1RvcCA9IHRydWU7XG5cbiAgcmV0Ll9zZXR1cCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMucGFydGlhbCkge1xuICAgICAgY29udGFpbmVyLmhlbHBlcnMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5oZWxwZXJzLCBlbnYuaGVscGVycyk7XG5cbiAgICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlUGFydGlhbCkge1xuICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5wYXJ0aWFscywgZW52LnBhcnRpYWxzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlUGFydGlhbCB8fCB0ZW1wbGF0ZVNwZWMudXNlRGVjb3JhdG9ycykge1xuICAgICAgICBjb250YWluZXIuZGVjb3JhdG9ycyA9IGNvbnRhaW5lci5tZXJnZShvcHRpb25zLmRlY29yYXRvcnMsIGVudi5kZWNvcmF0b3JzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyLmhlbHBlcnMgPSBvcHRpb25zLmhlbHBlcnM7XG4gICAgICBjb250YWluZXIucGFydGlhbHMgPSBvcHRpb25zLnBhcnRpYWxzO1xuICAgICAgY29udGFpbmVyLmRlY29yYXRvcnMgPSBvcHRpb25zLmRlY29yYXRvcnM7XG4gICAgfVxuICB9O1xuXG4gIHJldC5fY2hpbGQgPSBmdW5jdGlvbihpLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XG4gICAgaWYgKHRlbXBsYXRlU3BlYy51c2VCbG9ja1BhcmFtcyAmJiAhYmxvY2tQYXJhbXMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ211c3QgcGFzcyBibG9jayBwYXJhbXMnKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlU3BlYy51c2VEZXB0aHMgJiYgIWRlcHRocykge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignbXVzdCBwYXNzIHBhcmVudCBkZXB0aHMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcFByb2dyYW0oY29udGFpbmVyLCBpLCB0ZW1wbGF0ZVNwZWNbaV0sIGRhdGEsIDAsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICB9O1xuICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcFByb2dyYW0oY29udGFpbmVyLCBpLCBmbiwgZGF0YSwgZGVjbGFyZWRCbG9ja1BhcmFtcywgYmxvY2tQYXJhbXMsIGRlcHRocykge1xuICBmdW5jdGlvbiBwcm9nKGNvbnRleHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBjdXJyZW50RGVwdGhzID0gZGVwdGhzO1xuICAgIGlmIChkZXB0aHMgJiYgY29udGV4dCAhPSBkZXB0aHNbMF0gJiYgIShjb250ZXh0ID09PSBjb250YWluZXIubnVsbENvbnRleHQgJiYgZGVwdGhzWzBdID09PSBudWxsKSkge1xuICAgICAgY3VycmVudERlcHRocyA9IFtjb250ZXh0XS5jb25jYXQoZGVwdGhzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm4oY29udGFpbmVyLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjb250YWluZXIuaGVscGVycywgY29udGFpbmVyLnBhcnRpYWxzLFxuICAgICAgICBvcHRpb25zLmRhdGEgfHwgZGF0YSxcbiAgICAgICAgYmxvY2tQYXJhbXMgJiYgW29wdGlvbnMuYmxvY2tQYXJhbXNdLmNvbmNhdChibG9ja1BhcmFtcyksXG4gICAgICAgIGN1cnJlbnREZXB0aHMpO1xuICB9XG5cbiAgcHJvZyA9IGV4ZWN1dGVEZWNvcmF0b3JzKGZuLCBwcm9nLCBjb250YWluZXIsIGRlcHRocywgZGF0YSwgYmxvY2tQYXJhbXMpO1xuXG4gIHByb2cucHJvZ3JhbSA9IGk7XG4gIHByb2cuZGVwdGggPSBkZXB0aHMgPyBkZXB0aHMubGVuZ3RoIDogMDtcbiAgcHJvZy5ibG9ja1BhcmFtcyA9IGRlY2xhcmVkQmxvY2tQYXJhbXMgfHwgMDtcbiAgcmV0dXJuIHByb2c7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUGFydGlhbChwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gIGlmICghcGFydGlhbCkge1xuICAgIGlmIChvcHRpb25zLm5hbWUgPT09ICdAcGFydGlhbC1ibG9jaycpIHtcbiAgICAgIHBhcnRpYWwgPSBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydGlhbCA9IG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIXBhcnRpYWwuY2FsbCAmJiAhb3B0aW9ucy5uYW1lKSB7XG4gICAgLy8gVGhpcyBpcyBhIGR5bmFtaWMgcGFydGlhbCB0aGF0IHJldHVybmVkIGEgc3RyaW5nXG4gICAgb3B0aW9ucy5uYW1lID0gcGFydGlhbDtcbiAgICBwYXJ0aWFsID0gb3B0aW9ucy5wYXJ0aWFsc1twYXJ0aWFsXTtcbiAgfVxuICByZXR1cm4gcGFydGlhbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludm9rZVBhcnRpYWwocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xuICAvLyBVc2UgdGhlIGN1cnJlbnQgY2xvc3VyZSBjb250ZXh0IHRvIHNhdmUgdGhlIHBhcnRpYWwtYmxvY2sgaWYgdGhpcyBwYXJ0aWFsXG4gIGNvbnN0IGN1cnJlbnRQYXJ0aWFsQmxvY2sgPSBvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5kYXRhWydwYXJ0aWFsLWJsb2NrJ107XG4gIG9wdGlvbnMucGFydGlhbCA9IHRydWU7XG4gIGlmIChvcHRpb25zLmlkcykge1xuICAgIG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCA9IG9wdGlvbnMuaWRzWzBdIHx8IG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aDtcbiAgfVxuXG4gIGxldCBwYXJ0aWFsQmxvY2s7XG4gIGlmIChvcHRpb25zLmZuICYmIG9wdGlvbnMuZm4gIT09IG5vb3ApIHtcbiAgICBvcHRpb25zLmRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgIC8vIFdyYXBwZXIgZnVuY3Rpb24gdG8gZ2V0IGFjY2VzcyB0byBjdXJyZW50UGFydGlhbEJsb2NrIGZyb20gdGhlIGNsb3N1cmVcbiAgICBsZXQgZm4gPSBvcHRpb25zLmZuO1xuICAgIHBhcnRpYWxCbG9jayA9IG9wdGlvbnMuZGF0YVsncGFydGlhbC1ibG9jayddID0gZnVuY3Rpb24gcGFydGlhbEJsb2NrV3JhcHBlcihjb250ZXh0LCBvcHRpb25zID0ge30pIHtcblxuICAgICAgLy8gUmVzdG9yZSB0aGUgcGFydGlhbC1ibG9jayBmcm9tIHRoZSBjbG9zdXJlIGZvciB0aGUgZXhlY3V0aW9uIG9mIHRoZSBibG9ja1xuICAgICAgLy8gaS5lLiB0aGUgcGFydCBpbnNpZGUgdGhlIGJsb2NrIG9mIHRoZSBwYXJ0aWFsIGNhbGwuXG4gICAgICBvcHRpb25zLmRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgICAgb3B0aW9ucy5kYXRhWydwYXJ0aWFsLWJsb2NrJ10gPSBjdXJyZW50UGFydGlhbEJsb2NrO1xuICAgICAgcmV0dXJuIGZuKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgaWYgKGZuLnBhcnRpYWxzKSB7XG4gICAgICBvcHRpb25zLnBhcnRpYWxzID0gVXRpbHMuZXh0ZW5kKHt9LCBvcHRpb25zLnBhcnRpYWxzLCBmbi5wYXJ0aWFscyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnRpYWwgPT09IHVuZGVmaW5lZCAmJiBwYXJ0aWFsQmxvY2spIHtcbiAgICBwYXJ0aWFsID0gcGFydGlhbEJsb2NrO1xuICB9XG5cbiAgaWYgKHBhcnRpYWwgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1RoZSBwYXJ0aWFsICcgKyBvcHRpb25zLm5hbWUgKyAnIGNvdWxkIG5vdCBiZSBmb3VuZCcpO1xuICB9IGVsc2UgaWYgKHBhcnRpYWwgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIHJldHVybiBwYXJ0aWFsKGNvbnRleHQsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkgeyByZXR1cm4gJyc7IH1cblxuZnVuY3Rpb24gaW5pdERhdGEoY29udGV4dCwgZGF0YSkge1xuICBpZiAoIWRhdGEgfHwgISgncm9vdCcgaW4gZGF0YSkpIHtcbiAgICBkYXRhID0gZGF0YSA/IGNyZWF0ZUZyYW1lKGRhdGEpIDoge307XG4gICAgZGF0YS5yb290ID0gY29udGV4dDtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZXhlY3V0ZURlY29yYXRvcnMoZm4sIHByb2csIGNvbnRhaW5lciwgZGVwdGhzLCBkYXRhLCBibG9ja1BhcmFtcykge1xuICBpZiAoZm4uZGVjb3JhdG9yKSB7XG4gICAgbGV0IHByb3BzID0ge307XG4gICAgcHJvZyA9IGZuLmRlY29yYXRvcihwcm9nLCBwcm9wcywgY29udGFpbmVyLCBkZXB0aHMgJiYgZGVwdGhzWzBdLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcbiAgICBVdGlscy5leHRlbmQocHJvZywgcHJvcHMpO1xuICB9XG4gIHJldHVybiBwcm9nO1xufVxuIiwiLy8gQnVpbGQgb3V0IG91ciBiYXNpYyBTYWZlU3RyaW5nIHR5cGVcbmZ1bmN0aW9uIFNhZmVTdHJpbmcoc3RyaW5nKSB7XG4gIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xufVxuXG5TYWZlU3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyA9IFNhZmVTdHJpbmcucHJvdG90eXBlLnRvSFRNTCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJycgKyB0aGlzLnN0cmluZztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNhZmVTdHJpbmc7XG4iLCJjb25zdCBlc2NhcGUgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmI3gyNzsnLFxuICAnYCc6ICcmI3g2MDsnLFxuICAnPSc6ICcmI3gzRDsnXG59O1xuXG5jb25zdCBiYWRDaGFycyA9IC9bJjw+XCInYD1dL2csXG4gICAgICBwb3NzaWJsZSA9IC9bJjw+XCInYD1dLztcblxuZnVuY3Rpb24gZXNjYXBlQ2hhcihjaHIpIHtcbiAgcmV0dXJuIGVzY2FwZVtjaHJdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKG9iai8qICwgLi4uc291cmNlICovKSB7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQga2V5IGluIGFyZ3VtZW50c1tpXSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcmd1bWVudHNbaV0sIGtleSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSBhcmd1bWVudHNbaV1ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5leHBvcnQgbGV0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLy8gU291cmNlZCBmcm9tIGxvZGFzaFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL2xvZGFzaC9ibG9iL21hc3Rlci9MSUNFTlNFLnR4dFxuLyogZXNsaW50LWRpc2FibGUgZnVuYy1zdHlsZSAqL1xubGV0IGlzRnVuY3Rpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufTtcbi8vIGZhbGxiYWNrIGZvciBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChpc0Z1bmN0aW9uKC94LykpIHtcbiAgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgfTtcbn1cbmV4cG9ydCB7aXNGdW5jdGlvbn07XG4vKiBlc2xpbnQtZW5hYmxlIGZ1bmMtc3R5bGUgKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpID8gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScgOiBmYWxzZTtcbn07XG5cbi8vIE9sZGVyIElFIHZlcnNpb25zIGRvIG5vdCBkaXJlY3RseSBzdXBwb3J0IGluZGV4T2Ygc28gd2UgbXVzdCBpbXBsZW1lbnQgb3VyIG93biwgc2FkbHkuXG5leHBvcnQgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlRXhwcmVzc2lvbihzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZG9uJ3QgZXNjYXBlIFNhZmVTdHJpbmdzLCBzaW5jZSB0aGV5J3JlIGFscmVhZHkgc2FmZVxuICAgIGlmIChzdHJpbmcgJiYgc3RyaW5nLnRvSFRNTCkge1xuICAgICAgcmV0dXJuIHN0cmluZy50b0hUTUwoKTtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nICsgJyc7XG4gICAgfVxuXG4gICAgLy8gRm9yY2UgYSBzdHJpbmcgY29udmVyc2lvbiBhcyB0aGlzIHdpbGwgYmUgZG9uZSBieSB0aGUgYXBwZW5kIHJlZ2FyZGxlc3MgYW5kXG4gICAgLy8gdGhlIHJlZ2V4IHRlc3Qgd2lsbCBkbyB0aGlzIHRyYW5zcGFyZW50bHkgYmVoaW5kIHRoZSBzY2VuZXMsIGNhdXNpbmcgaXNzdWVzIGlmXG4gICAgLy8gYW4gb2JqZWN0J3MgdG8gc3RyaW5nIGhhcyBlc2NhcGVkIGNoYXJhY3RlcnMgaW4gaXQuXG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gIH1cblxuICBpZiAoIXBvc3NpYmxlLnRlc3Qoc3RyaW5nKSkgeyByZXR1cm4gc3RyaW5nOyB9XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShiYWRDaGFycywgZXNjYXBlQ2hhcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyYW1lKG9iamVjdCkge1xuICBsZXQgZnJhbWUgPSBleHRlbmQoe30sIG9iamVjdCk7XG4gIGZyYW1lLl9wYXJlbnQgPSBvYmplY3Q7XG4gIHJldHVybiBmcmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJsb2NrUGFyYW1zKHBhcmFtcywgaWRzKSB7XG4gIHBhcmFtcy5wYXRoID0gaWRzO1xuICByZXR1cm4gcGFyYW1zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kQ29udGV4dFBhdGgoY29udGV4dFBhdGgsIGlkKSB7XG4gIHJldHVybiAoY29udGV4dFBhdGggPyBjb250ZXh0UGF0aCArICcuJyA6ICcnKSArIGlkO1xufVxuIiwiLy8gVVNBR0U6XG4vLyB2YXIgaGFuZGxlYmFycyA9IHJlcXVpcmUoJ2hhbmRsZWJhcnMnKTtcbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuXG4vLyB2YXIgbG9jYWwgPSBoYW5kbGViYXJzLmNyZWF0ZSgpO1xuXG52YXIgaGFuZGxlYmFycyA9IHJlcXVpcmUoJy4uL2Rpc3QvY2pzL2hhbmRsZWJhcnMnKVsnZGVmYXVsdCddO1xuXG52YXIgcHJpbnRlciA9IHJlcXVpcmUoJy4uL2Rpc3QvY2pzL2hhbmRsZWJhcnMvY29tcGlsZXIvcHJpbnRlcicpO1xuaGFuZGxlYmFycy5QcmludFZpc2l0b3IgPSBwcmludGVyLlByaW50VmlzaXRvcjtcbmhhbmRsZWJhcnMucHJpbnQgPSBwcmludGVyLnByaW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhbmRsZWJhcnM7XG5cbi8vIFB1Ymxpc2ggYSBOb2RlLmpzIHJlcXVpcmUoKSBoYW5kbGVyIGZvciAuaGFuZGxlYmFycyBhbmQgLmhicyBmaWxlc1xuZnVuY3Rpb24gZXh0ZW5zaW9uKG1vZHVsZSwgZmlsZW5hbWUpIHtcbiAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgdmFyIHRlbXBsYXRlU3RyaW5nID0gZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLCAndXRmOCcpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGhhbmRsZWJhcnMuY29tcGlsZSh0ZW1wbGF0ZVN0cmluZyk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuaWYgKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJyAmJiByZXF1aXJlLmV4dGVuc2lvbnMpIHtcbiAgcmVxdWlyZS5leHRlbnNpb25zWycuaGFuZGxlYmFycyddID0gZXh0ZW5zaW9uO1xuICByZXF1aXJlLmV4dGVuc2lvbnNbJy5oYnMnXSA9IGV4dGVuc2lvbjtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRS50eHQgb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC9zb3VyY2UtbWFwLWNvbnN1bWVyJykuU291cmNlTWFwQ29uc3VtZXI7XG5leHBvcnRzLlNvdXJjZU5vZGUgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAvc291cmNlLW5vZGUnKS5Tb3VyY2VOb2RlO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIC8qKlxuICAgKiBBIGRhdGEgc3RydWN0dXJlIHdoaWNoIGlzIGEgY29tYmluYXRpb24gb2YgYW4gYXJyYXkgYW5kIGEgc2V0LiBBZGRpbmcgYSBuZXdcbiAgICogbWVtYmVyIGlzIE8oMSksIHRlc3RpbmcgZm9yIG1lbWJlcnNoaXAgaXMgTygxKSwgYW5kIGZpbmRpbmcgdGhlIGluZGV4IG9mIGFuXG4gICAqIGVsZW1lbnQgaXMgTygxKS4gUmVtb3ZpbmcgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGlzIG5vdCBzdXBwb3J0ZWQuIE9ubHlcbiAgICogc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBtZW1iZXJzaGlwLlxuICAgKi9cbiAgZnVuY3Rpb24gQXJyYXlTZXQoKSB7XG4gICAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgICB0aGlzLl9zZXQgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0aWMgbWV0aG9kIGZvciBjcmVhdGluZyBBcnJheVNldCBpbnN0YW5jZXMgZnJvbSBhbiBleGlzdGluZyBhcnJheS5cbiAgICovXG4gIEFycmF5U2V0LmZyb21BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X2Zyb21BcnJheShhQXJyYXksIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB2YXIgc2V0ID0gbmV3IEFycmF5U2V0KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2V0LmFkZChhQXJyYXlbaV0sIGFBbGxvd0R1cGxpY2F0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2V0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gaG93IG1hbnkgdW5pcXVlIGl0ZW1zIGFyZSBpbiB0aGlzIEFycmF5U2V0LiBJZiBkdXBsaWNhdGVzIGhhdmUgYmVlblxuICAgKiBhZGRlZCwgdGhhbiB0aG9zZSBkbyBub3QgY291bnQgdG93YXJkcyB0aGUgc2l6ZS5cbiAgICpcbiAgICogQHJldHVybnMgTnVtYmVyXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIEFycmF5U2V0X3NpemUoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3NldCkubGVuZ3RoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gQXJyYXlTZXRfYWRkKGFTdHIsIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB2YXIgaXNEdXBsaWNhdGUgPSB0aGlzLmhhcyhhU3RyKTtcbiAgICB2YXIgaWR4ID0gdGhpcy5fYXJyYXkubGVuZ3RoO1xuICAgIGlmICghaXNEdXBsaWNhdGUgfHwgYUFsbG93RHVwbGljYXRlcykge1xuICAgICAgdGhpcy5fYXJyYXkucHVzaChhU3RyKTtcbiAgICB9XG4gICAgaWYgKCFpc0R1cGxpY2F0ZSkge1xuICAgICAgdGhpcy5fc2V0W3V0aWwudG9TZXRTdHJpbmcoYVN0cildID0gaWR4O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSXMgdGhlIGdpdmVuIHN0cmluZyBhIG1lbWJlciBvZiB0aGlzIHNldD9cbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gQXJyYXlTZXRfaGFzKGFTdHIpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwudG9TZXRTdHJpbmcoYVN0cikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGF0IGlzIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gc3RyaW5nIGluIHRoZSBhcnJheT9cbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIEFycmF5U2V0X2luZGV4T2YoYVN0cikge1xuICAgIGlmICh0aGlzLmhhcyhhU3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFt1dGlsLnRvU2V0U3RyaW5nKGFTdHIpXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU3RyICsgJ1wiIGlzIG5vdCBpbiB0aGUgc2V0LicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGF0IGlzIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleD9cbiAgICpcbiAgICogQHBhcmFtIE51bWJlciBhSWR4XG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBBcnJheVNldF9hdChhSWR4KSB7XG4gICAgaWYgKGFJZHggPj0gMCAmJiBhSWR4IDwgdGhpcy5fYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXJyYXlbYUlkeF07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcgKyBhSWR4KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzZXQgKHdoaWNoIGhhcyB0aGUgcHJvcGVyIGluZGljZXNcbiAgICogaW5kaWNhdGVkIGJ5IGluZGV4T2YpLiBOb3RlIHRoYXQgdGhpcyBpcyBhIGNvcHkgb2YgdGhlIGludGVybmFsIGFycmF5IHVzZWRcbiAgICogZm9yIHN0b3JpbmcgdGhlIG1lbWJlcnMgc28gdGhhdCBubyBvbmUgY2FuIG1lc3Mgd2l0aCBpbnRlcm5hbCBzdGF0ZS5cbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKTtcbiAgfTtcblxuICBleHBvcnRzLkFycmF5U2V0ID0gQXJyYXlTZXQ7XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqXG4gKiBCYXNlZCBvbiB0aGUgQmFzZSA2NCBWTFEgaW1wbGVtZW50YXRpb24gaW4gQ2xvc3VyZSBDb21waWxlcjpcbiAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2xvc3VyZS1jb21waWxlci9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9jb20vZ29vZ2xlL2RlYnVnZ2luZy9zb3VyY2VtYXAvQmFzZTY0VkxRLmphdmFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBUaGUgQ2xvc3VyZSBDb21waWxlciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuICogICAgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAqIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcblxuICAvLyBBIHNpbmdsZSBiYXNlIDY0IGRpZ2l0IGNhbiBjb250YWluIDYgYml0cyBvZiBkYXRhLiBGb3IgdGhlIGJhc2UgNjQgdmFyaWFibGVcbiAgLy8gbGVuZ3RoIHF1YW50aXRpZXMgd2UgdXNlIGluIHRoZSBzb3VyY2UgbWFwIHNwZWMsIHRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ24sXG4gIC8vIHRoZSBuZXh0IGZvdXIgYml0cyBhcmUgdGhlIGFjdHVhbCB2YWx1ZSwgYW5kIHRoZSA2dGggYml0IGlzIHRoZVxuICAvLyBjb250aW51YXRpb24gYml0LiBUaGUgY29udGludWF0aW9uIGJpdCB0ZWxscyB1cyB3aGV0aGVyIHRoZXJlIGFyZSBtb3JlXG4gIC8vIGRpZ2l0cyBpbiB0aGlzIHZhbHVlIGZvbGxvd2luZyB0aGlzIGRpZ2l0LlxuICAvL1xuICAvLyAgIENvbnRpbnVhdGlvblxuICAvLyAgIHwgICAgU2lnblxuICAvLyAgIHwgICAgfFxuICAvLyAgIFYgICAgVlxuICAvLyAgIDEwMTAxMVxuXG4gIHZhciBWTFFfQkFTRV9TSElGVCA9IDU7XG5cbiAgLy8gYmluYXJ5OiAxMDAwMDBcbiAgdmFyIFZMUV9CQVNFID0gMSA8PCBWTFFfQkFTRV9TSElGVDtcblxuICAvLyBiaW5hcnk6IDAxMTExMVxuICB2YXIgVkxRX0JBU0VfTUFTSyA9IFZMUV9CQVNFIC0gMTtcblxuICAvLyBiaW5hcnk6IDEwMDAwMFxuICB2YXIgVkxRX0NPTlRJTlVBVElPTl9CSVQgPSBWTFFfQkFTRTtcblxuICAvKipcbiAgICogQ29udmVydHMgZnJvbSBhIHR3by1jb21wbGVtZW50IHZhbHVlIHRvIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gICAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICAgKiAgIDEgYmVjb21lcyAyICgxMCBiaW5hcnkpLCAtMSBiZWNvbWVzIDMgKDExIGJpbmFyeSlcbiAgICogICAyIGJlY29tZXMgNCAoMTAwIGJpbmFyeSksIC0yIGJlY29tZXMgNSAoMTAxIGJpbmFyeSlcbiAgICovXG4gIGZ1bmN0aW9uIHRvVkxRU2lnbmVkKGFWYWx1ZSkge1xuICAgIHJldHVybiBhVmFsdWUgPCAwXG4gICAgICA/ICgoLWFWYWx1ZSkgPDwgMSkgKyAxXG4gICAgICA6IChhVmFsdWUgPDwgMSkgKyAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRvIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgZnJvbSBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICAgKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAgICogICAyICgxMCBiaW5hcnkpIGJlY29tZXMgMSwgMyAoMTEgYmluYXJ5KSBiZWNvbWVzIC0xXG4gICAqICAgNCAoMTAwIGJpbmFyeSkgYmVjb21lcyAyLCA1ICgxMDEgYmluYXJ5KSBiZWNvbWVzIC0yXG4gICAqL1xuICBmdW5jdGlvbiBmcm9tVkxRU2lnbmVkKGFWYWx1ZSkge1xuICAgIHZhciBpc05lZ2F0aXZlID0gKGFWYWx1ZSAmIDEpID09PSAxO1xuICAgIHZhciBzaGlmdGVkID0gYVZhbHVlID4+IDE7XG4gICAgcmV0dXJuIGlzTmVnYXRpdmVcbiAgICAgID8gLXNoaWZ0ZWRcbiAgICAgIDogc2hpZnRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBiYXNlIDY0IFZMUSBlbmNvZGVkIHZhbHVlLlxuICAgKi9cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZW5jb2RlKGFWYWx1ZSkge1xuICAgIHZhciBlbmNvZGVkID0gXCJcIjtcbiAgICB2YXIgZGlnaXQ7XG5cbiAgICB2YXIgdmxxID0gdG9WTFFTaWduZWQoYVZhbHVlKTtcblxuICAgIGRvIHtcbiAgICAgIGRpZ2l0ID0gdmxxICYgVkxRX0JBU0VfTUFTSztcbiAgICAgIHZscSA+Pj49IFZMUV9CQVNFX1NISUZUO1xuICAgICAgaWYgKHZscSA+IDApIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHN0aWxsIG1vcmUgZGlnaXRzIGluIHRoaXMgdmFsdWUsIHNvIHdlIG11c3QgbWFrZSBzdXJlIHRoZVxuICAgICAgICAvLyBjb250aW51YXRpb24gYml0IGlzIG1hcmtlZC5cbiAgICAgICAgZGlnaXQgfD0gVkxRX0NPTlRJTlVBVElPTl9CSVQ7XG4gICAgICB9XG4gICAgICBlbmNvZGVkICs9IGJhc2U2NC5lbmNvZGUoZGlnaXQpO1xuICAgIH0gd2hpbGUgKHZscSA+IDApO1xuXG4gICAgcmV0dXJuIGVuY29kZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY29kZXMgdGhlIG5leHQgYmFzZSA2NCBWTFEgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXR1cm5zIHRoZVxuICAgKiB2YWx1ZSBhbmQgdGhlIHJlc3Qgb2YgdGhlIHN0cmluZyB2aWEgdGhlIG91dCBwYXJhbWV0ZXIuXG4gICAqL1xuICBleHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9kZWNvZGUoYVN0ciwgYUluZGV4LCBhT3V0UGFyYW0pIHtcbiAgICB2YXIgc3RyTGVuID0gYVN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgdmFyIHNoaWZ0ID0gMDtcbiAgICB2YXIgY29udGludWF0aW9uLCBkaWdpdDtcblxuICAgIGRvIHtcbiAgICAgIGlmIChhSW5kZXggPj0gc3RyTGVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG1vcmUgZGlnaXRzIGluIGJhc2UgNjQgVkxRIHZhbHVlLlwiKTtcbiAgICAgIH1cblxuICAgICAgZGlnaXQgPSBiYXNlNjQuZGVjb2RlKGFTdHIuY2hhckNvZGVBdChhSW5kZXgrKykpO1xuICAgICAgaWYgKGRpZ2l0ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBkaWdpdDogXCIgKyBhU3RyLmNoYXJBdChhSW5kZXggLSAxKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVhdGlvbiA9ICEhKGRpZ2l0ICYgVkxRX0NPTlRJTlVBVElPTl9CSVQpO1xuICAgICAgZGlnaXQgJj0gVkxRX0JBU0VfTUFTSztcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCArIChkaWdpdCA8PCBzaGlmdCk7XG4gICAgICBzaGlmdCArPSBWTFFfQkFTRV9TSElGVDtcbiAgICB9IHdoaWxlIChjb250aW51YXRpb24pO1xuXG4gICAgYU91dFBhcmFtLnZhbHVlID0gZnJvbVZMUVNpZ25lZChyZXN1bHQpO1xuICAgIGFPdXRQYXJhbS5yZXN0ID0gYUluZGV4O1xuICB9O1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIGludFRvQ2hhck1hcCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJy5zcGxpdCgnJyk7XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSBvZiAwIHRvIDYzIHRvIGEgc2luZ2xlIGJhc2UgNjQgZGlnaXQuXG4gICAqL1xuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICBpZiAoMCA8PSBudW1iZXIgJiYgbnVtYmVyIDwgaW50VG9DaGFyTWFwLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGludFRvQ2hhck1hcFtudW1iZXJdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcIiArIGFOdW1iZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBjaGFyYWN0ZXIgY29kZSBkaWdpdCB0byBhbiBpbnRlZ2VyLiBSZXR1cm5zIC0xIG9uXG4gICAqIGZhaWx1cmUuXG4gICAqL1xuICBleHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICAgIHZhciBiaWdBID0gNjU7ICAgICAvLyAnQSdcbiAgICB2YXIgYmlnWiA9IDkwOyAgICAgLy8gJ1onXG5cbiAgICB2YXIgbGl0dGxlQSA9IDk3OyAgLy8gJ2EnXG4gICAgdmFyIGxpdHRsZVogPSAxMjI7IC8vICd6J1xuXG4gICAgdmFyIHplcm8gPSA0ODsgICAgIC8vICcwJ1xuICAgIHZhciBuaW5lID0gNTc7ICAgICAvLyAnOSdcblxuICAgIHZhciBwbHVzID0gNDM7ICAgICAvLyAnKydcbiAgICB2YXIgc2xhc2ggPSA0NzsgICAgLy8gJy8nXG5cbiAgICB2YXIgbGl0dGxlT2Zmc2V0ID0gMjY7XG4gICAgdmFyIG51bWJlck9mZnNldCA9IDUyO1xuXG4gICAgLy8gMCAtIDI1OiBBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlxuICAgIGlmIChiaWdBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGJpZ1opIHtcbiAgICAgIHJldHVybiAoY2hhckNvZGUgLSBiaWdBKTtcbiAgICB9XG5cbiAgICAvLyAyNiAtIDUxOiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxuICAgIGlmIChsaXR0bGVBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGxpdHRsZVopIHtcbiAgICAgIHJldHVybiAoY2hhckNvZGUgLSBsaXR0bGVBICsgbGl0dGxlT2Zmc2V0KTtcbiAgICB9XG5cbiAgICAvLyA1MiAtIDYxOiAwMTIzNDU2Nzg5XG4gICAgaWYgKHplcm8gPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gbmluZSkge1xuICAgICAgcmV0dXJuIChjaGFyQ29kZSAtIHplcm8gKyBudW1iZXJPZmZzZXQpO1xuICAgIH1cblxuICAgIC8vIDYyOiArXG4gICAgaWYgKGNoYXJDb2RlID09IHBsdXMpIHtcbiAgICAgIHJldHVybiA2MjtcbiAgICB9XG5cbiAgICAvLyA2MzogL1xuICAgIGlmIChjaGFyQ29kZSA9PSBzbGFzaCkge1xuICAgICAgcmV0dXJuIDYzO1xuICAgIH1cblxuICAgIC8vIEludmFsaWQgYmFzZTY0IGRpZ2l0LlxuICAgIHJldHVybiAtMTtcbiAgfTtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuICBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuICAvKipcbiAgICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gICAqXG4gICAqIEBwYXJhbSBhTG93IEluZGljZXMgaGVyZSBhbmQgbG93ZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAgICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gICAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IGJlaW5nIHNlYXJjaGVkIGZvci5cbiAgICogQHBhcmFtIGFIYXlzdGFjayBUaGUgbm9uLWVtcHR5IGFycmF5IGJlaW5nIHNlYXJjaGVkLlxuICAgKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICAgKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gICAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICAgKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICAgKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gICAqL1xuICBmdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiB0ZXJtaW5hdGVzIHdoZW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcbiAgICAvL1xuICAgIC8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgLy9cbiAgICAvLyAgIDIuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYnV0IHdlIGNhbiByZXR1cm4gdGhlIGluZGV4IG9mXG4gICAgLy8gICAgICB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQuXG4gICAgLy9cbiAgICAvLyAgIDMuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYW5kIHRoZXJlIGlzIG5vIG5leHQtY2xvc2VzdFxuICAgIC8vICAgICAgZWxlbWVudCB0aGFuIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IsIHNvIHdlIHJldHVybiAtMS5cbiAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigoYUhpZ2ggLSBhTG93KSAvIDIpICsgYUxvdztcbiAgICB2YXIgY21wID0gYUNvbXBhcmUoYU5lZWRsZSwgYUhheXN0YWNrW21pZF0sIHRydWUpO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIC8vIEZvdW5kIHRoZSBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIC8vIE91ciBuZWVkbGUgaXMgZ3JlYXRlciB0aGFuIGFIYXlzdGFja1ttaWRdLlxuICAgICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChtaWQsIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBleGFjdCBuZWVkbGUgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluIHRoaXMgaGF5c3RhY2suIERldGVybWluZSBpZlxuICAgICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICAgIHJldHVybiBhSGlnaCA8IGFIYXlzdGFjay5sZW5ndGggPyBhSGlnaCA6IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBPdXIgbmVlZGxlIGlzIGxlc3MgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICAgIGlmIChtaWQgLSBhTG93ID4gMSkge1xuICAgICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICAgIH1cblxuICAgICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICAgIHJldHVybiBtaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYUxvdyA8IDAgPyAtMSA6IGFMb3c7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICAgKiB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgZWxlbWVudCBpZiB0aGVyZSBpcyBubyBleGFjdCBoaXQuIFRoaXMgaXMgYmVjYXVzZVxuICAgKiBtYXBwaW5ncyBiZXR3ZWVuIG9yaWdpbmFsIGFuZCBnZW5lcmF0ZWQgbGluZS9jb2wgcGFpcnMgYXJlIHNpbmdsZSBwb2ludHMsXG4gICAqIGFuZCB0aGVyZSBpcyBhbiBpbXBsaWNpdCByZWdpb24gYmV0d2VlbiBlYWNoIG9mIHRoZW0sIHNvIGEgbWlzcyBqdXN0IG1lYW5zXG4gICAqIHRoYXQgeW91IGFyZW4ndCBvbiB0aGUgdmVyeSBzdGFydCBvZiBhIHJlZ2lvbi5cbiAgICpcbiAgICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgeW91IGFyZSBsb29raW5nIGZvci5cbiAgICogQHBhcmFtIGFIYXlzdGFjayBUaGUgYXJyYXkgdGhhdCBpcyBiZWluZyBzZWFyY2hlZC5cbiAgICogQHBhcmFtIGFDb21wYXJlIEEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhlIG5lZWRsZSBhbmQgYW4gZWxlbWVudCBpbiB0aGVcbiAgICogICAgIGFycmF5IGFuZCByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBuZWVkbGUgaXMgbGVzc1xuICAgKiAgICAgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCwgcmVzcGVjdGl2ZWx5LlxuICAgKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gICAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICAgKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICAgKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gICAqICAgICBEZWZhdWx0cyB0byAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAgICovXG4gIGV4cG9ydHMuc2VhcmNoID0gZnVuY3Rpb24gc2VhcmNoKGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gICAgaWYgKGFIYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSByZWN1cnNpdmVTZWFyY2goLTEsIGFIYXlzdGFjay5sZW5ndGgsIGFOZWVkbGUsIGFIYXlzdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbXBhcmUsIGFCaWFzIHx8IGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyBXZSBoYXZlIGZvdW5kIGVpdGhlciB0aGUgZXhhY3QgZWxlbWVudCwgb3IgdGhlIG5leHQtY2xvc2VzdCBlbGVtZW50IHRoYW5cbiAgICAvLyB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLiBIb3dldmVyLCB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBzdWNoXG4gICAgLy8gZWxlbWVudC4gTWFrZSBzdXJlIHdlIGFsd2F5cyByZXR1cm4gdGhlIHNtYWxsZXN0IG9mIHRoZXNlLlxuICAgIHdoaWxlIChpbmRleCAtIDEgPj0gMCkge1xuICAgICAgaWYgKGFDb21wYXJlKGFIYXlzdGFja1tpbmRleF0sIGFIYXlzdGFja1tpbmRleCAtIDFdLCB0cnVlKSAhPT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC0taW5kZXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9O1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgbWFwcGluZ0IgaXMgYWZ0ZXIgbWFwcGluZ0Egd2l0aCByZXNwZWN0IHRvIGdlbmVyYXRlZFxuICAgKiBwb3NpdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gICAgLy8gT3B0aW1pemVkIGZvciBtb3N0IGNvbW1vbiBjYXNlXG4gICAgdmFyIGxpbmVBID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZTtcbiAgICB2YXIgbGluZUIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICAgIHZhciBjb2x1bW5BID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uO1xuICAgIHZhciBjb2x1bW5CID0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICAgIHJldHVybiBsaW5lQiA+IGxpbmVBIHx8IGxpbmVCID09IGxpbmVBICYmIGNvbHVtbkIgPj0gY29sdW1uQSB8fFxuICAgICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikgPD0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGRhdGEgc3RydWN0dXJlIHRvIHByb3ZpZGUgYSBzb3J0ZWQgdmlldyBvZiBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiBhXG4gICAqIHBlcmZvcm1hbmNlIGNvbnNjaW91cyBtYW5uZXIuIEl0IHRyYWRlcyBhIG5lZ2xpYmFibGUgb3ZlcmhlYWQgaW4gZ2VuZXJhbFxuICAgKiBjYXNlIGZvciBhIGxhcmdlIHNwZWVkdXAgaW4gY2FzZSBvZiBtYXBwaW5ncyBiZWluZyBhZGRlZCBpbiBvcmRlci5cbiAgICovXG4gIGZ1bmN0aW9uIE1hcHBpbmdMaXN0KCkge1xuICAgIHRoaXMuX2FycmF5ID0gW107XG4gICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgICAvLyBTZXJ2ZXMgYXMgaW5maW11bVxuICAgIHRoaXMuX2xhc3QgPSB7Z2VuZXJhdGVkTGluZTogLTEsIGdlbmVyYXRlZENvbHVtbjogMH07XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGludGVybmFsIGl0ZW1zLiBUaGlzIG1ldGhvZCB0YWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgdGhhdFxuICAgKiBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIHRha2VzLlxuICAgKlxuICAgKiBOT1RFOiBUaGUgb3JkZXIgb2YgdGhlIG1hcHBpbmdzIGlzIE5PVCBndWFyYW50ZWVkLlxuICAgKi9cbiAgTWFwcGluZ0xpc3QucHJvdG90eXBlLnVuc29ydGVkRm9yRWFjaCA9XG4gICAgZnVuY3Rpb24gTWFwcGluZ0xpc3RfZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKSB7XG4gICAgICB0aGlzLl9hcnJheS5mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgZ2l2ZW4gc291cmNlIG1hcHBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSBPYmplY3QgYU1hcHBpbmdcbiAgICovXG4gIE1hcHBpbmdMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF9hZGQoYU1hcHBpbmcpIHtcbiAgICB2YXIgbWFwcGluZztcbiAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb25BZnRlcih0aGlzLl9sYXN0LCBhTWFwcGluZykpIHtcbiAgICAgIHRoaXMuX2xhc3QgPSBhTWFwcGluZztcbiAgICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmxhdCwgc29ydGVkIGFycmF5IG9mIG1hcHBpbmdzLiBUaGUgbWFwcGluZ3MgYXJlIHNvcnRlZCBieVxuICAgKiBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gICAqXG4gICAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHJldHVybnMgaW50ZXJuYWwgZGF0YSB3aXRob3V0IGNvcHlpbmcsIGZvclxuICAgKiBwZXJmb3JtYW5jZS4gVGhlIHJldHVybiB2YWx1ZSBtdXN0IE5PVCBiZSBtdXRhdGVkLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXNcbiAgICogYW4gaW1tdXRhYmxlIGJvcnJvdy4gSWYgeW91IHdhbnQgdG8gdGFrZSBvd25lcnNoaXAsIHlvdSBtdXN0IG1ha2UgeW91ciBvd25cbiAgICogY29weS5cbiAgICovXG4gIE1hcHBpbmdMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfdG9BcnJheSgpIHtcbiAgICBpZiAoIXRoaXMuX3NvcnRlZCkge1xuICAgICAgdGhpcy5fYXJyYXkuc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKTtcbiAgICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hcnJheTtcbiAgfTtcblxuICBleHBvcnRzLk1hcHBpbmdMaXN0ID0gTWFwcGluZ0xpc3Q7XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICAvLyBJdCB0dXJucyBvdXQgdGhhdCBzb21lIChtb3N0PykgSmF2YVNjcmlwdCBlbmdpbmVzIGRvbid0IHNlbGYtaG9zdFxuICAvLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgLiBUaGlzIG1ha2VzIHNlbnNlIGJlY2F1c2UgQysrIHdpbGwgbGlrZWx5IHJlbWFpblxuICAvLyBmYXN0ZXIgdGhhbiBKUyB3aGVuIGRvaW5nIHJhdyBDUFUtaW50ZW5zaXZlIHNvcnRpbmcuIEhvd2V2ZXIsIHdoZW4gdXNpbmcgYVxuICAvLyBjdXN0b20gY29tcGFyYXRvciBmdW5jdGlvbiwgY2FsbGluZyBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIHRoZSBWTSdzIEMrKyBhbmRcbiAgLy8gSklUJ2QgSlMgaXMgcmF0aGVyIHNsb3cgKmFuZCogbG9zZXMgSklUIHR5cGUgaW5mb3JtYXRpb24sIHJlc3VsdGluZyBpblxuICAvLyB3b3JzZSBnZW5lcmF0ZWQgY29kZSBmb3IgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhbiB3b3VsZCBiZSBvcHRpbWFsLiBJblxuICAvLyBmYWN0LCB3aGVuIHNvcnRpbmcgd2l0aCBhIGNvbXBhcmF0b3IsIHRoZXNlIGNvc3RzIG91dHdlaWdoIHRoZSBiZW5lZml0cyBvZlxuICAvLyBzb3J0aW5nIGluIEMrKy4gQnkgdXNpbmcgb3VyIG93biBKUy1pbXBsZW1lbnRlZCBRdWljayBTb3J0IChiZWxvdyksIHdlIGdldFxuICAvLyBhIH4zNTAwbXMgbWVhbiBzcGVlZC11cCBpbiBgYmVuY2gvYmVuY2guaHRtbGAuXG5cbiAgLyoqXG4gICAqIFN3YXAgdGhlIGVsZW1lbnRzIGluZGV4ZWQgYnkgYHhgIGFuZCBgeWAgaW4gdGhlIGFycmF5IGBhcnlgLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAgICogICAgICAgIFRoZSBhcnJheS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIGl0ZW0uXG4gICAqL1xuICBmdW5jdGlvbiBzd2FwKGFyeSwgeCwgeSkge1xuICAgIHZhciB0ZW1wID0gYXJ5W3hdO1xuICAgIGFyeVt4XSA9IGFyeVt5XTtcbiAgICBhcnlbeV0gPSB0ZW1wO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciB3aXRoaW4gdGhlIHJhbmdlIGBsb3cgLi4gaGlnaGAgaW5jbHVzaXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbG93XG4gICAqICAgICAgICBUaGUgbG93ZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGlnaFxuICAgKiAgICAgICAgVGhlIHVwcGVyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJhbmRvbUludEluUmFuZ2UobG93LCBoaWdoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobG93ICsgKE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdykpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgUXVpY2sgU29ydCBhbGdvcml0aG0uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICAgKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICAgKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gcFxuICAgKiAgICAgICAgU3RhcnQgaW5kZXggb2YgdGhlIGFycmF5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSByXG4gICAqICAgICAgICBFbmQgaW5kZXggb2YgdGhlIGFycmF5XG4gICAqL1xuICBmdW5jdGlvbiBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHIpIHtcbiAgICAvLyBJZiBvdXIgbG93ZXIgYm91bmQgaXMgbGVzcyB0aGFuIG91ciB1cHBlciBib3VuZCwgd2UgKDEpIHBhcnRpdGlvbiB0aGVcbiAgICAvLyBhcnJheSBpbnRvIHR3byBwaWVjZXMgYW5kICgyKSByZWN1cnNlIG9uIGVhY2ggaGFsZi4gSWYgaXQgaXMgbm90LCB0aGlzIGlzXG4gICAgLy8gdGhlIGVtcHR5IGFycmF5IGFuZCBvdXIgYmFzZSBjYXNlLlxuXG4gICAgaWYgKHAgPCByKSB7XG4gICAgICAvLyAoMSkgUGFydGl0aW9uaW5nLlxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBwYXJ0aXRpb25pbmcgY2hvb3NlcyBhIHBpdm90IGJldHdlZW4gYHBgIGFuZCBgcmAgYW5kIG1vdmVzIGFsbFxuICAgICAgLy8gZWxlbWVudHMgdGhhdCBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdCB0byB0aGUgYmVmb3JlIGl0LCBhbmRcbiAgICAgIC8vIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBhcmUgZ3JlYXRlciB0aGFuIGl0IGFmdGVyIGl0LiBUaGUgZWZmZWN0IGlzIHRoYXRcbiAgICAgIC8vIG9uY2UgcGFydGl0aW9uIGlzIGRvbmUsIHRoZSBwaXZvdCBpcyBpbiB0aGUgZXhhY3QgcGxhY2UgaXQgd2lsbCBiZSB3aGVuXG4gICAgICAvLyB0aGUgYXJyYXkgaXMgcHV0IGluIHNvcnRlZCBvcmRlciwgYW5kIGl0IHdpbGwgbm90IG5lZWQgdG8gYmUgbW92ZWRcbiAgICAgIC8vIGFnYWluLiBUaGlzIHJ1bnMgaW4gTyhuKSB0aW1lLlxuXG4gICAgICAvLyBBbHdheXMgY2hvb3NlIGEgcmFuZG9tIHBpdm90IHNvIHRoYXQgYW4gaW5wdXQgYXJyYXkgd2hpY2ggaXMgcmV2ZXJzZVxuICAgICAgLy8gc29ydGVkIGRvZXMgbm90IGNhdXNlIE8obl4yKSBydW5uaW5nIHRpbWUuXG4gICAgICB2YXIgcGl2b3RJbmRleCA9IHJhbmRvbUludEluUmFuZ2UocCwgcik7XG4gICAgICB2YXIgaSA9IHAgLSAxO1xuXG4gICAgICBzd2FwKGFyeSwgcGl2b3RJbmRleCwgcik7XG4gICAgICB2YXIgcGl2b3QgPSBhcnlbcl07XG5cbiAgICAgIC8vIEltbWVkaWF0ZWx5IGFmdGVyIGBqYCBpcyBpbmNyZW1lbnRlZCBpbiB0aGlzIGxvb3AsIHRoZSBmb2xsb3dpbmcgaG9sZFxuICAgICAgLy8gdHJ1ZTpcbiAgICAgIC8vXG4gICAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W3AgLi4gaV1gIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QuXG4gICAgICAvL1xuICAgICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtpKzEgLi4gai0xXWAgaXMgZ3JlYXRlciB0aGFuIHRoZSBwaXZvdC5cbiAgICAgIGZvciAodmFyIGogPSBwOyBqIDwgcjsgaisrKSB7XG4gICAgICAgIGlmIChjb21wYXJhdG9yKGFyeVtqXSwgcGl2b3QpIDw9IDApIHtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgc3dhcChhcnksIGksIGopO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN3YXAoYXJ5LCBpICsgMSwgaik7XG4gICAgICB2YXIgcSA9IGkgKyAxO1xuXG4gICAgICAvLyAoMikgUmVjdXJzZSBvbiBlYWNoIGhhbGYuXG5cbiAgICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcSAtIDEpO1xuICAgICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBxICsgMSwgcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNvcnQgdGhlIGdpdmVuIGFycmF5IGluLXBsYWNlIHdpdGggdGhlIGdpdmVuIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICAgKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICAgKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICAgKi9cbiAgZXhwb3J0cy5xdWlja1NvcnQgPSBmdW5jdGlvbiAoYXJ5LCBjb21wYXJhdG9yKSB7XG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCAwLCBhcnkubGVuZ3RoIC0gMSk7XG4gIH07XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuICB2YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG4gIHZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG4gIHZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbiAgdmFyIHF1aWNrU29ydCA9IHJlcXVpcmUoJy4vcXVpY2stc29ydCcpLnF1aWNrU29ydDtcblxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gICAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gICAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlTWFwLnNlY3Rpb25zICE9IG51bGxcbiAgICAgID8gbmV3IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXApXG4gICAgICA6IG5ldyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcCk7XG4gIH1cblxuICBTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID0gZnVuY3Rpb24oYVNvdXJjZU1hcCkge1xuICAgIHJldHVybiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuICAvLyBgX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kIGBfX29yaWdpbmFsTWFwcGluZ3NgIGFyZSBhcnJheXMgdGhhdCBob2xkIHRoZVxuICAvLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuICAvLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBnZXR0ZXJzIHJlc3BlY3RpdmVseSwgYW5kIHdlIG9ubHkgcGFyc2UgdGhlIG1hcHBpbmdzXG4gIC8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuICAvLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbiAgLy8gdGhlbSBpcyBleHBlbnNpdmUsIHNvIHdlIG9ubHkgd2FudCB0byBkbyBpdCBpZiB3ZSBtdXN0LlxuICAvL1xuICAvLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuICAvL1xuICAvLyAgICAge1xuICAvLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBnZW5lcmF0ZWRDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuICAvLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuICAvLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2ZcbiAgLy8gICAgICAgICAgICAgY29kZS5cbiAgLy8gICAgIH1cbiAgLy9cbiAgLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuICAvLyBgbnVsbGAuXG4gIC8vXG4gIC8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4gIC8vXG4gIC8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19nZW5lcmF0ZWRNYXBwaW5ncycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgfVxuICB9KTtcblxuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19vcmlnaW5hbE1hcHBpbmdzID0gbnVsbDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19vcmlnaW5hbE1hcHBpbmdzJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncykge1xuICAgICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgfVxuICB9KTtcblxuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgaW5kZXgpIHtcbiAgICAgIHZhciBjID0gYVN0ci5jaGFyQXQoaW5kZXgpO1xuICAgICAgcmV0dXJuIGMgPT09IFwiO1wiIHx8IGMgPT09IFwiLFwiO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAgICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gICAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgX3BhcnNlTWFwcGluZ3NcIik7XG4gICAgfTtcblxuICBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVIgPSAxO1xuICBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUiA9IDI7XG5cbiAgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuICBTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgb3ZlciBlYWNoIG1hcHBpbmcgYmV0d2VlbiBhbiBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4gYW5kIGFcbiAgICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAgICpcbiAgICogQHBhcmFtIEZ1bmN0aW9uIGFDYWxsYmFja1xuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICAgKiBAcGFyYW0gT2JqZWN0IGFDb250ZXh0XG4gICAqICAgICAgICBPcHRpb25hbC4gSWYgc3BlY2lmaWVkLCB0aGlzIG9iamVjdCB3aWxsIGJlIHRoZSB2YWx1ZSBvZiBgdGhpc2AgZXZlcnlcbiAgICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gICAqIEBwYXJhbSBhT3JkZXJcbiAgICogICAgICAgIEVpdGhlciBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYCBvclxuICAgKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAgICogICAgICAgIGl0ZXJhdGUgb3ZlciB0aGUgbWFwcGluZ3Mgc29ydGVkIGJ5IHRoZSBnZW5lcmF0ZWQgZmlsZSdzIGxpbmUvY29sdW1uXG4gICAqICAgICAgICBvcmRlciBvciB0aGUgb3JpZ2luYWwncyBzb3VyY2UvbGluZS9jb2x1bW4gb3JkZXIsIHJlc3BlY3RpdmVseS4gRGVmYXVsdHMgdG9cbiAgICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmVhY2hNYXBwaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gYUNvbnRleHQgfHwgbnVsbDtcbiAgICAgIHZhciBvcmRlciA9IGFPcmRlciB8fCBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI7XG5cbiAgICAgIHZhciBtYXBwaW5ncztcbiAgICAgIHN3aXRjaCAob3JkZXIpIHtcbiAgICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSOlxuICAgICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVI6XG4gICAgICAgIG1hcHBpbmdzID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5zb3VyY2VSb290O1xuICAgICAgbWFwcGluZ3MubWFwKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9zb3VyY2VzLmF0KG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmIHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICBuYW1lOiBtYXBwaW5nLm5hbWUgPT09IG51bGwgPyBudWxsIDogdGhpcy5fbmFtZXMuYXQobWFwcGluZy5uYW1lKVxuICAgICAgICB9O1xuICAgICAgfSwgdGhpcykuZm9yRWFjaChhQ2FsbGJhY2ssIGNvbnRleHQpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gICAqIGxpbmUsIGFuZCBjb2x1bW4gcHJvdmlkZWQuIElmIG5vIGNvbHVtbiBpcyBwcm92aWRlZCwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAgICogY29ycmVzcG9uZGluZyB0byBhIGVpdGhlciB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciBvciB0aGUgbmV4dFxuICAgKiBjbG9zZXN0IGxpbmUgdGhhdCBoYXMgYW55IG1hcHBpbmdzLiBPdGhlcndpc2UsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gICAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxpbmUgYW5kIGVpdGhlciB0aGUgY29sdW1uIHdlIGFyZSBzZWFyY2hpbmcgZm9yXG4gICAqIG9yIHRoZSBuZXh0IGNsb3Nlc3QgY29sdW1uIHRoYXQgaGFzIGFueSBvZmZzZXRzLlxuICAgKlxuICAgKiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBjb2x1bW46IE9wdGlvbmFsLiB0aGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKlxuICAgKiBhbmQgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpcyByZXR1cm5lZCwgZWFjaCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IoYUFyZ3MpIHtcbiAgICAgIHZhciBsaW5lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyk7XG5cbiAgICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gZXhhY3QgbWF0Y2gsIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZ1xuICAgICAgLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgbWFwcGluZyBsZXNzIHRoYW4gdGhlIG5lZWRsZS4gQnlcbiAgICAgIC8vIHNldHRpbmcgbmVlZGxlLm9yaWdpbmFsQ29sdW1uIHRvIDAsIHdlIHRodXMgZmluZCB0aGUgbGFzdCBtYXBwaW5nIGZvclxuICAgICAgLy8gdGhlIGdpdmVuIGxpbmUsIHByb3ZpZGVkIHN1Y2ggYSBtYXBwaW5nIGV4aXN0cy5cbiAgICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICAgIHNvdXJjZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSxcbiAgICAgICAgb3JpZ2luYWxMaW5lOiBsaW5lLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nLCAwKVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIG5lZWRsZS5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgbmVlZGxlLnNvdXJjZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKG5lZWRsZS5zb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG5lZWRsZS5zb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobmVlZGxlLnNvdXJjZSk7XG5cbiAgICAgIHZhciBtYXBwaW5ncyA9IFtdO1xuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgICBpZiAoYUFyZ3MuY29sdW1uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgb3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG5cbiAgICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2UgZm91bmQuIFNpbmNlXG4gICAgICAgICAgLy8gbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAgIC8vIHRoZSBsaW5lIHdlIGZvdW5kLlxuICAgICAgICAgIHdoaWxlIChtYXBwaW5nICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBvcmlnaW5hbExpbmUpIHtcbiAgICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIHdlcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgICAvLyBTaW5jZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgICAgLy8gdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiZcbiAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IGxpbmUgJiZcbiAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9PSBvcmlnaW5hbENvbHVtbikge1xuICAgICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXBwaW5ncztcbiAgICB9O1xuXG4gIGV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuICAvKipcbiAgICogQSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaCB3ZSBjYW5cbiAgICogcXVlcnkgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBmaWxlIHBvc2l0aW9ucyBieSBnaXZpbmcgaXQgYSBmaWxlXG4gICAqIHBvc2l0aW9uIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKlxuICAgKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgdGhlIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3JcbiAgICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICAgKiBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAgICpcbiAgICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gICAqICAgLSBzb3VyY2VzOiBBbiBhcnJheSBvZiBVUkxzIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gICAqICAgLSBuYW1lczogQW4gYXJyYXkgb2YgaWRlbnRpZmllcnMgd2hpY2ggY2FuIGJlIHJlZmVycmVuY2VkIGJ5IGluZGl2aWR1YWwgbWFwcGluZ3MuXG4gICAqICAgLSBzb3VyY2VSb290OiBPcHRpb25hbC4gVGhlIFVSTCByb290IGZyb20gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIHJlbGF0aXZlLlxuICAgKiAgIC0gc291cmNlc0NvbnRlbnQ6IE9wdGlvbmFsLiBBbiBhcnJheSBvZiBjb250ZW50cyBvZiB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICAgKiAgIC0gbWFwcGluZ3M6IEEgc3RyaW5nIG9mIGJhc2U2NCBWTFFzIHdoaWNoIGNvbnRhaW4gdGhlIGFjdHVhbCBtYXBwaW5ncy5cbiAgICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICpcbiAgICogSGVyZSBpcyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXTpcbiAgICpcbiAgICogICAgIHtcbiAgICogICAgICAgdmVyc2lvbiA6IDMsXG4gICAqICAgICAgIGZpbGU6IFwib3V0LmpzXCIsXG4gICAqICAgICAgIHNvdXJjZVJvb3QgOiBcIlwiLFxuICAgKiAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gICAqICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICAgKiAgICAgICBtYXBwaW5nczogXCJBQSxBQjs7QUJDREU7XCJcbiAgICogICAgIH1cbiAgICpcbiAgICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQ/cGxpPTEjXG4gICAqL1xuICBmdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICAgIH1cblxuICAgIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICAgIHZhciBzb3VyY2VzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlcycpO1xuICAgIC8vIFNhc3MgMy4zIGxlYXZlcyBvdXQgdGhlICduYW1lcycgYXJyYXksIHNvIHdlIGRldmlhdGUgZnJvbSB0aGUgc3BlYyAod2hpY2hcbiAgICAvLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxuICAgIHZhciBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ25hbWVzJywgW10pO1xuICAgIHZhciBzb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICAgIHZhciBzb3VyY2VzQ29udGVudCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXNDb250ZW50JywgbnVsbCk7XG4gICAgdmFyIG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbWFwcGluZ3MnKTtcbiAgICB2YXIgZmlsZSA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ2ZpbGUnLCBudWxsKTtcblxuICAgIC8vIE9uY2UgYWdhaW4sIFNhc3MgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhbmQgc3VwcGxpZXMgdGhlIHZlcnNpb24gYXMgYVxuICAgIC8vIHN0cmluZyByYXRoZXIgdGhhbiBhIG51bWJlciwgc28gd2UgdXNlIGxvb3NlIGVxdWFsaXR5IGNoZWNraW5nIGhlcmUuXG4gICAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gICAgfVxuXG4gICAgLy8gU29tZSBzb3VyY2UgbWFwcyBwcm9kdWNlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBsaWtlIFwiLi9mb28uanNcIiBpbnN0ZWFkIG9mXG4gICAgLy8gXCJmb28uanNcIi4gIE5vcm1hbGl6ZSB0aGVzZSBmaXJzdCBzbyB0aGF0IGZ1dHVyZSBjb21wYXJpc29ucyB3aWxsIHN1Y2NlZWQuXG4gICAgLy8gU2VlIGJ1Z3ppbC5sYS8xMDkwNzY4LlxuICAgIHNvdXJjZXMgPSBzb3VyY2VzLm1hcCh1dGlsLm5vcm1hbGl6ZSk7XG5cbiAgICAvLyBQYXNzIGB0cnVlYCBiZWxvdyB0byBhbGxvdyBkdXBsaWNhdGUgbmFtZXMgYW5kIHNvdXJjZXMuIFdoaWxlIHNvdXJjZSBtYXBzXG4gICAgLy8gYXJlIGludGVuZGVkIHRvIGJlIGNvbXByZXNzZWQgYW5kIGRlZHVwbGljYXRlZCwgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXJcbiAgICAvLyBzb21ldGltZXMgZ2VuZXJhdGVzIHNvdXJjZSBtYXBzIHdpdGggZHVwbGljYXRlcyBpbiB0aGVtLiBTZWUgR2l0aHViIGlzc3VlXG4gICAgLy8gIzcyIGFuZCBidWd6aWwubGEvODg5NDkyLlxuICAgIHRoaXMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KG5hbWVzLCB0cnVlKTtcbiAgICB0aGlzLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KHNvdXJjZXMsIHRydWUpO1xuXG4gICAgdGhpcy5zb3VyY2VSb290ID0gc291cmNlUm9vdDtcbiAgICB0aGlzLnNvdXJjZXNDb250ZW50ID0gc291cmNlc0NvbnRlbnQ7XG4gICAgdGhpcy5fbWFwcGluZ3MgPSBtYXBwaW5ncztcbiAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICB9XG5cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgZnJvbSBhIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAgICpcbiAgICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gICAqICAgICAgICBUaGUgc291cmNlIG1hcCB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG4gICAqIEByZXR1cm5zIEJhc2ljU291cmNlTWFwQ29uc3VtZXJcbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwKSB7XG4gICAgICB2YXIgc21jID0gT2JqZWN0LmNyZWF0ZShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5cbiAgICAgIHZhciBuYW1lcyA9IHNtYy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fbmFtZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICAgIHZhciBzb3VyY2VzID0gc21jLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX3NvdXJjZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21jLnNvdXJjZVJvb3QpO1xuICAgICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuXG4gICAgICAvLyBCZWNhdXNlIHdlIGFyZSBtb2RpZnlpbmcgdGhlIGVudHJpZXMgKGJ5IGNvbnZlcnRpbmcgc3RyaW5nIHNvdXJjZXMgYW5kXG4gICAgICAvLyBuYW1lcyB0byBpbmRpY2VzIGludG8gdGhlIHNvdXJjZXMgYW5kIG5hbWVzIEFycmF5U2V0cyksIHdlIGhhdmUgdG8gbWFrZVxuICAgICAgLy8gYSBjb3B5IG9mIHRoZSBlbnRyeSBvciBlbHNlIGJhZCB0aGluZ3MgaGFwcGVuLiBTaGFyZWQgbXV0YWJsZSBzdGF0ZVxuICAgICAgLy8gc3RyaWtlcyBhZ2FpbiEgU2VlIGdpdGh1YiBpc3N1ZSAjMTkxLlxuXG4gICAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBhU291cmNlTWFwLl9tYXBwaW5ncy50b0FycmF5KCkuc2xpY2UoKTtcbiAgICAgIHZhciBkZXN0R2VuZXJhdGVkTWFwcGluZ3MgPSBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgdmFyIGRlc3RPcmlnaW5hbE1hcHBpbmdzID0gc21jLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNyY01hcHBpbmcgPSBnZW5lcmF0ZWRNYXBwaW5nc1tpXTtcbiAgICAgICAgdmFyIGRlc3RNYXBwaW5nID0gbmV3IE1hcHBpbmc7XG4gICAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBzcmNNYXBwaW5nLmdlbmVyYXRlZExpbmU7XG4gICAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChzcmNNYXBwaW5nLnNvdXJjZSkge1xuICAgICAgICAgIGRlc3RNYXBwaW5nLnNvdXJjZSA9IHNvdXJjZXMuaW5kZXhPZihzcmNNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxMaW5lID0gc3JjTWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBzcmNNYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKHNyY01hcHBpbmcubmFtZSkge1xuICAgICAgICAgICAgZGVzdE1hcHBpbmcubmFtZSA9IG5hbWVzLmluZGV4T2Yoc3JjTWFwcGluZy5uYW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXN0T3JpZ2luYWxNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3RHZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICAgIH1cblxuICAgICAgcXVpY2tTb3J0KHNtYy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgICByZXR1cm4gc21jO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCA/IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHMpIDogcztcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgdGhlIEpJVCB3aXRoIGEgbmljZSBzaGFwZSAvIGhpZGRlbiBjbGFzcy5cbiAgICovXG4gIGZ1bmN0aW9uIE1hcHBpbmcoKSB7XG4gICAgdGhpcy5nZW5lcmF0ZWRMaW5lID0gMDtcbiAgICB0aGlzLmdlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAgICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gICAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgICAgdmFyIGdlbmVyYXRlZExpbmUgPSAxO1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgICB2YXIgbGVuZ3RoID0gYVN0ci5sZW5ndGg7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIGNhY2hlZFNlZ21lbnRzID0ge307XG4gICAgICB2YXIgdGVtcCA9IHt9O1xuICAgICAgdmFyIG9yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgdmFyIG1hcHBpbmcsIHN0ciwgc2VnbWVudCwgZW5kLCB2YWx1ZTtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICc7Jykge1xuICAgICAgICAgIGdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICcsJykge1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbWFwcGluZyA9IG5ldyBNYXBwaW5nKCk7XG4gICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gZ2VuZXJhdGVkTGluZTtcblxuICAgICAgICAgIC8vIEJlY2F1c2UgZWFjaCBvZmZzZXQgaXMgZW5jb2RlZCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAgIC8vIG1hbnkgc2VnbWVudHMgb2Z0ZW4gaGF2ZSB0aGUgc2FtZSBlbmNvZGluZy4gV2UgY2FuIGV4cGxvaXQgdGhpc1xuICAgICAgICAgIC8vIGZhY3QgYnkgY2FjaGluZyB0aGUgcGFyc2VkIHZhcmlhYmxlIGxlbmd0aCBmaWVsZHMgb2YgZWFjaCBzZWdtZW50LFxuICAgICAgICAgIC8vIGFsbG93aW5nIHVzIHRvIGF2b2lkIGEgc2Vjb25kIHBhcnNlIGlmIHdlIGVuY291bnRlciB0aGUgc2FtZVxuICAgICAgICAgIC8vIHNlZ21lbnQgYWdhaW4uXG4gICAgICAgICAgZm9yIChlbmQgPSBpbmRleDsgZW5kIDwgbGVuZ3RoOyBlbmQrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgZW5kKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyID0gYVN0ci5zbGljZShpbmRleCwgZW5kKTtcblxuICAgICAgICAgIHNlZ21lbnQgPSBjYWNoZWRTZWdtZW50c1tzdHJdO1xuICAgICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgICBpbmRleCArPSBzdHIubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmQpIHtcbiAgICAgICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShhU3RyLCBpbmRleCwgdGVtcCk7XG4gICAgICAgICAgICAgIHZhbHVlID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgICAgaW5kZXggPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgICAgIHNlZ21lbnQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlIGFuZCBsaW5lLCBidXQgbm8gY29sdW1uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhY2hlZFNlZ21lbnRzW3N0cl0gPSBzZWdtZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEdlbmVyYXRlZCBjb2x1bW4uXG4gICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiArIHNlZ21lbnRbMF07XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIHNvdXJjZS5cbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gcHJldmlvdXNTb3VyY2UgKyBzZWdtZW50WzFdO1xuICAgICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gc2VnbWVudFsxXTtcblxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgbGluZS5cbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gcHJldmlvdXNPcmlnaW5hbExpbmUgKyBzZWdtZW50WzJdO1xuICAgICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAgIC8vIExpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZFxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgKz0gMTtcblxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gKyBzZWdtZW50WzNdO1xuICAgICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgLy8gT3JpZ2luYWwgbmFtZS5cbiAgICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gcHJldmlvdXNOYW1lICsgc2VnbWVudFs0XTtcbiAgICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHNlZ21lbnRbNF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgb3JpZ2luYWxNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBxdWlja1NvcnQoZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gZ2VuZXJhdGVkTWFwcGluZ3M7XG5cbiAgICAgIHF1aWNrU29ydChvcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gb3JpZ2luYWxNYXBwaW5ncztcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAgICogd2UgYXJlIHNlYXJjaGluZyBmb3IgaW4gdGhlIGdpdmVuIFwiaGF5c3RhY2tcIiBvZiBtYXBwaW5ncy5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZmluZE1hcHBpbmcoYU5lZWRsZSwgYU1hcHBpbmdzLCBhTGluZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbHVtbk5hbWUsIGFDb21wYXJhdG9yLCBhQmlhcykge1xuICAgICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgICAgLy8gbWFwcGluZyBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCB0aGVuIHJldHVybiB0aGUgb3Bwb3NpdGUgcG9zaXRpb24gaXRcbiAgICAgIC8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4gICAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICAgIGlmIChhTmVlZGxlW2FMaW5lTmFtZV0gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgICAgfVxuICAgICAgaWYgKGFOZWVkbGVbYUNvbHVtbk5hbWVdIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUNvbHVtbk5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvciwgYUJpYXMpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIGxhc3QgY29sdW1uIGZvciBlYWNoIGdlbmVyYXRlZCBtYXBwaW5nLiBUaGUgbGFzdCBjb2x1bW4gaXNcbiAgICogaW5jbHVzaXZlLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29tcHV0ZUNvbHVtblNwYW5zID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jb21wdXRlQ29sdW1uU3BhbnMoKSB7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAgIC8vIE1hcHBpbmdzIGRvIG5vdCBjb250YWluIGEgZmllbGQgZm9yIHRoZSBsYXN0IGdlbmVyYXRlZCBjb2x1bW50LiBXZVxuICAgICAgICAvLyBjYW4gY29tZSB1cCB3aXRoIGFuIG9wdGltaXN0aWMgZXN0aW1hdGUsIGhvd2V2ZXIsIGJ5IGFzc3VtaW5nIHRoYXRcbiAgICAgICAgLy8gbWFwcGluZ3MgYXJlIGNvbnRpZ3VvdXMgKGkuZS4gZ2l2ZW4gdHdvIGNvbnNlY3V0aXZlIG1hcHBpbmdzLCB0aGVcbiAgICAgICAgLy8gZmlyc3QgbWFwcGluZyBlbmRzIHdoZXJlIHRoZSBzZWNvbmQgb25lIHN0YXJ0cykuXG4gICAgICAgIGlmIChpbmRleCArIDEgPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbmV4dE1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleCArIDFdO1xuXG4gICAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC0gMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBsYXN0IG1hcHBpbmcgZm9yIGVhY2ggbGluZSBzcGFucyB0aGUgZW50aXJlIGxpbmUuXG4gICAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IEluZmluaXR5O1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICAgKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAgICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAgICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAgICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICAgKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAgICpcbiAgICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICAgIH07XG5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgICBuZWVkbGUsXG4gICAgICAgIHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLFxuICAgICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgICAgXCJnZW5lcmF0ZWRDb2x1bW5cIixcbiAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCxcbiAgICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgICApO1xuXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnc291cmNlJywgbnVsbCk7XG4gICAgICAgICAgaWYgKHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5hdChzb3VyY2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ25hbWUnLCBudWxsKTtcbiAgICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmF0KG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gICAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICAgIGZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnQubGVuZ3RoID49IHRoaXMuX3NvdXJjZXMuc2l6ZSgpICYmXG4gICAgICAgICF0aGlzLnNvdXJjZXNDb250ZW50LnNvbWUoZnVuY3Rpb24gKHNjKSB7IHJldHVybiBzYyA9PSBudWxsOyB9KTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAgICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICAgKiBhdmFpbGlibGUuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIGFTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgYVNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zb3VyY2VzLmhhcyhhU291cmNlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoYVNvdXJjZSldO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXJsO1xuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsXG4gICAgICAgICAgJiYgKHVybCA9IHV0aWwudXJsUGFyc2UodGhpcy5zb3VyY2VSb290KSkpIHtcbiAgICAgICAgLy8gWFhYOiBmaWxlOi8vIFVSSXMgYW5kIGFic29sdXRlIHBhdGhzIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvciBmb3JcbiAgICAgICAgLy8gbWFueSB1c2Vycy4gV2UgY2FuIGhlbHAgdGhlbSBvdXQgd2hlbiB0aGV5IGV4cGVjdCBmaWxlOi8vIFVSSXMgdG9cbiAgICAgICAgLy8gYmVoYXZlIGxpa2UgaXQgd291bGQgaWYgdGhleSB3ZXJlIHJ1bm5pbmcgYSBsb2NhbCBIVFRQIHNlcnZlci4gU2VlXG4gICAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4NTU5Ny5cbiAgICAgICAgdmFyIGZpbGVVcmlBYnNQYXRoID0gYVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgICAgaWYgKHVybC5zY2hlbWUgPT0gXCJmaWxlXCJcbiAgICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKGZpbGVVcmlBYnNQYXRoKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKCF1cmwucGF0aCB8fCB1cmwucGF0aCA9PSBcIi9cIilcbiAgICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgYVNvdXJjZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoXCIvXCIgKyBhU291cmNlKV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IGZyb21cbiAgICAgIC8vIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvci4gSW4gdGhhdCBjYXNlLCB3ZVxuICAgICAgLy8gZG9uJ3Qgd2FudCB0byB0aHJvdyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBzb3VyY2UgLSB3ZSBqdXN0IHdhbnQgdG9cbiAgICAgIC8vIHJldHVybiBudWxsLCBzbyB3ZSBwcm92aWRlIGEgZmxhZyB0byBleGl0IGdyYWNlZnVsbHkuXG4gICAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAgICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gICAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gICAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gICAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gICAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAgICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKTtcbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICAgIGxhc3RDb2x1bW46IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgb3JpZ2luYWxMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICAgIH07XG5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgICBuZWVkbGUsXG4gICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgICApO1xuXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gbmVlZGxlLnNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIGxhc3RDb2x1bW46IG51bGxcbiAgICAgIH07XG4gICAgfTtcblxuICBleHBvcnRzLkJhc2ljU291cmNlTWFwQ29uc3VtZXIgPSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyO1xuXG4gIC8qKlxuICAgKiBBbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoXG4gICAqIHdlIGNhbiBxdWVyeSBmb3IgaW5mb3JtYXRpb24uIEl0IGRpZmZlcnMgZnJvbSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluXG4gICAqIHRoYXQgaXQgdGFrZXMgXCJpbmRleGVkXCIgc291cmNlIG1hcHMgKGkuZS4gb25lcyB3aXRoIGEgXCJzZWN0aW9uc1wiIGZpZWxkKSBhc1xuICAgKiBpbnB1dC5cbiAgICpcbiAgICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIGEgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvciBhbHJlYWR5XG4gICAqIHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMgZm9yIGluZGV4ZWQgc291cmNlIG1hcHMsIHRoZXlcbiAgICogaGF2ZSB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gICAqXG4gICAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICAgKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgKiAgIC0gc2VjdGlvbnM6IEEgbGlzdCBvZiBzZWN0aW9uIGRlZmluaXRpb25zLlxuICAgKlxuICAgKiBFYWNoIHZhbHVlIHVuZGVyIHRoZSBcInNlY3Rpb25zXCIgZmllbGQgaGFzIHR3byBmaWVsZHM6XG4gICAqICAgLSBvZmZzZXQ6IFRoZSBvZmZzZXQgaW50byB0aGUgb3JpZ2luYWwgc3BlY2lmaWVkIGF0IHdoaWNoIHRoaXMgc2VjdGlvblxuICAgKiAgICAgICBiZWdpbnMgdG8gYXBwbHksIGRlZmluZWQgYXMgYW4gb2JqZWN0IHdpdGggYSBcImxpbmVcIiBhbmQgXCJjb2x1bW5cIlxuICAgKiAgICAgICBmaWVsZC5cbiAgICogICAtIG1hcDogQSBzb3VyY2UgbWFwIGRlZmluaXRpb24uIFRoaXMgc291cmNlIG1hcCBjb3VsZCBhbHNvIGJlIGluZGV4ZWQsXG4gICAqICAgICAgIGJ1dCBkb2Vzbid0IGhhdmUgdG8gYmUuXG4gICAqXG4gICAqIEluc3RlYWQgb2YgdGhlIFwibWFwXCIgZmllbGQsIGl0J3MgYWxzbyBwb3NzaWJsZSB0byBoYXZlIGEgXCJ1cmxcIiBmaWVsZFxuICAgKiBzcGVjaWZ5aW5nIGEgVVJMIHRvIHJldHJpZXZlIGEgc291cmNlIG1hcCBmcm9tLCBidXQgdGhhdCdzIGN1cnJlbnRseVxuICAgKiB1bnN1cHBvcnRlZC5cbiAgICpcbiAgICogSGVyZSdzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdLCBidXRcbiAgICogbW9kaWZpZWQgdG8gb21pdCBhIHNlY3Rpb24gd2hpY2ggdXNlcyB0aGUgXCJ1cmxcIiBmaWVsZC5cbiAgICpcbiAgICogIHtcbiAgICogICAgdmVyc2lvbiA6IDMsXG4gICAqICAgIGZpbGU6IFwiYXBwLmpzXCIsXG4gICAqICAgIHNlY3Rpb25zOiBbe1xuICAgKiAgICAgIG9mZnNldDoge2xpbmU6MTAwLCBjb2x1bW46MTB9LFxuICAgKiAgICAgIG1hcDoge1xuICAgKiAgICAgICAgdmVyc2lvbiA6IDMsXG4gICAqICAgICAgICBmaWxlOiBcInNlY3Rpb24uanNcIixcbiAgICogICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAgICogICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICAgKiAgICAgICAgbWFwcGluZ3M6IFwiQUFBQSxFOztBQkNERTtcIlxuICAgKiAgICAgIH1cbiAgICogICAgfV0sXG4gICAqICB9XG4gICAqXG4gICAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0I2hlYWRpbmc9aC41MzVlczN4ZXByZ3RcbiAgICovXG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gICAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gICAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgICB9XG5cbiAgICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgICB2YXIgc2VjdGlvbnMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzZWN0aW9ucycpO1xuXG4gICAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gICAgfVxuXG4gICAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICB2YXIgbGFzdE9mZnNldCA9IHtcbiAgICAgIGxpbmU6IC0xLFxuICAgICAgY29sdW1uOiAwXG4gICAgfTtcbiAgICB0aGlzLl9zZWN0aW9ucyA9IHNlY3Rpb25zLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgaWYgKHMudXJsKSB7XG4gICAgICAgIC8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMTZcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwb3J0IGZvciB1cmwgZmllbGQgaW4gc2VjdGlvbnMgbm90IGltcGxlbWVudGVkLicpO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IHV0aWwuZ2V0QXJnKHMsICdvZmZzZXQnKTtcbiAgICAgIHZhciBvZmZzZXRMaW5lID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnbGluZScpO1xuICAgICAgdmFyIG9mZnNldENvbHVtbiA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2NvbHVtbicpO1xuXG4gICAgICBpZiAob2Zmc2V0TGluZSA8IGxhc3RPZmZzZXQubGluZSB8fFxuICAgICAgICAgIChvZmZzZXRMaW5lID09PSBsYXN0T2Zmc2V0LmxpbmUgJiYgb2Zmc2V0Q29sdW1uIDwgbGFzdE9mZnNldC5jb2x1bW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO1xuICAgICAgfVxuICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2VuZXJhdGVkT2Zmc2V0OiB7XG4gICAgICAgICAgLy8gVGhlIG9mZnNldCBmaWVsZHMgYXJlIDAtYmFzZWQsIGJ1dCB3ZSB1c2UgMS1iYXNlZCBpbmRpY2VzIHdoZW5cbiAgICAgICAgICAvLyBlbmNvZGluZy9kZWNvZGluZyBmcm9tIFZMUS5cbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBvZmZzZXRMaW5lICsgMSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG9mZnNldENvbHVtbiArIDFcbiAgICAgICAgfSxcbiAgICAgICAgY29uc3VtZXI6IG5ldyBTb3VyY2VNYXBDb25zdW1lcih1dGlsLmdldEFyZyhzLCAnbWFwJykpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAgICovXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc291cmNlcy5wdXNoKHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXNbal0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNvdXJjZXM7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gICAqL1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICAgIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgICB9O1xuXG4gICAgICAvLyBGaW5kIHRoZSBzZWN0aW9uIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbiB3ZSdyZSB0cnlpbmcgdG8gbWFwXG4gICAgICAvLyB0byBhbiBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICAgIHZhciBzZWN0aW9uSW5kZXggPSBiaW5hcnlTZWFyY2guc2VhcmNoKG5lZWRsZSwgdGhpcy5fc2VjdGlvbnMsXG4gICAgICAgIGZ1bmN0aW9uKG5lZWRsZSwgc2VjdGlvbikge1xuICAgICAgICAgIHZhciBjbXAgPSBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmU7XG4gICAgICAgICAgaWYgKGNtcCkge1xuICAgICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gKG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgfSk7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW3NlY3Rpb25JbmRleF07XG5cbiAgICAgIGlmICghc2VjdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgICBuYW1lOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWN0aW9uLmNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICBsaW5lOiBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtXG4gICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgY29sdW1uOiBuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmVcbiAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgIDogMCksXG4gICAgICAgIGJpYXM6IGFBcmdzLmJpYXNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICAgKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICAgIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWN0aW9ucy5ldmVyeShmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gcy5jb25zdW1lci5oYXNDb250ZW50c09mQWxsU291cmNlcygpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gICAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAgICogYXZhaWxhYmxlLlxuICAgKi9cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgICAgdmFyIGNvbnRlbnQgPSBzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICAgKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAgICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICovXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICAgIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICAgIC8vIE9ubHkgY29uc2lkZXIgdGhpcyBzZWN0aW9uIGlmIHRoZSByZXF1ZXN0ZWQgc291cmNlIGlzIGluIHRoZSBsaXN0IG9mXG4gICAgICAgIC8vIHNvdXJjZXMgb2YgdGhlIGNvbnN1bWVyLlxuICAgICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VzLmluZGV4T2YodXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSkgPT09IC0xKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdlbmVyYXRlZFBvc2l0aW9uID0gc2VjdGlvbi5jb25zdW1lci5nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyk7XG4gICAgICAgIGlmIChnZW5lcmF0ZWRQb3NpdGlvbikge1xuICAgICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lICtcbiAgICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkUG9zaXRpb24uY29sdW1uICtcbiAgICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmVcbiAgICAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgICAgOiAwKVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGxcbiAgICAgIH07XG4gICAgfTtcblxuICAvKipcbiAgICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICAgKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAgICovXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICAgIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG4gICAgICAgIHZhciBzZWN0aW9uTWFwcGluZ3MgPSBzZWN0aW9uLmNvbnN1bWVyLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWN0aW9uTWFwcGluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgbWFwcGluZyA9IHNlY3Rpb25NYXBwaW5nc1tpXTtcblxuICAgICAgICAgIHZhciBzb3VyY2UgPSBzZWN0aW9uLmNvbnN1bWVyLl9zb3VyY2VzLmF0KG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4oc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXG4gICAgICAgICAgdmFyIG5hbWUgPSBzZWN0aW9uLmNvbnN1bWVyLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcblxuICAgICAgICAgIC8vIFRoZSBtYXBwaW5ncyBjb21pbmcgZnJvbSB0aGUgY29uc3VtZXIgZm9yIHRoZSBzZWN0aW9uIGhhdmVcbiAgICAgICAgICAvLyBnZW5lcmF0ZWQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VjdGlvbiwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIG9mZnNldCB0aGVtIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgY29uY2F0ZW5hdGVkXG4gICAgICAgICAgLy8gZ2VuZXJhdGVkIGZpbGUuXG4gICAgICAgICAgdmFyIGFkanVzdGVkTWFwcGluZyA9IHtcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lICtcbiAgICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5jb2x1bW4gK1xuICAgICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbWFwcGluZy5nZW5lcmF0ZWRMaW5lKVxuICAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICAgIGlmICh0eXBlb2YgYWRqdXN0ZWRNYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBxdWlja1NvcnQodGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICAgIHF1aWNrU29ydCh0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gICAgfTtcblxuICBleHBvcnRzLkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciA9IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcjtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgdmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbiAgdmFyIE1hcHBpbmdMaXN0ID0gcmVxdWlyZSgnLi9tYXBwaW5nLWxpc3QnKS5NYXBwaW5nTGlzdDtcblxuICAvKipcbiAgICogQW4gaW5zdGFuY2Ugb2YgdGhlIFNvdXJjZU1hcEdlbmVyYXRvciByZXByZXNlbnRzIGEgc291cmNlIG1hcCB3aGljaCBpc1xuICAgKiBiZWluZyBidWlsdCBpbmNyZW1lbnRhbGx5LiBZb3UgbWF5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gZmlsZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKiAgIC0gc291cmNlUm9vdDogQSByb290IGZvciBhbGwgcmVsYXRpdmUgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gICAqL1xuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpIHtcbiAgICBpZiAoIWFBcmdzKSB7XG4gICAgICBhQXJncyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLl9maWxlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdmaWxlJywgbnVsbCk7XG4gICAgdGhpcy5fc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICAgIHRoaXMuX3NraXBWYWxpZGF0aW9uID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdza2lwVmFsaWRhdGlvbicsIGZhbHNlKTtcbiAgICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB0aGlzLl9tYXBwaW5ncyA9IG5ldyBNYXBwaW5nTGlzdCgpO1xuICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG4gIH1cblxuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IgYmFzZWQgb24gYSBTb3VyY2VNYXBDb25zdW1lclxuICAgKlxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgICB2YXIgc291cmNlUm9vdCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VSb290O1xuICAgICAgdmFyIGdlbmVyYXRvciA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgICBmaWxlOiBhU291cmNlTWFwQ29uc3VtZXIuZmlsZSxcbiAgICAgICAgc291cmNlUm9vdDogc291cmNlUm9vdFxuICAgICAgfSk7XG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgdmFyIG5ld01hcHBpbmcgPSB7XG4gICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld01hcHBpbmcub3JpZ2luYWwgPSB7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5ld01hcHBpbmcubmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZW5lcmF0b3IuYWRkTWFwcGluZyhuZXdNYXBwaW5nKTtcbiAgICAgIH0pO1xuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgZ2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBzaW5nbGUgbWFwcGluZyBmcm9tIG9yaWdpbmFsIHNvdXJjZSBsaW5lIGFuZCBjb2x1bW4gdG8gdGhlIGdlbmVyYXRlZFxuICAgKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gZm9yIHRoaXMgc291cmNlIG1hcCBiZWluZyBjcmVhdGVkLiBUaGUgbWFwcGluZ1xuICAgKiBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gZ2VuZXJhdGVkOiBBbiBvYmplY3Qgd2l0aCB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gICAqICAgLSBvcmlnaW5hbDogQW4gb2JqZWN0IHdpdGggdGhlIG9yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSAocmVsYXRpdmUgdG8gdGhlIHNvdXJjZVJvb3QpLlxuICAgKiAgIC0gbmFtZTogQW4gb3B0aW9uYWwgb3JpZ2luYWwgdG9rZW4gbmFtZSBmb3IgdGhpcyBtYXBwaW5nLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNYXBwaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyhhQXJncykge1xuICAgICAgdmFyIGdlbmVyYXRlZCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZ2VuZXJhdGVkJyk7XG4gICAgICB2YXIgb3JpZ2luYWwgPSB1dGlsLmdldEFyZyhhQXJncywgJ29yaWdpbmFsJywgbnVsbCk7XG4gICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICduYW1lJywgbnVsbCk7XG5cbiAgICAgIGlmICghdGhpcy5fc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVNYXBwaW5nKGdlbmVyYXRlZCwgb3JpZ2luYWwsIHNvdXJjZSwgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiAhdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSAhPSBudWxsICYmICF0aGlzLl9uYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9tYXBwaW5ncy5hZGQoe1xuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uLFxuICAgICAgICBvcmlnaW5hbExpbmU6IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwubGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgICB2YXIgc291cmNlID0gYVNvdXJjZUZpbGU7XG4gICAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5fc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFTb3VyY2VDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgY29udGVudCB0byB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBfc291cmNlc0NvbnRlbnRzIG1hcCBpZiB0aGUgcHJvcGVydHkgaXMgbnVsbC5cbiAgICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBzb3VyY2UgZmlsZSBmcm9tIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgICAgLy8gSWYgdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwIGlzIGVtcHR5LCBzZXQgdGhlIHByb3BlcnR5IHRvIG51bGwuXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3NvdXJjZXNDb250ZW50cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIG1hcHBpbmdzIG9mIGEgc3ViLXNvdXJjZS1tYXAgZm9yIGEgc3BlY2lmaWMgc291cmNlIGZpbGUgdG8gdGhlXG4gICAqIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkLiBFYWNoIG1hcHBpbmcgdG8gdGhlIHN1cHBsaWVkIHNvdXJjZSBmaWxlIGlzXG4gICAqIHJld3JpdHRlbiB1c2luZyB0aGUgc3VwcGxpZWQgc291cmNlIG1hcC4gTm90ZTogVGhlIHJlc29sdXRpb24gZm9yIHRoZVxuICAgKiByZXN1bHRpbmcgbWFwcGluZ3MgaXMgdGhlIG1pbmltaXVtIG9mIHRoaXMgbWFwIGFuZCB0aGUgc3VwcGxpZWQgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQuXG4gICAqIEBwYXJhbSBhU291cmNlRmlsZSBPcHRpb25hbC4gVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZS5cbiAgICogICAgICAgIElmIG9taXR0ZWQsIFNvdXJjZU1hcENvbnN1bWVyJ3MgZmlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVzZWQuXG4gICAqIEBwYXJhbSBhU291cmNlTWFwUGF0aCBPcHRpb25hbC4gVGhlIGRpcm5hbWUgb2YgdGhlIHBhdGggdG8gdGhlIHNvdXJjZSBtYXBcbiAgICogICAgICAgIHRvIGJlIGFwcGxpZWQuIElmIHJlbGF0aXZlLCBpdCBpcyByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwQ29uc3VtZXIuXG4gICAqICAgICAgICBUaGlzIHBhcmFtZXRlciBpcyBuZWVkZWQgd2hlbiB0aGUgdHdvIHNvdXJjZSBtYXBzIGFyZW4ndCBpbiB0aGUgc2FtZVxuICAgKiAgICAgICAgZGlyZWN0b3J5LCBhbmQgdGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZCBjb250YWlucyByZWxhdGl2ZSBzb3VyY2VcbiAgICogICAgICAgIHBhdGhzLiBJZiBzbywgdGhvc2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIG5lZWQgdG8gYmUgcmV3cml0dGVuXG4gICAqICAgICAgICByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FwcGx5U291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lciwgYVNvdXJjZUZpbGUsIGFTb3VyY2VNYXBQYXRoKSB7XG4gICAgICB2YXIgc291cmNlRmlsZSA9IGFTb3VyY2VGaWxlO1xuICAgICAgLy8gSWYgYVNvdXJjZUZpbGUgaXMgb21pdHRlZCwgd2Ugd2lsbCB1c2UgdGhlIGZpbGUgcHJvcGVydHkgb2YgdGhlIFNvdXJjZU1hcFxuICAgICAgaWYgKGFTb3VyY2VGaWxlID09IG51bGwpIHtcbiAgICAgICAgaWYgKGFTb3VyY2VNYXBDb25zdW1lci5maWxlID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCByZXF1aXJlcyBlaXRoZXIgYW4gZXhwbGljaXQgc291cmNlIGZpbGUsICcgK1xuICAgICAgICAgICAgJ29yIHRoZSBzb3VyY2UgbWFwXFwncyBcImZpbGVcIiBwcm9wZXJ0eS4gQm90aCB3ZXJlIG9taXR0ZWQuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlRmlsZSA9IGFTb3VyY2VNYXBDb25zdW1lci5maWxlO1xuICAgICAgfVxuICAgICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgICAgLy8gTWFrZSBcInNvdXJjZUZpbGVcIiByZWxhdGl2ZSBpZiBhbiBhYnNvbHV0ZSBVcmwgaXMgcGFzc2VkLlxuICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgIH1cbiAgICAgIC8vIEFwcGx5aW5nIHRoZSBTb3VyY2VNYXAgY2FuIGFkZCBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZXMgYW5kXG4gICAgICAvLyB0aGUgbmFtZXMgYXJyYXkuXG4gICAgICB2YXIgbmV3U291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgICAgdmFyIG5ld05hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICAgIC8vIEZpbmQgbWFwcGluZ3MgZm9yIHRoZSBcInNvdXJjZUZpbGVcIlxuICAgICAgdGhpcy5fbWFwcGluZ3MudW5zb3J0ZWRGb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gc291cmNlRmlsZSAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgY2FuIGJlIG1hcHBlZCBieSB0aGUgc291cmNlIG1hcCwgdGhlbiB1cGRhdGUgdGhlIG1hcHBpbmcuXG4gICAgICAgICAgdmFyIG9yaWdpbmFsID0gYVNvdXJjZU1hcENvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvcHkgbWFwcGluZ1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgICAgbmV3U291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICBpZiAobmFtZSAhPSBudWxsICYmICFuZXdOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICBuZXdOYW1lcy5hZGQobmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgfSwgdGhpcyk7XG4gICAgICB0aGlzLl9zb3VyY2VzID0gbmV3U291cmNlcztcbiAgICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG5cbiAgICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnRzIG9mIGFwcGxpZWQgbWFwLlxuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBIG1hcHBpbmcgY2FuIGhhdmUgb25lIG9mIHRoZSB0aHJlZSBsZXZlbHMgb2YgZGF0YTpcbiAgICpcbiAgICogICAxLiBKdXN0IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gICAqICAgMi4gVGhlIEdlbmVyYXRlZCBwb3NpdGlvbiwgb3JpZ2luYWwgcG9zaXRpb24sIGFuZCBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgMy4gR2VuZXJhdGVkIGFuZCBvcmlnaW5hbCBwb3NpdGlvbiwgb3JpZ2luYWwgc291cmNlLCBhcyB3ZWxsIGFzIGEgbmFtZVxuICAgKiAgICAgIHRva2VuLlxuICAgKlxuICAgKiBUbyBtYWludGFpbiBjb25zaXN0ZW5jeSwgd2UgdmFsaWRhdGUgdGhhdCBhbnkgbmV3IG1hcHBpbmcgYmVpbmcgYWRkZWQgZmFsbHNcbiAgICogaW4gdG8gb25lIG9mIHRoZXNlIGNhdGVnb3JpZXMuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZU1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCwgYU9yaWdpbmFsLCBhU291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYU5hbWUpIHtcbiAgICAgIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAmJiAhYU9yaWdpbmFsICYmICFhU291cmNlICYmICFhTmFtZSkge1xuICAgICAgICAvLyBDYXNlIDEuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICAgICAgJiYgYU9yaWdpbmFsICYmICdsaW5lJyBpbiBhT3JpZ2luYWwgJiYgJ2NvbHVtbicgaW4gYU9yaWdpbmFsXG4gICAgICAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAgICAgICYmIGFPcmlnaW5hbC5saW5lID4gMCAmJiBhT3JpZ2luYWwuY29sdW1uID49IDBcbiAgICAgICAgICAgICAgICYmIGFTb3VyY2UpIHtcbiAgICAgICAgLy8gQ2FzZXMgMiBhbmQgMy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXBwaW5nOiAnICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGdlbmVyYXRlZDogYUdlbmVyYXRlZCxcbiAgICAgICAgICBzb3VyY2U6IGFTb3VyY2UsXG4gICAgICAgICAgb3JpZ2luYWw6IGFPcmlnaW5hbCxcbiAgICAgICAgICBuYW1lOiBhTmFtZVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICAgKiBzcGVjaWZpZWQgYnkgdGhlIHNvdXJjZSBtYXAgZm9ybWF0LlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplTWFwcGluZ3MgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncygpIHtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRMaW5lID0gMTtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbWFwcGluZztcblxuICAgICAgdmFyIG1hcHBpbmdzID0gdGhpcy5fbWFwcGluZ3MudG9BcnJheSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG1hcHBpbmcgPSBtYXBwaW5nc1tpXTtcblxuICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgd2hpbGUgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJzsnO1xuICAgICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaWYgKCF1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmcsIG1hcHBpbmdzW2kgLSAxXSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gJywnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUodGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNTb3VyY2UpO1xuICAgICAgICAgIHByZXZpb3VzU291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKTtcblxuICAgICAgICAgIC8vIGxpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZCBpbiBTb3VyY2VNYXAgc3BlYyB2ZXJzaW9uIDNcbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxMaW5lKTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMTtcblxuICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4pO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZSh0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNOYW1lKTtcbiAgICAgICAgICAgIHByZXZpb3VzTmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGFTb3VyY2VzLCBhU291cmNlUm9vdCkge1xuICAgICAgcmV0dXJuIGFTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFTb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKGFTb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSB1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSk7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc291cmNlc0NvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSlcbiAgICAgICAgICA/IHRoaXMuX3NvdXJjZXNDb250ZW50c1trZXldXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAvKipcbiAgICogRXh0ZXJuYWxpemUgdGhlIHNvdXJjZSBtYXAuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvSlNPTiA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvSlNPTigpIHtcbiAgICAgIHZhciBtYXAgPSB7XG4gICAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICAgIHNvdXJjZXM6IHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgICBuYW1lczogdGhpcy5fbmFtZXMudG9BcnJheSgpLFxuICAgICAgICBtYXBwaW5nczogdGhpcy5fc2VyaWFsaXplTWFwcGluZ3MoKVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLl9maWxlICE9IG51bGwpIHtcbiAgICAgICAgbWFwLmZpbGUgPSB0aGlzLl9maWxlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBtYXAuc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IHRoaXMuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQobWFwLnNvdXJjZXMsIG1hcC5zb3VyY2VSb290KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkIHRvIGEgc3RyaW5nLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpO1xuICAgIH07XG5cbiAgZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3I7XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvLyBNYXRjaGVzIGEgV2luZG93cy1zdHlsZSBgXFxyXFxuYCBuZXdsaW5lIG9yIGEgYFxcbmAgbmV3bGluZSB1c2VkIGJ5IGFsbCBvdGhlclxuICAvLyBvcGVyYXRpbmcgc3lzdGVtcyB0aGVzZSBkYXlzIChjYXB0dXJpbmcgdGhlIHJlc3VsdCkuXG4gIHZhciBSRUdFWF9ORVdMSU5FID0gLyhcXHI/XFxuKS87XG5cbiAgLy8gTmV3bGluZSBjaGFyYWN0ZXIgY29kZSBmb3IgY2hhckNvZGVBdCgpIGNvbXBhcmlzb25zXG4gIHZhciBORVdMSU5FX0NPREUgPSAxMDtcblxuICAvLyBQcml2YXRlIHN5bWJvbCBmb3IgaWRlbnRpZnlpbmcgYFNvdXJjZU5vZGVgcyB3aGVuIG11bHRpcGxlIHZlcnNpb25zIG9mXG4gIC8vIHRoZSBzb3VyY2UtbWFwIGxpYnJhcnkgYXJlIGxvYWRlZC4gVGhpcyBNVVNUIE5PVCBDSEFOR0UgYWNyb3NzXG4gIC8vIHZlcnNpb25zIVxuICB2YXIgaXNTb3VyY2VOb2RlID0gXCIkJCRpc1NvdXJjZU5vZGUkJCRcIjtcblxuICAvKipcbiAgICogU291cmNlTm9kZXMgcHJvdmlkZSBhIHdheSB0byBhYnN0cmFjdCBvdmVyIGludGVycG9sYXRpbmcvY29uY2F0ZW5hdGluZ1xuICAgKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAgICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gICAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICAgKiBAcGFyYW0gYVNvdXJjZSBUaGUgb3JpZ2luYWwgc291cmNlJ3MgZmlsZW5hbWUuXG4gICAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICAgKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAgICogQHBhcmFtIGFOYW1lIFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLlxuICAgKi9cbiAgZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICAgIHRoaXMubGluZSA9IGFMaW5lID09IG51bGwgPyBudWxsIDogYUxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBhQ29sdW1uID09IG51bGwgPyBudWxsIDogYUNvbHVtbjtcbiAgICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT0gbnVsbCA/IG51bGwgOiBhU291cmNlO1xuICAgIHRoaXMubmFtZSA9IGFOYW1lID09IG51bGwgPyBudWxsIDogYU5hbWU7XG4gICAgdGhpc1tpc1NvdXJjZU5vZGVdID0gdHJ1ZTtcbiAgICBpZiAoYUNodW5rcyAhPSBudWxsKSB0aGlzLmFkZChhQ2h1bmtzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgU291cmNlTm9kZSBmcm9tIGdlbmVyYXRlZCBjb2RlIGFuZCBhIFNvdXJjZU1hcENvbnN1bWVyLlxuICAgKlxuICAgKiBAcGFyYW0gYUdlbmVyYXRlZENvZGUgVGhlIGdlbmVyYXRlZCBjb2RlXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcCBmb3IgdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAqIEBwYXJhbSBhUmVsYXRpdmVQYXRoIE9wdGlvbmFsLiBUaGUgcGF0aCB0aGF0IHJlbGF0aXZlIHNvdXJjZXMgaW4gdGhlXG4gICAqICAgICAgICBTb3VyY2VNYXBDb25zdW1lciBzaG91bGQgYmUgcmVsYXRpdmUgdG8uXG4gICAqL1xuICBTb3VyY2VOb2RlLmZyb21TdHJpbmdXaXRoU291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlX2Zyb21TdHJpbmdXaXRoU291cmNlTWFwKGFHZW5lcmF0ZWRDb2RlLCBhU291cmNlTWFwQ29uc3VtZXIsIGFSZWxhdGl2ZVBhdGgpIHtcbiAgICAgIC8vIFRoZSBTb3VyY2VOb2RlIHdlIHdhbnQgdG8gZmlsbCB3aXRoIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgICAgLy8gYW5kIHRoZSBTb3VyY2VNYXBcbiAgICAgIHZhciBub2RlID0gbmV3IFNvdXJjZU5vZGUoKTtcblxuICAgICAgLy8gQWxsIGV2ZW4gaW5kaWNlcyBvZiB0aGlzIGFycmF5IGFyZSBvbmUgbGluZSBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gICAgICAvLyB3aGlsZSBhbGwgb2RkIGluZGljZXMgYXJlIHRoZSBuZXdsaW5lcyBiZXR3ZWVuIHR3byBhZGphY2VudCBsaW5lc1xuICAgICAgLy8gKHNpbmNlIGBSRUdFWF9ORVdMSU5FYCBjYXB0dXJlcyBpdHMgbWF0Y2gpLlxuICAgICAgLy8gUHJvY2Vzc2VkIGZyYWdtZW50cyBhcmUgcmVtb3ZlZCBmcm9tIHRoaXMgYXJyYXksIGJ5IGNhbGxpbmcgYHNoaWZ0TmV4dExpbmVgLlxuICAgICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoUkVHRVhfTkVXTElORSk7XG4gICAgICB2YXIgc2hpZnROZXh0TGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGluZUNvbnRlbnRzID0gcmVtYWluaW5nTGluZXMuc2hpZnQoKTtcbiAgICAgICAgLy8gVGhlIGxhc3QgbGluZSBvZiBhIGZpbGUgbWlnaHQgbm90IGhhdmUgYSBuZXdsaW5lLlxuICAgICAgICB2YXIgbmV3TGluZSA9IHJlbWFpbmluZ0xpbmVzLnNoaWZ0KCkgfHwgXCJcIjtcbiAgICAgICAgcmV0dXJuIGxpbmVDb250ZW50cyArIG5ld0xpbmU7XG4gICAgICB9O1xuXG4gICAgICAvLyBXZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwb3NpdGlvbiBvZiBcInJlbWFpbmluZ0xpbmVzXCJcbiAgICAgIHZhciBsYXN0R2VuZXJhdGVkTGluZSA9IDEsIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuXG4gICAgICAvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4gICAgICAvLyBUbyBleHRyYWN0IGl0IGN1cnJlbnQgYW5kIGxhc3QgbWFwcGluZyBpcyB1c2VkLlxuICAgICAgLy8gSGVyZSB3ZSBzdG9yZSB0aGUgbGFzdCBtYXBwaW5nLlxuICAgICAgdmFyIGxhc3RNYXBwaW5nID0gbnVsbDtcblxuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIGlmIChsYXN0TWFwcGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBpcyBhIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IFwiXCI7XG4gICAgICAgICAgICAvLyBBc3NvY2lhdGUgZmlyc3QgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyBjb2RlIGlzIGFkZGVkIHdpdGhvdXQgbWFwcGluZ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSBjb2RlIGJldHdlZW4gXCJsYXN0R2VuZXJhdGVkQ29sdW1uXCIgYW5kXG4gICAgICAgICAgICAvLyBcIm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXCIgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgICAvLyBObyBtb3JlIHJlbWFpbmluZyBjb2RlLCBjb250aW51ZVxuICAgICAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhZGQgdGhlIGdlbmVyYXRlZCBjb2RlIHVudGlsIHRoZSBmaXJzdCBtYXBwaW5nXG4gICAgICAgIC8vIHRvIHRoZSBTb3VyY2VOb2RlIHdpdGhvdXQgYW55IG1hcHBpbmcuXG4gICAgICAgIC8vIEVhY2ggbGluZSBpcyBhZGRlZCBhcyBzZXBhcmF0ZSBzdHJpbmcuXG4gICAgICAgIHdoaWxlIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG5vZGUuYWRkKHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEdlbmVyYXRlZENvbHVtbiA8IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSB7XG4gICAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbMF07XG4gICAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICAgIGlmIChyZW1haW5pbmdMaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChsYXN0TWFwcGluZykge1xuICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgICBub2RlLmFkZChyZW1haW5pbmdMaW5lcy5qb2luKFwiXCIpKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChhUmVsYXRpdmVQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBub2RlO1xuXG4gICAgICBmdW5jdGlvbiBhZGRNYXBwaW5nV2l0aENvZGUobWFwcGluZywgY29kZSkge1xuICAgICAgICBpZiAobWFwcGluZyA9PT0gbnVsbCB8fCBtYXBwaW5nLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9kZS5hZGQoY29kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IGFSZWxhdGl2ZVBhdGhcbiAgICAgICAgICAgID8gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgICAgOiBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcubmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoaXMgc291cmNlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICAgKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfYWRkKGFDaHVuaykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICAgIGFDaHVuay5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICB0aGlzLmFkZChjaHVuayk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGFDaHVuaykge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goYUNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gICAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcHJlcGVuZChhQ2h1bmspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgICBmb3IgKHZhciBpID0gYUNodW5rLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLnByZXBlbmQoYUNodW5rW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBKUyBzbmlwcGV0cyBpbiB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gVGhlXG4gICAqIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggc25pcHBldCBvZiBKUyBhbmQgaXMgcGFzc2VkIHRoYXRcbiAgICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gU291cmNlTm9kZV93YWxrKGFGbikge1xuICAgIHZhciBjaHVuaztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2h1bmsgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNodW5rW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgY2h1bmsud2FsayhhRm4pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChjaHVuayAhPT0gJycpIHtcbiAgICAgICAgICBhRm4oY2h1bmssIHsgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIExpa2UgYFN0cmluZy5wcm90b3R5cGUuam9pbmAgZXhjZXB0IGZvciBTb3VyY2VOb2Rlcy4gSW5zZXJ0cyBgYVN0cmAgYmV0d2VlblxuICAgKiBlYWNoIG9mIGB0aGlzLmNoaWxkcmVuYC5cbiAgICpcbiAgICogQHBhcmFtIGFTZXAgVGhlIHNlcGFyYXRvci5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2pvaW4oYVNlcCkge1xuICAgIHZhciBuZXdDaGlsZHJlbjtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgIG5ld0NoaWxkcmVuID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuLTE7IGkrKykge1xuICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKGFTZXApO1xuICAgICAgfVxuICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlIG9uIHRoZSB2ZXJ5IHJpZ2h0LW1vc3Qgc291cmNlIHNuaXBwZXQuIFVzZWZ1bFxuICAgKiBmb3IgdHJpbW1pbmcgd2hpdGVzcGFjZSBmcm9tIHRoZSBlbmQgb2YgYSBzb3VyY2Ugbm9kZSwgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0gYVBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAgICogQHBhcmFtIGFSZXBsYWNlbWVudCBUaGUgdGhpbmcgdG8gcmVwbGFjZSB0aGUgcGF0dGVybiB3aXRoLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUucmVwbGFjZVJpZ2h0ID0gZnVuY3Rpb24gU291cmNlTm9kZV9yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkge1xuICAgIHZhciBsYXN0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RDaGlsZFtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICBsYXN0Q2hpbGQucmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdID0gbGFzdENoaWxkLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKCcnLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAgICogaW4gdGhlIHNvdXJjZXNDb250ZW50IGZpZWxkLlxuICAgKlxuICAgKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICAgKiBAcGFyYW0gYVNvdXJjZUNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIHNvdXJjZSBmaWxlXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgICB0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gICAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrU291cmNlQ29udGVudHMgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzKGFGbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV1baXNTb3VyY2VOb2RlXSkge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGFGbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGFGbih1dGlsLmZyb21TZXRTdHJpbmcoc291cmNlc1tpXSksIHRoaXMuc291cmNlQ29udGVudHNbc291cmNlc1tpXV0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUuIFdhbGtzIG92ZXIgdGhlIHRyZWVcbiAgICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZygpIHtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBzdHIgKz0gY2h1bms7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUgYWxvbmcgd2l0aCBhIHNvdXJjZVxuICAgKiBtYXAuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZ1dpdGhTb3VyY2VNYXAgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcChhQXJncykge1xuICAgIHZhciBnZW5lcmF0ZWQgPSB7XG4gICAgICBjb2RlOiBcIlwiLFxuICAgICAgbGluZTogMSxcbiAgICAgIGNvbHVtbjogMFxuICAgIH07XG4gICAgdmFyIG1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbExpbmUgPSBudWxsO1xuICAgIHZhciBsYXN0T3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICAgIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rLCBvcmlnaW5hbCkge1xuICAgICAgZ2VuZXJhdGVkLmNvZGUgKz0gY2h1bms7XG4gICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICAgJiYgb3JpZ2luYWwubGluZSAhPT0gbnVsbFxuICAgICAgICAgICYmIG9yaWdpbmFsLmNvbHVtbiAhPT0gbnVsbCkge1xuICAgICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgICB8fCBsYXN0T3JpZ2luYWxMaW5lICE9PSBvcmlnaW5hbC5saW5lXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbENvbHVtbiAhPT0gb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgbGFzdE9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSBjaHVuay5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaWYgKGNodW5rLmNoYXJDb2RlQXQoaWR4KSA9PT0gTkVXTElORV9DT0RFKSB7XG4gICAgICAgICAgZ2VuZXJhdGVkLmxpbmUrKztcbiAgICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgICAvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG4gICAgICAgICAgaWYgKGlkeCArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdlbmVyYXRlZC5jb2x1bW4rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uIChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KSB7XG4gICAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7IGNvZGU6IGdlbmVyYXRlZC5jb2RlLCBtYXA6IG1hcCB9O1xuICB9O1xuXG4gIGV4cG9ydHMuU291cmNlTm9kZSA9IFNvdXJjZU5vZGU7XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBwYXJhbWV0ZXIvb3B0aW9uc1xuICAgKiBvYmplY3RzLlxuICAgKlxuICAgKiBAcGFyYW0gYXJncyBUaGUgb2JqZWN0IHdlIGFyZSBleHRyYWN0aW5nIHZhbHVlcyBmcm9tXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgZ2V0dGluZy5cbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAgICogZnJvbSB0aGUgb2JqZWN0LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBhblxuICAgKiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEFyZyhhQXJncywgYU5hbWUsIGFEZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoYU5hbWUgaW4gYUFyZ3MpIHtcbiAgICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXR1cm4gYURlZmF1bHRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhTmFtZSArICdcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO1xuICAgIH1cbiAgfVxuICBleHBvcnRzLmdldEFyZyA9IGdldEFyZztcblxuICB2YXIgdXJsUmVnZXhwID0gL14oPzooW1xcdytcXC0uXSspOik/XFwvXFwvKD86KFxcdys6XFx3KylAKT8oW1xcdy5dKikoPzo6KFxcZCspKT8oXFxTKikkLztcbiAgdmFyIGRhdGFVcmxSZWdleHAgPSAvXmRhdGE6LitcXCwuKyQvO1xuXG4gIGZ1bmN0aW9uIHVybFBhcnNlKGFVcmwpIHtcbiAgICB2YXIgbWF0Y2ggPSBhVXJsLm1hdGNoKHVybFJlZ2V4cCk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzY2hlbWU6IG1hdGNoWzFdLFxuICAgICAgYXV0aDogbWF0Y2hbMl0sXG4gICAgICBob3N0OiBtYXRjaFszXSxcbiAgICAgIHBvcnQ6IG1hdGNoWzRdLFxuICAgICAgcGF0aDogbWF0Y2hbNV1cbiAgICB9O1xuICB9XG4gIGV4cG9ydHMudXJsUGFyc2UgPSB1cmxQYXJzZTtcblxuICBmdW5jdGlvbiB1cmxHZW5lcmF0ZShhUGFyc2VkVXJsKSB7XG4gICAgdmFyIHVybCA9ICcnO1xuICAgIGlmIChhUGFyc2VkVXJsLnNjaGVtZSkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwuc2NoZW1lICsgJzonO1xuICAgIH1cbiAgICB1cmwgKz0gJy8vJztcbiAgICBpZiAoYVBhcnNlZFVybC5hdXRoKSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5hdXRoICsgJ0AnO1xuICAgIH1cbiAgICBpZiAoYVBhcnNlZFVybC5ob3N0KSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5ob3N0O1xuICAgIH1cbiAgICBpZiAoYVBhcnNlZFVybC5wb3J0KSB7XG4gICAgICB1cmwgKz0gXCI6XCIgKyBhUGFyc2VkVXJsLnBvcnRcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwucGF0aCkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwucGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBleHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgYSBwYXRoLCBvciB0aGUgcGF0aCBwb3J0aW9uIG9mIGEgVVJMOlxuICAgKlxuICAgKiAtIFJlcGxhY2VzIGNvbnNlcXV0aXZlIHNsYXNoZXMgd2l0aCBvbmUgc2xhc2guXG4gICAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnLicgcGFydHMuXG4gICAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnPGRpcj4vLi4nIHBhcnRzLlxuICAgKlxuICAgKiBCYXNlZCBvbiBjb2RlIGluIHRoZSBOb2RlLmpzICdwYXRoJyBjb3JlIG1vZHVsZS5cbiAgICpcbiAgICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIHVybCB0byBub3JtYWxpemUuXG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemUoYVBhdGgpIHtcbiAgICB2YXIgcGF0aCA9IGFQYXRoO1xuICAgIHZhciB1cmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gICAgaWYgKHVybCkge1xuICAgICAgaWYgKCF1cmwucGF0aCkge1xuICAgICAgICByZXR1cm4gYVBhdGg7XG4gICAgICB9XG4gICAgICBwYXRoID0gdXJsLnBhdGg7XG4gICAgfVxuICAgIHZhciBpc0Fic29sdXRlID0gKHBhdGguY2hhckF0KDApID09PSAnLycpO1xuXG4gICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgvXFwvKy8pO1xuICAgIGZvciAodmFyIHBhcnQsIHVwID0gMCwgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgICB1cCsrO1xuICAgICAgfSBlbHNlIGlmICh1cCA+IDApIHtcbiAgICAgICAgaWYgKHBhcnQgPT09ICcnKSB7XG4gICAgICAgICAgLy8gVGhlIGZpcnN0IHBhcnQgaXMgYmxhbmsgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGUuIFRyeWluZyB0byBnb1xuICAgICAgICAgIC8vIGFib3ZlIHRoZSByb290IGlzIGEgbm8tb3AuIFRoZXJlZm9yZSB3ZSBjYW4gcmVtb3ZlIGFsbCAnLi4nIHBhcnRzXG4gICAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgdGhlIHJvb3QuXG4gICAgICAgICAgcGFydHMuc3BsaWNlKGkgKyAxLCB1cCk7XG4gICAgICAgICAgdXAgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAyKTtcbiAgICAgICAgICB1cC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG5cbiAgICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICAgIHBhdGggPSBpc0Fic29sdXRlID8gJy8nIDogJy4nO1xuICAgIH1cblxuICAgIGlmICh1cmwpIHtcbiAgICAgIHVybC5wYXRoID0gcGF0aDtcbiAgICAgIHJldHVybiB1cmxHZW5lcmF0ZSh1cmwpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBleHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcblxuICAvKipcbiAgICogSm9pbnMgdHdvIHBhdGhzL1VSTHMuXG4gICAqXG4gICAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAgICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBqb2luZWQgd2l0aCB0aGUgcm9vdC5cbiAgICpcbiAgICogLSBJZiBhUGF0aCBpcyBhIFVSTCBvciBhIGRhdGEgVVJJLCBhUGF0aCBpcyByZXR1cm5lZCwgdW5sZXNzIGFQYXRoIGlzIGFcbiAgICogICBzY2hlbWUtcmVsYXRpdmUgVVJMOiBUaGVuIHRoZSBzY2hlbWUgb2YgYVJvb3QsIGlmIGFueSwgaXMgcHJlcGVuZGVkXG4gICAqICAgZmlyc3QuXG4gICAqIC0gT3RoZXJ3aXNlIGFQYXRoIGlzIGEgcGF0aC4gSWYgYVJvb3QgaXMgYSBVUkwsIHRoZW4gaXRzIHBhdGggcG9ydGlvblxuICAgKiAgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx0IGFuZCBhUm9vdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAgICogICBpcyByZXR1cm5lZC5cbiAgICogICAtIElmIGFQYXRoIGlzIGFic29sdXRlLCB0aGUgcmVzdWx0IGlzIGFQYXRoLlxuICAgKiAgIC0gT3RoZXJ3aXNlIHRoZSB0d28gcGF0aHMgYXJlIGpvaW5lZCB3aXRoIGEgc2xhc2guXG4gICAqIC0gSm9pbmluZyBmb3IgZXhhbXBsZSAnaHR0cDovLycgYW5kICd3d3cuZXhhbXBsZS5jb20nIGlzIGFsc28gc3VwcG9ydGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICAgIGFSb290ID0gXCIuXCI7XG4gICAgfVxuICAgIGlmIChhUGF0aCA9PT0gXCJcIikge1xuICAgICAgYVBhdGggPSBcIi5cIjtcbiAgICB9XG4gICAgdmFyIGFQYXRoVXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICAgIHZhciBhUm9vdFVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFSb290ID0gYVJvb3RVcmwucGF0aCB8fCAnLyc7XG4gICAgfVxuXG4gICAgLy8gYGpvaW4oZm9vLCAnLy93d3cuZXhhbXBsZS5vcmcnKWBcbiAgICBpZiAoYVBhdGhVcmwgJiYgIWFQYXRoVXJsLnNjaGVtZSkge1xuICAgICAgaWYgKGFSb290VXJsKSB7XG4gICAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUGF0aFVybCk7XG4gICAgfVxuXG4gICAgaWYgKGFQYXRoVXJsIHx8IGFQYXRoLm1hdGNoKGRhdGFVcmxSZWdleHApKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgLy8gYGpvaW4oJ2h0dHA6Ly8nLCAnd3d3LmV4YW1wbGUuY29tJylgXG4gICAgaWYgKGFSb290VXJsICYmICFhUm9vdFVybC5ob3N0ICYmICFhUm9vdFVybC5wYXRoKSB7XG4gICAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICAgIH1cblxuICAgIHZhciBqb2luZWQgPSBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgPyBhUGF0aFxuICAgICAgOiBub3JtYWxpemUoYVJvb3QucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyBhUGF0aCk7XG5cbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFSb290VXJsLnBhdGggPSBqb2luZWQ7XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICAgIH1cbiAgICByZXR1cm4gam9pbmVkO1xuICB9XG4gIGV4cG9ydHMuam9pbiA9IGpvaW47XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBwYXRoIHJlbGF0aXZlIHRvIGEgVVJMIG9yIGFub3RoZXIgcGF0aC5cbiAgICpcbiAgICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICAgKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIG1hZGUgcmVsYXRpdmUgdG8gYVJvb3QuXG4gICAqL1xuICBmdW5jdGlvbiByZWxhdGl2ZShhUm9vdCwgYVBhdGgpIHtcbiAgICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICAgIGFSb290ID0gXCIuXCI7XG4gICAgfVxuXG4gICAgYVJvb3QgPSBhUm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG4gICAgLy8gSXQgaXMgcG9zc2libGUgZm9yIHRoZSBwYXRoIHRvIGJlIGFib3ZlIHRoZSByb290LiBJbiB0aGlzIGNhc2UsIHNpbXBseVxuICAgIC8vIGNoZWNraW5nIHdoZXRoZXIgdGhlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlIHBhdGggd29uJ3Qgd29yay4gSW5zdGVhZCwgd2VcbiAgICAvLyBuZWVkIHRvIHJlbW92ZSBjb21wb25lbnRzIGZyb20gdGhlIHJvb3Qgb25lIGJ5IG9uZSwgdW50aWwgZWl0aGVyIHdlIGZpbmRcbiAgICAvLyBhIHByZWZpeCB0aGF0IGZpdHMsIG9yIHdlIHJ1biBvdXQgb2YgY29tcG9uZW50cyB0byByZW1vdmUuXG4gICAgdmFyIGxldmVsID0gMDtcbiAgICB3aGlsZSAoYVBhdGguaW5kZXhPZihhUm9vdCArICcvJykgIT09IDApIHtcbiAgICAgIHZhciBpbmRleCA9IGFSb290Lmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGFQYXRoO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgb25seSBwYXJ0IG9mIHRoZSByb290IHRoYXQgaXMgbGVmdCBpcyB0aGUgc2NoZW1lIChpLmUuIGh0dHA6Ly8sXG4gICAgICAvLyBmaWxlOi8vLywgZXRjLiksIG9uZSBvciBtb3JlIHNsYXNoZXMgKC8pLCBvciBzaW1wbHkgbm90aGluZyBhdCBhbGwsIHdlXG4gICAgICAvLyBoYXZlIGV4aGF1c3RlZCBhbGwgY29tcG9uZW50cywgc28gdGhlIHBhdGggaXMgbm90IHJlbGF0aXZlIHRvIHRoZSByb290LlxuICAgICAgYVJvb3QgPSBhUm9vdC5zbGljZSgwLCBpbmRleCk7XG4gICAgICBpZiAoYVJvb3QubWF0Y2goL14oW15cXC9dKzpcXC8pP1xcLyokLykpIHtcbiAgICAgICAgcmV0dXJuIGFQYXRoO1xuICAgICAgfVxuXG4gICAgICArK2xldmVsO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBhZGQgYSBcIi4uL1wiIGZvciBlYWNoIGNvbXBvbmVudCB3ZSByZW1vdmVkIGZyb20gdGhlIHJvb3QuXG4gICAgcmV0dXJuIEFycmF5KGxldmVsICsgMSkuam9pbihcIi4uL1wiKSArIGFQYXRoLnN1YnN0cihhUm9vdC5sZW5ndGggKyAxKTtcbiAgfVxuICBleHBvcnRzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG5cbiAgLyoqXG4gICAqIEJlY2F1c2UgYmVoYXZpb3IgZ29lcyB3YWNreSB3aGVuIHlvdSBzZXQgYF9fcHJvdG9fX2Agb24gb2JqZWN0cywgd2VcbiAgICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICAgKlxuICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9wdWxsLzMxIGFuZFxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIGZ1bmN0aW9uIHRvU2V0U3RyaW5nKGFTdHIpIHtcbiAgICByZXR1cm4gJyQnICsgYVN0cjtcbiAgfVxuICBleHBvcnRzLnRvU2V0U3RyaW5nID0gdG9TZXRTdHJpbmc7XG5cbiAgZnVuY3Rpb24gZnJvbVNldFN0cmluZyhhU3RyKSB7XG4gICAgcmV0dXJuIGFTdHIuc3Vic3RyKDEpO1xuICB9XG4gIGV4cG9ydHMuZnJvbVNldFN0cmluZyA9IGZyb21TZXRTdHJpbmc7XG5cbiAgLyoqXG4gICAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2hlcmUgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gICAqXG4gICAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAgICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4sIGJ1dCBkaWZmZXJlbnQgZ2VuZXJhdGVkXG4gICAqIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhIG1hcHBpbmcgd2l0aCBhXG4gICAqIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyhtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICB2YXIgY21wID0gbWFwcGluZ0Euc291cmNlIC0gbWFwcGluZ0Iuc291cmNlO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGluZ0EubmFtZSAtIG1hcHBpbmdCLm5hbWU7XG4gIH07XG4gIGV4cG9ydHMuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMgPSBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucztcblxuICAvKipcbiAgICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGRlZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBpbmRpY2VzIHdoZXJlXG4gICAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAgICpcbiAgICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICAgKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4sIGJ1dCBkaWZmZXJlbnRcbiAgICogc291cmNlL25hbWUvb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGFcbiAgICogbWFwcGluZyB3aXRoIGEgc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gICAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5zb3VyY2UgLSBtYXBwaW5nQi5zb3VyY2U7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBpbmdBLm5hbWUgLSBtYXBwaW5nQi5uYW1lO1xuICB9O1xuICBleHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQ7XG5cbiAgZnVuY3Rpb24gc3RyY21wKGFTdHIxLCBhU3RyMikge1xuICAgIGlmIChhU3RyMSA9PT0gYVN0cjIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChhU3RyMSA+IGFTdHIyKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGluZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBzdHJpbmdzIHdoZXJlXG4gICAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICAgIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbiAgfTtcbiAgZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkO1xuXG59KTtcbiIsIi8qISFcbiAqIEhhc2hlciA8aHR0cDovL2dpdGh1Yi5jb20vbWlsbGVybWVkZWlyb3MvaGFzaGVyPlxuICogQGF1dGhvciBNaWxsZXIgTWVkZWlyb3NcbiAqIEB2ZXJzaW9uIDEuMi4wICgyMDEzLzExLzExIDAzOjE4IFBNKVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cblxuOyhmdW5jdGlvbiAoKSB7XG52YXIgZmFjdG9yeSA9IGZ1bmN0aW9uKHNpZ25hbHMpe1xuXG4vKmpzaGludCB3aGl0ZTpmYWxzZSovXG4vKmdsb2JhbCBzaWduYWxzOmZhbHNlLCB3aW5kb3c6ZmFsc2UqL1xuXG4vKipcbiAqIEhhc2hlclxuICogQG5hbWVzcGFjZSBIaXN0b3J5IE1hbmFnZXIgZm9yIHJpY2gtbWVkaWEgYXBwbGljYXRpb25zLlxuICogQG5hbWUgaGFzaGVyXG4gKi9cbnZhciBoYXNoZXIgPSAoZnVuY3Rpb24od2luZG93KXtcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBQcml2YXRlIFZhcnNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXJcblxuICAgICAgICAvLyBmcmVxdWVuY3kgdGhhdCBpdCB3aWxsIGNoZWNrIGhhc2ggdmFsdWUgb24gSUUgNi03IHNpbmNlIGl0IGRvZXNuJ3RcbiAgICAgICAgLy8gc3VwcG9ydCB0aGUgaGFzaGNoYW5nZSBldmVudFxuICAgICAgICBQT09MX0lOVEVSVkFMID0gMjUsXG5cbiAgICAgICAgLy8gbG9jYWwgc3RvcmFnZSBmb3IgYnJldml0eSBhbmQgYmV0dGVyIGNvbXByZXNzaW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsXG4gICAgICAgIGhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeSxcbiAgICAgICAgU2lnbmFsID0gc2lnbmFscy5TaWduYWwsXG5cbiAgICAgICAgLy8gbG9jYWwgdmFycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgaGFzaGVyLFxuICAgICAgICBfaGFzaCxcbiAgICAgICAgX2NoZWNrSW50ZXJ2YWwsXG4gICAgICAgIF9pc0FjdGl2ZSxcbiAgICAgICAgX2ZyYW1lLCAvL2lmcmFtZSB1c2VkIGZvciBsZWdhY3kgSUUgKDYtNylcbiAgICAgICAgX2NoZWNrSGlzdG9yeSxcbiAgICAgICAgX2hhc2hWYWxSZWdleHAgPSAvIyguKikkLyxcbiAgICAgICAgX2Jhc2VVcmxSZWdleHAgPSAvKFxcPy4qKXwoXFwjLiopLyxcbiAgICAgICAgX2hhc2hSZWdleHAgPSAvXlxcIy8sXG5cbiAgICAgICAgLy8gc25pZmZpbmcvZmVhdHVyZSBkZXRlY3Rpb24gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vaGFjayBiYXNlZCBvbiB0aGlzOiBodHRwOi8vd2VicmVmbGVjdGlvbi5ibG9nc3BvdC5jb20vMjAwOS8wMS8zMi1ieXRlcy10by1rbm93LWlmLXlvdXItYnJvd3Nlci1pcy1pZS5odG1sXG4gICAgICAgIF9pc0lFID0gKCErXCJcXHYxXCIpLFxuICAgICAgICAvLyBoYXNoY2hhbmdlIGlzIHN1cHBvcnRlZCBieSBGRjMuNissIElFOCssIENocm9tZSA1KywgU2FmYXJpIDUrIGJ1dFxuICAgICAgICAvLyBmZWF0dXJlIGRldGVjdGlvbiBmYWlscyBvbiBJRSBjb21wYXRpYmlsaXR5IG1vZGUsIHNvIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gY2hlY2sgZG9jdW1lbnRNb2RlXG4gICAgICAgIF9pc0hhc2hDaGFuZ2VTdXBwb3J0ZWQgPSAoJ29uaGFzaGNoYW5nZScgaW4gd2luZG93KSAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgIT09IDcsXG4gICAgICAgIC8vY2hlY2sgaWYgaXMgSUU2LTcgc2luY2UgaGFzaCBjaGFuZ2UgaXMgb25seSBzdXBwb3J0ZWQgb24gSUU4KyBhbmRcbiAgICAgICAgLy9jaGFuZ2luZyBoYXNoIHZhbHVlIG9uIElFNi03IGRvZXNuJ3QgZ2VuZXJhdGUgaGlzdG9yeSByZWNvcmQuXG4gICAgICAgIF9pc0xlZ2FjeUlFID0gX2lzSUUgJiYgIV9pc0hhc2hDaGFuZ2VTdXBwb3J0ZWQsXG4gICAgICAgIF9pc0xvY2FsID0gKGxvY2F0aW9uLnByb3RvY29sID09PSAnZmlsZTonKTtcblxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFByaXZhdGUgTWV0aG9kc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGZ1bmN0aW9uIF9lc2NhcGVSZWdFeHAoc3RyKXtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhzdHIgfHwgJycpLnJlcGxhY2UoL1xcVy9nLCBcIlxcXFwkJlwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdHJpbUhhc2goaGFzaCl7XG4gICAgICAgIGlmICghaGFzaCkgcmV0dXJuICcnO1xuICAgICAgICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnXicgKyBfZXNjYXBlUmVnRXhwKGhhc2hlci5wcmVwZW5kSGFzaCkgKyAnfCcgKyBfZXNjYXBlUmVnRXhwKGhhc2hlci5hcHBlbmRIYXNoKSArICckJywgJ2cnKTtcbiAgICAgICAgcmV0dXJuIGhhc2gucmVwbGFjZShyZWdleHAsICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZ2V0V2luZG93SGFzaCgpe1xuICAgICAgICAvL3BhcnNlZCBmdWxsIFVSTCBpbnN0ZWFkIG9mIGdldHRpbmcgd2luZG93LmxvY2F0aW9uLmhhc2ggYmVjYXVzZSBGaXJlZm94IGRlY29kZSBoYXNoIHZhbHVlIChhbmQgYWxsIHRoZSBvdGhlciBicm93c2VycyBkb24ndClcbiAgICAgICAgLy9hbHNvIGJlY2F1c2Ugb2YgSUU4IGJ1ZyB3aXRoIGhhc2ggcXVlcnkgaW4gbG9jYWwgZmlsZSBbaXNzdWUgIzZdXG4gICAgICAgIHZhciByZXN1bHQgPSBfaGFzaFZhbFJlZ2V4cC5leGVjKCBoYXNoZXIuZ2V0VVJMKCkgKTtcbiAgICAgICAgdmFyIHBhdGggPSAocmVzdWx0ICYmIHJlc3VsdFsxXSkgfHwgJyc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGhhc2hlci5yYXc/IHBhdGggOiBkZWNvZGVVUklDb21wb25lbnQocGF0aCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIHVzZXIgZGlkIG5vdCBzZXQgYGhhc2hlci5yYXdgIGFuZCBkZWNvZGVVUklDb21wb25lbnRcbiAgICAgICAgICAvLyB0aHJvd3MgYW4gZXJyb3IgKHNlZSAjNTcpXG4gICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZ2V0RnJhbWVIYXNoKCl7XG4gICAgICAgIHJldHVybiAoX2ZyYW1lKT8gX2ZyYW1lLmNvbnRlbnRXaW5kb3cuZnJhbWVIYXNoIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY3JlYXRlRnJhbWUoKXtcbiAgICAgICAgX2ZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgIF9mcmFtZS5zcmMgPSAnYWJvdXQ6YmxhbmsnO1xuICAgICAgICBfZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChfZnJhbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF91cGRhdGVGcmFtZSgpe1xuICAgICAgICBpZihfZnJhbWUgJiYgX2hhc2ggIT09IF9nZXRGcmFtZUhhc2goKSl7XG4gICAgICAgICAgICB2YXIgZnJhbWVEb2MgPSBfZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgICAgIGZyYW1lRG9jLm9wZW4oKTtcbiAgICAgICAgICAgIC8vdXBkYXRlIGlmcmFtZSBjb250ZW50IHRvIGZvcmNlIG5ldyBoaXN0b3J5IHJlY29yZC5cbiAgICAgICAgICAgIC8vYmFzZWQgb24gUmVhbGx5IFNpbXBsZSBIaXN0b3J5LCBTV0ZBZGRyZXNzIGFuZCBZVUkuaGlzdG9yeS5cbiAgICAgICAgICAgIGZyYW1lRG9jLndyaXRlKCc8aHRtbD48aGVhZD48dGl0bGU+JyArIGRvY3VtZW50LnRpdGxlICsgJzwvdGl0bGU+PHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCI+dmFyIGZyYW1lSGFzaD1cIicgKyBfaGFzaCArICdcIjs8L3NjcmlwdD48L2hlYWQ+PGJvZHk+Jm5ic3A7PC9ib2R5PjwvaHRtbD4nKTtcbiAgICAgICAgICAgIGZyYW1lRG9jLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcmVnaXN0ZXJDaGFuZ2UobmV3SGFzaCwgaXNSZXBsYWNlKXtcbiAgICAgICAgaWYoX2hhc2ggIT09IG5ld0hhc2gpe1xuICAgICAgICAgICAgdmFyIG9sZEhhc2ggPSBfaGFzaDtcbiAgICAgICAgICAgIF9oYXNoID0gbmV3SGFzaDsgLy9zaG91bGQgY29tZSBiZWZvcmUgZXZlbnQgZGlzcGF0Y2ggdG8gbWFrZSBzdXJlIHVzZXIgY2FuIGdldCBwcm9wZXIgdmFsdWUgaW5zaWRlIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICAgIGlmKF9pc0xlZ2FjeUlFKXtcbiAgICAgICAgICAgICAgICBpZighaXNSZXBsYWNlKXtcbiAgICAgICAgICAgICAgICAgICAgX3VwZGF0ZUZyYW1lKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmNvbnRlbnRXaW5kb3cuZnJhbWVIYXNoID0gbmV3SGFzaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXNoZXIuY2hhbmdlZC5kaXNwYXRjaChfdHJpbUhhc2gobmV3SGFzaCksIF90cmltSGFzaChvbGRIYXNoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX2lzTGVnYWN5SUUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfY2hlY2tIaXN0b3J5ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciB3aW5kb3dIYXNoID0gX2dldFdpbmRvd0hhc2goKSxcbiAgICAgICAgICAgICAgICBmcmFtZUhhc2ggPSBfZ2V0RnJhbWVIYXNoKCk7XG4gICAgICAgICAgICBpZihmcmFtZUhhc2ggIT09IF9oYXNoICYmIGZyYW1lSGFzaCAhPT0gd2luZG93SGFzaCl7XG4gICAgICAgICAgICAgICAgLy9kZXRlY3QgY2hhbmdlcyBtYWRlIHByZXNzaW5nIGJyb3dzZXIgaGlzdG9yeSBidXR0b25zLlxuICAgICAgICAgICAgICAgIC8vV29ya2Fyb3VuZCBzaW5jZSBoaXN0b3J5LmJhY2soKSBhbmQgaGlzdG9yeS5mb3J3YXJkKCkgZG9lc24ndFxuICAgICAgICAgICAgICAgIC8vdXBkYXRlIGhhc2ggdmFsdWUgb24gSUU2LzcgYnV0IHVwZGF0ZXMgY29udGVudCBvZiB0aGUgaWZyYW1lLlxuICAgICAgICAgICAgICAgIC8vbmVlZHMgdG8gdHJpbSBoYXNoIHNpbmNlIHZhbHVlIHN0b3JlZCBhbHJlYWR5IGhhdmVcbiAgICAgICAgICAgICAgICAvL3ByZXBlbmRIYXNoICsgYXBwZW5kSGFzaCBmb3IgZmFzdCBjaGVjay5cbiAgICAgICAgICAgICAgICBoYXNoZXIuc2V0SGFzaChfdHJpbUhhc2goZnJhbWVIYXNoKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHdpbmRvd0hhc2ggIT09IF9oYXNoKXtcbiAgICAgICAgICAgICAgICAvL2RldGVjdCBpZiBoYXNoIGNoYW5nZWQgKG1hbnVhbGx5IG9yIHVzaW5nIHNldEhhc2gpXG4gICAgICAgICAgICAgICAgX3JlZ2lzdGVyQ2hhbmdlKHdpbmRvd0hhc2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2NoZWNrSGlzdG9yeSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgd2luZG93SGFzaCA9IF9nZXRXaW5kb3dIYXNoKCk7XG4gICAgICAgICAgICBpZih3aW5kb3dIYXNoICE9PSBfaGFzaCl7XG4gICAgICAgICAgICAgICAgX3JlZ2lzdGVyQ2hhbmdlKHdpbmRvd0hhc2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9hZGRMaXN0ZW5lcihlbG0sIGVUeXBlLCBmbil7XG4gICAgICAgIGlmKGVsbS5hZGRFdmVudExpc3RlbmVyKXtcbiAgICAgICAgICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKGVUeXBlLCBmbiwgZmFsc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsbS5hdHRhY2hFdmVudCl7XG4gICAgICAgICAgICBlbG0uYXR0YWNoRXZlbnQoJ29uJyArIGVUeXBlLCBmbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcmVtb3ZlTGlzdGVuZXIoZWxtLCBlVHlwZSwgZm4pe1xuICAgICAgICBpZihlbG0ucmVtb3ZlRXZlbnRMaXN0ZW5lcil7XG4gICAgICAgICAgICBlbG0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihlVHlwZSwgZm4sIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChlbG0uZGV0YWNoRXZlbnQpe1xuICAgICAgICAgICAgZWxtLmRldGFjaEV2ZW50KCdvbicgKyBlVHlwZSwgZm4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX21ha2VQYXRoKHBhdGhzKXtcbiAgICAgICAgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgICAgIHZhciBwYXRoID0gcGF0aHMuam9pbihoYXNoZXIuc2VwYXJhdG9yKTtcbiAgICAgICAgcGF0aCA9IHBhdGg/IGhhc2hlci5wcmVwZW5kSGFzaCArIHBhdGgucmVwbGFjZShfaGFzaFJlZ2V4cCwgJycpICsgaGFzaGVyLmFwcGVuZEhhc2ggOiBwYXRoO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZW5jb2RlUGF0aChwYXRoKXtcbiAgICAgICAgLy91c2VkIGVuY29kZVVSSSBpbnN0ZWFkIG9mIGVuY29kZVVSSUNvbXBvbmVudCB0byBwcmVzZXJ2ZSAnPycsICcvJyxcbiAgICAgICAgLy8nIycuIEZpeGVzIFNhZmFyaSBidWcgW2lzc3VlICM4XVxuICAgICAgICBwYXRoID0gZW5jb2RlVVJJKHBhdGgpO1xuICAgICAgICBpZihfaXNJRSAmJiBfaXNMb2NhbCl7XG4gICAgICAgICAgICAvL2ZpeCBJRTggbG9jYWwgZmlsZSBidWcgW2lzc3VlICM2XVxuICAgICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFw/LywgJyUzRicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBQdWJsaWMgKEFQSSlcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBoYXNoZXIgPSAvKiogQGxlbmRzIGhhc2hlciAqLyB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGhhc2hlciBWZXJzaW9uIE51bWJlclxuICAgICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAgICogQGNvbnN0YW50XG4gICAgICAgICAqL1xuICAgICAgICBWRVJTSU9OIDogJzEuMi4wJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQm9vbGVhbiBkZWNpZGluZyBpZiBoYXNoZXIgZW5jb2Rlcy9kZWNvZGVzIHRoZSBoYXNoIG9yIG5vdC5cbiAgICAgICAgICogPHVsPlxuICAgICAgICAgKiA8bGk+ZGVmYXVsdCB2YWx1ZTogZmFsc2U7PC9saT5cbiAgICAgICAgICogPC91bD5cbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgcmF3IDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0cmluZyB0aGF0IHNob3VsZCBhbHdheXMgYmUgYWRkZWQgdG8gdGhlIGVuZCBvZiBIYXNoIHZhbHVlLlxuICAgICAgICAgKiA8dWw+XG4gICAgICAgICAqIDxsaT5kZWZhdWx0IHZhbHVlOiAnJzs8L2xpPlxuICAgICAgICAgKiA8bGk+d2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgZnJvbSBgaGFzaGVyLmdldEhhc2goKWA8L2xpPlxuICAgICAgICAgKiA8bGk+YXZvaWQgY29uZmxpY3RzIHdpdGggZWxlbWVudHMgdGhhdCBjb250YWluIElEIGVxdWFsIHRvIGhhc2ggdmFsdWU7PC9saT5cbiAgICAgICAgICogPC91bD5cbiAgICAgICAgICogQHR5cGUgc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBhcHBlbmRIYXNoIDogJycsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0cmluZyB0aGF0IHNob3VsZCBhbHdheXMgYmUgYWRkZWQgdG8gdGhlIGJlZ2lubmluZyBvZiBIYXNoIHZhbHVlLlxuICAgICAgICAgKiA8dWw+XG4gICAgICAgICAqIDxsaT5kZWZhdWx0IHZhbHVlOiAnLyc7PC9saT5cbiAgICAgICAgICogPGxpPndpbGwgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIGZyb20gYGhhc2hlci5nZXRIYXNoKClgPC9saT5cbiAgICAgICAgICogPGxpPmF2b2lkIGNvbmZsaWN0cyB3aXRoIGVsZW1lbnRzIHRoYXQgY29udGFpbiBJRCBlcXVhbCB0byBoYXNoIHZhbHVlOzwvbGk+XG4gICAgICAgICAqIDwvdWw+XG4gICAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlcGVuZEhhc2ggOiAnLycsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0cmluZyB1c2VkIHRvIHNwbGl0IGhhc2ggcGF0aHM7IHVzZWQgYnkgYGhhc2hlci5nZXRIYXNoQXNBcnJheSgpYCB0byBzcGxpdCBwYXRocy5cbiAgICAgICAgICogPHVsPlxuICAgICAgICAgKiA8bGk+ZGVmYXVsdCB2YWx1ZTogJy8nOzwvbGk+XG4gICAgICAgICAqIDwvdWw+XG4gICAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgc2VwYXJhdG9yIDogJy8nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaWduYWwgZGlzcGF0Y2hlZCB3aGVuIGhhc2ggdmFsdWUgY2hhbmdlcy5cbiAgICAgICAgICogLSBwYXNzIGN1cnJlbnQgaGFzaCBhcyAxc3QgcGFyYW1ldGVyIHRvIGxpc3RlbmVycyBhbmQgcHJldmlvdXMgaGFzaCB2YWx1ZSBhcyAybmQgcGFyYW1ldGVyLlxuICAgICAgICAgKiBAdHlwZSBzaWduYWxzLlNpZ25hbFxuICAgICAgICAgKi9cbiAgICAgICAgY2hhbmdlZCA6IG5ldyBTaWduYWwoKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2lnbmFsIGRpc3BhdGNoZWQgd2hlbiBoYXNoZXIgaXMgc3RvcHBlZC5cbiAgICAgICAgICogLSAgcGFzcyBjdXJyZW50IGhhc2ggYXMgZmlyc3QgcGFyYW1ldGVyIHRvIGxpc3RlbmVyc1xuICAgICAgICAgKiBAdHlwZSBzaWduYWxzLlNpZ25hbFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcHBlZCA6IG5ldyBTaWduYWwoKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2lnbmFsIGRpc3BhdGNoZWQgd2hlbiBoYXNoZXIgaXMgaW5pdGlhbGl6ZWQuXG4gICAgICAgICAqIC0gcGFzcyBjdXJyZW50IGhhc2ggYXMgZmlyc3QgcGFyYW1ldGVyIHRvIGxpc3RlbmVycy5cbiAgICAgICAgICogQHR5cGUgc2lnbmFscy5TaWduYWxcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxpemVkIDogbmV3IFNpZ25hbCgpLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydCBsaXN0ZW5pbmcvZGlzcGF0Y2hpbmcgY2hhbmdlcyBpbiB0aGUgaGFzaC9oaXN0b3J5LlxuICAgICAgICAgKiA8dWw+XG4gICAgICAgICAqICAgPGxpPmhhc2hlciB3b24ndCBkaXNwYXRjaCBDSEFOR0UgZXZlbnRzIGJ5IG1hbnVhbGx5IHR5cGluZyBhIG5ldyB2YWx1ZSBvciBwcmVzc2luZyB0aGUgYmFjay9mb3J3YXJkIGJ1dHRvbnMgYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QuPC9saT5cbiAgICAgICAgICogPC91bD5cbiAgICAgICAgICovXG4gICAgICAgIGluaXQgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYoX2lzQWN0aXZlKSByZXR1cm47XG5cbiAgICAgICAgICAgIF9oYXNoID0gX2dldFdpbmRvd0hhc2goKTtcblxuICAgICAgICAgICAgLy90aG91Z2h0IGFib3V0IGJyYW5jaGluZy9vdmVybG9hZGluZyBoYXNoZXIuaW5pdCgpIHRvIGF2b2lkIGNoZWNraW5nIG11bHRpcGxlIHRpbWVzIGJ1dFxuICAgICAgICAgICAgLy9kb24ndCB0aGluayB3b3J0aCBkb2luZyBpdCBzaW5jZSBpdCBwcm9iYWJseSB3b24ndCBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG4gICAgICAgICAgICBpZihfaXNIYXNoQ2hhbmdlU3VwcG9ydGVkKXtcbiAgICAgICAgICAgICAgICBfYWRkTGlzdGVuZXIod2luZG93LCAnaGFzaGNoYW5nZScsIF9jaGVja0hpc3RvcnkpO1xuICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKF9pc0xlZ2FjeUlFKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoISBfZnJhbWUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NyZWF0ZUZyYW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3VwZGF0ZUZyYW1lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jaGVja0ludGVydmFsID0gc2V0SW50ZXJ2YWwoX2NoZWNrSGlzdG9yeSwgUE9PTF9JTlRFUlZBTCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBoYXNoZXIuaW5pdGlhbGl6ZWQuZGlzcGF0Y2goX3RyaW1IYXNoKF9oYXNoKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3AgbGlzdGVuaW5nL2Rpc3BhdGNoaW5nIGNoYW5nZXMgaW4gdGhlIGhhc2gvaGlzdG9yeS5cbiAgICAgICAgICogPHVsPlxuICAgICAgICAgKiAgIDxsaT5oYXNoZXIgd29uJ3QgZGlzcGF0Y2ggQ0hBTkdFIGV2ZW50cyBieSBtYW51YWxseSB0eXBpbmcgYSBuZXcgdmFsdWUgb3IgcHJlc3NpbmcgdGhlIGJhY2svZm9yd2FyZCBidXR0b25zIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsIHVubGVzcyB5b3UgY2FsbCBoYXNoZXIuaW5pdCgpIGFnYWluLjwvbGk+XG4gICAgICAgICAqICAgPGxpPmhhc2hlciB3aWxsIHN0aWxsIGRpc3BhdGNoIGNoYW5nZXMgbWFkZSBwcm9ncmFtYXRpY2FsbHkgYnkgY2FsbGluZyBoYXNoZXIuc2V0SGFzaCgpOzwvbGk+XG4gICAgICAgICAqIDwvdWw+XG4gICAgICAgICAqL1xuICAgICAgICBzdG9wIDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmKCEgX2lzQWN0aXZlKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmKF9pc0hhc2hDaGFuZ2VTdXBwb3J0ZWQpe1xuICAgICAgICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih3aW5kb3csICdoYXNoY2hhbmdlJywgX2NoZWNrSGlzdG9yeSk7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKF9jaGVja0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICBfY2hlY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaGFzaGVyLnN0b3BwZWQuZGlzcGF0Y2goX3RyaW1IYXNoKF9oYXNoKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgIElmIGhhc2hlciBpcyBsaXN0ZW5pbmcgdG8gY2hhbmdlcyBvbiB0aGUgYnJvd3NlciBoaXN0b3J5IGFuZC9vciBoYXNoIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNBY3RpdmUgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIF9pc0FjdGl2ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBGdWxsIFVSTC5cbiAgICAgICAgICovXG4gICAgICAgIGdldFVSTCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gUmV0cmlldmUgVVJMIHdpdGhvdXQgcXVlcnkgc3RyaW5nIGFuZCBoYXNoLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QmFzZVVSTCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gaGFzaGVyLmdldFVSTCgpLnJlcGxhY2UoX2Jhc2VVcmxSZWdleHAsICcnKTsgLy9yZW1vdmVzIGV2ZXJ5dGhpbmcgYWZ0ZXIgJz8nIGFuZC9vciAnIydcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IEhhc2ggdmFsdWUsIGdlbmVyYXRpbmcgYSBuZXcgaGlzdG9yeSByZWNvcmQuXG4gICAgICAgICAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwYXRoICAgIEhhc2ggdmFsdWUgd2l0aG91dCAnIycuIEhhc2hlciB3aWxsIGpvaW5cbiAgICAgICAgICogcGF0aCBzZWdtZW50cyB1c2luZyBgaGFzaGVyLnNlcGFyYXRvcmAgYW5kIHByZXBlbmQvYXBwZW5kIGhhc2ggdmFsdWVcbiAgICAgICAgICogd2l0aCBgaGFzaGVyLmFwcGVuZEhhc2hgIGFuZCBgaGFzaGVyLnByZXBlbmRIYXNoYFxuICAgICAgICAgKiBAZXhhbXBsZSBoYXNoZXIuc2V0SGFzaCgnbG9yZW0nLCAnaXBzdW0nLCAnZG9sb3InKSAtPiAnIy9sb3JlbS9pcHN1bS9kb2xvcidcbiAgICAgICAgICovXG4gICAgICAgIHNldEhhc2ggOiBmdW5jdGlvbihwYXRoKXtcbiAgICAgICAgICAgIHBhdGggPSBfbWFrZVBhdGguYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmKHBhdGggIT09IF9oYXNoKXtcbiAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgc3RvcmUgcmF3IHZhbHVlXG4gICAgICAgICAgICAgICAgX3JlZ2lzdGVyQ2hhbmdlKHBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSBfaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjaGVjayBpZiBwYXRoIGlzIHN0aWxsID09PSBfaGFzaCB0byBhdm9pZCBlcnJvciBpblxuICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIG9mIG11bHRpcGxlIGNvbnNlY3V0aXZlIHJlZGlyZWN0cyBbaXNzdWUgIzM5XVxuICAgICAgICAgICAgICAgICAgICBpZiAoISBoYXNoZXIucmF3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gX2VuY29kZVBhdGgocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSAnIycgKyBwYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IEhhc2ggdmFsdWUgd2l0aG91dCBrZWVwaW5nIHByZXZpb3VzIGhhc2ggb24gdGhlIGhpc3RvcnkgcmVjb3JkLlxuICAgICAgICAgKiBTaW1pbGFyIHRvIGNhbGxpbmcgYHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKFwiIy9oYXNoXCIpYCBidXQgd2lsbCBhbHNvIHdvcmsgb24gSUU2LTcuXG4gICAgICAgICAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwYXRoICAgIEhhc2ggdmFsdWUgd2l0aG91dCAnIycuIEhhc2hlciB3aWxsIGpvaW5cbiAgICAgICAgICogcGF0aCBzZWdtZW50cyB1c2luZyBgaGFzaGVyLnNlcGFyYXRvcmAgYW5kIHByZXBlbmQvYXBwZW5kIGhhc2ggdmFsdWVcbiAgICAgICAgICogd2l0aCBgaGFzaGVyLmFwcGVuZEhhc2hgIGFuZCBgaGFzaGVyLnByZXBlbmRIYXNoYFxuICAgICAgICAgKiBAZXhhbXBsZSBoYXNoZXIucmVwbGFjZUhhc2goJ2xvcmVtJywgJ2lwc3VtJywgJ2RvbG9yJykgLT4gJyMvbG9yZW0vaXBzdW0vZG9sb3InXG4gICAgICAgICAqL1xuICAgICAgICByZXBsYWNlSGFzaCA6IGZ1bmN0aW9uKHBhdGgpe1xuICAgICAgICAgICAgcGF0aCA9IF9tYWtlUGF0aC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYocGF0aCAhPT0gX2hhc2gpe1xuICAgICAgICAgICAgICAgIC8vIHdlIHNob3VsZCBzdG9yZSByYXcgdmFsdWVcbiAgICAgICAgICAgICAgICBfcmVnaXN0ZXJDaGFuZ2UocGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IF9oYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNoZWNrIGlmIHBhdGggaXMgc3RpbGwgPT09IF9oYXNoIHRvIGF2b2lkIGVycm9yIGluXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhc2Ugb2YgbXVsdGlwbGUgY29uc2VjdXRpdmUgcmVkaXJlY3RzIFtpc3N1ZSAjMzldXG4gICAgICAgICAgICAgICAgICAgIGlmICghIGhhc2hlci5yYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBfZW5jb2RlUGF0aChwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSgnIycgKyBwYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gSGFzaCB2YWx1ZSB3aXRob3V0ICcjJywgYGhhc2hlci5hcHBlbmRIYXNoYCBhbmQgYGhhc2hlci5wcmVwZW5kSGFzaGAuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRIYXNoIDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIC8vZGlkbid0IHVzZWQgYWN0dWFsIHZhbHVlIG9mIHRoZSBgd2luZG93LmxvY2F0aW9uLmhhc2hgIHRvIGF2b2lkIGJyZWFraW5nIHRoZSBhcHBsaWNhdGlvbiBpbiBjYXNlIGB3aW5kb3cubG9jYXRpb24uaGFzaGAgaXNuJ3QgYXZhaWxhYmxlIGFuZCBhbHNvIGJlY2F1c2UgdmFsdWUgc2hvdWxkIGFsd2F5cyBiZSBzeW5jaGVkLlxuICAgICAgICAgICAgcmV0dXJuIF90cmltSGFzaChfaGFzaCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBIYXNoIHZhbHVlIHNwbGl0IGludG8gYW4gQXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRIYXNoQXNBcnJheSA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gaGFzaGVyLmdldEhhc2goKS5zcGxpdChoYXNoZXIuc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzLCBzdG9wcyBoYXNoZXIgYW5kIGRlc3Ryb3kgaGFzaGVyIG9iamVjdC5cbiAgICAgICAgICogLSBJTVBPUlRBTlQ6IGhhc2hlciB3b24ndCB3b3JrIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsIGhhc2hlciBPYmplY3Qgd2lsbCBiZSBkZWxldGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZSA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBoYXNoZXIuc3RvcCgpO1xuICAgICAgICAgICAgaGFzaGVyLmluaXRpYWxpemVkLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGhhc2hlci5zdG9wcGVkLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGhhc2hlci5jaGFuZ2VkLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIF9mcmFtZSA9IGhhc2hlciA9IHdpbmRvdy5oYXNoZXIgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0b1N0cmluZyA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gJ1toYXNoZXIgdmVyc2lvbj1cIicrIGhhc2hlci5WRVJTSU9OICsnXCIgaGFzaD1cIicrIGhhc2hlci5nZXRIYXNoKCkgKydcIl0nO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgaGFzaGVyLmluaXRpYWxpemVkLm1lbW9yaXplID0gdHJ1ZTsgLy9zZWUgIzMzXG5cbiAgICByZXR1cm4gaGFzaGVyO1xuXG59KHdpbmRvdykpO1xuXG5cbiAgICByZXR1cm4gaGFzaGVyO1xufTtcblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ3NpZ25hbHMnXSwgZmFjdG9yeSk7XG59IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdzaWduYWxzJykpO1xufSBlbHNlIHtcbiAgICAvKmpzaGludCBzdWI6dHJ1ZSAqL1xuICAgIHdpbmRvd1snaGFzaGVyJ10gPSBmYWN0b3J5KHdpbmRvd1snc2lnbmFscyddKTtcbn1cblxufSgpKTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuIiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG4gIHZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGludmFyaWFudCh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAndGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCVzYC4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSk7XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcik7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YXJpYW50KFxuICAgICAgZmFsc2UsXG4gICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICApO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYm9vbDogc2hpbSxcbiAgICBmdW5jOiBzaGltLFxuICAgIG51bWJlcjogc2hpbSxcbiAgICBvYmplY3Q6IHNoaW0sXG4gICAgc3RyaW5nOiBzaGltLFxuICAgIHN5bWJvbDogc2hpbSxcblxuICAgIGFueTogc2hpbSxcbiAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgIGVsZW1lbnQ6IHNoaW0sXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICBub2RlOiBzaGltLFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICAgIG9uZU9mOiBnZXRTaGltLFxuICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcbiAgICBzaGFwZTogZ2V0U2hpbSxcbiAgICBleGFjdDogZ2V0U2hpbVxuICB9O1xuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZW1wdHlGdW5jdGlvbjtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCVzYCBwcm9wIG9uIGAlc2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nLFxuICAgICAgICAgICAgICBwcm9wRnVsbE5hbWUsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAlcyBhdCBpbmRleCAlcy4nLFxuICAgICAgICAgIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgU3ltYm9sLmZvciAmJlxuICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAweGVhYzc7XG5cbiAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9O1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBhcHBseU1pZGRsZXdhcmU7XG5cbnZhciBfY29tcG9zZSA9IHJlcXVpcmUoJy4vY29tcG9zZScpO1xuXG52YXIgX2NvbXBvc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9zZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RvcmUgZW5oYW5jZXIgdGhhdCBhcHBsaWVzIG1pZGRsZXdhcmUgdG8gdGhlIGRpc3BhdGNoIG1ldGhvZFxuICogb2YgdGhlIFJlZHV4IHN0b3JlLiBUaGlzIGlzIGhhbmR5IGZvciBhIHZhcmlldHkgb2YgdGFza3MsIHN1Y2ggYXMgZXhwcmVzc2luZ1xuICogYXN5bmNocm9ub3VzIGFjdGlvbnMgaW4gYSBjb25jaXNlIG1hbm5lciwgb3IgbG9nZ2luZyBldmVyeSBhY3Rpb24gcGF5bG9hZC5cbiAqXG4gKiBTZWUgYHJlZHV4LXRodW5rYCBwYWNrYWdlIGFzIGFuIGV4YW1wbGUgb2YgdGhlIFJlZHV4IG1pZGRsZXdhcmUuXG4gKlxuICogQmVjYXVzZSBtaWRkbGV3YXJlIGlzIHBvdGVudGlhbGx5IGFzeW5jaHJvbm91cywgdGhpcyBzaG91bGQgYmUgdGhlIGZpcnN0XG4gKiBzdG9yZSBlbmhhbmNlciBpbiB0aGUgY29tcG9zaXRpb24gY2hhaW4uXG4gKlxuICogTm90ZSB0aGF0IGVhY2ggbWlkZGxld2FyZSB3aWxsIGJlIGdpdmVuIHRoZSBgZGlzcGF0Y2hgIGFuZCBgZ2V0U3RhdGVgIGZ1bmN0aW9uc1xuICogYXMgbmFtZWQgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IG1pZGRsZXdhcmVzIFRoZSBtaWRkbGV3YXJlIGNoYWluIHRvIGJlIGFwcGxpZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgc3RvcmUgZW5oYW5jZXIgYXBwbHlpbmcgdGhlIG1pZGRsZXdhcmUuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1pZGRsZXdhcmVzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWlkZGxld2FyZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNyZWF0ZVN0b3JlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgICAgIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcik7XG4gICAgICB2YXIgX2Rpc3BhdGNoID0gc3RvcmUuZGlzcGF0Y2g7XG4gICAgICB2YXIgY2hhaW4gPSBbXTtcblxuICAgICAgdmFyIG1pZGRsZXdhcmVBUEkgPSB7XG4gICAgICAgIGdldFN0YXRlOiBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiBfZGlzcGF0Y2goYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNoYWluID0gbWlkZGxld2FyZXMubWFwKGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgICAgIHJldHVybiBtaWRkbGV3YXJlKG1pZGRsZXdhcmVBUEkpO1xuICAgICAgfSk7XG4gICAgICBfZGlzcGF0Y2ggPSBfY29tcG9zZTJbJ2RlZmF1bHQnXS5hcHBseSh1bmRlZmluZWQsIGNoYWluKShzdG9yZS5kaXNwYXRjaCk7XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RvcmUsIHtcbiAgICAgICAgZGlzcGF0Y2g6IF9kaXNwYXRjaFxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzWydkZWZhdWx0J10gPSBiaW5kQWN0aW9uQ3JlYXRvcnM7XG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uIGNyZWF0b3JzLCBpbnRvIGFuIG9iamVjdCB3aXRoIHRoZVxuICogc2FtZSBrZXlzLCBidXQgd2l0aCBldmVyeSBmdW5jdGlvbiB3cmFwcGVkIGludG8gYSBgZGlzcGF0Y2hgIGNhbGwgc28gdGhleVxuICogbWF5IGJlIGludm9rZWQgZGlyZWN0bHkuIFRoaXMgaXMganVzdCBhIGNvbnZlbmllbmNlIG1ldGhvZCwgYXMgeW91IGNhbiBjYWxsXG4gKiBgc3RvcmUuZGlzcGF0Y2goTXlBY3Rpb25DcmVhdG9ycy5kb1NvbWV0aGluZygpKWAgeW91cnNlbGYganVzdCBmaW5lLlxuICpcbiAqIEZvciBjb252ZW5pZW5jZSwgeW91IGNhbiBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxuICogYW5kIGdldCBhIGZ1bmN0aW9uIGluIHJldHVybi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gYWN0aW9uQ3JlYXRvcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uXG4gKiBjcmVhdG9yIGZ1bmN0aW9ucy4gT25lIGhhbmR5IHdheSB0byBvYnRhaW4gaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXNgXG4gKiBzeW50YXguIFlvdSBtYXkgYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3BhdGNoIFRoZSBgZGlzcGF0Y2hgIGZ1bmN0aW9uIGF2YWlsYWJsZSBvbiB5b3VyIFJlZHV4XG4gKiBzdG9yZS5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBUaGUgb2JqZWN0IG1pbWlja2luZyB0aGUgb3JpZ2luYWwgb2JqZWN0LCBidXQgd2l0aFxuICogZXZlcnkgYWN0aW9uIGNyZWF0b3Igd3JhcHBlZCBpbnRvIHRoZSBgZGlzcGF0Y2hgIGNhbGwuIElmIHlvdSBwYXNzZWQgYVxuICogZnVuY3Rpb24gYXMgYGFjdGlvbkNyZWF0b3JzYCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGFsc28gYmUgYSBzaW5nbGVcbiAqIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSB7XG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgIT09ICdvYmplY3QnIHx8IGFjdGlvbkNyZWF0b3JzID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWN0aW9uQ3JlYXRvcnMgZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGluc3RlYWQgcmVjZWl2ZWQgJyArIChhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBhY3Rpb25DcmVhdG9ycykgKyAnLiAnICsgJ0RpZCB5b3Ugd3JpdGUgXCJpbXBvcnQgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiIGluc3RlYWQgb2YgXCJpbXBvcnQgKiBhcyBBY3Rpb25DcmVhdG9ycyBmcm9tXCI/Jyk7XG4gIH1cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFjdGlvbkNyZWF0b3JzKTtcbiAgdmFyIGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgdmFyIGFjdGlvbkNyZWF0b3IgPSBhY3Rpb25DcmVhdG9yc1trZXldO1xuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn0iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzWydkZWZhdWx0J10gPSBjb21iaW5lUmVkdWNlcnM7XG5cbnZhciBfY3JlYXRlU3RvcmUgPSByZXF1aXJlKCcuL2NyZWF0ZVN0b3JlJyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0KTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShrZXksIGFjdGlvbikge1xuICB2YXIgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcbiAgdmFyIGFjdGlvbk5hbWUgPSBhY3Rpb25UeXBlICYmICdcIicgKyBhY3Rpb25UeXBlLnRvU3RyaW5nKCkgKyAnXCInIHx8ICdhbiBhY3Rpb24nO1xuXG4gIHJldHVybiAnR2l2ZW4gYWN0aW9uICcgKyBhY3Rpb25OYW1lICsgJywgcmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkLiAnICsgJ1RvIGlnbm9yZSBhbiBhY3Rpb24sIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS4gJyArICdJZiB5b3Ugd2FudCB0aGlzIHJlZHVjZXIgdG8gaG9sZCBubyB2YWx1ZSwgeW91IGNhbiByZXR1cm4gbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC4nO1xufVxuXG5mdW5jdGlvbiBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKGlucHV0U3RhdGUsIHJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSkge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBhcmd1bWVudE5hbWUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUID8gJ3ByZWxvYWRlZFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZScgOiAncHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXInO1xuXG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ1N0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCAnICsgJ3RvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy4nO1xuICB9XG5cbiAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyWydkZWZhdWx0J10pKGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuICdUaGUgJyArIGFyZ3VtZW50TmFtZSArICcgaGFzIHVuZXhwZWN0ZWQgdHlwZSBvZiBcIicgKyB7fS50b1N0cmluZy5jYWxsKGlucHV0U3RhdGUpLm1hdGNoKC9cXHMoW2EtenxBLVpdKykvKVsxXSArICdcIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyAnICsgKCdrZXlzOiBcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIicpO1xuICB9XG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgIXVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldO1xuICB9KTtcblxuICB1bmV4cGVjdGVkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XSA9IHRydWU7XG4gIH0pO1xuXG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuICdVbmV4cGVjdGVkICcgKyAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMSA/ICdrZXlzJyA6ICdrZXknKSArICcgJyArICgnXCInICsgdW5leHBlY3RlZEtleXMuam9pbignXCIsIFwiJykgKyAnXCIgZm91bmQgaW4gJyArIGFyZ3VtZW50TmFtZSArICcuICcpICsgJ0V4cGVjdGVkIHRvIGZpbmQgb25lIG9mIHRoZSBrbm93biByZWR1Y2VyIGtleXMgaW5zdGVhZDogJyArICgnXCInICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyAnXCIuIFVuZXhwZWN0ZWQga2V5cyB3aWxsIGJlIGlnbm9yZWQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNoYXBlKHJlZHVjZXJzKSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcmVkdWNlciA9IHJlZHVjZXJzW2tleV07XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHJlZHVjZXIodW5kZWZpbmVkLCB7IHR5cGU6IF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uICcgKyAnSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0ICcgKyAnZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSAnICsgJ25vdCBiZSB1bmRlZmluZWQuIElmIHlvdSBkb25cXCd0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgJyArICd5b3UgY2FuIHVzZSBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLicpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gJ0BAcmVkdXgvUFJPQkVfVU5LTk9XTl9BQ1RJT05fJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgnJykuam9pbignLicpO1xuICAgIGlmICh0eXBlb2YgcmVkdWNlcih1bmRlZmluZWQsIHsgdHlwZTogdHlwZSB9KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gcHJvYmVkIHdpdGggYSByYW5kb20gdHlwZS4gJyArICgnRG9uXFwndCB0cnkgdG8gaGFuZGxlICcgKyBfY3JlYXRlU3RvcmUuQWN0aW9uVHlwZXMuSU5JVCArICcgb3Igb3RoZXIgYWN0aW9ucyBpbiBcInJlZHV4LypcIiAnKSArICduYW1lc3BhY2UuIFRoZXkgYXJlIGNvbnNpZGVyZWQgcHJpdmF0ZS4gSW5zdGVhZCwgeW91IG11c3QgcmV0dXJuIHRoZSAnICsgJ2N1cnJlbnQgc3RhdGUgZm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHVubGVzcyBpdCBpcyB1bmRlZmluZWQsICcgKyAnaW4gd2hpY2ggY2FzZSB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUsIHJlZ2FyZGxlc3Mgb2YgdGhlICcgKyAnYWN0aW9uIHR5cGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLCBidXQgY2FuIGJlIG51bGwuJyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBkaWZmZXJlbnQgcmVkdWNlciBmdW5jdGlvbnMsIGludG8gYSBzaW5nbGVcbiAqIHJlZHVjZXIgZnVuY3Rpb24uIEl0IHdpbGwgY2FsbCBldmVyeSBjaGlsZCByZWR1Y2VyLCBhbmQgZ2F0aGVyIHRoZWlyIHJlc3VsdHNcbiAqIGludG8gYSBzaW5nbGUgc3RhdGUgb2JqZWN0LCB3aG9zZSBrZXlzIGNvcnJlc3BvbmQgdG8gdGhlIGtleXMgb2YgdGhlIHBhc3NlZFxuICogcmVkdWNlciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlZHVjZXJzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgY29ycmVzcG9uZCB0byBkaWZmZXJlbnRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBjb21iaW5lZCBpbnRvIG9uZS4gT25lIGhhbmR5IHdheSB0byBvYnRhaW5cbiAqIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzIHJlZHVjZXJzYCBzeW50YXguIFRoZSByZWR1Y2VycyBtYXkgbmV2ZXIgcmV0dXJuXG4gKiB1bmRlZmluZWQgZm9yIGFueSBhY3Rpb24uIEluc3RlYWQsIHRoZXkgc2hvdWxkIHJldHVybiB0aGVpciBpbml0aWFsIHN0YXRlXG4gKiBpZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZW0gd2FzIHVuZGVmaW5lZCwgYW5kIHRoZSBjdXJyZW50IHN0YXRlIGZvciBhbnlcbiAqIHVucmVjb2duaXplZCBhY3Rpb24uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHJlZHVjZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGV2ZXJ5IHJlZHVjZXIgaW5zaWRlIHRoZVxuICogcGFzc2VkIG9iamVjdCwgYW5kIGJ1aWxkcyBhIHN0YXRlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlLlxuICovXG5mdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgZmluYWxSZWR1Y2VycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IHJlZHVjZXJLZXlzW2ldO1xuXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMlsnZGVmYXVsdCddKSgnTm8gcmVkdWNlciBwcm92aWRlZCBmb3Iga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmluYWxSZWR1Y2Vyc1trZXldID0gcmVkdWNlcnNba2V5XTtcbiAgICB9XG4gIH1cbiAgdmFyIGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcblxuICB2YXIgdW5leHBlY3RlZEtleUNhY2hlID0gdm9pZCAwO1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZSA9IHt9O1xuICB9XG5cbiAgdmFyIHNoYXBlQXNzZXJ0aW9uRXJyb3IgPSB2b2lkIDA7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UmVkdWNlclNoYXBlKGZpbmFsUmVkdWNlcnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2hhcGVBc3NlcnRpb25FcnJvciA9IGU7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gY29tYmluYXRpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzWzFdO1xuXG4gICAgaWYgKHNoYXBlQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICAgIHRocm93IHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKTtcbiAgICAgIGlmICh3YXJuaW5nTWVzc2FnZSkge1xuICAgICAgICAoMCwgX3dhcm5pbmcyWydkZWZhdWx0J10pKHdhcm5pbmdNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBuZXh0U3RhdGUgPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZmluYWxSZWR1Y2VyS2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfa2V5ID0gZmluYWxSZWR1Y2VyS2V5c1tfaV07XG4gICAgICB2YXIgcmVkdWNlciA9IGZpbmFsUmVkdWNlcnNbX2tleV07XG4gICAgICB2YXIgcHJldmlvdXNTdGF0ZUZvcktleSA9IHN0YXRlW19rZXldO1xuICAgICAgdmFyIG5leHRTdGF0ZUZvcktleSA9IHJlZHVjZXIocHJldmlvdXNTdGF0ZUZvcktleSwgYWN0aW9uKTtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFN0YXRlRm9yS2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2UoX2tleSwgYWN0aW9uKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBuZXh0U3RhdGVbX2tleV0gPSBuZXh0U3RhdGVGb3JLZXk7XG4gICAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBuZXh0U3RhdGVGb3JLZXkgIT09IHByZXZpb3VzU3RhdGVGb3JLZXk7XG4gICAgfVxuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gbmV4dFN0YXRlIDogc3RhdGU7XG4gIH07XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNvbXBvc2U7XG4vKipcbiAqIENvbXBvc2VzIHNpbmdsZS1hcmd1bWVudCBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LiBUaGUgcmlnaHRtb3N0XG4gKiBmdW5jdGlvbiBjYW4gdGFrZSBtdWx0aXBsZSBhcmd1bWVudHMgYXMgaXQgcHJvdmlkZXMgdGhlIHNpZ25hdHVyZSBmb3JcbiAqIHRoZSByZXN1bHRpbmcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmNzIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiBvYnRhaW5lZCBieSBjb21wb3NpbmcgdGhlIGFyZ3VtZW50IGZ1bmN0aW9uc1xuICogZnJvbSByaWdodCB0byBsZWZ0LiBGb3IgZXhhbXBsZSwgY29tcG9zZShmLCBnLCBoKSBpcyBpZGVudGljYWwgdG8gZG9pbmdcbiAqICguLi5hcmdzKSA9PiBmKGcoaCguLi5hcmdzKSkpLlxuICovXG5cbmZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmNzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZ1bmNzWzBdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmNzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYShiLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5BY3Rpb25UeXBlcyA9IHVuZGVmaW5lZDtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZVN0b3JlO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbnZhciBfc3ltYm9sT2JzZXJ2YWJsZSA9IHJlcXVpcmUoJ3N5bWJvbC1vYnNlcnZhYmxlJyk7XG5cbnZhciBfc3ltYm9sT2JzZXJ2YWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2xPYnNlcnZhYmxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIFRoZXNlIGFyZSBwcml2YXRlIGFjdGlvbiB0eXBlcyByZXNlcnZlZCBieSBSZWR1eC5cbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqIERvIG5vdCByZWZlcmVuY2UgdGhlc2UgYWN0aW9uIHR5cGVzIGRpcmVjdGx5IGluIHlvdXIgY29kZS5cbiAqL1xudmFyIEFjdGlvblR5cGVzID0gZXhwb3J0cy5BY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogJ0BAcmVkdXgvSU5JVCdcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlZHV4IHN0b3JlIHRoYXQgaG9sZHMgdGhlIHN0YXRlIHRyZWUuXG4gICAqIFRoZSBvbmx5IHdheSB0byBjaGFuZ2UgdGhlIGRhdGEgaW4gdGhlIHN0b3JlIGlzIHRvIGNhbGwgYGRpc3BhdGNoKClgIG9uIGl0LlxuICAgKlxuICAgKiBUaGVyZSBzaG91bGQgb25seSBiZSBhIHNpbmdsZSBzdG9yZSBpbiB5b3VyIGFwcC4gVG8gc3BlY2lmeSBob3cgZGlmZmVyZW50XG4gICAqIHBhcnRzIG9mIHRoZSBzdGF0ZSB0cmVlIHJlc3BvbmQgdG8gYWN0aW9ucywgeW91IG1heSBjb21iaW5lIHNldmVyYWwgcmVkdWNlcnNcbiAgICogaW50byBhIHNpbmdsZSByZWR1Y2VyIGZ1bmN0aW9uIGJ5IHVzaW5nIGBjb21iaW5lUmVkdWNlcnNgLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWR1Y2VyIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlIHRyZWUsIGdpdmVuXG4gICAqIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBhY3Rpb24gdG8gaGFuZGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gW3ByZWxvYWRlZFN0YXRlXSBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAgICogdG8gaHlkcmF0ZSB0aGUgc3RhdGUgZnJvbSB0aGUgc2VydmVyIGluIHVuaXZlcnNhbCBhcHBzLCBvciB0byByZXN0b3JlIGFcbiAgICogcHJldmlvdXNseSBzZXJpYWxpemVkIHVzZXIgc2Vzc2lvbi5cbiAgICogSWYgeW91IHVzZSBgY29tYmluZVJlZHVjZXJzYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXIgZnVuY3Rpb24sIHRoaXMgbXVzdCBiZVxuICAgKiBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyBgY29tYmluZVJlZHVjZXJzYCBrZXlzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZW5oYW5jZXJdIFRoZSBzdG9yZSBlbmhhbmNlci4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAgICogdG8gZW5oYW5jZSB0aGUgc3RvcmUgd2l0aCB0aGlyZC1wYXJ0eSBjYXBhYmlsaXRpZXMgc3VjaCBhcyBtaWRkbGV3YXJlLFxuICAgKiB0aW1lIHRyYXZlbCwgcGVyc2lzdGVuY2UsIGV0Yy4gVGhlIG9ubHkgc3RvcmUgZW5oYW5jZXIgdGhhdCBzaGlwcyB3aXRoIFJlZHV4XG4gICAqIGlzIGBhcHBseU1pZGRsZXdhcmUoKWAuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdG9yZX0gQSBSZWR1eCBzdG9yZSB0aGF0IGxldHMgeW91IHJlYWQgdGhlIHN0YXRlLCBkaXNwYXRjaCBhY3Rpb25zXG4gICAqIGFuZCBzdWJzY3JpYmUgdG8gY2hhbmdlcy5cbiAgICovXG59O2Z1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICB2YXIgX3JlZjI7XG5cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZW5oYW5jZXIgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIHJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50U3RhdGUgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgdmFyIGN1cnJlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xuICB2YXIgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBzdGF0ZSB0cmVlIG1hbmFnZWQgYnkgdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgY3VycmVudCBzdGF0ZSB0cmVlIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuXG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIG5leHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoIWlzU3Vic2NyaWJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuXG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICB2YXIgaW5kZXggPSBuZXh0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbmV4dExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBhY3Rpb24uIEl0IGlzIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGEgc3RhdGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGdpdmVuIGBhY3Rpb25gLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xuICAgKiB3cmFwIHlvdXIgc3RvcmUgY3JlYXRpbmcgZnVuY3Rpb24gaW50byB0aGUgY29ycmVzcG9uZGluZyBtaWRkbGV3YXJlLiBGb3JcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxuICAgKiBzZXNzaW9ucywgb3IgdXNlIHRoZSB0aW1lIHRyYXZlbGxpbmcgYHJlZHV4LWRldnRvb2xzYC4gQW4gYWN0aW9uIG11c3QgaGF2ZVxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCwgaWYgeW91IHVzZSBhIGN1c3RvbSBtaWRkbGV3YXJlLCBpdCBtYXkgd3JhcCBgZGlzcGF0Y2goKWAgdG9cbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxuICAgKi9cbiAgZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyWydkZWZhdWx0J10pKGFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuICcgKyAnVXNlIGN1c3RvbSBtaWRkbGV3YXJlIGZvciBhc3luYyBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gJyArICdIYXZlIHlvdSBtaXNzcGVsbGVkIGEgY29uc3RhbnQ/Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSByZWR1Y2VyIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBzdG9yZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBZb3UgbWlnaHQgbmVlZCB0aGlzIGlmIHlvdXIgYXBwIGltcGxlbWVudHMgY29kZSBzcGxpdHRpbmcgYW5kIHlvdSB3YW50IHRvXG4gICAqIGxvYWQgc29tZSBvZiB0aGUgcmVkdWNlcnMgZHluYW1pY2FsbHkuIFlvdSBtaWdodCBhbHNvIG5lZWQgdGhpcyBpZiB5b3VcbiAgICogaW1wbGVtZW50IGEgaG90IHJlbG9hZGluZyBtZWNoYW5pc20gZm9yIFJlZHV4LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0UmVkdWNlciBUaGUgcmVkdWNlciBmb3IgdGhlIHN0b3JlIHRvIHVzZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0UmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyO1xuICAgIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm9wZXJhYmlsaXR5IHBvaW50IGZvciBvYnNlcnZhYmxlL3JlYWN0aXZlIGxpYnJhcmllcy5cbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgcmV0dXJuIF9yZWYgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlciBBbnkgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gb2JzZXJ2ZXIuXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cbiAgICAgICAqIEByZXR1cm5zIHtzdWJzY3JpcHRpb259IEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXG4gICAgICAgKiBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZhYmxlIGZyb20gdGhlIHN0b3JlLCBhbmQgcHJldmVudCBmdXJ0aGVyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAqL1xuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnNlcnZlciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb2JzZXJ2ZVN0YXRlKCkge1xuICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGdldFN0YXRlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9ic2VydmVTdGF0ZSgpO1xuICAgICAgICB2YXIgdW5zdWJzY3JpYmUgPSBvdXRlclN1YnNjcmliZShvYnNlcnZlU3RhdGUpO1xuICAgICAgICByZXR1cm4geyB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmUgfTtcbiAgICAgIH1cbiAgICB9LCBfcmVmW19zeW1ib2xPYnNlcnZhYmxlMlsnZGVmYXVsdCddXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIF9yZWY7XG4gIH1cblxuICAvLyBXaGVuIGEgc3RvcmUgaXMgY3JlYXRlZCwgYW4gXCJJTklUXCIgYWN0aW9uIGlzIGRpc3BhdGNoZWQgc28gdGhhdCBldmVyeVxuICAvLyByZWR1Y2VyIHJldHVybnMgdGhlaXIgaW5pdGlhbCBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgLy8gdGhlIGluaXRpYWwgc3RhdGUgdHJlZS5cbiAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxuICB9LCBfcmVmMltfc3ltYm9sT2JzZXJ2YWJsZTJbJ2RlZmF1bHQnXV0gPSBvYnNlcnZhYmxlLCBfcmVmMjtcbn0iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvbXBvc2UgPSBleHBvcnRzLmFwcGx5TWlkZGxld2FyZSA9IGV4cG9ydHMuYmluZEFjdGlvbkNyZWF0b3JzID0gZXhwb3J0cy5jb21iaW5lUmVkdWNlcnMgPSBleHBvcnRzLmNyZWF0ZVN0b3JlID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZVN0b3JlID0gcmVxdWlyZSgnLi9jcmVhdGVTdG9yZScpO1xuXG52YXIgX2NyZWF0ZVN0b3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVN0b3JlKTtcblxudmFyIF9jb21iaW5lUmVkdWNlcnMgPSByZXF1aXJlKCcuL2NvbWJpbmVSZWR1Y2VycycpO1xuXG52YXIgX2NvbWJpbmVSZWR1Y2VyczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21iaW5lUmVkdWNlcnMpO1xuXG52YXIgX2JpbmRBY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4vYmluZEFjdGlvbkNyZWF0b3JzJyk7XG5cbnZhciBfYmluZEFjdGlvbkNyZWF0b3JzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpbmRBY3Rpb25DcmVhdG9ycyk7XG5cbnZhciBfYXBwbHlNaWRkbGV3YXJlID0gcmVxdWlyZSgnLi9hcHBseU1pZGRsZXdhcmUnKTtcblxudmFyIF9hcHBseU1pZGRsZXdhcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXBwbHlNaWRkbGV3YXJlKTtcblxudmFyIF9jb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJyk7XG5cbnZhciBfY29tcG9zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb3NlKTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKlxuKiBUaGlzIGlzIGEgZHVtbXkgZnVuY3Rpb24gdG8gY2hlY2sgaWYgdGhlIGZ1bmN0aW9uIG5hbWUgaGFzIGJlZW4gYWx0ZXJlZCBieSBtaW5pZmljYXRpb24uXG4qIElmIHRoZSBmdW5jdGlvbiBoYXMgYmVlbiBtaW5pZmllZCBhbmQgTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJywgd2FybiB0aGUgdXNlci5cbiovXG5mdW5jdGlvbiBpc0NydXNoZWQoKSB7fVxuXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgaXNDcnVzaGVkLm5hbWUgPT09ICdzdHJpbmcnICYmIGlzQ3J1c2hlZC5uYW1lICE9PSAnaXNDcnVzaGVkJykge1xuICAoMCwgX3dhcm5pbmcyWydkZWZhdWx0J10pKCdZb3UgYXJlIGN1cnJlbnRseSB1c2luZyBtaW5pZmllZCBjb2RlIG91dHNpZGUgb2YgTk9ERV9FTlYgPT09IFxcJ3Byb2R1Y3Rpb25cXCcuICcgKyAnVGhpcyBtZWFucyB0aGF0IHlvdSBhcmUgcnVubmluZyBhIHNsb3dlciBkZXZlbG9wbWVudCBidWlsZCBvZiBSZWR1eC4gJyArICdZb3UgY2FuIHVzZSBsb29zZS1lbnZpZnkgKGh0dHBzOi8vZ2l0aHViLmNvbS96ZXJ0b3NoL2xvb3NlLWVudmlmeSkgZm9yIGJyb3dzZXJpZnkgJyArICdvciBEZWZpbmVQbHVnaW4gZm9yIHdlYnBhY2sgKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzAwMzAwMzEpICcgKyAndG8gZW5zdXJlIHlvdSBoYXZlIHRoZSBjb3JyZWN0IGNvZGUgZm9yIHlvdXIgcHJvZHVjdGlvbiBidWlsZC4nKTtcbn1cblxuZXhwb3J0cy5jcmVhdGVTdG9yZSA9IF9jcmVhdGVTdG9yZTJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuY29tYmluZVJlZHVjZXJzID0gX2NvbWJpbmVSZWR1Y2VyczJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuYmluZEFjdGlvbkNyZWF0b3JzID0gX2JpbmRBY3Rpb25DcmVhdG9yczJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuYXBwbHlNaWRkbGV3YXJlID0gX2FwcGx5TWlkZGxld2FyZTJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuY29tcG9zZSA9IF9jb21wb3NlMlsnZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHdhcm5pbmc7XG4vKipcbiAqIFByaW50cyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xufSIsIi8qanNsaW50IG9uZXZhcjp0cnVlLCB1bmRlZjp0cnVlLCBuZXdjYXA6dHJ1ZSwgcmVnZXhwOnRydWUsIGJpdHdpc2U6dHJ1ZSwgbWF4ZXJyOjUwLCBpbmRlbnQ6NCwgd2hpdGU6ZmFsc2UsIG5vbWVuOmZhbHNlLCBwbHVzcGx1czpmYWxzZSAqL1xuLypnbG9iYWwgZGVmaW5lOmZhbHNlLCByZXF1aXJlOmZhbHNlLCBleHBvcnRzOmZhbHNlLCBtb2R1bGU6ZmFsc2UsIHNpZ25hbHM6ZmFsc2UgKi9cblxuLyoqIEBsaWNlbnNlXG4gKiBKUyBTaWduYWxzIDxodHRwOi8vbWlsbGVybWVkZWlyb3MuZ2l0aHViLmNvbS9qcy1zaWduYWxzLz5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogQXV0aG9yOiBNaWxsZXIgTWVkZWlyb3NcbiAqIFZlcnNpb246IDEuMC4wIC0gQnVpbGQ6IDI2OCAoMjAxMi8xMS8yOSAwNTo0OCBQTSlcbiAqL1xuXG4oZnVuY3Rpb24oZ2xvYmFsKXtcblxuICAgIC8vIFNpZ25hbEJpbmRpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIGJpbmRpbmcgYmV0d2VlbiBhIFNpZ25hbCBhbmQgYSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICAgKiA8YnIgLz4tIDxzdHJvbmc+VGhpcyBpcyBhbiBpbnRlcm5hbCBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkbid0IGJlIGNhbGxlZCBieSByZWd1bGFyIHVzZXJzLjwvc3Ryb25nPlxuICAgICAqIDxiciAvPi0gaW5zcGlyZWQgYnkgSm9hIEViZXJ0IEFTMyBTaWduYWxCaW5kaW5nIGFuZCBSb2JlcnQgUGVubmVyJ3MgU2xvdCBjbGFzc2VzLlxuICAgICAqIEBhdXRob3IgTWlsbGVyIE1lZGVpcm9zXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGludGVybmFsXG4gICAgICogQG5hbWUgU2lnbmFsQmluZGluZ1xuICAgICAqIEBwYXJhbSB7U2lnbmFsfSBzaWduYWwgUmVmZXJlbmNlIHRvIFNpZ25hbCBvYmplY3QgdGhhdCBsaXN0ZW5lciBpcyBjdXJyZW50bHkgYm91bmQgdG8uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgSGFuZGxlciBmdW5jdGlvbiBib3VuZCB0byB0aGUgc2lnbmFsLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNPbmNlIElmIGJpbmRpbmcgc2hvdWxkIGJlIGV4ZWN1dGVkIGp1c3Qgb25jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2xpc3RlbmVyQ29udGV4dF0gQ29udGV4dCBvbiB3aGljaCBsaXN0ZW5lciB3aWxsIGJlIGV4ZWN1dGVkIChvYmplY3QgdGhhdCBzaG91bGQgcmVwcmVzZW50IHRoZSBgdGhpc2AgdmFyaWFibGUgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9uKS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ByaW9yaXR5XSBUaGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlIGV2ZW50IGxpc3RlbmVyLiAoZGVmYXVsdCA9IDApLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNpZ25hbEJpbmRpbmcoc2lnbmFsLCBsaXN0ZW5lciwgaXNPbmNlLCBsaXN0ZW5lckNvbnRleHQsIHByaW9yaXR5KSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXIgZnVuY3Rpb24gYm91bmQgdG8gdGhlIHNpZ25hbC5cbiAgICAgICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xpc3RlbmVyID0gbGlzdGVuZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGJpbmRpbmcgc2hvdWxkIGJlIGV4ZWN1dGVkIGp1c3Qgb25jZS5cbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXNPbmNlID0gaXNPbmNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250ZXh0IG9uIHdoaWNoIGxpc3RlbmVyIHdpbGwgYmUgZXhlY3V0ZWQgKG9iamVjdCB0aGF0IHNob3VsZCByZXByZXNlbnQgdGhlIGB0aGlzYCB2YXJpYWJsZSBpbnNpZGUgbGlzdGVuZXIgZnVuY3Rpb24pLlxuICAgICAgICAgKiBAbWVtYmVyT2YgU2lnbmFsQmluZGluZy5wcm90b3R5cGVcbiAgICAgICAgICogQG5hbWUgY29udGV4dFxuICAgICAgICAgKiBAdHlwZSBPYmplY3R8dW5kZWZpbmVkfG51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGV4dCA9IGxpc3RlbmVyQ29udGV4dDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIFNpZ25hbCBvYmplY3QgdGhhdCBsaXN0ZW5lciBpcyBjdXJyZW50bHkgYm91bmQgdG8uXG4gICAgICAgICAqIEB0eXBlIFNpZ25hbFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2lnbmFsID0gc2lnbmFsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0ZW5lciBwcmlvcml0eVxuICAgICAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMDtcbiAgICB9XG5cbiAgICBTaWduYWxCaW5kaW5nLnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYmluZGluZyBpcyBhY3RpdmUgYW5kIHNob3VsZCBiZSBleGVjdXRlZC5cbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlIDogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBwYXJhbWV0ZXJzIHBhc3NlZCB0byBsaXN0ZW5lciBkdXJpbmcgYFNpZ25hbC5kaXNwYXRjaGAgYW5kIGBTaWduYWxCaW5kaW5nLmV4ZWN1dGVgLiAoY3VycmllZCBwYXJhbWV0ZXJzKVxuICAgICAgICAgKiBAdHlwZSBBcnJheXxudWxsXG4gICAgICAgICAqL1xuICAgICAgICBwYXJhbXMgOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsIGxpc3RlbmVyIHBhc3NpbmcgYXJiaXRyYXJ5IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIDxwPklmIGJpbmRpbmcgd2FzIGFkZGVkIHVzaW5nIGBTaWduYWwuYWRkT25jZSgpYCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHNpZ25hbCBkaXNwYXRjaCBxdWV1ZSwgdGhpcyBtZXRob2QgaXMgdXNlZCBpbnRlcm5hbGx5IGZvciB0aGUgc2lnbmFsIGRpc3BhdGNoLjwvcD5cbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gW3BhcmFtc0Fycl0gQXJyYXkgb2YgcGFyYW1ldGVycyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIGxpc3RlbmVyXG4gICAgICAgICAqIEByZXR1cm4geyp9IFZhbHVlIHJldHVybmVkIGJ5IHRoZSBsaXN0ZW5lci5cbiAgICAgICAgICovXG4gICAgICAgIGV4ZWN1dGUgOiBmdW5jdGlvbiAocGFyYW1zQXJyKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlclJldHVybiwgcGFyYW1zO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlICYmICEhdGhpcy5fbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSB0aGlzLnBhcmFtcz8gdGhpcy5wYXJhbXMuY29uY2F0KHBhcmFtc0FycikgOiBwYXJhbXNBcnI7XG4gICAgICAgICAgICAgICAgaGFuZGxlclJldHVybiA9IHRoaXMuX2xpc3RlbmVyLmFwcGx5KHRoaXMuY29udGV4dCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNPbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJSZXR1cm47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGFjaCBiaW5kaW5nIGZyb20gc2lnbmFsLlxuICAgICAgICAgKiAtIGFsaWFzIHRvOiBteVNpZ25hbC5yZW1vdmUobXlCaW5kaW5nLmdldExpc3RlbmVyKCkpO1xuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfSBIYW5kbGVyIGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBzaWduYWwgb3IgYG51bGxgIGlmIGJpbmRpbmcgd2FzIHByZXZpb3VzbHkgZGV0YWNoZWQuXG4gICAgICAgICAqL1xuICAgICAgICBkZXRhY2ggOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0JvdW5kKCk/IHRoaXMuX3NpZ25hbC5yZW1vdmUodGhpcy5fbGlzdGVuZXIsIHRoaXMuY29udGV4dCkgOiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYmluZGluZyBpcyBzdGlsbCBib3VuZCB0byB0aGUgc2lnbmFsIGFuZCBoYXZlIGEgbGlzdGVuZXIuXG4gICAgICAgICAqL1xuICAgICAgICBpc0JvdW5kIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICghIXRoaXMuX3NpZ25hbCAmJiAhIXRoaXMuX2xpc3RlbmVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgU2lnbmFsQmluZGluZyB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgb25jZS5cbiAgICAgICAgICovXG4gICAgICAgIGlzT25jZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc09uY2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBIYW5kbGVyIGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBzaWduYWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRMaXN0ZW5lciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7U2lnbmFsfSBTaWduYWwgdGhhdCBsaXN0ZW5lciBpcyBjdXJyZW50bHkgYm91bmQgdG8uXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTaWduYWwgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGUgaW5zdGFuY2UgcHJvcGVydGllc1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2Rlc3Ryb3kgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc2lnbmFsO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29udGV4dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdbU2lnbmFsQmluZGluZyBpc09uY2U6JyArIHRoaXMuX2lzT25jZSArJywgaXNCb3VuZDonKyB0aGlzLmlzQm91bmQoKSArJywgYWN0aXZlOicgKyB0aGlzLmFjdGl2ZSArICddJztcbiAgICAgICAgfVxuXG4gICAgfTtcblxuXG4vKmdsb2JhbCBTaWduYWxCaW5kaW5nOmZhbHNlKi9cblxuICAgIC8vIFNpZ25hbCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVMaXN0ZW5lcihsaXN0ZW5lciwgZm5OYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ2xpc3RlbmVyIGlzIGEgcmVxdWlyZWQgcGFyYW0gb2Yge2ZufSgpIGFuZCBzaG91bGQgYmUgYSBGdW5jdGlvbi4nLnJlcGxhY2UoJ3tmbn0nLCBmbk5hbWUpICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gZXZlbnQgYnJvYWRjYXN0ZXJcbiAgICAgKiA8YnIgLz4tIGluc3BpcmVkIGJ5IFJvYmVydCBQZW5uZXIncyBBUzMgU2lnbmFscy5cbiAgICAgKiBAbmFtZSBTaWduYWxcbiAgICAgKiBAYXV0aG9yIE1pbGxlciBNZWRlaXJvc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNpZ25hbCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIEFycmF5LjxTaWduYWxCaW5kaW5nPlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYmluZGluZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJldlBhcmFtcyA9IG51bGw7XG5cbiAgICAgICAgLy8gZW5mb3JjZSBkaXNwYXRjaCB0byBhd2F5cyB3b3JrIG9uIHNhbWUgY29udGV4dCAoIzQ3KVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgU2lnbmFsLnByb3RvdHlwZS5kaXNwYXRjaC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIFNpZ25hbC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpZ25hbHMgVmVyc2lvbiBOdW1iZXJcbiAgICAgICAgICogQHR5cGUgU3RyaW5nXG4gICAgICAgICAqIEBjb25zdFxuICAgICAgICAgKi9cbiAgICAgICAgVkVSU0lPTiA6ICcxLjAuMCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIFNpZ25hbCBzaG91bGQga2VlcCByZWNvcmQgb2YgcHJldmlvdXNseSBkaXNwYXRjaGVkIHBhcmFtZXRlcnMgYW5kXG4gICAgICAgICAqIGF1dG9tYXRpY2FsbHkgZXhlY3V0ZSBsaXN0ZW5lciBkdXJpbmcgYGFkZCgpYC9gYWRkT25jZSgpYCBpZiBTaWduYWwgd2FzXG4gICAgICAgICAqIGFscmVhZHkgZGlzcGF0Y2hlZCBiZWZvcmUuXG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIG1lbW9yaXplIDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9zaG91bGRQcm9wYWdhdGUgOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBTaWduYWwgaXMgYWN0aXZlIGFuZCBzaG91bGQgYnJvYWRjYXN0IGV2ZW50cy5cbiAgICAgICAgICogPHA+PHN0cm9uZz5JTVBPUlRBTlQ6PC9zdHJvbmc+IFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBkdXJpbmcgYSBkaXNwYXRjaCB3aWxsIG9ubHkgYWZmZWN0IHRoZSBuZXh0IGRpc3BhdGNoLCBpZiB5b3Ugd2FudCB0byBzdG9wIHRoZSBwcm9wYWdhdGlvbiBvZiBhIHNpZ25hbCB1c2UgYGhhbHQoKWAgaW5zdGVhZC48L3A+XG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZSA6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNPbmNlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbbGlzdGVuZXJDb250ZXh0XVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ByaW9yaXR5XVxuICAgICAgICAgKiBAcmV0dXJuIHtTaWduYWxCaW5kaW5nfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3JlZ2lzdGVyTGlzdGVuZXIgOiBmdW5jdGlvbiAobGlzdGVuZXIsIGlzT25jZSwgbGlzdGVuZXJDb250ZXh0LCBwcmlvcml0eSkge1xuXG4gICAgICAgICAgICB2YXIgcHJldkluZGV4ID0gdGhpcy5faW5kZXhPZkxpc3RlbmVyKGxpc3RlbmVyLCBsaXN0ZW5lckNvbnRleHQpLFxuICAgICAgICAgICAgICAgIGJpbmRpbmc7XG5cbiAgICAgICAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYmluZGluZyA9IHRoaXMuX2JpbmRpbmdzW3ByZXZJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcuaXNPbmNlKCkgIT09IGlzT25jZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgYWRkJysgKGlzT25jZT8gJycgOiAnT25jZScpICsnKCkgdGhlbiBhZGQnKyAoIWlzT25jZT8gJycgOiAnT25jZScpICsnKCkgdGhlIHNhbWUgbGlzdGVuZXIgd2l0aG91dCByZW1vdmluZyB0aGUgcmVsYXRpb25zaGlwIGZpcnN0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmluZGluZyA9IG5ldyBTaWduYWxCaW5kaW5nKHRoaXMsIGxpc3RlbmVyLCBpc09uY2UsIGxpc3RlbmVyQ29udGV4dCwgcHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEJpbmRpbmcoYmluZGluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHRoaXMubWVtb3JpemUgJiYgdGhpcy5fcHJldlBhcmFtcyl7XG4gICAgICAgICAgICAgICAgYmluZGluZy5leGVjdXRlKHRoaXMuX3ByZXZQYXJhbXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYmluZGluZztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtTaWduYWxCaW5kaW5nfSBiaW5kaW5nXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfYWRkQmluZGluZyA6IGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAvL3NpbXBsaWZpZWQgaW5zZXJ0aW9uIHNvcnRcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5fYmluZGluZ3MubGVuZ3RoO1xuICAgICAgICAgICAgZG8geyAtLW47IH0gd2hpbGUgKHRoaXMuX2JpbmRpbmdzW25dICYmIGJpbmRpbmcuX3ByaW9yaXR5IDw9IHRoaXMuX2JpbmRpbmdzW25dLl9wcmlvcml0eSk7XG4gICAgICAgICAgICB0aGlzLl9iaW5kaW5ncy5zcGxpY2UobiArIDEsIDAsIGJpbmRpbmcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfaW5kZXhPZkxpc3RlbmVyIDogZnVuY3Rpb24gKGxpc3RlbmVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuX2JpbmRpbmdzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjdXI7XG4gICAgICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICAgICAgY3VyID0gdGhpcy5fYmluZGluZ3Nbbl07XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5fbGlzdGVuZXIgPT09IGxpc3RlbmVyICYmIGN1ci5jb250ZXh0ID09PSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgbGlzdGVuZXIgd2FzIGF0dGFjaGVkIHRvIFNpZ25hbC5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBpZiBTaWduYWwgaGFzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIuXG4gICAgICAgICAqL1xuICAgICAgICBoYXMgOiBmdW5jdGlvbiAobGlzdGVuZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbmRleE9mTGlzdGVuZXIobGlzdGVuZXIsIGNvbnRleHQpICE9PSAtMTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGEgbGlzdGVuZXIgdG8gdGhlIHNpZ25hbC5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgU2lnbmFsIGhhbmRsZXIgZnVuY3Rpb24uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbbGlzdGVuZXJDb250ZXh0XSBDb250ZXh0IG9uIHdoaWNoIGxpc3RlbmVyIHdpbGwgYmUgZXhlY3V0ZWQgKG9iamVjdCB0aGF0IHNob3VsZCByZXByZXNlbnQgdGhlIGB0aGlzYCB2YXJpYWJsZSBpbnNpZGUgbGlzdGVuZXIgZnVuY3Rpb24pLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ByaW9yaXR5XSBUaGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlIGV2ZW50IGxpc3RlbmVyLiBMaXN0ZW5lcnMgd2l0aCBoaWdoZXIgcHJpb3JpdHkgd2lsbCBiZSBleGVjdXRlZCBiZWZvcmUgbGlzdGVuZXJzIHdpdGggbG93ZXIgcHJpb3JpdHkuIExpc3RlbmVycyB3aXRoIHNhbWUgcHJpb3JpdHkgbGV2ZWwgd2lsbCBiZSBleGVjdXRlZCBhdCB0aGUgc2FtZSBvcmRlciBhcyB0aGV5IHdlcmUgYWRkZWQuIChkZWZhdWx0ID0gMClcbiAgICAgICAgICogQHJldHVybiB7U2lnbmFsQmluZGluZ30gQW4gT2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYmluZGluZyBiZXR3ZWVuIHRoZSBTaWduYWwgYW5kIGxpc3RlbmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgYWRkIDogZnVuY3Rpb24gKGxpc3RlbmVyLCBsaXN0ZW5lckNvbnRleHQsIHByaW9yaXR5KSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyLCAnYWRkJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcihsaXN0ZW5lciwgZmFsc2UsIGxpc3RlbmVyQ29udGV4dCwgcHJpb3JpdHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgbGlzdGVuZXIgdG8gdGhlIHNpZ25hbCB0aGF0IHNob3VsZCBiZSByZW1vdmVkIGFmdGVyIGZpcnN0IGV4ZWN1dGlvbiAod2lsbCBiZSBleGVjdXRlZCBvbmx5IG9uY2UpLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBTaWduYWwgaGFuZGxlciBmdW5jdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtsaXN0ZW5lckNvbnRleHRdIENvbnRleHQgb24gd2hpY2ggbGlzdGVuZXIgd2lsbCBiZSBleGVjdXRlZCAob2JqZWN0IHRoYXQgc2hvdWxkIHJlcHJlc2VudCB0aGUgYHRoaXNgIHZhcmlhYmxlIGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbikuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHldIFRoZSBwcmlvcml0eSBsZXZlbCBvZiB0aGUgZXZlbnQgbGlzdGVuZXIuIExpc3RlbmVycyB3aXRoIGhpZ2hlciBwcmlvcml0eSB3aWxsIGJlIGV4ZWN1dGVkIGJlZm9yZSBsaXN0ZW5lcnMgd2l0aCBsb3dlciBwcmlvcml0eS4gTGlzdGVuZXJzIHdpdGggc2FtZSBwcmlvcml0eSBsZXZlbCB3aWxsIGJlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIG9yZGVyIGFzIHRoZXkgd2VyZSBhZGRlZC4gKGRlZmF1bHQgPSAwKVxuICAgICAgICAgKiBAcmV0dXJuIHtTaWduYWxCaW5kaW5nfSBBbiBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBiaW5kaW5nIGJldHdlZW4gdGhlIFNpZ25hbCBhbmQgbGlzdGVuZXIuXG4gICAgICAgICAqL1xuICAgICAgICBhZGRPbmNlIDogZnVuY3Rpb24gKGxpc3RlbmVyLCBsaXN0ZW5lckNvbnRleHQsIHByaW9yaXR5KSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyLCAnYWRkT25jZScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXIobGlzdGVuZXIsIHRydWUsIGxpc3RlbmVyQ29udGV4dCwgcHJpb3JpdHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgYSBzaW5nbGUgbGlzdGVuZXIgZnJvbSB0aGUgZGlzcGF0Y2ggcXVldWUuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIEhhbmRsZXIgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBFeGVjdXRpb24gY29udGV4dCAoc2luY2UgeW91IGNhbiBhZGQgdGhlIHNhbWUgaGFuZGxlciBtdWx0aXBsZSB0aW1lcyBpZiBleGVjdXRpbmcgaW4gYSBkaWZmZXJlbnQgY29udGV4dCkuXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBMaXN0ZW5lciBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlIDogZnVuY3Rpb24gKGxpc3RlbmVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyLCAncmVtb3ZlJyk7XG5cbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5faW5kZXhPZkxpc3RlbmVyKGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdzW2ldLl9kZXN0cm95KCk7IC8vbm8gcmVhc29uIHRvIGEgU2lnbmFsQmluZGluZyBleGlzdCBpZiBpdCBpc24ndCBhdHRhY2hlZCB0byBhIHNpZ25hbFxuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZnJvbSB0aGUgU2lnbmFsLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQWxsIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLl9iaW5kaW5ncy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ3Nbbl0uX2Rlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdzLmxlbmd0aCA9IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIGxpc3RlbmVycyBhdHRhY2hlZCB0byB0aGUgU2lnbmFsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TnVtTGlzdGVuZXJzIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdzLmxlbmd0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcCBwcm9wYWdhdGlvbiBvZiB0aGUgZXZlbnQsIGJsb2NraW5nIHRoZSBkaXNwYXRjaCB0byBuZXh0IGxpc3RlbmVycyBvbiB0aGUgcXVldWUuXG4gICAgICAgICAqIDxwPjxzdHJvbmc+SU1QT1JUQU5UOjwvc3Ryb25nPiBzaG91bGQgYmUgY2FsbGVkIG9ubHkgZHVyaW5nIHNpZ25hbCBkaXNwYXRjaCwgY2FsbGluZyBpdCBiZWZvcmUvYWZ0ZXIgZGlzcGF0Y2ggd29uJ3QgYWZmZWN0IHNpZ25hbCBicm9hZGNhc3QuPC9wPlxuICAgICAgICAgKiBAc2VlIFNpZ25hbC5wcm90b3R5cGUuZGlzYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgaGFsdCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nob3VsZFByb3BhZ2F0ZSA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwYXRjaC9Ccm9hZGNhc3QgU2lnbmFsIHRvIGFsbCBsaXN0ZW5lcnMgYWRkZWQgdG8gdGhlIHF1ZXVlLlxuICAgICAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJhbXNdIFBhcmFtZXRlcnMgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIGVhY2ggaGFuZGxlci5cbiAgICAgICAgICovXG4gICAgICAgIGRpc3BhdGNoIDogZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKCEgdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXJhbXNBcnIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIG4gPSB0aGlzLl9iaW5kaW5ncy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgYmluZGluZ3M7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm1lbW9yaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldlBhcmFtcyA9IHBhcmFtc0FycjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEgbikge1xuICAgICAgICAgICAgICAgIC8vc2hvdWxkIGNvbWUgYWZ0ZXIgbWVtb3JpemVcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3Muc2xpY2UoKTsgLy9jbG9uZSBhcnJheSBpbiBjYXNlIGFkZC9yZW1vdmUgaXRlbXMgZHVyaW5nIGRpc3BhdGNoXG4gICAgICAgICAgICB0aGlzLl9zaG91bGRQcm9wYWdhdGUgPSB0cnVlOyAvL2luIGNhc2UgYGhhbHRgIHdhcyBjYWxsZWQgYmVmb3JlIGRpc3BhdGNoIG9yIGR1cmluZyB0aGUgcHJldmlvdXMgZGlzcGF0Y2guXG5cbiAgICAgICAgICAgIC8vZXhlY3V0ZSBhbGwgY2FsbGJhY2tzIHVudGlsIGVuZCBvZiB0aGUgbGlzdCBvciB1bnRpbCBhIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYCBvciBzdG9wcyBwcm9wYWdhdGlvblxuICAgICAgICAgICAgLy9yZXZlcnNlIGxvb3Agc2luY2UgbGlzdGVuZXJzIHdpdGggaGlnaGVyIHByaW9yaXR5IHdpbGwgYmUgYWRkZWQgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgICAgICAgICAgZG8geyBuLS07IH0gd2hpbGUgKGJpbmRpbmdzW25dICYmIHRoaXMuX3Nob3VsZFByb3BhZ2F0ZSAmJiBiaW5kaW5nc1tuXS5leGVjdXRlKHBhcmFtc0FycikgIT09IGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9yZ2V0IG1lbW9yaXplZCBhcmd1bWVudHMuXG4gICAgICAgICAqIEBzZWUgU2lnbmFsLm1lbW9yaXplXG4gICAgICAgICAqL1xuICAgICAgICBmb3JnZXQgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5fcHJldlBhcmFtcyA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhbGwgYmluZGluZ3MgZnJvbSBzaWduYWwgYW5kIGRlc3Ryb3kgYW55IHJlZmVyZW5jZSB0byBleHRlcm5hbCBvYmplY3RzIChkZXN0cm95IFNpZ25hbCBvYmplY3QpLlxuICAgICAgICAgKiA8cD48c3Ryb25nPklNUE9SVEFOVDo8L3N0cm9uZz4gY2FsbGluZyBhbnkgbWV0aG9kIG9uIHRoZSBzaWduYWwgaW5zdGFuY2UgYWZ0ZXIgY2FsbGluZyBkaXNwb3NlIHdpbGwgdGhyb3cgZXJyb3JzLjwvcD5cbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2UgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbCgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2JpbmRpbmdzO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3ByZXZQYXJhbXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0b1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnW1NpZ25hbCBhY3RpdmU6JysgdGhpcy5hY3RpdmUgKycgbnVtTGlzdGVuZXJzOicrIHRoaXMuZ2V0TnVtTGlzdGVuZXJzKCkgKyddJztcbiAgICAgICAgfVxuXG4gICAgfTtcblxuXG4gICAgLy8gTmFtZXNwYWNlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvKipcbiAgICAgKiBTaWduYWxzIG5hbWVzcGFjZVxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbmFtZSBzaWduYWxzXG4gICAgICovXG4gICAgdmFyIHNpZ25hbHMgPSBTaWduYWw7XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gZXZlbnQgYnJvYWRjYXN0ZXJcbiAgICAgKiBAc2VlIFNpZ25hbFxuICAgICAqL1xuICAgIC8vIGFsaWFzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoc2VlICNnaC00NClcbiAgICBzaWduYWxzLlNpZ25hbCA9IFNpZ25hbDtcblxuXG5cbiAgICAvL2V4cG9ydHMgdG8gbXVsdGlwbGUgZW52aXJvbm1lbnRzXG4gICAgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKXsgLy9BTURcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNpZ25hbHM7IH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpeyAvL25vZGVcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBzaWduYWxzO1xuICAgIH0gZWxzZSB7IC8vYnJvd3NlclxuICAgICAgICAvL3VzZSBzdHJpbmcgYmVjYXVzZSBvZiBHb29nbGUgY2xvc3VyZSBjb21waWxlciBBRFZBTkNFRF9NT0RFXG4gICAgICAgIC8qanNsaW50IHN1Yjp0cnVlICovXG4gICAgICAgIGdsb2JhbFsnc2lnbmFscyddID0gc2lnbmFscztcbiAgICB9XG5cbn0odGhpcykpO1xuIiwiLyoqXG4gKiBSb290IHJlZmVyZW5jZSBmb3IgaWZyYW1lcy5cbiAqL1xuXG52YXIgcm9vdDtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyAvLyBCcm93c2VyIHdpbmRvd1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gV2ViIFdvcmtlclxuICByb290ID0gc2VsZjtcbn0gZWxzZSB7IC8vIE90aGVyIGVudmlyb25tZW50c1xuICBjb25zb2xlLndhcm4oXCJVc2luZyBicm93c2VyLW9ubHkgdmVyc2lvbiBvZiBzdXBlcmFnZW50IGluIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuICByb290ID0gdGhpcztcbn1cblxudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdlbWl0dGVyJyk7XG52YXIgcmVxdWVzdEJhc2UgPSByZXF1aXJlKCcuL3JlcXVlc3QtYmFzZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pcy1vYmplY3QnKTtcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIG5vb3AoKXt9O1xuXG4vKipcbiAqIEV4cG9zZSBgcmVxdWVzdGAuXG4gKi9cblxudmFyIHJlcXVlc3QgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpLmJpbmQobnVsbCwgUmVxdWVzdCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIFhIUi5cbiAqL1xuXG5yZXF1ZXN0LmdldFhIUiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHJvb3QuWE1MSHR0cFJlcXVlc3RcbiAgICAgICYmICghcm9vdC5sb2NhdGlvbiB8fCAnZmlsZTonICE9IHJvb3QubG9jYXRpb24ucHJvdG9jb2xcbiAgICAgICAgICB8fCAhcm9vdC5BY3RpdmVYT2JqZWN0KSkge1xuICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3Q7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC42LjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuMy4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgfVxuICB0aHJvdyBFcnJvcihcIkJyb3dzZXItb25seSB2ZXJpc29uIG9mIHN1cGVyYWdlbnQgY291bGQgbm90IGZpbmQgWEhSXCIpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGFkZGVkIHRvIHN1cHBvcnQgSUUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciB0cmltID0gJycudHJpbVxuICA/IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMudHJpbSgpOyB9XG4gIDogZnVuY3Rpb24ocykgeyByZXR1cm4gcy5yZXBsYWNlKC8oXlxccyp8XFxzKiQpL2csICcnKTsgfTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShvYmopIHtcbiAgaWYgKCFpc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICB2YXIgcGFpcnMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIG9ialtrZXldKTtcbiAgfVxuICByZXR1cm4gcGFpcnMuam9pbignJicpO1xufVxuXG4vKipcbiAqIEhlbHBzICdzZXJpYWxpemUnIHdpdGggc2VyaWFsaXppbmcgYXJyYXlzLlxuICogTXV0YXRlcyB0aGUgcGFpcnMgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFpcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICovXG5cbmZ1bmN0aW9uIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHZhbCkge1xuICBpZiAodmFsICE9IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB2YWwuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHYpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICBmb3IodmFyIHN1YmtleSBpbiB2YWwpIHtcbiAgICAgICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSArICdbJyArIHN1YmtleSArICddJywgdmFsW3N1YmtleV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpXG4gICAgICAgICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBzZXJpYWxpemF0aW9uIG1ldGhvZC5cbiAqL1xuXG4gcmVxdWVzdC5zZXJpYWxpemVPYmplY3QgPSBzZXJpYWxpemU7XG5cbiAvKipcbiAgKiBQYXJzZSB0aGUgZ2l2ZW4geC13d3ctZm9ybS11cmxlbmNvZGVkIGBzdHJgLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAqIEByZXR1cm4ge09iamVjdH1cbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyKSB7XG4gIHZhciBvYmogPSB7fTtcbiAgdmFyIHBhaXJzID0gc3RyLnNwbGl0KCcmJyk7XG4gIHZhciBwYWlyO1xuICB2YXIgcG9zO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYWlycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHBhaXIgPSBwYWlyc1tpXTtcbiAgICBwb3MgPSBwYWlyLmluZGV4T2YoJz0nKTtcbiAgICBpZiAocG9zID09IC0xKSB7XG4gICAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXIpXSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXIuc2xpY2UoMCwgcG9zKSldID1cbiAgICAgICAgZGVjb2RlVVJJQ29tcG9uZW50KHBhaXIuc2xpY2UocG9zICsgMSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogRXhwb3NlIHBhcnNlci5cbiAqL1xuXG5yZXF1ZXN0LnBhcnNlU3RyaW5nID0gcGFyc2VTdHJpbmc7XG5cbi8qKlxuICogRGVmYXVsdCBNSU1FIHR5cGUgbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnR5cGVzLnhtbCA9ICdhcHBsaWNhdGlvbi94bWwnO1xuICpcbiAqL1xuXG5yZXF1ZXN0LnR5cGVzID0ge1xuICBodG1sOiAndGV4dC9odG1sJyxcbiAganNvbjogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICB4bWw6ICdhcHBsaWNhdGlvbi94bWwnLFxuICB1cmxlbmNvZGVkOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0nOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0tZGF0YSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG4vKipcbiAqIERlZmF1bHQgc2VyaWFsaXphdGlvbiBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQuc2VyaWFsaXplWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKG9iail7XG4gKiAgICAgICByZXR1cm4gJ2dlbmVyYXRlZCB4bWwgaGVyZSc7XG4gKiAgICAgfTtcbiAqXG4gKi9cblxuIHJlcXVlc3Quc2VyaWFsaXplID0ge1xuICAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc6IHNlcmlhbGl6ZSxcbiAgICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5zdHJpbmdpZnlcbiB9O1xuXG4gLyoqXG4gICogRGVmYXVsdCBwYXJzZXJzLlxuICAqXG4gICogICAgIHN1cGVyYWdlbnQucGFyc2VbJ2FwcGxpY2F0aW9uL3htbCddID0gZnVuY3Rpb24oc3RyKXtcbiAgKiAgICAgICByZXR1cm4geyBvYmplY3QgcGFyc2VkIGZyb20gc3RyIH07XG4gICogICAgIH07XG4gICpcbiAgKi9cblxucmVxdWVzdC5wYXJzZSA9IHtcbiAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc6IHBhcnNlU3RyaW5nLFxuICAnYXBwbGljYXRpb24vanNvbic6IEpTT04ucGFyc2Vcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGhlYWRlciBgc3RyYCBpbnRvXG4gKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbWFwcGVkIGZpZWxkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcihzdHIpIHtcbiAgdmFyIGxpbmVzID0gc3RyLnNwbGl0KC9cXHI/XFxuLyk7XG4gIHZhciBmaWVsZHMgPSB7fTtcbiAgdmFyIGluZGV4O1xuICB2YXIgbGluZTtcbiAgdmFyIGZpZWxkO1xuICB2YXIgdmFsO1xuXG4gIGxpbmVzLnBvcCgpOyAvLyB0cmFpbGluZyBDUkxGXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuICAgIGluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAgZmllbGQgPSBsaW5lLnNsaWNlKDAsIGluZGV4KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHRyaW0obGluZS5zbGljZShpbmRleCArIDEpKTtcbiAgICBmaWVsZHNbZmllbGRdID0gdmFsO1xuICB9XG5cbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgbWltZWAgaXMganNvbiBvciBoYXMgK2pzb24gc3RydWN0dXJlZCBzeW50YXggc3VmZml4LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNKU09OKG1pbWUpIHtcbiAgcmV0dXJuIC9bXFwvK11qc29uXFxiLy50ZXN0KG1pbWUpO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbWltZSB0eXBlIGZvciB0aGUgZ2l2ZW4gYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gdHlwZShzdHIpe1xuICByZXR1cm4gc3RyLnNwbGl0KC8gKjsgKi8pLnNoaWZ0KCk7XG59O1xuXG4vKipcbiAqIFJldHVybiBoZWFkZXIgZmllbGQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJhbXMoc3RyKXtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvICo7ICovKS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBzdHIpe1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICo9ICovKSxcbiAgICAgICAga2V5ID0gcGFydHMuc2hpZnQoKSxcbiAgICAgICAgdmFsID0gcGFydHMuc2hpZnQoKTtcblxuICAgIGlmIChrZXkgJiYgdmFsKSBvYmpba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gb2JqO1xuICB9LCB7fSk7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlYCB3aXRoIHRoZSBnaXZlbiBgeGhyYC5cbiAqXG4gKiAgLSBzZXQgZmxhZ3MgKC5vaywgLmVycm9yLCBldGMpXG4gKiAgLSBwYXJzZSBoZWFkZXJcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgQWxpYXNpbmcgYHN1cGVyYWdlbnRgIGFzIGByZXF1ZXN0YCBpcyBuaWNlOlxuICpcbiAqICAgICAgcmVxdWVzdCA9IHN1cGVyYWdlbnQ7XG4gKlxuICogIFdlIGNhbiB1c2UgdGhlIHByb21pc2UtbGlrZSBBUEksIG9yIHBhc3MgY2FsbGJhY2tzOlxuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nKS5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nLCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBTZW5kaW5nIGRhdGEgY2FuIGJlIGNoYWluZWQ6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnNlbmQoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAucG9zdCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogT3IgZnVydGhlciByZWR1Y2VkIHRvIGEgc2luZ2xlIGNhbGwgZm9yIHNpbXBsZSBjYXNlczpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBAcGFyYW0ge1hNTEhUVFBSZXF1ZXN0fSB4aHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBSZXNwb25zZShyZXEsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMucmVxID0gcmVxO1xuICB0aGlzLnhociA9IHRoaXMucmVxLnhocjtcbiAgLy8gcmVzcG9uc2VUZXh0IGlzIGFjY2Vzc2libGUgb25seSBpZiByZXNwb25zZVR5cGUgaXMgJycgb3IgJ3RleHQnIGFuZCBvbiBvbGRlciBicm93c2Vyc1xuICB0aGlzLnRleHQgPSAoKHRoaXMucmVxLm1ldGhvZCAhPSdIRUFEJyAmJiAodGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAnJyB8fCB0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JykpIHx8IHR5cGVvZiB0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICd1bmRlZmluZWQnKVxuICAgICA/IHRoaXMueGhyLnJlc3BvbnNlVGV4dFxuICAgICA6IG51bGw7XG4gIHRoaXMuc3RhdHVzVGV4dCA9IHRoaXMucmVxLnhoci5zdGF0dXNUZXh0O1xuICB0aGlzLl9zZXRTdGF0dXNQcm9wZXJ0aWVzKHRoaXMueGhyLnN0YXR1cyk7XG4gIHRoaXMuaGVhZGVyID0gdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXIodGhpcy54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAvLyBnZXRBbGxSZXNwb25zZUhlYWRlcnMgc29tZXRpbWVzIGZhbHNlbHkgcmV0dXJucyBcIlwiIGZvciBDT1JTIHJlcXVlc3RzLCBidXRcbiAgLy8gZ2V0UmVzcG9uc2VIZWFkZXIgc3RpbGwgd29ya3MuIHNvIHdlIGdldCBjb250ZW50LXR5cGUgZXZlbiBpZiBnZXR0aW5nXG4gIC8vIG90aGVyIGhlYWRlcnMgZmFpbHMuXG4gIHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcbiAgdGhpcy5fc2V0SGVhZGVyUHJvcGVydGllcyh0aGlzLmhlYWRlcik7XG4gIHRoaXMuYm9keSA9IHRoaXMucmVxLm1ldGhvZCAhPSAnSEVBRCdcbiAgICA/IHRoaXMuX3BhcnNlQm9keSh0aGlzLnRleHQgPyB0aGlzLnRleHQgOiB0aGlzLnhoci5yZXNwb25zZSlcbiAgICA6IG51bGw7XG59XG5cbi8qKlxuICogR2V0IGNhc2UtaW5zZW5zaXRpdmUgYGZpZWxkYCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgcmV0dXJuIHRoaXMuaGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIHJlbGF0ZWQgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYC50eXBlYCB0aGUgY29udGVudCB0eXBlIHdpdGhvdXQgcGFyYW1zXG4gKlxuICogQSByZXNwb25zZSBvZiBcIkNvbnRlbnQtVHlwZTogdGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gKiB3aWxsIHByb3ZpZGUgeW91IHdpdGggYSBgLnR5cGVgIG9mIFwidGV4dC9wbGFpblwiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5fc2V0SGVhZGVyUHJvcGVydGllcyA9IGZ1bmN0aW9uKGhlYWRlcil7XG4gIC8vIGNvbnRlbnQtdHlwZVxuICB2YXIgY3QgPSB0aGlzLmhlYWRlclsnY29udGVudC10eXBlJ10gfHwgJyc7XG4gIHRoaXMudHlwZSA9IHR5cGUoY3QpO1xuXG4gIC8vIHBhcmFtc1xuICB2YXIgb2JqID0gcGFyYW1zKGN0KTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikgdGhpc1trZXldID0gb2JqW2tleV07XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBib2R5IGBzdHJgLlxuICpcbiAqIFVzZWQgZm9yIGF1dG8tcGFyc2luZyBvZiBib2RpZXMuIFBhcnNlcnNcbiAqIGFyZSBkZWZpbmVkIG9uIHRoZSBgc3VwZXJhZ2VudC5wYXJzZWAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLl9wYXJzZUJvZHkgPSBmdW5jdGlvbihzdHIpe1xuICB2YXIgcGFyc2UgPSByZXF1ZXN0LnBhcnNlW3RoaXMudHlwZV07XG4gIGlmICghcGFyc2UgJiYgaXNKU09OKHRoaXMudHlwZSkpIHtcbiAgICBwYXJzZSA9IHJlcXVlc3QucGFyc2VbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgfVxuICByZXR1cm4gcGFyc2UgJiYgc3RyICYmIChzdHIubGVuZ3RoIHx8IHN0ciBpbnN0YW5jZW9mIE9iamVjdClcbiAgICA/IHBhcnNlKHN0cilcbiAgICA6IG51bGw7XG59O1xuXG4vKipcbiAqIFNldCBmbGFncyBzdWNoIGFzIGAub2tgIGJhc2VkIG9uIGBzdGF0dXNgLlxuICpcbiAqIEZvciBleGFtcGxlIGEgMnh4IHJlc3BvbnNlIHdpbGwgZ2l2ZSB5b3UgYSBgLm9rYCBvZiBfX3RydWVfX1xuICogd2hlcmVhcyA1eHggd2lsbCBiZSBfX2ZhbHNlX18gYW5kIGAuZXJyb3JgIHdpbGwgYmUgX190cnVlX18uIFRoZVxuICogYC5jbGllbnRFcnJvcmAgYW5kIGAuc2VydmVyRXJyb3JgIGFyZSBhbHNvIGF2YWlsYWJsZSB0byBiZSBtb3JlXG4gKiBzcGVjaWZpYywgYW5kIGAuc3RhdHVzVHlwZWAgaXMgdGhlIGNsYXNzIG9mIGVycm9yIHJhbmdpbmcgZnJvbSAxLi41XG4gKiBzb21ldGltZXMgdXNlZnVsIGZvciBtYXBwaW5nIHJlc3BvbmQgY29sb3JzIGV0Yy5cbiAqXG4gKiBcInN1Z2FyXCIgcHJvcGVydGllcyBhcmUgYWxzbyBkZWZpbmVkIGZvciBjb21tb24gY2FzZXMuIEN1cnJlbnRseSBwcm92aWRpbmc6XG4gKlxuICogICAtIC5ub0NvbnRlbnRcbiAqICAgLSAuYmFkUmVxdWVzdFxuICogICAtIC51bmF1dGhvcml6ZWRcbiAqICAgLSAubm90QWNjZXB0YWJsZVxuICogICAtIC5ub3RGb3VuZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5fc2V0U3RhdHVzUHJvcGVydGllcyA9IGZ1bmN0aW9uKHN0YXR1cyl7XG4gIC8vIGhhbmRsZSBJRTkgYnVnOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMDQ2OTcyL21zaWUtcmV0dXJucy1zdGF0dXMtY29kZS1vZi0xMjIzLWZvci1hamF4LXJlcXVlc3RcbiAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgIHN0YXR1cyA9IDIwNDtcbiAgfVxuXG4gIHZhciB0eXBlID0gc3RhdHVzIC8gMTAwIHwgMDtcblxuICAvLyBzdGF0dXMgLyBjbGFzc1xuICB0aGlzLnN0YXR1cyA9IHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1cztcbiAgdGhpcy5zdGF0dXNUeXBlID0gdHlwZTtcblxuICAvLyBiYXNpY3NcbiAgdGhpcy5pbmZvID0gMSA9PSB0eXBlO1xuICB0aGlzLm9rID0gMiA9PSB0eXBlO1xuICB0aGlzLmNsaWVudEVycm9yID0gNCA9PSB0eXBlO1xuICB0aGlzLnNlcnZlckVycm9yID0gNSA9PSB0eXBlO1xuICB0aGlzLmVycm9yID0gKDQgPT0gdHlwZSB8fCA1ID09IHR5cGUpXG4gICAgPyB0aGlzLnRvRXJyb3IoKVxuICAgIDogZmFsc2U7XG5cbiAgLy8gc3VnYXJcbiAgdGhpcy5hY2NlcHRlZCA9IDIwMiA9PSBzdGF0dXM7XG4gIHRoaXMubm9Db250ZW50ID0gMjA0ID09IHN0YXR1cztcbiAgdGhpcy5iYWRSZXF1ZXN0ID0gNDAwID09IHN0YXR1cztcbiAgdGhpcy51bmF1dGhvcml6ZWQgPSA0MDEgPT0gc3RhdHVzO1xuICB0aGlzLm5vdEFjY2VwdGFibGUgPSA0MDYgPT0gc3RhdHVzO1xuICB0aGlzLm5vdEZvdW5kID0gNDA0ID09IHN0YXR1cztcbiAgdGhpcy5mb3JiaWRkZW4gPSA0MDMgPT0gc3RhdHVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYEVycm9yYCByZXByZXNlbnRhdGl2ZSBvZiB0aGlzIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm4ge0Vycm9yfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUudG9FcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciByZXEgPSB0aGlzLnJlcTtcbiAgdmFyIG1ldGhvZCA9IHJlcS5tZXRob2Q7XG4gIHZhciB1cmwgPSByZXEudXJsO1xuXG4gIHZhciBtc2cgPSAnY2Fubm90ICcgKyBtZXRob2QgKyAnICcgKyB1cmwgKyAnICgnICsgdGhpcy5zdGF0dXMgKyAnKSc7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICBlcnIubWV0aG9kID0gbWV0aG9kO1xuICBlcnIudXJsID0gdXJsO1xuXG4gIHJldHVybiBlcnI7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VgLlxuICovXG5cbnJlcXVlc3QuUmVzcG9uc2UgPSBSZXNwb25zZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXF1ZXN0YCB3aXRoIHRoZSBnaXZlbiBgbWV0aG9kYCBhbmQgYHVybGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fcXVlcnkgPSB0aGlzLl9xdWVyeSB8fCBbXTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMudXJsID0gdXJsO1xuICB0aGlzLmhlYWRlciA9IHt9OyAvLyBwcmVzZXJ2ZXMgaGVhZGVyIG5hbWUgY2FzZVxuICB0aGlzLl9oZWFkZXIgPSB7fTsgLy8gY29lcmNlcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXJjYXNlXG4gIHRoaXMub24oJ2VuZCcsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVyciA9IG51bGw7XG4gICAgdmFyIHJlcyA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgcmVzID0gbmV3IFJlc3BvbnNlKHNlbGYpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgZXJyID0gbmV3IEVycm9yKCdQYXJzZXIgaXMgdW5hYmxlIHRvIHBhcnNlIHRoZSByZXNwb25zZScpO1xuICAgICAgZXJyLnBhcnNlID0gdHJ1ZTtcbiAgICAgIGVyci5vcmlnaW5hbCA9IGU7XG4gICAgICAvLyBpc3N1ZSAjNjc1OiByZXR1cm4gdGhlIHJhdyByZXNwb25zZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgZXJyLnJhd1Jlc3BvbnNlID0gc2VsZi54aHIgJiYgc2VsZi54aHIucmVzcG9uc2VUZXh0ID8gc2VsZi54aHIucmVzcG9uc2VUZXh0IDogbnVsbDtcbiAgICAgIC8vIGlzc3VlICM4NzY6IHJldHVybiB0aGUgaHR0cCBzdGF0dXMgY29kZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgZXJyLnN0YXR1c0NvZGUgPSBzZWxmLnhociAmJiBzZWxmLnhoci5zdGF0dXMgPyBzZWxmLnhoci5zdGF0dXMgOiBudWxsO1xuICAgICAgcmV0dXJuIHNlbGYuY2FsbGJhY2soZXJyKTtcbiAgICB9XG5cbiAgICBzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgcmVzKTtcblxuICAgIHZhciBuZXdfZXJyO1xuICAgIHRyeSB7XG4gICAgICBpZiAocmVzLnN0YXR1cyA8IDIwMCB8fCByZXMuc3RhdHVzID49IDMwMCkge1xuICAgICAgICBuZXdfZXJyID0gbmV3IEVycm9yKHJlcy5zdGF0dXNUZXh0IHx8ICdVbnN1Y2Nlc3NmdWwgSFRUUCByZXNwb25zZScpO1xuICAgICAgICBuZXdfZXJyLm9yaWdpbmFsID0gZXJyO1xuICAgICAgICBuZXdfZXJyLnJlc3BvbnNlID0gcmVzO1xuICAgICAgICBuZXdfZXJyLnN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBuZXdfZXJyID0gZTsgLy8gIzk4NSB0b3VjaGluZyByZXMgbWF5IGNhdXNlIElOVkFMSURfU1RBVEVfRVJSIG9uIG9sZCBBbmRyb2lkXG4gICAgfVxuXG4gICAgLy8gIzEwMDAgZG9uJ3QgY2F0Y2ggZXJyb3JzIGZyb20gdGhlIGNhbGxiYWNrIHRvIGF2b2lkIGRvdWJsZSBjYWxsaW5nIGl0XG4gICAgaWYgKG5ld19lcnIpIHtcbiAgICAgIHNlbGYuY2FsbGJhY2sobmV3X2VyciwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5jYWxsYmFjayhudWxsLCByZXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogTWl4aW4gYEVtaXR0ZXJgIGFuZCBgcmVxdWVzdEJhc2VgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuZm9yICh2YXIga2V5IGluIHJlcXVlc3RCYXNlKSB7XG4gIFJlcXVlc3QucHJvdG90eXBlW2tleV0gPSByZXF1ZXN0QmFzZVtrZXldO1xufVxuXG4vKipcbiAqIFNldCBDb250ZW50LVR5cGUgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCd4bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ2FwcGxpY2F0aW9uL3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQ29udGVudC1UeXBlJywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCByZXNwb25zZVR5cGUgdG8gYHZhbGAuIFByZXNlbnRseSB2YWxpZCByZXNwb25zZVR5cGVzIGFyZSAnYmxvYicgYW5kXG4gKiAnYXJyYXlidWZmZXInLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnJlc3BvbnNlVHlwZSgnYmxvYicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnJlc3BvbnNlVHlwZSA9IGZ1bmN0aW9uKHZhbCl7XG4gIHRoaXMuX3Jlc3BvbnNlVHlwZSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBY2NlcHQgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMuanNvbiA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2VwdFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQWNjZXB0JywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBdXRob3JpemF0aW9uIGZpZWxkIHZhbHVlIHdpdGggYHVzZXJgIGFuZCBgcGFzc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB3aXRoICd0eXBlJyBwcm9wZXJ0eSAnYXV0bycgb3IgJ2Jhc2ljJyAoZGVmYXVsdCAnYmFzaWMnKVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbih1c2VyLCBwYXNzLCBvcHRpb25zKXtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHR5cGU6ICdiYXNpYydcbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgIGNhc2UgJ2Jhc2ljJzpcbiAgICAgIHZhciBzdHIgPSBidG9hKHVzZXIgKyAnOicgKyBwYXNzKTtcbiAgICAgIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBzdHIpO1xuICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXV0byc6XG4gICAgICB0aGlzLnVzZXJuYW1lID0gdXNlcjtcbiAgICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4qIEFkZCBxdWVyeS1zdHJpbmcgYHZhbGAuXG4qXG4qIEV4YW1wbGVzOlxuKlxuKiAgIHJlcXVlc3QuZ2V0KCcvc2hvZXMnKVxuKiAgICAgLnF1ZXJ5KCdzaXplPTEwJylcbiogICAgIC5xdWVyeSh7IGNvbG9yOiAnYmx1ZScgfSlcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWxcbiogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4qIEBhcGkgcHVibGljXG4qL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHZhbCl7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgdmFsKSB2YWwgPSBzZXJpYWxpemUodmFsKTtcbiAgaWYgKHZhbCkgdGhpcy5fcXVlcnkucHVzaCh2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUXVldWUgdGhlIGdpdmVuIGBmaWxlYCBhcyBhbiBhdHRhY2htZW50IHRvIHRoZSBzcGVjaWZpZWQgYGZpZWxkYCxcbiAqIHdpdGggb3B0aW9uYWwgYGZpbGVuYW1lYC5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5hdHRhY2goJ2NvbnRlbnQnLCBuZXcgQmxvYihbJzxhIGlkPVwiYVwiPjxiIGlkPVwiYlwiPmhleSE8L2I+PC9hPiddLCB7IHR5cGU6IFwidGV4dC9odG1sXCJ9KSlcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEBwYXJhbSB7QmxvYnxGaWxlfSBmaWxlXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbihmaWVsZCwgZmlsZSwgZmlsZW5hbWUpe1xuICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChmaWVsZCwgZmlsZSwgZmlsZW5hbWUgfHwgZmlsZS5uYW1lKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5fZ2V0Rm9ybURhdGEgPSBmdW5jdGlvbigpe1xuICBpZiAoIXRoaXMuX2Zvcm1EYXRhKSB7XG4gICAgdGhpcy5fZm9ybURhdGEgPSBuZXcgcm9vdC5Gb3JtRGF0YSgpO1xuICB9XG4gIHJldHVybiB0aGlzLl9mb3JtRGF0YTtcbn07XG5cbi8qKlxuICogSW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIGBlcnJgIGFuZCBgcmVzYFxuICogYW5kIGhhbmRsZSBhcml0eSBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2FsbGJhY2sgPSBmdW5jdGlvbihlcnIsIHJlcyl7XG4gIHZhciBmbiA9IHRoaXMuX2NhbGxiYWNrO1xuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICBmbihlcnIsIHJlcyk7XG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHgtZG9tYWluIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyb3NzRG9tYWluRXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgZXJyID0gbmV3IEVycm9yKCdSZXF1ZXN0IGhhcyBiZWVuIHRlcm1pbmF0ZWRcXG5Qb3NzaWJsZSBjYXVzZXM6IHRoZSBuZXR3b3JrIGlzIG9mZmxpbmUsIE9yaWdpbiBpcyBub3QgYWxsb3dlZCBieSBBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4sIHRoZSBwYWdlIGlzIGJlaW5nIHVubG9hZGVkLCBldGMuJyk7XG4gIGVyci5jcm9zc0RvbWFpbiA9IHRydWU7XG5cbiAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICBlcnIubWV0aG9kID0gdGhpcy5tZXRob2Q7XG4gIGVyci51cmwgPSB0aGlzLnVybDtcblxuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHRpbWVvdXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuX3RpbWVvdXRFcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcigndGltZW91dCBvZiAnICsgdGltZW91dCArICdtcyBleGNlZWRlZCcpO1xuICBlcnIudGltZW91dCA9IHRpbWVvdXQ7XG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cbi8qKlxuICogQ29tcG9zZSBxdWVyeXN0cmluZyB0byBhcHBlbmQgdG8gcmVxLnVybFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLl9hcHBlbmRRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBxdWVyeSA9IHRoaXMuX3F1ZXJ5LmpvaW4oJyYnKTtcbiAgaWYgKHF1ZXJ5KSB7XG4gICAgdGhpcy51cmwgKz0gfnRoaXMudXJsLmluZGV4T2YoJz8nKVxuICAgICAgPyAnJicgKyBxdWVyeVxuICAgICAgOiAnPycgKyBxdWVyeTtcbiAgfVxufTtcblxuLyoqXG4gKiBJbml0aWF0ZSByZXF1ZXN0LCBpbnZva2luZyBjYWxsYmFjayBgZm4ocmVzKWBcbiAqIHdpdGggYW4gaW5zdGFuY2VvZiBgUmVzcG9uc2VgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB4aHIgPSB0aGlzLnhociA9IHJlcXVlc3QuZ2V0WEhSKCk7XG4gIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgdmFyIGRhdGEgPSB0aGlzLl9mb3JtRGF0YSB8fCB0aGlzLl9kYXRhO1xuXG4gIC8vIHN0b3JlIGNhbGxiYWNrXG4gIHRoaXMuX2NhbGxiYWNrID0gZm4gfHwgbm9vcDtcblxuICAvLyBzdGF0ZSBjaGFuZ2VcbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgaWYgKDQgIT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcblxuICAgIC8vIEluIElFOSwgcmVhZHMgdG8gYW55IHByb3BlcnR5IChlLmcuIHN0YXR1cykgb2ZmIG9mIGFuIGFib3J0ZWQgWEhSIHdpbGxcbiAgICAvLyByZXN1bHQgaW4gdGhlIGVycm9yIFwiQ291bGQgbm90IGNvbXBsZXRlIHRoZSBvcGVyYXRpb24gZHVlIHRvIGVycm9yIGMwMGMwMjNmXCJcbiAgICB2YXIgc3RhdHVzO1xuICAgIHRyeSB7IHN0YXR1cyA9IHhoci5zdGF0dXMgfSBjYXRjaChlKSB7IHN0YXR1cyA9IDA7IH1cblxuICAgIGlmICgwID09IHN0YXR1cykge1xuICAgICAgaWYgKHNlbGYudGltZWRvdXQpIHJldHVybiBzZWxmLl90aW1lb3V0RXJyb3IoKTtcbiAgICAgIGlmIChzZWxmLl9hYm9ydGVkKSByZXR1cm47XG4gICAgICByZXR1cm4gc2VsZi5jcm9zc0RvbWFpbkVycm9yKCk7XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZW5kJyk7XG4gIH07XG5cbiAgLy8gcHJvZ3Jlc3NcbiAgdmFyIGhhbmRsZVByb2dyZXNzID0gZnVuY3Rpb24oZGlyZWN0aW9uLCBlKSB7XG4gICAgaWYgKGUudG90YWwgPiAwKSB7XG4gICAgICBlLnBlcmNlbnQgPSBlLmxvYWRlZCAvIGUudG90YWwgKiAxMDA7XG4gICAgfVxuICAgIGUuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIHNlbGYuZW1pdCgncHJvZ3Jlc3MnLCBlKTtcbiAgfVxuICBpZiAodGhpcy5oYXNMaXN0ZW5lcnMoJ3Byb2dyZXNzJykpIHtcbiAgICB0cnkge1xuICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBoYW5kbGVQcm9ncmVzcy5iaW5kKG51bGwsICdkb3dubG9hZCcpO1xuICAgICAgaWYgKHhoci51cGxvYWQpIHtcbiAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3MuYmluZChudWxsLCAndXBsb2FkJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAvLyBBY2Nlc3NpbmcgeGhyLnVwbG9hZCBmYWlscyBpbiBJRSBmcm9tIGEgd2ViIHdvcmtlciwgc28ganVzdCBwcmV0ZW5kIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAvLyBSZXBvcnRlZCBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy84MzcyNDUveG1saHR0cHJlcXVlc3QtdXBsb2FkLXRocm93cy1pbnZhbGlkLWFyZ3VtZW50LXdoZW4tdXNlZC1mcm9tLXdlYi13b3JrZXItY29udGV4dFxuICAgIH1cbiAgfVxuXG4gIC8vIHRpbWVvdXRcbiAgaWYgKHRpbWVvdXQgJiYgIXRoaXMuX3RpbWVyKSB7XG4gICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBzZWxmLnRpbWVkb3V0ID0gdHJ1ZTtcbiAgICAgIHNlbGYuYWJvcnQoKTtcbiAgICB9LCB0aW1lb3V0KTtcbiAgfVxuXG4gIC8vIHF1ZXJ5c3RyaW5nXG4gIHRoaXMuX2FwcGVuZFF1ZXJ5U3RyaW5nKCk7XG5cbiAgLy8gaW5pdGlhdGUgcmVxdWVzdFxuICBpZiAodGhpcy51c2VybmFtZSAmJiB0aGlzLnBhc3N3b3JkKSB7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlLCB0aGlzLnVzZXJuYW1lLCB0aGlzLnBhc3N3b3JkKTtcbiAgfSBlbHNlIHtcbiAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUpO1xuICB9XG5cbiAgLy8gQ09SU1xuICBpZiAodGhpcy5fd2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblxuICAvLyBib2R5XG4gIGlmICgnR0VUJyAhPSB0aGlzLm1ldGhvZCAmJiAnSEVBRCcgIT0gdGhpcy5tZXRob2QgJiYgJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgJiYgIXRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgIC8vIHNlcmlhbGl6ZSBzdHVmZlxuICAgIHZhciBjb250ZW50VHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG4gICAgdmFyIHNlcmlhbGl6ZSA9IHRoaXMuX3NlcmlhbGl6ZXIgfHwgcmVxdWVzdC5zZXJpYWxpemVbY29udGVudFR5cGUgPyBjb250ZW50VHlwZS5zcGxpdCgnOycpWzBdIDogJyddO1xuICAgIGlmICghc2VyaWFsaXplICYmIGlzSlNPTihjb250ZW50VHlwZSkpIHNlcmlhbGl6ZSA9IHJlcXVlc3Quc2VyaWFsaXplWydhcHBsaWNhdGlvbi9qc29uJ107XG4gICAgaWYgKHNlcmlhbGl6ZSkgZGF0YSA9IHNlcmlhbGl6ZShkYXRhKTtcbiAgfVxuXG4gIC8vIHNldCBoZWFkZXIgZmllbGRzXG4gIGZvciAodmFyIGZpZWxkIGluIHRoaXMuaGVhZGVyKSB7XG4gICAgaWYgKG51bGwgPT0gdGhpcy5oZWFkZXJbZmllbGRdKSBjb250aW51ZTtcbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihmaWVsZCwgdGhpcy5oZWFkZXJbZmllbGRdKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9yZXNwb25zZVR5cGUpIHtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gdGhpcy5fcmVzcG9uc2VUeXBlO1xuICB9XG5cbiAgLy8gc2VuZCBzdHVmZlxuICB0aGlzLmVtaXQoJ3JlcXVlc3QnLCB0aGlzKTtcblxuICAvLyBJRTExIHhoci5zZW5kKHVuZGVmaW5lZCkgc2VuZHMgJ3VuZGVmaW5lZCcgc3RyaW5nIGFzIFBPU1QgcGF5bG9hZCAoaW5zdGVhZCBvZiBub3RoaW5nKVxuICAvLyBXZSBuZWVkIG51bGwgaGVyZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICB4aHIuc2VuZCh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcgPyBkYXRhIDogbnVsbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIEV4cG9zZSBgUmVxdWVzdGAuXG4gKi9cblxucmVxdWVzdC5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBHRVQgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LmdldCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnR0VUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEucXVlcnkoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIEhFQUQgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LmhlYWQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0hFQUQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBPUFRJT05TIHF1ZXJ5IHRvIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5vcHRpb25zID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbil7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdPUFRJT05TJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogREVMRVRFIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlbCh1cmwsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0RFTEVURScsIHVybCk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG5yZXF1ZXN0WydkZWwnXSA9IGRlbDtcbnJlcXVlc3RbJ2RlbGV0ZSddID0gZGVsO1xuXG4vKipcbiAqIFBBVENIIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBhdGNoID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbil7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQQVRDSCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBPU1QgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucG9zdCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUE9TVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBVVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wdXQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BVVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuIiwiLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gbnVsbCAhPT0gb2JqICYmICdvYmplY3QnID09PSB0eXBlb2Ygb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBNb2R1bGUgb2YgbWl4ZWQtaW4gZnVuY3Rpb25zIHNoYXJlZCBiZXR3ZWVuIG5vZGUgYW5kIGNsaWVudCBjb2RlXG4gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG5cbi8qKlxuICogQ2xlYXIgcHJldmlvdXMgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBfY2xlYXJUaW1lb3V0KCl7XG4gIHRoaXMuX3RpbWVvdXQgPSAwO1xuICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXNwb25zZSBib2R5IHBhcnNlclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBpbmNvbWluZyBkYXRhIGludG8gcmVxdWVzdC5ib2R5XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGZuKXtcbiAgdGhpcy5fcGFyc2VyID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlcXVlc3QgYm9keSBzZXJpYWxpemVyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGRhdGEgc2V0IHZpYSAuc2VuZCBvciAuYXR0YWNoIGludG8gcGF5bG9hZCB0byBzZW5kXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoZm4pe1xuICB0aGlzLl9zZXJpYWxpemVyID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGltZW91dCB0byBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudGltZW91dCA9IGZ1bmN0aW9uIHRpbWVvdXQobXMpe1xuICB0aGlzLl90aW1lb3V0ID0gbXM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQcm9taXNlIHN1cHBvcnRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RcbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKi9cblxuZXhwb3J0cy50aGVuID0gZnVuY3Rpb24gdGhlbihyZXNvbHZlLCByZWplY3QpIHtcbiAgaWYgKCF0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKGlubmVyUmVzb2x2ZSwgaW5uZXJSZWplY3Qpe1xuICAgICAgc2VsZi5lbmQoZnVuY3Rpb24oZXJyLCByZXMpe1xuICAgICAgICBpZiAoZXJyKSBpbm5lclJlamVjdChlcnIpOyBlbHNlIGlubmVyUmVzb2x2ZShyZXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbn1cblxuZXhwb3J0cy5jYXRjaCA9IGZ1bmN0aW9uKGNiKSB7XG4gIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBjYik7XG59O1xuXG4vKipcbiAqIEFsbG93IGZvciBleHRlbnNpb25cbiAqL1xuXG5leHBvcnRzLnVzZSA9IGZ1bmN0aW9uIHVzZShmbikge1xuICBmbih0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuLyoqXG4gKiBHZXQgcmVxdWVzdCBoZWFkZXIgYGZpZWxkYC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICByZXR1cm4gdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBoZWFkZXIgYGZpZWxkYCB2YWx1ZS5cbiAqIFRoaXMgaXMgYSBkZXByZWNhdGVkIGludGVybmFsIEFQSS4gVXNlIGAuZ2V0KGZpZWxkKWAgaW5zdGVhZC5cbiAqXG4gKiAoZ2V0SGVhZGVyIGlzIG5vIGxvbmdlciB1c2VkIGludGVybmFsbHkgYnkgdGhlIHN1cGVyYWdlbnQgY29kZSBiYXNlKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cbmV4cG9ydHMuZ2V0SGVhZGVyID0gZXhwb3J0cy5nZXQ7XG5cbi8qKlxuICogU2V0IGhlYWRlciBgZmllbGRgIHRvIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0LlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuc2V0KCdYLUFQSS1LZXknLCAnZm9vYmFyJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoeyBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJywgJ1gtQVBJLUtleSc6ICdmb29iYXInIH0pXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuc2V0ID0gZnVuY3Rpb24oZmllbGQsIHZhbCl7XG4gIGlmIChpc09iamVjdChmaWVsZCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZmllbGQpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgZmllbGRba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXSA9IHZhbDtcbiAgdGhpcy5oZWFkZXJbZmllbGRdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnVuc2V0KCdVc2VyLUFnZW50JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqL1xuZXhwb3J0cy51bnNldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgZGVsZXRlIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbiAgZGVsZXRlIHRoaXMuaGVhZGVyW2ZpZWxkXTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlIHRoZSBmaWVsZCBgbmFtZWAgYW5kIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0XG4gKiBmb3IgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIgcmVxdWVzdCBib2RpZXMuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoJ2ZvbycsICdiYXInKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoeyBmb286ICdiYXInLCBiYXo6ICdxdXgnIH0pXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ3xCbG9ifEZpbGV8QnVmZmVyfGZzLlJlYWRTdHJlYW19IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmZpZWxkID0gZnVuY3Rpb24obmFtZSwgdmFsKSB7XG5cbiAgLy8gbmFtZSBzaG91bGQgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIG9iamVjdC5cbiAgaWYgKG51bGwgPT09IG5hbWUgfHwgIHVuZGVmaW5lZCA9PT0gbmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignLmZpZWxkKG5hbWUsIHZhbCkgbmFtZSBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkge1xuICAgICAgdGhpcy5maWVsZChrZXksIG5hbWVba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdmFsIHNob3VsZCBiZSBkZWZpbmVkIG5vd1xuICBpZiAobnVsbCA9PT0gdmFsIHx8IHVuZGVmaW5lZCA9PT0gdmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcuZmllbGQobmFtZSwgdmFsKSB2YWwgY2FuIG5vdCBiZSBlbXB0eScpO1xuICB9XG4gIHRoaXMuX2dldEZvcm1EYXRhKCkuYXBwZW5kKG5hbWUsIHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBYm9ydCB0aGUgcmVxdWVzdCwgYW5kIGNsZWFyIHBvdGVudGlhbCB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLl9hYm9ydGVkID0gdHJ1ZTtcbiAgdGhpcy54aHIgJiYgdGhpcy54aHIuYWJvcnQoKTsgLy8gYnJvd3NlclxuICB0aGlzLnJlcSAmJiB0aGlzLnJlcS5hYm9ydCgpOyAvLyBub2RlXG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gIHRoaXMuZW1pdCgnYWJvcnQnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZSB0cmFuc21pc3Npb24gb2YgY29va2llcyB3aXRoIHgtZG9tYWluIHJlcXVlc3RzLlxuICpcbiAqIE5vdGUgdGhhdCBmb3IgdGhpcyB0byB3b3JrIHRoZSBvcmlnaW4gbXVzdCBub3QgYmVcbiAqIHVzaW5nIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCIgd2l0aCBhIHdpbGRjYXJkLFxuICogYW5kIGFsc28gbXVzdCBzZXQgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiXG4gKiB0byBcInRydWVcIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMud2l0aENyZWRlbnRpYWxzID0gZnVuY3Rpb24oKXtcbiAgLy8gVGhpcyBpcyBicm93c2VyLW9ubHkgZnVuY3Rpb25hbGl0eS4gTm9kZSBzaWRlIGlzIG5vLW9wLlxuICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXggcmVkaXJlY3RzIHRvIGBuYC4gRG9lcyBub3RpbmcgaW4gYnJvd3NlciBYSFIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnJlZGlyZWN0cyA9IGZ1bmN0aW9uKG4pe1xuICB0aGlzLl9tYXhSZWRpcmVjdHMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydCB0byBhIHBsYWluIGphdmFzY3JpcHQgb2JqZWN0IChub3QgSlNPTiBzdHJpbmcpIG9mIHNjYWxhciBwcm9wZXJ0aWVzLlxuICogTm90ZSBhcyB0aGlzIG1ldGhvZCBpcyBkZXNpZ25lZCB0byByZXR1cm4gYSB1c2VmdWwgbm9uLXRoaXMgdmFsdWUsXG4gKiBpdCBjYW5ub3QgYmUgY2hhaW5lZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlc2NyaWJpbmcgbWV0aG9kLCB1cmwsIGFuZCBkYXRhIG9mIHRoaXMgcmVxdWVzdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnRvSlNPTiA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICB1cmw6IHRoaXMudXJsLFxuICAgIGRhdGE6IHRoaXMuX2RhdGEsXG4gICAgaGVhZGVyczogdGhpcy5faGVhZGVyXG4gIH07XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgaG9zdCBvYmplY3QsXG4gKiB3ZSBkb24ndCB3YW50IHRvIHNlcmlhbGl6ZSB0aGVzZSA6KVxuICpcbiAqIFRPRE86IGZ1dHVyZSBwcm9vZiwgbW92ZSB0byBjb21wb2VudCBsYW5kXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuX2lzSG9zdCA9IGZ1bmN0aW9uIF9pc0hvc3Qob2JqKSB7XG4gIHZhciBzdHIgPSB7fS50b1N0cmluZy5jYWxsKG9iaik7XG5cbiAgc3dpdGNoIChzdHIpIHtcbiAgICBjYXNlICdbb2JqZWN0IEZpbGVdJzpcbiAgICBjYXNlICdbb2JqZWN0IEJsb2JdJzpcbiAgICBjYXNlICdbb2JqZWN0IEZvcm1EYXRhXSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogU2VuZCBgZGF0YWAgYXMgdGhlIHJlcXVlc3QgYm9keSwgZGVmYXVsdGluZyB0aGUgYC50eXBlKClgIHRvIFwianNvblwiIHdoZW5cbiAqIGFuIG9iamVjdCBpcyBnaXZlbi5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgICAvLyBtYW51YWwganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdqc29uJylcbiAqICAgICAgICAgLnNlbmQoJ3tcIm5hbWVcIjpcInRqXCJ9JylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBtYW51YWwgeC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCgnbmFtZT10aicpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGRlZmF1bHRzIHRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCgnbmFtZT10b2JpJylcbiAqICAgICAgICAuc2VuZCgnc3BlY2llcz1mZXJyZXQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5zZW5kID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBvYmogPSBpc09iamVjdChkYXRhKTtcbiAgdmFyIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuXG4gIC8vIG1lcmdlXG4gIGlmIChvYmogJiYgaXNPYmplY3QodGhpcy5fZGF0YSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YVtrZXldID0gZGF0YVtrZXldO1xuICAgIH1cbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZGF0YSkge1xuICAgIC8vIGRlZmF1bHQgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gICAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2Zvcm0nKTtcbiAgICB0eXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICBpZiAoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcgPT0gdHlwZSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGFcbiAgICAgICAgPyB0aGlzLl9kYXRhICsgJyYnICsgZGF0YVxuICAgICAgICA6IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RhdGEgPSAodGhpcy5fZGF0YSB8fCAnJykgKyBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGlmICghb2JqIHx8IHRoaXMuX2lzSG9zdChkYXRhKSkgcmV0dXJuIHRoaXM7XG5cbiAgLy8gZGVmYXVsdCB0byBqc29uXG4gIGlmICghdHlwZSkgdGhpcy50eXBlKCdqc29uJyk7XG4gIHJldHVybiB0aGlzO1xufTtcbiIsIi8vIFRoZSBub2RlIGFuZCBicm93c2VyIG1vZHVsZXMgZXhwb3NlIHZlcnNpb25zIG9mIHRoaXMgd2l0aCB0aGVcbi8vIGFwcHJvcHJpYXRlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGJvdW5kIGFzIGZpcnN0IGFyZ3VtZW50XG4vKipcbiAqIElzc3VlIGEgcmVxdWVzdDpcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICByZXF1ZXN0KCdHRVQnLCAnL3VzZXJzJykuZW5kKGNhbGxiYWNrKVxuICogICAgcmVxdWVzdCgnL3VzZXJzJykuZW5kKGNhbGxiYWNrKVxuICogICAgcmVxdWVzdCgnL3VzZXJzJywgY2FsbGJhY2spXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHVybCBvciBjYWxsYmFja1xuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gcmVxdWVzdChSZXF1ZXN0Q29uc3RydWN0b3IsIG1ldGhvZCwgdXJsKSB7XG4gIC8vIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB1cmwpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3RDb25zdHJ1Y3RvcignR0VUJywgbWV0aG9kKS5lbmQodXJsKTtcbiAgfVxuXG4gIC8vIHVybCBmaXJzdFxuICBpZiAoMiA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0Q29uc3RydWN0b3IoJ0dFVCcsIG1ldGhvZCk7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlcXVlc3RDb25zdHJ1Y3RvcihtZXRob2QsIHVybCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWVzdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wb255ZmlsbCA9IHJlcXVpcmUoJy4vcG9ueWZpbGwuanMnKTtcblxudmFyIF9wb255ZmlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb255ZmlsbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHJvb3Q7IC8qIGdsb2JhbCB3aW5kb3cgKi9cblxuXG5pZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gbW9kdWxlO1xufSBlbHNlIHtcbiAgcm9vdCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG59XG5cbnZhciByZXN1bHQgPSAoMCwgX3BvbnlmaWxsMlsnZGVmYXVsdCddKShyb290KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHJlc3VsdDsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGw7XG5mdW5jdGlvbiBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGwocm9vdCkge1xuXHR2YXIgcmVzdWx0O1xuXHR2YXIgX1N5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdGlmICh0eXBlb2YgX1N5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGlmIChfU3ltYm9sLm9ic2VydmFibGUpIHtcblx0XHRcdHJlc3VsdCA9IF9TeW1ib2wub2JzZXJ2YWJsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gX1N5bWJvbCgnb2JzZXJ2YWJsZScpO1xuXHRcdFx0X1N5bWJvbC5vYnNlcnZhYmxlID0gcmVzdWx0O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXN1bHQgPSAnQEBvYnNlcnZhYmxlJztcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59OyIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOS4wXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE4IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgKGBzZWxmYCkgaW4gdGhlIGJyb3dzZXIsIGBnbG9iYWxgXG4gIC8vIG9uIHRoZSBzZXJ2ZXIsIG9yIGB0aGlzYCBpbiBzb21lIHZpcnR1YWwgbWFjaGluZXMuIFdlIHVzZSBgc2VsZmBcbiAgLy8gaW5zdGVhZCBvZiBgd2luZG93YCBmb3IgYFdlYldvcmtlcmAgc3VwcG9ydC5cbiAgdmFyIHJvb3QgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT09IHNlbGYgJiYgc2VsZiB8fFxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwuZ2xvYmFsID09PSBnbG9iYWwgJiYgZ2xvYmFsIHx8XG4gICAgICAgICAgICB0aGlzIHx8XG4gICAgICAgICAgICB7fTtcblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBTeW1ib2xQcm90byA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sLnByb3RvdHlwZSA6IG51bGw7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhciBwdXNoID0gQXJyYXlQcm90by5wdXNoLFxuICAgICAgc2xpY2UgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgICAgdG9TdHJpbmcgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICB2YXIgbmF0aXZlSXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgICBuYXRpdmVLZXlzID0gT2JqZWN0LmtleXMsXG4gICAgICBuYXRpdmVDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4gIC8vIE5ha2VkIGZ1bmN0aW9uIHJlZmVyZW5jZSBmb3Igc3Vycm9nYXRlLXByb3RvdHlwZS1zd2FwcGluZy5cbiAgdmFyIEN0b3IgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICB0aGlzLl93cmFwcGVkID0gb2JqO1xuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGVpciBvbGQgbW9kdWxlIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0LlxuICAvLyAoYG5vZGVUeXBlYCBpcyBjaGVja2VkIHRvIGVuc3VyZSB0aGF0IGBtb2R1bGVgXG4gIC8vIGFuZCBgZXhwb3J0c2AgYXJlIG5vdCBIVE1MIGVsZW1lbnRzLilcbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmICFleHBvcnRzLm5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS45LjAnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICAvLyBUaGUgMi1hcmd1bWVudCBjYXNlIGlzIG9taXR0ZWQgYmVjYXVzZSB3ZeKAmXJlIG5vdCB1c2luZyBpdC5cbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBidWlsdGluSXRlcmF0ZWU7XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgY2FsbGJhY2tzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gZWFjaFxuICAvLyBlbGVtZW50IGluIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIHJlc3VsdCDigJQgZWl0aGVyIGBpZGVudGl0eWAsXG4gIC8vIGFuIGFyYml0cmFyeSBjYWxsYmFjaywgYSBwcm9wZXJ0eSBtYXRjaGVyLCBvciBhIHByb3BlcnR5IGFjY2Vzc29yLlxuICB2YXIgY2IgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAoXy5pdGVyYXRlZSAhPT0gYnVpbHRpbkl0ZXJhdGVlKSByZXR1cm4gXy5pdGVyYXRlZSh2YWx1ZSwgY29udGV4dCk7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBfLmlkZW50aXR5O1xuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gb3B0aW1pemVDYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSAmJiAhXy5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIF8ubWF0Y2hlcih2YWx1ZSk7XG4gICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xuICB9O1xuXG4gIC8vIEV4dGVybmFsIHdyYXBwZXIgZm9yIG91ciBjYWxsYmFjayBnZW5lcmF0b3IuIFVzZXJzIG1heSBjdXN0b21pemVcbiAgLy8gYF8uaXRlcmF0ZWVgIGlmIHRoZXkgd2FudCBhZGRpdGlvbmFsIHByZWRpY2F0ZS9pdGVyYXRlZSBzaG9ydGhhbmQgc3R5bGVzLlxuICAvLyBUaGlzIGFic3RyYWN0aW9uIGhpZGVzIHRoZSBpbnRlcm5hbC1vbmx5IGFyZ0NvdW50IGFyZ3VtZW50LlxuICBfLml0ZXJhdGVlID0gYnVpbHRpbkl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY2IodmFsdWUsIGNvbnRleHQsIEluZmluaXR5KTtcbiAgfTtcblxuICAvLyBTb21lIGZ1bmN0aW9ucyB0YWtlIGEgdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cywgb3IgYSBmZXcgZXhwZWN0ZWRcbiAgLy8gYXJndW1lbnRzIGF0IHRoZSBiZWdpbm5pbmcgYW5kIHRoZW4gYSB2YXJpYWJsZSBudW1iZXIgb2YgdmFsdWVzIHRvIG9wZXJhdGVcbiAgLy8gb24uIFRoaXMgaGVscGVyIGFjY3VtdWxhdGVzIGFsbCByZW1haW5pbmcgYXJndW1lbnRzIHBhc3QgdGhlIGZ1bmN0aW9u4oCZc1xuICAvLyBhcmd1bWVudCBsZW5ndGggKG9yIGFuIGV4cGxpY2l0IGBzdGFydEluZGV4YCksIGludG8gYW4gYXJyYXkgdGhhdCBiZWNvbWVzXG4gIC8vIHRoZSBsYXN0IGFyZ3VtZW50LiBTaW1pbGFyIHRvIEVTNuKAmXMgXCJyZXN0IHBhcmFtZXRlclwiLlxuICB2YXIgcmVzdEFyZ3VtZW50cyA9IGZ1bmN0aW9uKGZ1bmMsIHN0YXJ0SW5kZXgpIHtcbiAgICBzdGFydEluZGV4ID0gc3RhcnRJbmRleCA9PSBudWxsID8gZnVuYy5sZW5ndGggLSAxIDogK3N0YXJ0SW5kZXg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KGFyZ3VtZW50cy5sZW5ndGggLSBzdGFydEluZGV4LCAwKSxcbiAgICAgICAgICByZXN0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgcmVzdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXggKyBzdGFydEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoc3RhcnRJbmRleCkge1xuICAgICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpcywgcmVzdCk7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0sIHJlc3QpO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIHJlc3QpO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBBcnJheShzdGFydEluZGV4ICsgMSk7XG4gICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBzdGFydEluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGFyZ3Nbc3RhcnRJbmRleF0gPSByZXN0O1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBhbm90aGVyLlxuICB2YXIgYmFzZUNyZWF0ZSA9IGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgIGlmICghXy5pc09iamVjdChwcm90b3R5cGUpKSByZXR1cm4ge307XG4gICAgaWYgKG5hdGl2ZUNyZWF0ZSkgcmV0dXJuIG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgIEN0b3IucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcjtcbiAgICBDdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgc2hhbGxvd1Byb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZGVlcEdldCA9IGZ1bmN0aW9uKG9iaiwgcGF0aCkge1xuICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgICBvYmogPSBvYmpbcGF0aFtpXV07XG4gICAgfVxuICAgIHJldHVybiBsZW5ndGggPyBvYmogOiB2b2lkIDA7XG4gIH07XG5cbiAgLy8gSGVscGVyIGZvciBjb2xsZWN0aW9uIG1ldGhvZHMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBjb2xsZWN0aW9uXG4gIC8vIHNob3VsZCBiZSBpdGVyYXRlZCBhcyBhbiBhcnJheSBvciBhcyBhbiBvYmplY3QuXG4gIC8vIFJlbGF0ZWQ6IGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoXG4gIC8vIEF2b2lkcyBhIHZlcnkgbmFzdHkgaU9TIDggSklUIGJ1ZyBvbiBBUk0tNjQuICMyMDk0XG4gIHZhciBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICB2YXIgZ2V0TGVuZ3RoID0gc2hhbGxvd1Byb3BlcnR5KCdsZW5ndGgnKTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIHZhciBjcmVhdGVSZWR1Y2UgPSBmdW5jdGlvbihkaXIpIHtcbiAgICAvLyBXcmFwIGNvZGUgdGhhdCByZWFzc2lnbnMgYXJndW1lbnQgdmFyaWFibGVzIGluIGEgc2VwYXJhdGUgZnVuY3Rpb24gdGhhblxuICAgIC8vIHRoZSBvbmUgdGhhdCBhY2Nlc3NlcyBgYXJndW1lbnRzLmxlbmd0aGAgdG8gYXZvaWQgYSBwZXJmIGhpdC4gKCMxOTkxKVxuICAgIHZhciByZWR1Y2VyID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgaW5pdGlhbCkge1xuICAgICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgICBtZW1vID0gaXRlcmF0ZWUobWVtbywgb2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMztcbiAgICAgIHJldHVybiByZWR1Y2VyKG9iaiwgb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgNCksIG1lbW8sIGluaXRpYWwpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxuICAvLyBvciBgZm9sZGxgLlxuICBfLnJlZHVjZSA9IF8uZm9sZGwgPSBfLmluamVjdCA9IGNyZWF0ZVJlZHVjZSgxKTtcblxuICAvLyBUaGUgcmlnaHQtYXNzb2NpYXRpdmUgdmVyc2lvbiBvZiByZWR1Y2UsIGFsc28ga25vd24gYXMgYGZvbGRyYC5cbiAgXy5yZWR1Y2VSaWdodCA9IF8uZm9sZHIgPSBjcmVhdGVSZWR1Y2UoLTEpO1xuXG4gIC8vIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggcGFzc2VzIGEgdHJ1dGggdGVzdC4gQWxpYXNlZCBhcyBgZGV0ZWN0YC5cbiAgXy5maW5kID0gXy5kZXRlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBrZXlGaW5kZXIgPSBpc0FycmF5TGlrZShvYmopID8gXy5maW5kSW5kZXggOiBfLmZpbmRLZXk7XG4gICAgdmFyIGtleSA9IGtleUZpbmRlcihvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgaWYgKGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gLTEpIHJldHVybiBvYmpba2V5XTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBzZWxlY3RgLlxuICBfLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgbGlzdCkpIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy5cbiAgXy5yZWplY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubmVnYXRlKGNiKHByZWRpY2F0ZSkpLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgd2hldGhlciBhbGwgb2YgdGhlIGVsZW1lbnRzIG1hdGNoIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYWxsYC5cbiAgXy5ldmVyeSA9IF8uYWxsID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAoIXByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgbWF0Y2hlcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFueWAuXG4gIF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgdGhlIGFycmF5IG9yIG9iamVjdCBjb250YWlucyBhIGdpdmVuIGl0ZW0gKHVzaW5nIGA9PT1gKS5cbiAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZXNgIGFuZCBgaW5jbHVkZWAuXG4gIF8uY29udGFpbnMgPSBfLmluY2x1ZGVzID0gXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCBpdGVtLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gICAgaWYgKCFpc0FycmF5TGlrZShvYmopKSBvYmogPSBfLnZhbHVlcyhvYmopO1xuICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ICE9ICdudW1iZXInIHx8IGd1YXJkKSBmcm9tSW5kZXggPSAwO1xuICAgIHJldHVybiBfLmluZGV4T2Yob2JqLCBpdGVtLCBmcm9tSW5kZXgpID49IDA7XG4gIH07XG5cbiAgLy8gSW52b2tlIGEgbWV0aG9kICh3aXRoIGFyZ3VtZW50cykgb24gZXZlcnkgaXRlbSBpbiBhIGNvbGxlY3Rpb24uXG4gIF8uaW52b2tlID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihvYmosIHBhdGgsIGFyZ3MpIHtcbiAgICB2YXIgY29udGV4dFBhdGgsIGZ1bmM7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihwYXRoKSkge1xuICAgICAgZnVuYyA9IHBhdGg7XG4gICAgfSBlbHNlIGlmIChfLmlzQXJyYXkocGF0aCkpIHtcbiAgICAgIGNvbnRleHRQYXRoID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgICBwYXRoID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgbWV0aG9kID0gZnVuYztcbiAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgIGlmIChjb250ZXh0UGF0aCAmJiBjb250ZXh0UGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICBjb250ZXh0ID0gZGVlcEdldChjb250ZXh0LCBjb250ZXh0UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgbWV0aG9kID0gY29udGV4dFtwYXRoXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXRob2QgPT0gbnVsbCA/IG1ldGhvZCA6IG1ldGhvZC5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgbWFwYDogZmV0Y2hpbmcgYSBwcm9wZXJ0eS5cbiAgXy5wbHVjayA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgXy5wcm9wZXJ0eShrZXkpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaWx0ZXJgOiBzZWxlY3Rpbmcgb25seSBvYmplY3RzXG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ud2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmluZGA6IGdldHRpbmcgdGhlIGZpcnN0IG9iamVjdFxuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmZpbmRXaGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maW5kKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtYXhpbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1heCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gLUluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSAtSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCB8fCB0eXBlb2YgaXRlcmF0ZWUgPT0gJ251bWJlcicgJiYgdHlwZW9mIG9ialswXSAhPSAnb2JqZWN0JyAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odiwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2LCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA+IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gLUluZmluaXR5ICYmIHJlc3VsdCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdjtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgfHwgdHlwZW9mIGl0ZXJhdGVlID09ICdudW1iZXInICYmIHR5cGVvZiBvYmpbMF0gIT0gJ29iamVjdCcgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHYsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodiwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2O1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBTaHVmZmxlIGEgY29sbGVjdGlvbi5cbiAgXy5zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uc2FtcGxlKG9iaiwgSW5maW5pdHkpO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHZhciBzYW1wbGUgPSBpc0FycmF5TGlrZShvYmopID8gXy5jbG9uZShvYmopIDogXy52YWx1ZXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKHNhbXBsZSk7XG4gICAgbiA9IE1hdGgubWF4KE1hdGgubWluKG4sIGxlbmd0aCksIDApO1xuICAgIHZhciBsYXN0ID0gbGVuZ3RoIC0gMTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbjsgaW5kZXgrKykge1xuICAgICAgdmFyIHJhbmQgPSBfLnJhbmRvbShpbmRleCwgbGFzdCk7XG4gICAgICB2YXIgdGVtcCA9IHNhbXBsZVtpbmRleF07XG4gICAgICBzYW1wbGVbaW5kZXhdID0gc2FtcGxlW3JhbmRdO1xuICAgICAgc2FtcGxlW3JhbmRdID0gdGVtcDtcbiAgICB9XG4gICAgcmV0dXJuIHNhbXBsZS5zbGljZSgwLCBuKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0ZWUuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIF8ucGx1Y2soXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGluZGV4OiBpbmRleCsrLFxuICAgICAgICBjcml0ZXJpYTogaXRlcmF0ZWUodmFsdWUsIGtleSwgbGlzdClcbiAgICAgIH07XG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yLCBwYXJ0aXRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHBhcnRpdGlvbiA/IFtbXSwgW11dIDoge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICB2YXIgcmVTdHJTeW1ib2wgPSAvW15cXHVkODAwLVxcdWRmZmZdfFtcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl18W1xcdWQ4MDAtXFx1ZGZmZl0vZztcbiAgLy8gU2FmZWx5IGNyZWF0ZSBhIHJlYWwsIGxpdmUgYXJyYXkgZnJvbSBhbnl0aGluZyBpdGVyYWJsZS5cbiAgXy50b0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBbXTtcbiAgICBpZiAoXy5pc0FycmF5KG9iaikpIHJldHVybiBzbGljZS5jYWxsKG9iaik7XG4gICAgaWYgKF8uaXNTdHJpbmcob2JqKSkge1xuICAgICAgLy8gS2VlcCBzdXJyb2dhdGUgcGFpciBjaGFyYWN0ZXJzIHRvZ2V0aGVyXG4gICAgICByZXR1cm4gb2JqLm1hdGNoKHJlU3RyU3ltYm9sKTtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHJldHVybiBfLm1hcChvYmosIF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBfLnZhbHVlcyhvYmopO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9iamVjdC5cbiAgXy5zaXplID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gMDtcbiAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqKSA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7XG4gIH07XG5cbiAgLy8gU3BsaXQgYSBjb2xsZWN0aW9uIGludG8gdHdvIGFycmF5czogb25lIHdob3NlIGVsZW1lbnRzIGFsbCBzYXRpc2Z5IHRoZSBnaXZlblxuICAvLyBwcmVkaWNhdGUsIGFuZCBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIGRvIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG4gIF8ucGFydGl0aW9uID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwgcGFzcykge1xuICAgIHJlc3VsdFtwYXNzID8gMCA6IDFdLnB1c2godmFsdWUpO1xuICB9LCB0cnVlKTtcblxuICAvLyBBcnJheSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwgfHwgYXJyYXkubGVuZ3RoIDwgMSkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbMF07XG4gICAgcmV0dXJuIF8uaW5pdGlhbChhcnJheSwgYXJyYXkubGVuZ3RoIC0gbik7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEVzcGVjaWFsbHkgdXNlZnVsIG9uXG4gIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4gIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uXG4gIF8uaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSAobiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pKSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICBfLmxhc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCB8fCBhcnJheS5sZW5ndGggPCAxKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgQm9vbGVhbik7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIG91dHB1dCkge1xuICAgIG91dHB1dCA9IG91dHB1dCB8fCBbXTtcbiAgICB2YXIgaWR4ID0gb3V0cHV0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGlucHV0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vIEZsYXR0ZW4gY3VycmVudCBsZXZlbCBvZiBhcnJheSBvciBhcmd1bWVudHMgb2JqZWN0LlxuICAgICAgICBpZiAoc2hhbGxvdykge1xuICAgICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChqIDwgbGVuKSBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbGF0dGVuKHZhbHVlLCBzaGFsbG93LCBzdHJpY3QsIG91dHB1dCk7XG4gICAgICAgICAgaWR4ID0gb3V0cHV0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihhcnJheSwgb3RoZXJBcnJheXMpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBvdGhlckFycmF5cyk7XG4gIH0pO1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gVGhlIGZhc3RlciBhbGdvcml0aG0gd2lsbCBub3Qgd29yayB3aXRoIGFuIGl0ZXJhdGVlIGlmIHRoZSBpdGVyYXRlZVxuICAvLyBpcyBub3QgYSBvbmUtdG8tb25lIGZ1bmN0aW9uLCBzbyBwcm92aWRpbmcgYW4gaXRlcmF0ZWUgd2lsbCBkaXNhYmxlXG4gIC8vIHRoZSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoIV8uaXNCb29sZWFuKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdGVlO1xuICAgICAgaXRlcmF0ZWUgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpdGVyYXRlZSAhPSBudWxsKSBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXSxcbiAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGksIGFycmF5KSA6IHZhbHVlO1xuICAgICAgaWYgKGlzU29ydGVkICYmICFpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgcmV0dXJuIF8udW5pcShmbGF0dGVuKGFycmF5cywgdHJ1ZSwgdHJ1ZSkpO1xuICB9KTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIHZhciBqO1xuICAgICAgZm9yIChqID0gMTsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoYXJndW1lbnRzW2pdLCBpdGVtKSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gYXJnc0xlbmd0aCkgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICBfLmRpZmZlcmVuY2UgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGFycmF5LCByZXN0KSB7XG4gICAgcmVzdCA9IGZsYXR0ZW4ocmVzdCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlcy5cbiAgXy51bnppcCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ICYmIF8ubWF4KGFycmF5LCBnZXRMZW5ndGgpLmxlbmd0aCB8fCAwO1xuICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IF8ucGx1Y2soYXJyYXksIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IHJlc3RBcmd1bWVudHMoXy51bnppcCk7XG5cbiAgLy8gQ29udmVydHMgbGlzdHMgaW50byBvYmplY3RzLiBQYXNzIGVpdGhlciBhIHNpbmdsZSBhcnJheSBvZiBgW2tleSwgdmFsdWVdYFxuICAvLyBwYWlycywgb3IgdHdvIHBhcmFsbGVsIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGggLS0gb25lIG9mIGtleXMsIGFuZCBvbmUgb2ZcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLiBQYXNzaW5nIGJ5IHBhaXJzIGlzIHRoZSByZXZlcnNlIG9mIF8ucGFpcnMuXG4gIF8ub2JqZWN0ID0gZnVuY3Rpb24obGlzdCwgdmFsdWVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgobGlzdCk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXN1bHRbbGlzdFtpXV0gPSB2YWx1ZXNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGZpbmRJbmRleCBhbmQgZmluZExhc3RJbmRleCBmdW5jdGlvbnMuXG4gIHZhciBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlciA9IGZ1bmN0aW9uKGRpcikge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICB2YXIgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3QuXG4gIF8uZmluZEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoMSk7XG4gIF8uZmluZExhc3RJbmRleCA9IGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKC0xKTtcblxuICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoXG4gIC8vIGFuIG9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cbiAgXy5zb3J0ZWRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgdmFyIHZhbHVlID0gaXRlcmF0ZWUob2JqKTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W21pZF0pIDwgdmFsdWUpIGxvdyA9IG1pZCArIDE7IGVsc2UgaGlnaCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfTtcblxuICAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBpbmRleE9mIGFuZCBsYXN0SW5kZXhPZiBmdW5jdGlvbnMuXG4gIHZhciBjcmVhdGVJbmRleEZpbmRlciA9IGZ1bmN0aW9uKGRpciwgcHJlZGljYXRlRmluZCwgc29ydGVkSW5kZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlkeCkge1xuICAgICAgdmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgaWYgKHR5cGVvZiBpZHggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICBpID0gaWR4ID49IDAgPyBpZHggOiBNYXRoLm1heChpZHggKyBsZW5ndGgsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlbmd0aCA9IGlkeCA+PSAwID8gTWF0aC5taW4oaWR4ICsgMSwgbGVuZ3RoKSA6IGlkeCArIGxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc29ydGVkSW5kZXggJiYgaWR4ICYmIGxlbmd0aCkge1xuICAgICAgICBpZHggPSBzb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7XG4gICAgICAgIHJldHVybiBhcnJheVtpZHhdID09PSBpdGVtID8gaWR4IDogLTE7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSAhPT0gaXRlbSkge1xuICAgICAgICBpZHggPSBwcmVkaWNhdGVGaW5kKHNsaWNlLmNhbGwoYXJyYXksIGksIGxlbmd0aCksIF8uaXNOYU4pO1xuICAgICAgICByZXR1cm4gaWR4ID49IDAgPyBpZHggKyBpIDogLTE7XG4gICAgICB9XG4gICAgICBmb3IgKGlkeCA9IGRpciA+IDAgPyBpIDogbGVuZ3RoIC0gMTsgaWR4ID49IDAgJiYgaWR4IDwgbGVuZ3RoOyBpZHggKz0gZGlyKSB7XG4gICAgICAgIGlmIChhcnJheVtpZHhdID09PSBpdGVtKSByZXR1cm4gaWR4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LFxuICAvLyBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cbiAgXy5pbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoMSwgXy5maW5kSW5kZXgsIF8uc29ydGVkSW5kZXgpO1xuICBfLmxhc3RJbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoLTEsIF8uZmluZExhc3RJbmRleCk7XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoc3RvcCA9PSBudWxsKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgaWYgKCFzdGVwKSB7XG4gICAgICBzdGVwID0gc3RvcCA8IHN0YXJ0ID8gLTEgOiAxO1xuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIHJhbmdlID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyssIHN0YXJ0ICs9IHN0ZXApIHtcbiAgICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gQ2h1bmsgYSBzaW5nbGUgYXJyYXkgaW50byBtdWx0aXBsZSBhcnJheXMsIGVhY2ggY29udGFpbmluZyBgY291bnRgIG9yIGZld2VyXG4gIC8vIGl0ZW1zLlxuICBfLmNodW5rID0gZnVuY3Rpb24oYXJyYXksIGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IG51bGwgfHwgY291bnQgPCAxKSByZXR1cm4gW107XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaChzbGljZS5jYWxsKGFycmF5LCBpLCBpICs9IGNvdW50KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3JcbiAgLy8gb3IgYSBub3JtYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihmdW5jLCBjb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JpbmQgbXVzdCBiZSBjYWxsZWQgb24gYSBmdW5jdGlvbicpO1xuICAgIHZhciBib3VuZCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oY2FsbEFyZ3MpIHtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIGNvbnRleHQsIHRoaXMsIGFyZ3MuY29uY2F0KGNhbGxBcmdzKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9KTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciBieSBkZWZhdWx0LCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlXG4gIC8vIHByZS1maWxsZWQuIFNldCBgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyYCBmb3IgYSBjdXN0b20gcGxhY2Vob2xkZXIgYXJndW1lbnQuXG4gIF8ucGFydGlhbCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oZnVuYywgYm91bmRBcmdzKSB7XG4gICAgdmFyIHBsYWNlaG9sZGVyID0gXy5wYXJ0aWFsLnBsYWNlaG9sZGVyO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gYm91bmRBcmdzLmxlbmd0aDtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9IGJvdW5kQXJnc1tpXSA9PT0gcGxhY2Vob2xkZXIgPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9KTtcblxuICBfLnBhcnRpYWwucGxhY2Vob2xkZXIgPSBfO1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKG9iaiwga2V5cykge1xuICAgIGtleXMgPSBmbGF0dGVuKGtleXMsIGZhbHNlLCBmYWxzZSk7XG4gICAgdmFyIGluZGV4ID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGluZGV4IDwgMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgIG9ialtrZXldID0gXy5iaW5kKG9ialtrZXldLCBvYmopO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW9pemUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBjYWNoZSA9IG1lbW9pemUuY2FjaGU7XG4gICAgICB2YXIgYWRkcmVzcyA9ICcnICsgKGhhc2hlciA/IGhhc2hlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5KTtcbiAgICAgIGlmICghXy5oYXMoY2FjaGUsIGFkZHJlc3MpKSBjYWNoZVthZGRyZXNzXSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBjYWNoZVthZGRyZXNzXTtcbiAgICB9O1xuICAgIG1lbW9pemUuY2FjaGUgPSB7fTtcbiAgICByZXR1cm4gbWVtb2l6ZTtcbiAgfTtcblxuICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgXy5kZWxheSA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oZnVuYywgd2FpdCwgYXJncykge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSwgd2FpdCk7XG4gIH0pO1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gXy5wYXJ0aWFsKF8uZGVsYXksIF8sIDEpO1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGltZW91dCwgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcblxuICAgIHZhciB0aHJvdHRsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSBfLm5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB0aHJvdHRsZWQuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICBwcmV2aW91cyA9IDA7XG4gICAgICB0aW1lb3V0ID0gY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhyb3R0bGVkO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCByZXN1bHQ7XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmIChhcmdzKSByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH07XG5cbiAgICB2YXIgZGVib3VuY2VkID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihhcmdzKSB7XG4gICAgICBpZiAodGltZW91dCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgICB2YXIgY2FsbE5vdyA9ICF0aW1lb3V0O1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICAgIGlmIChjYWxsTm93KSByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IF8uZGVsYXkobGF0ZXIsIHdhaXQsIHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgZGVib3VuY2VkLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWJvdW5jZWQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICBfLnJlc3RBcmd1bWVudHMgPSByZXN0QXJndW1lbnRzO1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3QgYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuXG4gIHZhciBoYXNFbnVtQnVnID0gIXt0b1N0cmluZzogbnVsbH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsXG4gICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG5cbiAgdmFyIGNvbGxlY3ROb25FbnVtUHJvcHMgPSBmdW5jdGlvbihvYmosIGtleXMpIHtcbiAgICB2YXIgbm9uRW51bUlkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGg7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwcm90byA9IF8uaXNGdW5jdGlvbihjb25zdHJ1Y3RvcikgJiYgY29uc3RydWN0b3IucHJvdG90eXBlIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChfLmhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgbmFtZXMgb2YgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2AuXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSBhbGwgdGhlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgXy5hbGxLZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvYmpba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBvYmplY3QuXG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0LlxuICBfLm1hcE9iamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICByZXN1bHRzW2N1cnJlbnRLZXldID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgLy8gVGhlIG9wcG9zaXRlIG9mIF8ub2JqZWN0LlxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWlyc1tpXSA9IFtrZXlzW2ldLCBvYmpba2V5c1tpXV1dO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW2tleXNbaV1dXSA9IGtleXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYC5cbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhc3NpZ25lciBmdW5jdGlvbnMuXG4gIHZhciBjcmVhdGVBc3NpZ25lciA9IGZ1bmN0aW9uKGtleXNGdW5jLCBkZWZhdWx0cykge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKGRlZmF1bHRzKSBvYmogPSBPYmplY3Qob2JqKTtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghZGVmYXVsdHMgfHwgb2JqW2tleV0gPT09IHZvaWQgMCkgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIC8vIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduKVxuICBfLmV4dGVuZE93biA9IF8uYXNzaWduID0gY3JlYXRlQXNzaWduZXIoXy5rZXlzKTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBrZXkgb24gYW4gb2JqZWN0IHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3QuXG4gIF8uZmluZEtleSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopLCBrZXk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtrZXldLCBrZXksIG9iaikpIHJldHVybiBrZXk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEludGVybmFsIHBpY2sgaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBgb2JqYCBoYXMga2V5IGBrZXlgLlxuICB2YXIga2V5SW5PYmogPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHtcbiAgICByZXR1cm4ga2V5IGluIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKG9iaiwga2V5cykge1xuICAgIHZhciByZXN1bHQgPSB7fSwgaXRlcmF0ZWUgPSBrZXlzWzBdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaWYgKGtleXMubGVuZ3RoID4gMSkgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBrZXlzWzFdKTtcbiAgICAgIGtleXMgPSBfLmFsbEtleXMob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBrZXlJbk9iajtcbiAgICAgIGtleXMgPSBmbGF0dGVuKGtleXMsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24ob2JqLCBrZXlzKSB7XG4gICAgdmFyIGl0ZXJhdGVlID0ga2V5c1swXSwgY29udGV4dDtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPiAxKSBjb250ZXh0ID0ga2V5c1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IF8ubWFwKGZsYXR0ZW4oa2V5cywgZmFsc2UsIGZhbHNlKSwgU3RyaW5nKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gIV8uY29udGFpbnMoa2V5cywga2V5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfLnBpY2sob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH0pO1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbiAgLy8gSWYgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZCB0aGVuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgLy8gY3JlYXRlZCBvYmplY3QuXG4gIF8uY3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBfLmV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSwgZGVlcEVxO1xuICBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gYG51bGxgIG9yIGB1bmRlZmluZWRgIG9ubHkgZXF1YWwgdG8gaXRzZWxmIChzdHJpY3QgY29tcGFyaXNvbikuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICAgIGlmIChhICE9PSBhKSByZXR1cm4gYiAhPT0gYjtcbiAgICAvLyBFeGhhdXN0IHByaW1pdGl2ZSBjaGVja3NcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBhO1xuICAgIGlmICh0eXBlICE9PSAnZnVuY3Rpb24nICYmIHR5cGUgIT09ICdvYmplY3QnICYmIHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGRlZXBFcShhLCBiLCBhU3RhY2ssIGJTdGFjayk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgZGVlcEVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOLlxuICAgICAgICBpZiAoK2EgIT09ICthKSByZXR1cm4gK2IgIT09ICtiO1xuICAgICAgICAvLyBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuICAgICAgICByZXR1cm4gK2EgPT09IDAgPyAxIC8gK2EgPT09IDEgLyBiIDogK2EgPT09ICtiO1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmV0dXJuICthID09PSArYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3ltYm9sXSc6XG4gICAgICAgIHJldHVybiBTeW1ib2xQcm90by52YWx1ZU9mLmNhbGwoYSkgPT09IFN5bWJvbFByb3RvLnZhbHVlT2YuY2FsbChiKTtcbiAgICB9XG5cbiAgICB2YXIgYXJlQXJyYXlzID0gY2xhc3NOYW1lID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIGlmICghYXJlQXJyYXlzKSB7XG4gICAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzIG9yIGBBcnJheWBzXG4gICAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvciwgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNGdW5jdGlvbihiQ3RvcikgJiYgYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuXG4gICAgLy8gSW5pdGlhbGl6aW5nIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIC8vIEl0J3MgZG9uZSBoZXJlIHNpbmNlIHdlIG9ubHkgbmVlZCB0aGVtIGZvciBvYmplY3RzIGFuZCBhcnJheXMgY29tcGFyaXNvbi5cbiAgICBhU3RhY2sgPSBhU3RhY2sgfHwgW107XG4gICAgYlN0YWNrID0gYlN0YWNrIHx8IFtdO1xuICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PT0gYjtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnB1c2goYSk7XG4gICAgYlN0YWNrLnB1c2goYik7XG5cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICBpZiAoYXJlQXJyYXlzKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKCFlcShhW2xlbmd0aF0sIGJbbGVuZ3RoXSwgYVN0YWNrLCBiU3RhY2spKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgICAgdmFyIGtleXMgPSBfLmtleXMoYSksIGtleTtcbiAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYmVmb3JlIGNvbXBhcmluZyBkZWVwIGVxdWFsaXR5LlxuICAgICAgaWYgKF8ua2V5cyhiKS5sZW5ndGggIT09IGxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlclxuICAgICAgICBrZXkgPSBrZXlzW2xlbmd0aF07XG4gICAgICAgIGlmICghKF8uaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrKSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbiAgXy5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBlcShhLCBiKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIGFycmF5LCBzdHJpbmcsIG9yIG9iamVjdCBlbXB0eT9cbiAgLy8gQW4gXCJlbXB0eVwiIG9iamVjdCBoYXMgbm8gZW51bWVyYWJsZSBvd24tcHJvcGVydGllcy5cbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSAmJiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopIHx8IF8uaXNBcmd1bWVudHMob2JqKSkpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xuICAgIHJldHVybiBfLmtleXMob2JqKS5sZW5ndGggPT09IDA7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xuICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgQXJyYXkuaXNBcnJheVxuICBfLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHNvbWUgaXNUeXBlIG1ldGhvZHM6IGlzQXJndW1lbnRzLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXIsIGlzRGF0ZSwgaXNSZWdFeHAsIGlzRXJyb3IsIGlzTWFwLCBpc1dlYWtNYXAsIGlzU2V0LCBpc1dlYWtTZXQuXG4gIF8uZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJywgJ0Vycm9yJywgJ1N5bWJvbCcsICdNYXAnLCAnV2Vha01hcCcsICdTZXQnLCAnV2Vha1NldCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIERlZmluZSBhIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIG1ldGhvZCBpbiBicm93c2VycyAoYWhlbSwgSUUgPCA5KSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5oYXMob2JqLCAnY2FsbGVlJyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIGBpc0Z1bmN0aW9uYCBpZiBhcHByb3ByaWF0ZS4gV29yayBhcm91bmQgc29tZSB0eXBlb2YgYnVncyBpbiBvbGQgdjgsXG4gIC8vIElFIDExICgjMTYyMSksIFNhZmFyaSA4ICgjMTkyOSksIGFuZCBQaGFudG9tSlMgKCMyMjM2KS5cbiAgdmFyIG5vZGVsaXN0ID0gcm9vdC5kb2N1bWVudCAmJiByb290LmRvY3VtZW50LmNoaWxkTm9kZXM7XG4gIGlmICh0eXBlb2YgLy4vICE9ICdmdW5jdGlvbicgJiYgdHlwZW9mIEludDhBcnJheSAhPSAnb2JqZWN0JyAmJiB0eXBlb2Ygbm9kZWxpc3QgIT0gJ2Z1bmN0aW9uJykge1xuICAgIF8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJyB8fCBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICFfLmlzU3ltYm9sKG9iaikgJiYgaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/XG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIGlzTmFOKG9iaik7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGJvb2xlYW4/XG4gIF8uaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgZXF1YWwgdG8gbnVsbD9cbiAgXy5pc051bGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgdW5kZWZpbmVkP1xuICBfLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xuICB9O1xuXG4gIC8vIFNob3J0Y3V0IGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gcHJvcGVydHkgZGlyZWN0bHlcbiAgLy8gb24gaXRzZWxmIChpbiBvdGhlciB3b3Jkcywgbm90IG9uIGEgcHJvdG90eXBlKS5cbiAgXy5oYXMgPSBmdW5jdGlvbihvYmosIHBhdGgpIHtcbiAgICBpZiAoIV8uaXNBcnJheShwYXRoKSkge1xuICAgICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwYXRoKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwYXRoW2ldO1xuICAgICAgaWYgKG9iaiA9PSBudWxsIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmogPSBvYmpba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuICEhbGVuZ3RoO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gcGFzc2VkIGFuIG9iamVjdCwgd2lsbCB0cmF2ZXJzZSB0aGF0IG9iamVjdOKAmXNcbiAgLy8gcHJvcGVydGllcyBkb3duIHRoZSBnaXZlbiBgcGF0aGAsIHNwZWNpZmllZCBhcyBhbiBhcnJheSBvZiBrZXlzIG9yIGluZGV4ZXMuXG4gIF8ucHJvcGVydHkgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgaWYgKCFfLmlzQXJyYXkocGF0aCkpIHtcbiAgICAgIHJldHVybiBzaGFsbG93UHJvcGVydHkocGF0aCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBkZWVwR2V0KG9iaiwgcGF0aCk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZXMgYSBmdW5jdGlvbiBmb3IgYSBnaXZlbiBvYmplY3QgdGhhdCByZXR1cm5zIGEgZ2l2ZW4gcHJvcGVydHkuXG4gIF8ucHJvcGVydHlPZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7fTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHJldHVybiAhXy5pc0FycmF5KHBhdGgpID8gb2JqW3BhdGhdIDogZGVlcEdldChvYmosIHBhdGgpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIHByZWRpY2F0ZSBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mXG4gIC8vIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLm1hdGNoZXIgPSBfLm1hdGNoZXMgPSBmdW5jdGlvbihhdHRycykge1xuICAgIGF0dHJzID0gXy5leHRlbmRPd24oe30sIGF0dHJzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5pc01hdGNoKG9iaiwgYXR0cnMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXG4gIF8udGltZXMgPSBmdW5jdGlvbihuLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhY2N1bVtpXSA9IGl0ZXJhdGVlKGkpO1xuICAgIHJldHVybiBhY2N1bTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiBhbmQgbWF4IChpbmNsdXNpdmUpLlxuICBfLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBtaW47XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgfTtcblxuICAvLyBBIChwb3NzaWJseSBmYXN0ZXIpIHdheSB0byBnZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGFzIGFuIGludGVnZXIuXG4gIF8ubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9O1xuXG4gIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkLlxuICAgIHZhciBzb3VyY2UgPSAnKD86JyArIF8ua2V5cyhtYXApLmpvaW4oJ3wnKSArICcpJztcbiAgICB2YXIgdGVzdFJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UpO1xuICAgIHZhciByZXBsYWNlUmVnZXhwID0gUmVnRXhwKHNvdXJjZSwgJ2cnKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcgPT0gbnVsbCA/ICcnIDogJycgKyBzdHJpbmc7XG4gICAgICByZXR1cm4gdGVzdFJlZ2V4cC50ZXN0KHN0cmluZykgPyBzdHJpbmcucmVwbGFjZShyZXBsYWNlUmVnZXhwLCBlc2NhcGVyKSA6IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBfLmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIoZXNjYXBlTWFwKTtcbiAgXy51bmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIodW5lc2NhcGVNYXApO1xuXG4gIC8vIFRyYXZlcnNlcyB0aGUgY2hpbGRyZW4gb2YgYG9iamAgYWxvbmcgYHBhdGhgLiBJZiBhIGNoaWxkIGlzIGEgZnVuY3Rpb24sIGl0XG4gIC8vIGlzIGludm9rZWQgd2l0aCBpdHMgcGFyZW50IGFzIGNvbnRleHQuIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmaW5hbFxuICAvLyBjaGlsZCwgb3IgYGZhbGxiYWNrYCBpZiBhbnkgY2hpbGQgaXMgdW5kZWZpbmVkLlxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iaiwgcGF0aCwgZmFsbGJhY2spIHtcbiAgICBpZiAoIV8uaXNBcnJheShwYXRoKSkgcGF0aCA9IFtwYXRoXTtcbiAgICB2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHJldHVybiBfLmlzRnVuY3Rpb24oZmFsbGJhY2spID8gZmFsbGJhY2suY2FsbChvYmopIDogZmFsbGJhY2s7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmpbcGF0aFtpXV07XG4gICAgICBpZiAocHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHByb3AgPSBmYWxsYmFjaztcbiAgICAgICAgaSA9IGxlbmd0aDsgLy8gRW5zdXJlIHdlIGRvbid0IGNvbnRpbnVlIGl0ZXJhdGluZy5cbiAgICAgIH1cbiAgICAgIG9iaiA9IF8uaXNGdW5jdGlvbihwcm9wKSA/IHByb3AuY2FsbChvYmopIDogcHJvcDtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgIGludGVycG9sYXRlOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGU6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgdmFyIGVzY2FwZVJlZ0V4cCA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZVJlZ0V4cCwgZXNjYXBlQ2hhcik7XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2Zmc2V0LlxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXG4gICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xuICAgICAgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcblxuICAgIHZhciByZW5kZXI7XG4gICAgdHJ5IHtcbiAgICAgIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgY2hhaW5SZXN1bHQgPSBmdW5jdGlvbihpbnN0YW5jZSwgb2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIF8uZWFjaChfLmZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl93cmFwcGVkXTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gY2hhaW5SZXN1bHQodGhpcywgZnVuYy5hcHBseShfLCBhcmdzKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBfO1xuICB9O1xuXG4gIC8vIEFkZCBhbGwgb2YgdGhlIFVuZGVyc2NvcmUgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgXy5taXhpbihfKTtcblxuICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcbiAgICAgIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoKG5hbWUgPT09ICdzaGlmdCcgfHwgbmFtZSA9PT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIGRlbGV0ZSBvYmpbMF07XG4gICAgICByZXR1cm4gY2hhaW5SZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY2hhaW5SZXN1bHQodGhpcywgbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxuICBfLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIFByb3ZpZGUgdW53cmFwcGluZyBwcm94eSBmb3Igc29tZSBtZXRob2RzIHVzZWQgaW4gZW5naW5lIG9wZXJhdGlvbnNcbiAgLy8gc3VjaCBhcyBhcml0aG1ldGljIGFuZCBKU09OIHN0cmluZ2lmaWNhdGlvbi5cbiAgXy5wcm90b3R5cGUudmFsdWVPZiA9IF8ucHJvdG90eXBlLnRvSlNPTiA9IF8ucHJvdG90eXBlLnZhbHVlO1xuXG4gIF8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLl93cmFwcGVkKTtcbiAgfTtcblxuICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXG4gIC8vIHRoYXQgbWF5IG5vdCBlbmZvcmNlIG5leHQtdHVybiBzZW1hbnRpY3Mgb24gbW9kdWxlcy4gRXZlbiB0aG91Z2ggZ2VuZXJhbFxuICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXG4gIC8vIHBvcHVsYXIgZW5vdWdoIHRvIGJlIGJ1bmRsZWQgaW4gYSB0aGlyZCBwYXJ0eSBsaWIsIGJ1dCBub3QgYmUgcGFydCBvZlxuICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ3VuZGVyc2NvcmUnLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxufSgpKTtcbiJdfQ==
